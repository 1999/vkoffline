/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_electron__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_electron___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_electron__);
'use strict';



const prepareStackText = errStack => {
	return errStack.split('\n    ');
};

const flattenError = err => {
	const isErrorInstance = err instanceof Error;
	const message = isErrorInstance ? err.message : err;
	const stack = isErrorInstance ? prepareStackText(err.stack) : null;

	return { message, stack };
};

/* harmony default export */ exports["a"] = file => {
	// listen to node-related errors
	process.on('uncaughtException', err => {
		// TODO log errors to IndexedDB
		// LogManager.error(msgError);

		__WEBPACK_IMPORTED_MODULE_0_electron__["ipcRenderer"].send('rendererError', {
			file,
			err: flattenError(err),
			type: 'uncaughtException'
		});
	});

	// listen to unhandled promises being rejected
	process.on('unhandledRejection', reason => {
		// TODO log errors to IndexedDB
		// LogManager.error(msgError);
		// reason is mostly an Error instance

		__WEBPACK_IMPORTED_MODULE_0_electron__["ipcRenderer"].send('rendererError', {
			file,
			err: flattenError(err),
			type: 'unhandledRejection'
		});
	});
};

/***/ },
/* 1 */
/***/ function(module, exports) {

module.exports = require("electron");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_assert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__idb__ = __webpack_require__(5);
'use strict';

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }




const OBJ_STORE_NAME = 'keyvalues';

class Storage {
    // it's kinda like constructor but other modules need to know the moment
    // when storage is initialized
    load() {
        var _this = this;

        return _asyncToGenerator(function* () {
            const conn = yield __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__idb__["a" /* openMeta */])();
            const records = yield conn.get(OBJ_STORE_NAME);

            console.log(records);
            _this._data = records;
        })();
    }

    set(key, value) {
        this._checkIsInitialized();

        var storageData = {};
        storageData[key] = value;
        chrome.storage.local.set(storageData);

        this._data[key] = value;

        // this op should not block others so the function is still sync
        openConn().then(conn => conn.upsert(OBJ_STORE_NAME, { key, value }));
    }

    get(key, params) {
        this._checkIsInitialized();

        let value = this._data[key] || null;
        let valueCreated = false;

        params = params || {};
        params.constructor = params.constructor || String;
        params.strict = params.strict || false;
        params.create = params.create || false;

        if (value === null && params.create) {
            value = params.constructor === String ? '' : new params.constructor();
            valueCreated = true;
        }

        if (params.strict && params.constructor !== String && valueCreated === false) {
            // проверка на тип данных
            __WEBPACK_IMPORTED_MODULE_0_assert___default()(value instanceof params.constructor, `Wrong storage data type of key "${ key }"`);
        }

        return value;
    }

    remove(key) {
        this._checkIsInitialized();

        delete this._data[key];

        // this op should not block others so the function is still sync
        openConn().then(conn => conn.delete(OBJ_STORE_NAME, key));
    }

    _checkIsInitialized() {
        __WEBPACK_IMPORTED_MODULE_0_assert___default()(this._initialized, 'Storage hasn\'t yet been initialized');
    }
}

/* harmony default export */ exports["a"] = Storage;

/***/ },
/* 3 */,
/* 4 */
/***/ function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if (true) module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if (typeof exports === 'object') exports["sklad"] = factory();else root["sklad"] = factory();
})(this, function () {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};
			/******/
			/******/ // The require function
			/******/function __webpack_require__(moduleId) {
				/******/
				/******/ // Check if module is in cache
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;
				/******/
				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };
				/******/
				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
				/******/
				/******/ // Flag the module as loaded
				/******/module.loaded = true;
				/******/
				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}
			/******/
			/******/
			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;
			/******/
			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;
			/******/
			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";
			/******/
			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports, __webpack_require__) {

			/**
    * Copyright (c) 2013-2016 Dmitry Sorin <info@staypositive.ru>
    * https://github.com/1999/sklad
    *
    * Permission is hereby granted, free of charge, to any person obtaining a copy
    * of this software and associated documentation files (the "Software"), to deal
    * in the Software without restriction, including without limitation the rights
    * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    * copies of the Software, and to permit persons to whom the Software is
    * furnished to do so, subject to the following conditions:
    *
    * The above copyright notice and this permission notice shall be included in
    * all copies or substantial portions of the Software.
    *
    * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    * THE SOFTWARE.
    *
    * @author Dmitry Sorin <info@staypositive.ru>
    * @license http://www.opensource.org/licenses/mit-license.html MIT License
    */
			'use strict';

			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
				return typeof obj;
			} : function (obj) {
				return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
			};

			var _kinopromise = __webpack_require__(1);

			var _kinopromise2 = _interopRequireDefault(_kinopromise);

			var _uuid = __webpack_require__(2);

			var _uuid2 = _interopRequireDefault(_uuid);

			var _error = __webpack_require__(3);

			var _env = __webpack_require__(4);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			function _defineProperty(obj, key, value) {
				if (key in obj) {
					Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
				} else {
					obj[key] = value;
				}return obj;
			}

			var skladAPI = {};
			skladAPI.ASC = _env.SORT_ASC;
			skladAPI.ASC_UNIQUE = _env.SORT_ASC_UNIQUE;
			skladAPI.DESC = _env.SORT_DESC;
			skladAPI.DESC_UNIQUE = _env.SORT_DESC_UNIQUE;

			// unfortunately `babel-plugin-array-includes` can't convert Array.prototype.includes
			// into Array.prototype.indexOf with its code
			var indexOf = Array.prototype.indexOf;
			var supportsObjStoreGetAll = typeof IDBObjectStore.prototype.getAll === 'function' && typeof IDBObjectStore.prototype.getAllKeys === 'function';
			var objStoresMeta = new Map();

			/**
    * Common ancestor for objects created with sklad.keyValue() method
    * Used to distinguish standard objects with "key" and "value" fields from special ones
    */
			var skladKeyValueContainer = Object.create(null);

			/**
    * Checks data before saving it in the object store
    * @return {Boolean} false if saved data type is incorrect, otherwise {Array} object store function arguments
    */
			function checkSavedData(dbName, objStore, data) {
				var keyValueContainer = Object.prototype.isPrototypeOf.call(skladKeyValueContainer, data);
				var value = keyValueContainer ? data.value : data;
				var objStoreMeta = objStoresMeta.get(dbName).get(objStore.name);
				var key = keyValueContainer ? data.key : undefined;

				var keyPath = objStore.keyPath || objStoreMeta.keyPath;
				var autoIncrement = objStore.autoIncrement || objStoreMeta.autoIncrement;

				if (keyPath === null) {
					if (!autoIncrement && key === undefined) {
						key = (0, _uuid2.default)();
					}
				} else {
					if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {
						return false;
					}

					// TODO: support dot-separated and array keyPaths
					if (!autoIncrement && data[keyPath] === undefined) {
						data[keyPath] = (0, _uuid2.default)();
					}
				}

				return key ? [value, key] : [value];
			}

			/**
    * Check whether database contains all needed stores
    *
    * @param {Array<String>} objStoreNames
    * @return {Boolean}
    */
			function checkContainingStores(objStoreNames) {
				return objStoreNames.every(function (storeName) {
					return indexOf.call(this.database.objectStoreNames, storeName) !== -1;
				}, this);
			}

			/**
    * autoIncrement is broken in IE family. Run this transaction to get its value
    * on every object store
    *
    * @param {IDBDatabase} db
    * @param {Array<String>} objStoreNames
    * @return {Promise}
    *
    * @see http://stackoverflow.com/questions/35682165/indexeddb-in-ie11-edge-why-is-objstore-autoincrement-undefined
    * @see https://connect.microsoft.com/IE/Feedback/Details/772726
    */
			function getObjStoresMeta(db, objStoreNames) {
				var dbMeta = objStoresMeta.get(db.name);
				var promises = [];

				objStoreNames.forEach(function (objStoreName) {
					if (dbMeta.has(objStoreName)) {
						return;
					}

					var promise = new Promise(function (resolve) {
						var transaction = db.transaction([objStoreName], _env.TRANSACTION_READWRITE);
						transaction.oncomplete = resolve;
						transaction.onabort = resolve;

						var objStore = transaction.objectStore(objStoreName);

						if (objStore.autoIncrement !== undefined) {
							dbMeta.set(objStoreName, {
								autoIncrement: objStore.autoIncrement,
								keyPath: objStore.keyPath
							});

							return;
						}

						var autoIncrement = void 0;

						if (objStore.keyPath !== null) {
							// if key path is defined it's possible to insert only objects
							// but if key generator (autoIncrement) is not defined the inserted objects
							// must contain field(s) described in keyPath value otherwise IDBObjectStore.add op fails
							// so if we run ODBObjectStore.add with an empty object and it fails, this means that
							// autoIncrement property was false. Otherwise - true
							// if key path is array autoIncrement property can't be true
							if (Array.isArray(objStore.keyPath)) {
								autoIncrement = false;
							} else {
								try {
									objStore.add({});
									autoIncrement = true;
								} catch (ex) {
									autoIncrement = false;
								}
							}
						} else {
							// if key path is not defined it's possible to insert any kind of data
							// but if key generator (autoIncrement) is not defined you should set it explicitly
							// so if we run ODBObjectStore.add with one argument and it fails, this means that
							// autoIncrement property was false. Otherwise - true
							try {
								objStore.add('some value');
								autoIncrement = true;
							} catch (ex) {
								autoIncrement = false;
							}
						}

						// save meta properties
						dbMeta.set(objStoreName, {
							autoIncrement: autoIncrement,
							keyPath: objStore.keyPath
						});

						// and abort transaction so that new record is forgotten
						transaction.abort();
					});

					promises.push(promise);
				});

				return Promise.all(promises);
			}

			var skladConnection = {
				/**
     * 1) Insert one record into the object store
     * @param {String} objStoreName name of object store
     * @param {*} data
     * @return {Promise}
     *   @param {Error} [err] if promise is rejected
     *   @param {*} inserted object key
     *
     * 2) Insert multiple records into the object stores (during one transaction)
     * @param {Object} data
     * @return {Promise}
     *   @param {Error} [err] if promise is rejected
     *   @param {Object} inserted objects' keys
     */
				insert: function skladConnection_insert() {
					var _this = this;

					var isMulti = arguments.length === 1;
					var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];

					var allObjStoresExist = checkContainingStores.call(this, objStoreNames);
					if (!allObjStoresExist) {
						var err = (0, _error.createError)('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\'t contain all needed stores');
						return Promise.reject(err);
					}

					var data = void 0;
					if (isMulti) {
						data = arguments[0];
					} else {
						data = {};
						data[arguments[0]] = [arguments[1]];
					}

					return getObjStoresMeta(this.database, objStoreNames).then(function () {
						return new Promise(function (resolve, reject) {
							var result = {};
							var transaction = void 0;
							var abortErr = void 0;

							// Safari9 can't run multi-objectstore transactions
							// divide one transaction into many with one object store to fix this
							try {
								transaction = _this.database.transaction(objStoreNames, _env.TRANSACTION_READWRITE);
							} catch (ex) {
								if (ex.name === 'NotFoundError') {
									(function () {
										var promises = {};

										objStoreNames.forEach(function (objStoreName) {
											var promise = _this.insert(_defineProperty({}, objStoreName, Array.isArray(data[objStoreName]) ? data[objStoreName] : [data[objStoreName]])).then(function (res) {
												return res[objStoreName];
											});

											promises[objStoreName] = promise;
										});

										_kinopromise2.default.all(promises).then(resolve).catch(reject);
									})();
								} else {
									reject(ex);
								}

								return;
							}

							transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_insert_onFinish(evt) {
								var err = abortErr || evt.target.error;
								var isSuccess = !err && evt.type === 'complete';

								if (isSuccess) {
									resolve(isMulti ? result : result[objStoreNames[0]][0]);
								} else {
									reject((0, _error.ensureError)(err));
								}

								if (evt.type === 'error') {
									evt.preventDefault();
								}
							};

							var _loop = function _loop(objStoreName) {
								var objStore = transaction.objectStore(objStoreName);

								var _loop2 = function _loop2(i) {
									var checkedData = checkSavedData(_this.database.name, objStore, data[objStoreName][i]);

									if (!checkedData) {
										abortErr = (0, _error.createError)('InvalidStateError', 'You must supply objects to be saved in the object store with set keyPath');
										return {
											v: {
												v: void 0
											}
										};
									}

									var req = void 0;
									try {
										req = objStore.add.apply(objStore, checkedData);
									} catch (ex) {
										abortErr = ex;
										return 'continue';
									}

									req.onsuccess = function (evt) {
										result[objStoreName] = result[objStoreName] || [];
										result[objStoreName][i] = evt.target.result;
									};
								};

								for (var i = 0; i < data[objStoreName].length; i++) {
									var _ret3 = _loop2(i);

									switch (_ret3) {
										case 'continue':
											continue;

										default:
											if ((typeof _ret3 === 'undefined' ? 'undefined' : _typeof(_ret3)) === "object") return _ret3.v;
									}
								}
							};

							for (var objStoreName in data) {
								var _ret2 = _loop(objStoreName);

								if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
							}
						});
					});
				},

				/**
     * 1) Insert or update one record in the object store
     * @param {String} objStoreName name of object store
     * @param {*} data
     * @return {Promise}
     *   @param {Error} [err] if promise is rejected
     *   @param {*} inserted/updated object key otherwise
     *
     * 2) Insert or update multiple records in the object stores (during one transaction)
     * @param {Object} data
     * @return {Promise}
     *   @param {Error} [err] if promise is rejected
     *   @param {Object} inserted/updated objects' keys otherwise
     */
				upsert: function skladConnection_upsert() {
					var _this2 = this;

					var isMulti = arguments.length === 1;
					var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];

					var allObjStoresExist = checkContainingStores.call(this, objStoreNames);
					if (!allObjStoresExist) {
						var err = (0, _error.createError)('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\'t contain all needed stores');
						return Promise.reject(err);
					}

					var data = void 0;
					if (isMulti) {
						data = arguments[0];
					} else {
						data = {};
						data[arguments[0]] = [arguments[1]];
					}

					return getObjStoresMeta(this.database, objStoreNames).then(function () {
						return new Promise(function (resolve, reject) {
							var result = {};
							var transaction = void 0;
							var abortErr = void 0;

							// Safari9 can't run multi-objectstore transactions
							// divide one transaction into many with one object store to fix this
							try {
								transaction = _this2.database.transaction(objStoreNames, _env.TRANSACTION_READWRITE);
							} catch (ex) {
								if (ex.name === 'NotFoundError') {
									(function () {
										var promises = {};

										objStoreNames.forEach(function (objStoreName) {
											var promise = _this2.upsert(_defineProperty({}, objStoreName, Array.isArray(data[objStoreName]) ? data[objStoreName] : [data[objStoreName]])).then(function (res) {
												return res[objStoreName];
											});

											promises[objStoreName] = promise;
										});

										_kinopromise2.default.all(promises).then(resolve).catch(reject);
									})();
								} else {
									reject(ex);
								}

								return;
							}

							transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_upsert_onFinish(evt) {
								var err = abortErr || evt.target.error;
								var isSuccess = !err && evt.type === 'complete';

								if (isSuccess) {
									resolve(isMulti ? result : result[objStoreNames[0]][0]);
								} else {
									reject((0, _error.ensureError)(err));
								}

								if (evt.type === 'error') {
									evt.preventDefault();
								}
							};

							var _loop3 = function _loop3(objStoreName) {
								var objStore = transaction.objectStore(objStoreName);

								var _loop4 = function _loop4(i) {
									var checkedData = checkSavedData(_this2.database.name, objStore, data[objStoreName][i]);

									if (!checkedData) {
										abortErr = (0, _error.createError)('InvalidStateError', 'You must supply objects to be saved in the object store with set keyPath');
										return {
											v: {
												v: void 0
											}
										};
									}

									var req = void 0;
									try {
										req = objStore.put.apply(objStore, checkedData);
									} catch (ex) {
										abortErr = ex;
										return 'continue';
									}

									req.onsuccess = function (evt) {
										result[objStoreName] = result[objStoreName] || [];
										result[objStoreName][i] = evt.target.result;
									};
								};

								for (var i = 0; i < data[objStoreName].length; i++) {
									var _ret6 = _loop4(i);

									switch (_ret6) {
										case 'continue':
											continue;

										default:
											if ((typeof _ret6 === 'undefined' ? 'undefined' : _typeof(_ret6)) === "object") return _ret6.v;
									}
								}
							};

							for (var objStoreName in data) {
								var _ret5 = _loop3(objStoreName);

								if ((typeof _ret5 === 'undefined' ? 'undefined' : _typeof(_ret5)) === "object") return _ret5.v;
							}
						});
					});
				},

				/**
     * 1) Delete one record from the object store
     * @param {String} objStoreName name of object store
     * @param {Mixed} key
     * @return {Promise}
     *   @param {Error} [err] if promise is rejected
     *
     * 2) Delete multiple records from the object stores (during one transaction)
     * @param {Object} data
     * @return {Promise}
     *   @param {Error} [err] if promise is rejected
     *
     * ATTENTION: you can pass only VALID KEYS OR KEY RANGES to delete records
     * @see https://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#dfn-valid-key
     * @see https://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#dfn-key-range
     */
				delete: function skladConnection_delete() {
					var _this3 = this;

					var isMulti = arguments.length === 1;
					var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];

					var allObjStoresExist = checkContainingStores.call(this, objStoreNames);
					if (!allObjStoresExist) {
						var err = (0, _error.createError)('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\'t contain all needed stores');
						return Promise.reject(err);
					}

					var data = void 0;
					if (isMulti) {
						data = arguments[0];
					} else {
						data = {};
						data[arguments[0]] = [arguments[1]];
					}

					return new Promise(function (resolve, reject) {
						var transaction = void 0;
						var abortErr = void 0;

						// Safari9 can't run multi-objectstore transactions
						// divide one transaction into many with one object store to fix this
						try {
							transaction = _this3.database.transaction(objStoreNames, _env.TRANSACTION_READWRITE);
						} catch (ex) {
							if (ex.name === 'NotFoundError') {
								var promises = objStoreNames.map(function (objStoreName) {
									return _this3.delete(objStoreName, data[objStoreName]);
								});
								Promise.all(promises).then(function () {
									return resolve();
								}).catch(reject);
							} else {
								reject(ex);
							}

							return;
						}

						transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_delete_onFinish(evt) {
							var err = abortErr || evt.target.error;

							if (err) {
								reject((0, _error.ensureError)(err));
							} else {
								resolve();
							}

							if (evt.type === 'error') {
								evt.preventDefault();
							}
						};

						var _loop5 = function _loop5(objStoreName) {
							var objStore = transaction.objectStore(objStoreName);

							data[objStoreName].forEach(function (recordKey) {
								if (abortErr) {
									return;
								}

								try {
									objStore.delete(recordKey);
								} catch (ex) {
									abortErr = ex;
								}
							});
						};

						for (var objStoreName in data) {
							_loop5(objStoreName);
						}
					});
				},

				/**
     * Clear object store(s)
     *
     * @param {Array|String} objStoreNames array of object stores or a single object store
     * @return {Promise}
     *   @param {Error} err
     */
				clear: function skladConnection_clear(objStoreNames) {
					var _this4 = this;

					objStoreNames = Array.isArray(objStoreNames) ? objStoreNames : [objStoreNames];

					var allObjStoresExist = checkContainingStores.call(this, objStoreNames);
					if (!allObjStoresExist) {
						var err = (0, _error.createError)('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\'t contain all needed stores');
						return Promise.reject(err);
					}

					return new Promise(function (resolve, reject) {
						var transaction = void 0;
						var abortErr = void 0;

						// Safari9 can't run multi-objectstore transactions
						// divide one transaction into many with one object store to fix this
						try {
							transaction = _this4.database.transaction(objStoreNames, _env.TRANSACTION_READWRITE);
						} catch (ex) {
							if (ex.name === 'NotFoundError') {
								var promises = objStoreNames.map(function (objStoreName) {
									return _this4.clear([objStoreName]);
								});
								Promise.all(promises).then(function () {
									return resolve();
								}).catch(reject);
							} else {
								reject(ex);
							}

							return;
						}

						transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_clear_onFinish(evt) {
							var err = abortErr || evt.target.error;

							if (err) {
								reject((0, _error.ensureError)(err));
							} else {
								resolve();
							}

							if (evt.type === 'error') {
								evt.preventDefault();
							}
						};

						objStoreNames.forEach(function (objStoreName) {
							var objStore = transaction.objectStore(objStoreName);

							if (abortErr) {
								return;
							}

							try {
								objStore.clear();
							} catch (ex) {
								abortErr = ex;
							}
						});
					});
				},

				/**
     * 1) Get objects from one object store
     * @param {String} objStoreName name of object store
     * @param {Object} options (optional) object with keys 'index', 'range', 'offset', 'limit' and 'direction'
     * @return {Promise}
     *   @param {Error} [err] if promise is rejected
     *   @param {Array} stored objects otherwise
     *
     * 2) Get objects from multiple object stores (during one transaction)
     * @param {Object} data
     * @return {Promise}
     *   @param {Error} [err] if promise is rejected
     *   @param {Object} stored objects otherwise
     */
				get: function skladConnection_get() {
					var _this5 = this;

					var isMulti = arguments.length === 1 && _typeof(arguments[0]) === 'object';
					var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];

					var allObjStoresExist = checkContainingStores.call(this, objStoreNames);
					if (!allObjStoresExist) {
						var err = (0, _error.createError)('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\'t contain all needed stores');
						return Promise.reject(err);
					}

					var result = {};
					var data = void 0,
					    abortErr = void 0;

					if (isMulti) {
						data = arguments[0];
					} else {
						data = {};
						data[arguments[0]] = arguments[1];
					}

					objStoreNames.forEach(function (objStoreName) {
						result[objStoreName] = [];
					});

					return new Promise(function (resolve, reject) {
						var transaction = void 0;

						// Safari9 can't run multi-objectstore transactions
						// divide one transaction into many with one object store to fix this
						try {
							transaction = _this5.database.transaction(objStoreNames, _env.TRANSACTION_READONLY);
						} catch (ex) {
							if (ex.name === 'NotFoundError') {
								(function () {
									var promises = {};

									objStoreNames.forEach(function (objStoreName) {
										var promise = _this5.get(objStoreName, data[objStoreName]);
										promises[objStoreName] = promise;
									});

									_kinopromise2.default.all(promises).then(resolve).catch(reject);
								})();
							} else {
								reject(ex);
							}

							return;
						}

						transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_get_onFinish(evt) {
							var err = abortErr || evt.target.error;
							var isSuccess = !err && evt.type === 'complete';

							if (isSuccess) {
								resolve(isMulti ? result : result[objStoreNames[0]]);
							} else {
								reject((0, _error.ensureError)(err));
							}

							if (evt.type === 'error') {
								evt.preventDefault();
							}
						};

						var _loop6 = function _loop6(objStoreName) {
							var objStore = transaction.objectStore(objStoreName);
							var options = data[objStoreName] || {};
							var direction = options.direction || skladAPI.ASC;
							var range = options.range instanceof _env.IDBKeyRangeRef ? options.range : null;

							var useGetAll = false;
							var iterateRequest = void 0;

							if (supportsObjStoreGetAll) {
								// getAll doesn't work for index ranges + it doesn't support special directions
								// @see https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAll
								useGetAll = Object.keys(options).every(function (key) {
									return key !== 'index' && key !== 'direction';
								});
							}

							if (options.index) {
								if (!objStore.indexNames.contains(options.index)) {
									abortErr = (0, _error.createError)('NotFoundError', 'Object store ' + objStore.name + ' doesn\'t contain "' + options.index + '" index');
									return {
										v: void 0
									};
								}

								try {
									iterateRequest = objStore.index(options.index).openCursor(range, direction);
								} catch (ex) {
									abortErr = ex;
									return {
										v: void 0
									};
								}
							} else if (useGetAll) {
								var _ret10 = function () {
									// If browser supports getAll/getAllKeys methods it could be faster to run these methods
									// to get all records if there's no `index` or `direction` options set
									// Unfortunately getAll doesn't expose result keys so we have to run both these methods
									// to get all keys and values
									// Anyway it seems like 2 getAll* ops are faster in modern browsers than that one
									// working with UDBCursor
									//
									// @see https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAll
									// @see https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAllKeys
									// @see http://jsperf.com/idb-idbcursor-vs-idbobjectstore-getall-ops/3
									var args = [range];
									var offset = 0;

									if (options.limit) {
										args.push(options.limit);

										if (options.offset) {
											args[1] += options.offset;
											offset = options.offset;
										}
									}

									try {
										// get all values request
										objStore.getAll.apply(objStore, args).onsuccess = function (evt) {
											var values = evt.target.result;

											values.forEach(function (value, index) {
												if (index < offset) {
													return;
												}

												var resultIndex = index - offset;
												result[objStoreName][resultIndex] = result[objStoreName][resultIndex] || {};
												result[objStoreName][resultIndex].value = value;
											});
										};

										// get all keys request
										objStore.getAllKeys.apply(objStore, args).onsuccess = function (evt) {
											var keys = evt.target.result;

											keys.forEach(function (key, index) {
												if (index < offset) {
													return;
												}

												var resultIndex = index - offset;
												result[objStoreName][resultIndex] = result[objStoreName][resultIndex] || {};
												result[objStoreName][resultIndex].key = key;
											});
										};
									} catch (ex) {
										abortErr = ex;
									} finally {
										// there are 2 separate IDBRequests running
										// so there's no need to bind listener to success event of any of them
										return {
											v: 'continue'
										};
									}
								}();

								if ((typeof _ret10 === 'undefined' ? 'undefined' : _typeof(_ret10)) === "object") return _ret10.v;
							} else {
								try {
									iterateRequest = objStore.openCursor(range, direction);
								} catch (ex) {
									abortErr = ex;
									return {
										v: void 0
									};
								}
							}

							var cursorPositionMoved = false;

							iterateRequest.onsuccess = function (evt) {
								var cursor = evt.target.result;

								// no more results
								if (!cursor) {
									return;
								}

								if (options.offset && !cursorPositionMoved) {
									cursorPositionMoved = true;
									cursor.advance(options.offset);

									return;
								}

								result[objStoreName].push({
									key: cursor.key,
									value: cursor.value
								});

								if (options.limit && options.limit === result[objStoreName].length) {
									return;
								}

								cursor.continue();
							};
						};

						for (var objStoreName in data) {
							var _ret9 = _loop6(objStoreName);

							switch (_ret9) {
								case 'continue':
									continue;

								default:
									if ((typeof _ret9 === 'undefined' ? 'undefined' : _typeof(_ret9)) === "object") return _ret9.v;
							}
						}
					});
				},

				/**
     * 1) Count objects in one object store
     * @param {String} objStoreName name of object store
     * @param {Object} options (optional) object with keys 'index' or/and 'range'
     * @return {Promise}
     *   @param {Error} [err] if promise is rejected
     *   @param {Number} number of stored objects otherwise
     *
     * 2) Count objects in multiple object stores (during one transaction)
     * @param {Object} data
     * @return {Promise}
     *   @param {Error} [err] if promise is rejected
     *   @param {Object} number of stored objects otherwise
     */
				count: function skladConnection_count() {
					var _this6 = this;

					var isMulti = arguments.length === 1 && _typeof(arguments[0]) === 'object';
					var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];
					var data = void 0;

					if (isMulti) {
						data = arguments[0];
					} else {
						data = {};
						data[arguments[0]] = typeof arguments[1] === 'function' ? null : arguments[1];
					}

					var allObjStoresExist = checkContainingStores.call(this, objStoreNames);
					if (!allObjStoresExist) {
						var err = (0, _error.createError)('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\'t contain all needed stores');
						return Promise.reject(err);
					}

					return new Promise(function (resolve, reject) {
						var result = {};
						var transaction = void 0;
						var countRequest = void 0;
						var abortErr = void 0;

						// Safari9 can't run multi-objectstore transactions
						// divide one transaction into many with one object store to fix this
						try {
							transaction = _this6.database.transaction(objStoreNames, _env.TRANSACTION_READONLY);
						} catch (ex) {
							if (ex.name === 'NotFoundError') {
								(function () {
									var promises = {};

									objStoreNames.forEach(function (objStoreName) {
										var promise = _this6.count(objStoreName, data[objStoreName]);
										promises[objStoreName] = promise;
									});

									_kinopromise2.default.all(promises).then(resolve).catch(reject);
								})();
							} else {
								reject(ex);
							}

							return;
						}

						transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_count_onFinish(evt) {
							var err = abortErr || evt.target.error;
							var isSuccess = !err && evt.type === 'complete';

							if (isSuccess) {
								resolve(isMulti ? result : result[objStoreNames[0]]);
							} else {
								reject((0, _error.ensureError)(err));
							}

							if (evt.type === 'error') {
								evt.preventDefault();
							}
						};

						var _loop7 = function _loop7(objStoreName) {
							var objStore = transaction.objectStore(objStoreName);
							var options = data[objStoreName] || {};
							var rangeArgs = options.range instanceof _env.IDBKeyRangeRef ? [options.range] : [];

							if (options.index) {
								if (!objStore.indexNames.contains(options.index)) {
									abortErr = (0, _error.createError)('NotFoundError', 'Object store ' + objStore.name + ' doesn\'t contain "' + options.index + '" index');
									return {
										v: void 0
									};
								}

								try {
									var index = objStore.index(options.index);
									countRequest = index.count.apply(index, rangeArgs);
								} catch (ex) {
									abortErr = ex;
									return {
										v: void 0
									};
								}
							} else {
								try {
									countRequest = objStore.count.apply(objStore, rangeArgs);
								} catch (ex) {
									abortErr = ex;
									return {
										v: void 0
									};
								}
							}

							countRequest.onsuccess = function (evt) {
								result[objStoreName] = evt.target.result || 0;
							};
						};

						for (var objStoreName in data) {
							var _ret12 = _loop7(objStoreName);

							if ((typeof _ret12 === 'undefined' ? 'undefined' : _typeof(_ret12)) === "object") return _ret12.v;
						}
					});
				},

				/**
     * Close IndexedDB connection
     */
				close: function skladConnection_close() {
					this.database.close();
					delete this.database;
				}
			};

			/**
    * Opens connection to a database
    *
    * @param {String} dbName database name
    * @param {Object} [options = {}] connection options
    * @param {Number} [options.version] database version
    * @param {Object} [options.migration] migration scripts
    * @return {Promise}
    *   @param {Object} [conn] if - promise is resolved
    *   @param {Error} [err] - if promise is rejected
    */
			skladAPI.open = function sklad_open(dbName) {
				var options = arguments.length <= 1 || arguments[1] === undefined ? { version: 1 } : arguments[1];

				return new Promise(function (resolve, reject) {
					if (!_env.indexedDbRef) {
						reject((0, _error.createError)('NotSupportedError', 'Your browser doesn\'t support IndexedDB'));
						return;
					}

					var openConnRequest = _env.indexedDbRef.open(dbName, options.version);
					var isResolvedOrRejected = false;

					openConnRequest.onupgradeneeded = function (evt) {
						if (isResolvedOrRejected) {
							return;
						}

						options.migration = options.migration || {};
						for (var i = evt.oldVersion + 1; i <= evt.newVersion; i++) {
							if (!options.migration[i]) continue;

							options.migration[i].call(this, this.result);
						}
					};

					openConnRequest.onerror = function (evt) {
						if (isResolvedOrRejected) {
							return;
						}

						evt.preventDefault();
						reject((0, _error.ensureError)(evt.target.error));

						isResolvedOrRejected = true;
					};

					openConnRequest.onsuccess = function (evt) {
						if (isResolvedOrRejected) {
							return;
						}

						var database = this.result;
						var oldVersion = parseInt(database.version || 0, 10);

						if (typeof database.setVersion === 'function' && oldVersion < options.version) {
							var changeVerRequest = database.setVersion(options.version);

							changeVerRequest.onsuccess = function (evt) {
								var customUpgradeNeededEvt = new Event('upgradeneeded');
								customUpgradeNeededEvt.oldVersion = oldVersion;
								customUpgradeNeededEvt.newVersion = options.version;
								openConnRequest.onupgradeneeded.call({ result: evt.target.source }, customUpgradeNeededEvt);

								database.close();
								skladAPI.open(dbName, options).then(resolve, reject);
							};

							changeVerRequest.onerror = function (evt) {
								var err = evt.target.errorMessage || evt.target.webkitErrorMessage || evt.target.mozErrorMessage || evt.target.msErrorMessage || evt.target.error.name;
								reject((0, _error.ensureError)(err));
							};

							return;
						}

						// store object stores properties in their own map
						objStoresMeta.set(dbName, new Map());

						resolve(Object.create(skladConnection, {
							database: {
								configurable: true,
								enumerable: false,
								value: database,
								writable: false
							}
						}));

						isResolvedOrRejected = true;
					};

					openConnRequest.onblocked = function (evt) {
						if (isResolvedOrRejected) {
							return;
						}

						evt.preventDefault();

						reject((0, _error.createError)('InvalidStateError', 'Database ' + dbName + ' is blocked'));
						isResolvedOrRejected = true;
					};
				});
			};

			/**
    * Deletes database
    *
    * @param {String} dbName
    * @return {Promise}
    *   @param {Error} [err] if promise is rejected
    */
			skladAPI.deleteDatabase = function sklad_deleteDatabase(dbName) {
				return new Promise(function (resolve, reject) {
					if (!_env.indexedDbRef) {
						reject((0, _error.createError)('NotSupportedError', 'Your browser doesn\'t support IndexedDB'));
						return;
					}

					var openDbRequest = _env.indexedDbRef.deleteDatabase(dbName);

					openDbRequest.onsuccess = openDbRequest.onerror = openDbRequest.onblocked = function sklad_deleteDatabase_onFinish(evt) {
						var err = evt.type === 'blocked' ? (0, _error.createError)('InvalidStateError', 'Database ' + dbName + ' is blocked') : evt.target.error;

						if (err) {
							reject((0, _error.ensureError)(err));
						} else {
							resolve();
						}

						if (evt.type !== 'success') {
							evt.preventDefault();
						}
					};
				});
			};

			skladAPI.keyValue = function sklad_keyValue(key, value) {
				return Object.create(skladKeyValueContainer, {
					key: { value: key, configurable: false, writable: false },
					value: { value: value, configurable: false, writable: false }
				});
			};

			exports.default = skladAPI;
			module.exports = exports['default'];

			/***/
		},
		/* 1 */
		/***/function (module, exports) {

			'use strict';

			var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
				return typeof obj;
			} : function (obj) {
				return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
			};

			var _createClass = function () {
				function defineProperties(target, props) {
					for (var i = 0; i < props.length; i++) {
						var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
					}
				}return function (Constructor, protoProps, staticProps) {
					if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
				};
			}();

			function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			}

			function _possibleConstructorReturn(self, call) {
				if (!self) {
					throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				}return call && (typeof call === "object" || typeof call === "function") ? call : self;
			}

			function _inherits(subClass, superClass) {
				if (typeof superClass !== "function" && superClass !== null) {
					throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
				}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
			}

			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			function _toConsumableArray(arr) {
				if (Array.isArray(arr)) {
					for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
						arr2[i] = arr[i];
					}return arr2;
				} else {
					return Array.from(arr);
				}
			}

			var KinoPromise = function (_Promise) {
				_inherits(KinoPromise, _Promise);

				function KinoPromise() {
					_classCallCheck(this, KinoPromise);

					return _possibleConstructorReturn(this, Object.getPrototypeOf(KinoPromise).apply(this, arguments));
				}

				_createClass(KinoPromise, [{
					key: 'spread',
					value: function spread(onFulfilled, onRejected) {
						function onFulfilledInternal(res) {
							if (Array.isArray(res)) {
								return onFulfilled.apply(undefined, _toConsumableArray(res));
							}
						};

						return this.then(onFulfilledInternal, onRejected);
					}
				}]);

				return KinoPromise;
			}(Promise);

			KinoPromise.all = function KinoPromise_static_all(promises) {
				if (arguments.length > 1 || (typeof promises === 'undefined' ? 'undefined' : _typeof(promises)) !== 'object') {
					return Promise.all.apply(Promise, arguments);
				}

				return new KinoPromise(function (resolve, reject) {
					var isPromisesList = Array.isArray(promises);
					var promisesArray = void 0;
					var promisesKeys = void 0;

					if (isPromisesList) {
						promisesArray = promises;
					} else {
						promisesKeys = Object.keys(promises);
						promisesArray = promisesKeys.map(function (key) {
							return promises[key];
						});
					}

					Promise.all(promisesArray).then(function (res) {
						// transform output into an object
						var output = void 0;

						if (isPromisesList) {
							output = res;
						} else {
							output = res.reduce(function (output, chunk, index) {
								output[promisesKeys[index]] = chunk;
								return output;
							}, {});
						}

						resolve(output);
					}).catch(reject);
				});
			};

			exports.default = KinoPromise;
			module.exports = exports['default'];

			/***/
		},
		/* 2 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Generates UUIDs for objects without keys set
    * @link http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = uuid;
			function uuid() {
				return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
					var r = Math.random() * 16 | 0;
					var v = c === 'x' ? r : r & 0x3 | 0x8;

					return v.toString(16);
				});
			}
			module.exports = exports['default'];

			/***/
		},
		/* 3 */
		/***/function (module, exports) {

			'use strict';

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.createError = createError;
			exports.ensureError = ensureError;
			function createError(name, message) {
				var errObj = new Error(message);
				errObj.name = name;

				return errObj;
			}

			function ensureError(err) {
				if (err instanceof Error) {
					return err;
				}

				return createError(err.name, err.message);
			}

			/***/
		},
		/* 4 */
		/***/function (module, exports) {

			'use strict';

			// service workers don't have access to window

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			var isBrowserUI = typeof window !== 'undefined';

			var indexedDbRef = exports.indexedDbRef = isBrowserUI ? window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB : indexedDB;

			var IDBKeyRangeRef = exports.IDBKeyRangeRef = isBrowserUI ? window.IDBKeyRange || window.mozIDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange : IDBKeyRange;

			var TRANSACTION_READONLY = exports.TRANSACTION_READONLY = isBrowserUI ? window.IDBTransaction.READ_ONLY || 'readonly' : 'readonly';

			var TRANSACTION_READWRITE = exports.TRANSACTION_READWRITE = isBrowserUI ? window.IDBTransaction.READ_WRITE || 'readwrite' : 'readwrite';

			var SORT_ASC = exports.SORT_ASC = isBrowserUI ? window.IDBCursor.NEXT || 'next' : 'next';

			var SORT_ASC_UNIQUE = exports.SORT_ASC_UNIQUE = isBrowserUI ? window.IDBCursor.NEXT_NO_DUPLICATE || 'nextunique' : 'nextunique';

			var SORT_DESC = exports.SORT_DESC = isBrowserUI ? window.IDBCursor.PREV || 'prev' : 'prev';

			var SORT_DESC_UNIQUE = exports.SORT_DESC_UNIQUE = isBrowserUI ? window.IDBCursor.PREV_NO_DUPLICATE || 'prevunique' : 'prevunique';

			/***/
		}
		/******/])
	);
});
;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_sklad__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_sklad___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_sklad__);
'use strict';

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }



const openMeta = (() => {
    var _ref = _asyncToGenerator(function* () {
        return yield __WEBPACK_IMPORTED_MODULE_0_sklad___default.a.open('meta', {
            version: 1,
            migration: {
                '1': function (database) {
                    // object store for logs
                    database.createObjectStore('log', { autoIncrement: true });

                    // object store for simple localStorage-like data
                    // which was previously managed by StorageManager
                    database.createObjectStore('keyvalues', { keyPath: 'key' });
                }
            }
        });
    });

    return function openMeta() {
        return _ref.apply(this, arguments);
    };
})();
/* harmony export (immutable) */ exports["a"] = openMeta;


const openUser = (() => {
    var _ref2 = _asyncToGenerator(function* (userId) {
        return yield __WEBPACK_IMPORTED_MODULE_0_sklad___default.a.open(`db_${ userId }`, {
            version: 1,
            migration: {
                '1': function (database) {
                    const contactsStore = database.createObjectStore('contacts', { keyPath: 'uid' });
                    contactsStore.createIndex('last_message', 'last_message_ts');
                    contactsStore.createIndex('messages_num', 'messages_num');
                    contactsStore.createIndex('name', ['first_name', 'last_name']);
                    contactsStore.createIndex('fulltext', 'fulltext', { multiEntry: true });

                    const messagesStore = database.createObjectStore('messages', { keyPath: 'mid' });
                    messagesStore.createIndex('user_chats', ['uid', 'chat']); // get all chats where user said smth
                    messagesStore.createIndex('user_messages', 'uid'); // get all user messages
                    messagesStore.createIndex('chat_participants', ['chat', 'uid']); // get all chat participants
                    messagesStore.createIndex('chat_messages', 'chat'); // get all chat messages sorted by date
                    messagesStore.createIndex('tag', 'tags', { multiEntry: true });
                    messagesStore.createIndex('fulltext', 'fulltext', { multiEntry: true });

                    const chatsStore = database.createObjectStore('chats', { keyPath: 'id' });
                    chatsStore.createIndex('last_message', 'last_message_ts');
                }
            }
        });
    });

    return function openUser(_x) {
        return _ref2.apply(this, arguments);
    };
})();
/* harmony export (immutable) */ exports["b"] = openUser;


const dropUser = (() => {
    var _ref3 = _asyncToGenerator(function* (userId) {
        return yield __WEBPACK_IMPORTED_MODULE_0_sklad___default.a.deleteDatabase(`db_${ userId }`);
    });

    return function dropUser(_x2) {
        return _ref3.apply(this, arguments);
    };
})();
/* harmony export (immutable) */ exports["c"] = dropUser;


/***/ },
/* 6 */
/***/ function(module, exports) {

module.exports = require("assert");

/***/ },
/* 7 */,
/* 8 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__errorhandler__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__storage__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__db__ = __webpack_require__(9);
'use strict';





const storageManager = new __WEBPACK_IMPORTED_MODULE_1__storage__["a" /* default */]();

// enable error processing
__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__errorhandler__["a" /* default */])(global.__filename);

var forceSkipSync = false;

/**
 * Показать chrome.notification
 *
 * @param {Object} data
 * @param {String} data.title
 * @param {String} data.message
 * @param {String} data.icon
 * @param {Number} [data.uid]
 * @param {String} [data.id]
 * @param {String} [data.sound]
 * @param {Number} [data.timeout]
 * @param {Function} [data.onclick]
 */
function showChromeNotification(data) {
    // Linux check
    // @see https://developer.chrome.com/extensions/notifications
    if (!chrome.notifications) return;

    var promise = data.uid ? getAvatarImage(data.icon, data.uid) : Promise.resolve(data.icon);

    var showChromeNotificationInner = function (uri) {
        uri = uri || data.icon;

        chrome.notifications.create((data.id || Math.random()) + '', {
            type: 'basic',
            iconUrl: uri,
            title: data.title,
            message: data.message,
            isClickable: true
        }, function (notificationId) {
            if (data.onclick) {
                notificationHandlers[notificationId] = data.onclick;
            }

            if (data.sound) {
                SoundManager.play(data.sound);
            }

            if (data.timeout) {
                setTimeout(function () {
                    chrome.notifications.clear(notificationId, _.noop);
                }, data.timeout * 1000);
            }
        });
    };

    promise.then(showChromeNotificationInner, function () {
        showChromeNotificationInner();
    });
}

/**
 * Flatten settings by getting their values in this moment
 * @return {Object}
 */
function getFlatSettings() {
    var flatSettings = {};
    SettingsManager.getAvailable().forEach(function (key) {
        flatSettings[key] = SettingsManager[key];
    });

    return flatSettings;
}

function leaveOneAppWindowInstance(openIfNoExist) {
    var appWindows = chrome.app.window.getAll();
    appWindows.forEach(function (win, isNotFirst) {
        if (isNotFirst) {
            win.close();
        } else {
            win.focus();
            win.show();
        }
    });

    if (!appWindows.length && openIfNoExist) {
        openAppWindow();
    }
}

// notification click handlers
// FIXME refactor
/*var notificationHandlers = {};
chrome.notifications.onClicked.addListener(function notificationHandler(notificationId) {
    var notificationCallback = notificationHandlers[notificationId];

    if (notificationId === "tokenExpiredRequest") {
        notificationCallback = function () {
            CPA.sendEvent("App-Data", "tokenExpired notification click");

            // close all app windows
            var appWindows = chrome.app.window.getAll();
            appWindows.forEach(function (win) {
                win.close();
            });

            openAppWindow(null, true);
        };
    }

    if (!notificationCallback)
        return;

    chrome.notifications.clear(notificationId, _.noop);
    notificationCallback();

    delete notificationHandlers[notificationId];
});

chrome.alarms.onAlarm.addListener(function (alarmInfo) {
    switch (alarmInfo.name) {
        case "dayuse":
            CPA.sendEvent("Lifecycle", "Dayuse", "Total users", 1);
            CPA.sendEvent("Lifecycle", "Dayuse", "Authorized users", AccountsManager.currentUserId ? 1 : 0);

            var appInstallTime = storageManager.get("app_install_time");
            if (appInstallTime) {
                var totalDaysLive = Math.floor((Date.now() - appInstallTime) / 1000 / 60 / 60 / 24);
                CPA.sendEvent("Lifecycle", "Dayuse", "App life time", totalDaysLive);
            }

            var requestsLog = storageManager.get("requests", {constructor: Object, strict: true, create: true});
            for (var url in requestsLog) {
                CPA.sendEvent("Lifecycle", "Dayuse", "Requests: " + url, requestsLog[url]);
            }

            storageManager.remove("requests");

            chrome.storage.local.get("dayuse.dau", function (records) {
                var isActiveUser = records["dayuse.dau"];
                if (!isActiveUser) {
                    return;
                }

                CPA.sendEvent("Lifecycle", "DAU");
                chrome.storage.local.remove("dayuse.dau", _.noop);
            });

            break;

        case "weekuse":
            chrome.storage.local.get("weekuse.wau", function (records) {
                var isActiveUser = records["weekuse.wau"];
                if (!isActiveUser) {
                    return;
                }

                CPA.sendEvent("Lifecycle", "WAU");
                chrome.storage.local.remove("weekuse.wau", _.noop);
            });

            break;

        case "fetchnews":
            ReqManager.apiMethod("wall.get", {
                access_token: null, // объявления получать обязательно, поэтому ходим без токенов
                owner_id: (0 - App.VK_ADV_GROUP[0]),
                count: 5,
                filter: "owner"
            }, function (data) {
                var seenPosts = storageManager.get("vkgroupwall_synced_posts", {constructor: Array, strict: true, create: true});
                var postsToStore = [];

                data.response.slice(1).forEach(function (post) {
                    if (seenPosts.indexOf(post.id) !== -1 || App.VK_ADV_GROUP[1] >= post.id)
                        return;

                    postsToStore.push(post);
                });

                if (postsToStore.length) {
                    storageManager.set("vkgroupwall_stored_posts", postsToStore);

                    chrome.runtime.sendMessage({
                        action: "newWallPosts",
                        newPostsNum: postsToStore.length
                    });
                }
            }, _.noop);

            break;

        case "actualizeChats":
            DatabaseManager.actualizeChatDates();
            break;

        case "actualizeContacts":
            DatabaseManager.actualizeContacts().catch(function (errMsg) {
                LogManager.error(errMsg);
                CPA.sendEvent("Custom-Errors", "Database error", errMsg);
            });

            break;

        case "propose-launcher":
            // promote VK Offline launcher
            chrome.notifications && chrome.notifications.create(Math.random() + "", {
                type: "image",
                imageUrl: chrome.runtime.getURL("pic/launcher.png"),
                title: chrome.i18n.getMessage("launcherNotificationTitle"),
                message: chrome.i18n.getMessage("launcherNotificationMessage"),
                iconUrl: chrome.runtime.getURL("pic/icon48.png"),
                isClickable: false
            }, function (id) {
                SoundManager.play("message");
                CPA.sendEvent("Lifecycle", "Actions", "Install.NotifyLauncherPromote.Show");
            });

            break;

        case "sleeping-awake":
            // do nothing. this alarm is just for waking up an app
            break;
    }
});

// install & update handling
chrome.runtime.onInstalled.addListener(function (details) {
    var appName = chrome.runtime.getManifest().name;
    var currentVersion = chrome.runtime.getManifest().version;

    switch (details.reason) {
        case "install":
            CPA.changePermittedState(true);
            CPA.sendEvent("Lifecycle", "Dayuse", "Install", 1);

            MigrationManager.start(currentVersion);

            // propose to install VK Offline launcher after 2 minutes on inactivity after install
            // inactivity means not opening app window
            chrome.alarms.create("propose-launcher", {delayInMinutes: 2});
            break;

        case "update":
            if (currentVersion !== details.previousVersion) {
                MigrationManager.start(currentVersion);
                CPA.sendEvent("Lifecycle", "Dayuse", "Upgrade", 1);
            }

            break;
    }

    chrome.alarms.get("dayuse", function (alarmInfo) {
        if (!alarmInfo) {
            chrome.alarms.create("dayuse", {
                delayInMinutes: 24 * 60,
                periodInMinutes: 24 * 60
            });
        }
    });

    chrome.alarms.get("fetchnews", function (alarmInfo) {
        if (!alarmInfo) {
            chrome.alarms.create("fetchnews", {
                periodInMinutes: 24 * 60,
                delayInMinutes: 1
            });
        }
    });

    chrome.alarms.get("weekuse", function (alarmInfo) {
        if (!alarmInfo) {
            chrome.alarms.create("weekuse", {
                delayInMinutes: 7 * 24 * 60,
                periodInMinutes: 7 * 24 * 60
            });
        }
    });

    var uninstallUrl = App.GOODBYE_PAGE_URL + "?ver=" + currentVersion;
    if (typeof chrome.runtime.setUninstallURL === "function") {
        chrome.runtime.setUninstallURL(uninstallUrl);
    }

    var installDateKey = "app_install_time";
    chrome.storage.local.get(installDateKey, function (records) {
        records[installDateKey] = records[installDateKey] || Date.now();
        chrome.storage.local.set(records);
    });

    // create sleeping awake alarm
    chrome.alarms.create("sleeping-awake", {periodInMinutes: 1});
});

// listen to messages from Listen! app
chrome.runtime.onMessageExternal.addListener(function (msg, sender, sendResponse) {
    if (sender.id === App.LISTENAPP_ID && msg.action === "importAuthToken") {
        if (AccountsManager.currentUserId) {
            sendResponse({
                user_id: Number(AccountsManager.currentUserId),
                token: AccountsManager.list[AccountsManager.currentUserId].token
            });
        } else {
            sendResponse(null);
        }
    } else if (sender.id === App.LAUNCHER_EXTENSION_ID && msg.action === "launch") {
        leaveOneAppWindowInstance(true);
    } else {
        sendResponse(false);
    }
});

function openAppWindow(evt, tokenExpired) {
    chrome.app.window.create("main.html", {
        id: uuid(),
        innerBounds: {
            minWidth: 1000,
            minHeight: 700
        }
    }, function (win) {
        // flatten settings by getting their values in this moment
        win.contentWindow.Settings = getFlatSettings();

        // pass current user data
        win.contentWindow.Account = {
            currentUserId: AccountsManager.currentUserId,
            currentUserFio: AccountsManager.current ? AccountsManager.current.fio : null,
            tokenExpired: tokenExpired
        };
    });

    chrome.alarms.clear("propose-launcher", _.noop);
}

// app lifecycle
chrome.app.runtime.onLaunched.addListener(openAppWindow);
chrome.app.runtime.onRestarted.addListener(openAppWindow);*/

Promise.all([storageManager.load(), __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].initMeta()]).then(function readyToGo(err) {
    SettingsManager.init();
    LogManager.config("App started");

    var syncingData = {},
        // объект с ключами inbox, sent и contacts - счетчик максимальных чисел
    uidsProcessing = {}; // объект из элементов вида {currentUserId1: {uid1: true, uid2: true, uid3: true}, ...}

    var clearSyncingDataCounters = function (userId) {
        if (syncingData[userId] !== undefined) {
            syncingData[userId].contacts[0] = 0;
            syncingData[userId].contacts[1] = 0;

            syncingData[userId].inbox[0] = 0;
            syncingData[userId].inbox[1] = 0;

            syncingData[userId].sent[0] = 0;
            syncingData[userId].sent[1] = 0;
        } else {
            syncingData[userId] = {
                "contacts": [0, 0], // [total, current]
                "inbox": [0, 0],
                "sent": [0, 0]
            };
        }
    };

    // устанавливаем обработчики offline-событий
    window.addEventListener("online", function (e) {
        chrome.runtime.sendMessage({ "action": "onlineStatusChanged", "status": "online" });

        // на самом деле сеть может быть, а связи с интернетом - нет
        if (AccountsManager.currentUserId) {
            startUserSession();
        }
    }, false);

    window.addEventListener("offline", function (e) {
        ReqManager.abortAll();
        chrome.runtime.sendMessage({ "action": "onlineStatusChanged", "status": "offline" });
    }, false);

    var longPollEventsRegistrar = {
        init: function (currentUserId) {
            // обрываем LP-запрос старого пользователя
            if (this._longPollXhrIds[currentUserId]) {
                ReqManager.abort(this._longPollXhrIds[currentUserId]);
                delete this._longPollXhrIds[currentUserId];
            }

            // [ISSUES6] решение проблемы
            this._longPollXhrIds[currentUserId] = null;
            this._getCredentials(currentUserId);
        },

        _onLoad: function (currentUserId, res) {
            var self = this;

            if (res.failed !== undefined) {
                if (res.failed === 2) {
                    // ключ устарел
                    LogManager.warn("LongPoll server key is now obsolete. Re-requesting a new key..." + " [" + this._longPollXhrIds[currentUserId] + "]");
                } else {
                    LogManager.error("LongPoll server request failed: " + JSON.stringify(res) + " [" + this._longPollXhrIds[currentUserId] + "]");
                }

                delete this._longPollXhrIds[currentUserId];

                this.init(currentUserId);
                return;
            }

            LogManager.info(JSON.stringify(res));

            res.updates.forEach(function (data) {
                switch (data[0]) {
                    case 2:
                        if (data[2] & 128) {
                            // Сообщение удалено на сайте.
                            // в идеале нужно менять соответствующий индекс массива "messagesGot" для корректной работы mailSync
                            // В то же время и для исходящих, и для входящих сообщений data[2] === 128, и чтобы определить входящее сообщение или нет, необходимо делать доп. запрос.
                            // За это время может произойти ошибка duplicate key
                        } else if (data[2] & 8) {
                            // сообщение отмечено как важное
                            __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].markMessageWithTag(data[1], "important", _.noop, function (isDatabaseError, errMsg) {
                                if (isDatabaseError) {
                                    LogManager.error(errMsg);
                                    CPA.sendEvent("Custom-Errors", "Database error", errMsg);
                                }
                            });
                        } else if (data[2] & 1) {
                            __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].markAsUnread(data[1], function () {
                                chrome.runtime.sendMessage({ "action": "msgReadStatusChange", "read": false, "id": data[1] });
                            }, function (errMsg) {
                                LogManager.error(errMsg);
                                CPA.sendEvent("Custom-Errors", "Database error", errMsg);
                            });
                        }

                        break;

                    case 3:
                        if (data[2] & 128) {
                            // сообщение восстановлено на сайте
                            __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].unmarkMessageWithTag(data[1], "trash", _.noop, function (isDatabaseError, errMsg) {
                                if (isDatabaseError) {
                                    LogManager.error(errMsg);
                                    CPA.sendEvent("Custom-Errors", "Database error", errMsg);
                                }
                            });
                        } else if (data[2] & 8) {
                            // сообщение больше не важное
                            __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].unmarkMessageWithTag(data[1], "important", _.noop, function (isDatabaseError, errMsg) {
                                if (isDatabaseError) {
                                    LogManager.error(errMsg);
                                    CPA.sendEvent("Custom-Errors", "Database error", errMsg);
                                }
                            });
                        } else if (data[2] & 1) {
                            __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].markAsRead(data[1], function () {
                                chrome.runtime.sendMessage({ "action": "msgReadStatusChange", "read": true, "id": data[1] });
                            }, function (errMsg) {
                                LogManager.error(errMsg);
                                CPA.sendEvent("Custom-Errors", "Database error", errMsg);
                            });
                        }

                        break;

                    case 4:
                        var uid = data[7].from !== undefined ? data[7].from : data[3],
                            mailType = data[2] & 2 ? "sent" : "inbox",
                            onUserDataReady;

                        syncingData[currentUserId][mailType][1] += 1;

                        onUserDataReady = function (userData) {
                            var attachments = [];
                            var msgData = {};

                            for (var field in data[7]) {
                                var matches = field.match(/^attach([\d]+)$/);
                                if (!matches) continue;

                                var attachType = data[7]["attach" + matches[1] + "_type"];
                                attachments.push([attachType].concat(data[7][field].split("_")));
                            }

                            if (data[7].geo !== undefined) {
                                attachments.push(["geopoint", data[7].geo]);
                            }

                            msgData.mid = data[1];
                            msgData.uid = userData.uid;
                            msgData.date = data[4];
                            msgData.title = data[5];
                            msgData.body = data[6];
                            msgData.read_state = data[2] & 1 ? 0 : 1;
                            msgData.attachments = attachments;
                            msgData.chat_id = data[7].from !== undefined ? data[3] - 2000000000 : 0;
                            msgData.tags = [mailType];
                            msgData.emoji = data[7].emoji ? 1 : 0;

                            if (attachments.length) {
                                msgData.tags.push("attachments");
                            }

                            __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].insertMessages(currentUserId, [msgData], function () {
                                // обновляем фронтенд
                                chrome.runtime.sendMessage({
                                    action: "messageReceived",
                                    data: msgData,
                                    userdata: userData
                                });

                                if (mailType === "inbox") {
                                    var avatar = userData.photo || chrome.runtime.getURL("pic/question_th.gif");
                                    showNotification(avatar, userData.uid);
                                }

                                function showNotification(avatarUrl, uid) {
                                    if (SettingsManager.NotificationsTime === 0 /* || SettingsManager.ShowWhenVK === 0*/) return;

                                    showChromeNotification({
                                        uid: uid,
                                        title: userData.first_name + " " + userData.last_name,
                                        message: msgData.body.replace(/<br>/gm, "\n"),
                                        icon: avatarUrl,
                                        sound: "message",
                                        timeout: SettingsManager.NotificationsTime === 12 ? undefined : SettingsManager.NotificationsTime * 5,
                                        onclick: function () {
                                            LogManager.config("Clicked notification with message #" + msgData.mid);
                                            leaveOneAppWindowInstance(true);
                                        }
                                    });

                                    LogManager.config("Open notification with message #" + msgData.mid);
                                }
                            });
                        };

                        __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].getContactById(currentUserId, uid, onUserDataReady, function (err) {
                            // теоретически может измениться currentUserId
                            if (currentUserId === AccountsManager.currentUserId) {
                                getUserProfile(currentUserId, parseInt(uid, 10), onUserDataReady);
                            }
                        });

                        break;

                    case 8:
                        // пользователь -data[1] онлайн
                        if (SettingsManager.ShowOnline === 1) {
                            chrome.runtime.sendMessage({ "action": "contactOnlineStatus", "uid": -data[1], "online": true });
                        }

                        break;

                    case 9:
                        // пользователь -data[1] оффлайн (нажал кнопку "выйти" если data[2] === 0, иначе по таймауту)
                        if (SettingsManager.ShowOnline === 1) {
                            chrome.runtime.sendMessage({ "action": "contactOnlineStatus", "uid": -data[1], "online": false });
                        }

                        break;

                    case 61: // пользователь data[1] начал набирать текст в диалоге
                    case 62:
                        // пользователь data[1] начал набирать текст в беседе data[2]
                        break;

                    default:
                        LogManager.info([data[0], data]);
                }
            });

            if (AccountsManager.currentUserId === currentUserId) {
                this._longPollData[currentUserId].ts = res.ts;
                this._longPollInit(currentUserId);
            }
        },

        _onError: function (currentUserId, errorCode, errorData) {
            delete this._longPollXhrIds[currentUserId];
            if (errorCode === ReqManager.ABORT) return;

            this.init(currentUserId);

            if (AccountsManager.currentUserId === currentUserId) {
                mailSync(currentUserId, "inbox");
                mailSync(currentUserId, "sent");
            }
        },

        _getCredentials: function (currentUserId) {
            var self = this;

            ReqManager.apiMethod("messages.getLongPollServer", function (data) {
                if (AccountsManager.currentUserId !== currentUserId) return;

                self._longPollData[currentUserId] = data.response;
                self._longPollInit(currentUserId);
            }, function (errCode) {
                delete self._longPollXhrIds[currentUserId];

                if (errCode === ReqManager.ACCESS_DENIED) {
                    chrome.runtime.sendMessage({ action: "tokenExpired" });
                }

                switch (errCode) {
                    case ReqManager.ABORT:
                    case ReqManager.ACCESS_DENIED:
                        return;
                }

                window.setTimeout(self.init.bind(self), 5000, currentUserId);
            });
        },

        _longPollInit: function (currentUserId) {
            var domain = this._longPollData[currentUserId].server.replace("vkontakte.ru", "vk.com");

            this._longPollXhrIds[currentUserId] = ReqManager.forceUrlGet("https://" + domain, {
                "act": "a_check",
                "key": this._longPollData[currentUserId].key,
                "ts": this._longPollData[currentUserId].ts,
                "wait": 25,
                "mode": 2,
                "timeout": 30
            }, this._onLoad.bind(this, currentUserId), this._onError.bind(this, currentUserId));
        },

        _longPollData: {},
        _longPollXhrIds: {},
        _tags: {}
    };

    /**
     * Запрос к API ВКонтакте за пользователями и последующая запись их в БД
     *
     * @param {Number} currentUserId
     * @param {Number} uid
     * @param {Function} callback функция, в которую передается весь объект-ответ от API ВКонтакте
     */
    function getUserProfile(currentUserId, uid, callback) {
        var tokenForRequest = AccountsManager.list[currentUserId].token;

        uidsProcessing[currentUserId] = uidsProcessing[currentUserId] || {};
        callback = callback || _.noop;

        // проверяем uid на нахождение в списке обрабатываемых
        if (uidsProcessing[currentUserId][uid]) {
            return;
        }

        ReqManager.apiMethod("users.get", {
            uids: String(uid),
            fields: "first_name,last_name,sex,domain,bdate,photo,contacts",
            access_token: tokenForRequest
        }, function (data) {
            // записываем данные друзей в БД и скачиваем их аватарки
            updateUsersData(currentUserId, data.response).then(function (users) {
                var userData = users[0];

                // удаляем из списка обрабатываемых
                delete uidsProcessing[currentUserId][userData.uid];

                callback(userData);
            });
        }, function (errCode, errData) {
            switch (errCode) {
                case ReqManager.ABORT:
                case ReqManager.ACCESS_DENIED:
                    return;
            }

            window.setTimeout(getUserProfile, 5 * 1000, currentUserId, uid, callback);
        });
    }

    /**
     * Синхронизация списка друзей
     * @param {Integer} currentUserId
     */
    var friendsSync = function (currentUserId) {
        if (friendsSync.running) return;

        // флаг, чтобы не вызывать метод одновременно несколько раз подряд
        friendsSync.running = true;

        var friendsSyncTimes = storageManager.get("friends_sync_time", { constructor: Object, strict: true, create: true });
        var milliSecondsTimeout = App.FRIENDS_UPDATE_TIMEOUT * 1000;
        var nextRequestTimeout;

        // проверяем, чтобы запросы на синхронизацию шли только от текущего активного пользователя
        if (currentUserId !== AccountsManager.currentUserId) {
            friendsSync.running = false;
            return;
        }

        // проверяем, чтобы не было слишком частых запросов
        if (friendsSyncTimes[currentUserId]) {
            nextRequestTimeout = Math.max(milliSecondsTimeout - Math.abs(Date.now() - friendsSyncTimes[currentUserId]), 0);
            if (nextRequestTimeout > 0) {
                window.setTimeout(friendsSync, nextRequestTimeout, currentUserId);

                friendsSync.running = false;
                return;
            }
        }

        // поздравляем текущего пользователя с ДР
        getUserProfile(currentUserId, currentUserId, function (currentUserData) {
            var nowDate = new Date(),
                nowDay = nowDate.getDate(),
                nowYear = nowDate.getFullYear(),
                nowMonth = nowDate.getMonth() + 1,
                bDate,
                i,
                notification,
                msg;

            if (currentUserData.bdate === undefined || currentUserData.bdate.length === 0) return;

            // разбиваем и преобразуем в числа
            bDate = currentUserData.bdate.split(".");
            for (i = 0; i < bDate.length; i++) bDate[i] = parseInt(bDate[i], 10);

            if (bDate[0] !== nowDay || bDate[1] !== nowMonth) return;

            showChromeNotification({
                title: App.NAME,
                message: chrome.i18n.getMessage("happyBirthday").replace("%appname%", App.NAME),
                icon: chrome.runtime.getURL("pic/smile.png"),
                sound: "message",
                onclick: function () {
                    CPA.sendEvent("App-Actions", "BD notification click");
                    leaveOneAppWindowInstance(true);
                }
            });

            CPA.sendEvent("App-Data", "Show BD notification");
        });

        ReqManager.apiMethod("friends.get", { fields: "first_name,last_name,sex,domain,bdate,photo,contacts" }, function (data) {
            var nowDate = new Date(),
                nowDay = nowDate.getDate(),
                nowYear = nowDate.getFullYear(),
                nowMonth = nowDate.getMonth() + 1;

            syncingData[currentUserId].contacts[0] += data.response.length;

            // записываем данные друзей в БД и скачиваем их аватарки
            updateUsersData(currentUserId, data.response).then(function (users) {
                users.forEach(function (userDoc) {
                    var bDate, i;

                    // удаляем из списка обрабатываемых
                    delete uidsProcessing[currentUserId][userDoc.uid];

                    syncingData[currentUserId].contacts[1] += 1;
                    chrome.runtime.sendMessage({
                        action: "syncProgress",
                        userId: currentUserId,
                        type: "contacts",
                        total: syncingData[currentUserId].contacts[0],
                        current: syncingData[currentUserId].contacts[1]
                    });

                    if (SettingsManager.ShowBirthdayNotifications === 0) return;

                    // показываем уведомление, если у кого-то из друзей ДР
                    if (userDoc.bdate === undefined || userDoc.bdate.length === 0) return;

                    // разбиваем и преобразуем в числа
                    bDate = userDoc.bdate.split(".");
                    for (i = 0; i < bDate.length; i++) bDate[i] = parseInt(bDate[i], 10);

                    if (bDate[0] !== nowDay || bDate[1] !== nowMonth) return;

                    // показываем уведомление о ДР
                    var i18nBirthDay = chrome.i18n.getMessage("birthday").split("|"),
                        i18nYears = chrome.i18n.getMessage("years").split("|"),
                        hisHerMatches = i18nBirthDay[0].match(/([^\s]+)-([^\s]+)/),
                        msg,
                        yoNow,
                        notification;

                    userDoc.sex = userDoc.sex || 0;
                    switch (userDoc.sex) {
                        case 1:
                            // female
                            msg = i18nBirthDay[0].replace(hisHerMatches[0], hisHerMatches[2]) + "!";
                            break;

                        case 2:
                            // male
                            msg = i18nBirthDay[0].replace(hisHerMatches[0], hisHerMatches[1]) + "!";
                            break;

                        default:
                            // non-specified
                            msg = i18nBirthDay[0].replace(hisHerMatches[0], hisHerMatches[1] + " (" + hisHerMatches[2] + ")") + "!";
                    }

                    if (bDate.length === 3) {
                        yoNow = nowYear - bDate[2];
                        msg += " (" + i18nBirthDay[1].replace("%years%", yoNow + " " + Utils.string.plural(yoNow, i18nYears)) + ")";
                    }

                    showChromeNotification({
                        uid: userDoc.uid,
                        title: userDoc.first_name + " " + userDoc.last_name,
                        message: msg,
                        icon: userDoc.photo || chrome.runtime.getURL("pic/question_th.gif"),
                        sound: "message",
                        onclick: function () {
                            leaveOneAppWindowInstance(true);
                        }
                    });
                });

                var inboxSynced = storageManager.get("perm_inbox_" + currentUserId) !== null;
                var sentSynced = storageManager.get("perm_outbox_" + currentUserId) !== null;

                friendsSyncTimes[currentUserId] = Date.now();
                storageManager.set("friends_sync_time", friendsSyncTimes);

                // следующая синхронизация должна начаться через FRIENDS_UPDATE_TIMEOUT
                window.setTimeout(friendsSync, milliSecondsTimeout, currentUserId);

                // если к этому моменту уже синхронизированы входящие и исходящие
                if (AccountsManager.currentUserId === currentUserId) {
                    if (inboxSynced && sentSynced) {
                        // сбрасываем счетчик синхронизации
                        clearSyncingDataCounters(currentUserId);

                        Promise.all([__WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].actualizeContacts(currentUserId), __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].actualizeChatDates(currentUserId)]).then(function () {
                            chrome.runtime.sendMessage({
                                action: "ui",
                                which: "user",
                                currentUserId: AccountsManager.currentUserId,
                                currentUserFio: AccountsManager.current ? AccountsManager.current.fio : null
                            });
                        });
                    }
                }

                friendsSync.running = false;
            });
        }, function (errCode, errData) {
            friendsSync.running = false;

            switch (errCode) {
                case ReqManager.ABORT:
                case ReqManager.ACCESS_DENIED:
                    return;
            }

            window.setTimeout(friendsSync, 5 * 1000, currentUserId);
        });
    };

    /**
     * Функция-обработчик, которая запускается в методах friends.get/users.get, поскольку оба метода возвращают примерно
     * одинаковый ответ и имеют общую логику записи данных в БД
     *
     * @param {Number} currentUserId
     * @param {Array} users
     * @return {Promise} [description]
     */
    function updateUsersData(currentUserId, users) {
        return new Promise(function (resolve, reject) {
            var dataToReplace = [];
            uidsProcessing[currentUserId] = uidsProcessing[currentUserId] || {};

            users.forEach(function (userData) {
                // добавляем uid в список обрабатываемых
                uidsProcessing[currentUserId][userData.uid] = true;

                // обновляем ФИО пользователя
                if (currentUserId === userData.uid) {
                    AccountsManager.setFio(currentUserId, userData.first_name + " " + userData.last_name);
                }

                dataToReplace.push([userData.uid, userData.first_name, userData.last_name, userData]);
            });

            if (!dataToReplace.length) {
                resolve([]);
                return;
            }

            __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].replaceContacts(currentUserId, dataToReplace).then(resolve, function (err) {
                var errMessage = err.name + ": " + err.message;

                LogManager.error(errMessage);
                CPA.sendEvent("Custom-Errors", "Database error", "Failed to replace contact: " + errMessage);

                reject(errMessage);
            });
        });
    }

    /**
     * Особенность mailSync заключается в том, что она должна запускаться редко и из startUserSession
     * К моменту начала работы mailSync текущий активный пользователь может смениться. Тем не менее
     * функция должна отработать до конца, то есть или скачать все сообщения до нуля in descending order, или
     * дойти до момента, когда внутреннняя функция записи сообщений в БД вернет ошибку DUPLICATE ID. mailSync не должна
     * показывать всплывающие уведомления, это прерогатива обработчика данных от LongPoll-сервера
     */
    var mailSync = function (currentUserId, mailType, latestMessageId) {
        var offset = syncingData[currentUserId][mailType][1];
        var userDataForRequest = AccountsManager.list[currentUserId],
            compatName = mailType === "inbox" ? "inbox" : "outbox",
            permKey = "perm_" + compatName + "_" + currentUserId,
            firstSync = storageManager.get(permKey) === null;

        var latestMsg = offset ? Promise.resolve(latestMessageId) : __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].getLatestTagMessageId(mailType);

        var getMessages = new Promise(function (resolve, reject) {
            var reqData = {
                access_token: userDataForRequest.token,
                count: 100,
                preview_length: 0,
                out: mailType === "sent" ? 1 : 0,
                offset: offset
            };

            ReqManager.apiMethod("messages.get", reqData, resolve, function (errCode, errData) {
                reject({
                    code: errCode,
                    data: errData
                });
            });
        });

        Promise.all([getMessages, latestMsg]).then(function (res) {
            var data = res[0];
            var latestMessageId = res[1];
            var timeToStopAfter = false; // message found with id equal to latestMessageId

            // flatten response structure
            var messages = [],
                dataSyncedFn;

            dataSyncedFn = function () {
                var inboxSynced, sentSynced, friendsSynced, wallTokenUpdated;

                storageManager.set(permKey, 1);

                inboxSynced = storageManager.get("perm_inbox_" + currentUserId) !== null;
                sentSynced = storageManager.get("perm_outbox_" + currentUserId) !== null;
                friendsSynced = storageManager.get("friends_sync_time", { constructor: Object, strict: true, create: true })[currentUserId] !== undefined;

                if (AccountsManager.currentUserId === currentUserId) {
                    // если к этому моменту вся почта синхронизирована и друзья тоже, то перерисовываем фронт
                    if (inboxSynced && sentSynced && friendsSynced) {
                        // сбрасываем счетчик синхронизации
                        clearSyncingDataCounters(currentUserId);

                        // маленькое замечение: после того как аккаунт мигрирован с 3 на 4 версию, стартует startUserSession()
                        // она запускает mailSync(), что в свою очередь породит перерисовку фронта на "ui" => "user"
                        // чтобы защититься от этого проверяем, был ли обновлен токен
                        wallTokenUpdated = storageManager.get("wall_token_updated", { constructor: Object, strict: true, create: true })[AccountsManager.currentUserId] !== undefined;
                        if (wallTokenUpdated) {
                            Promise.all([__WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].actualizeContacts(currentUserId), __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].actualizeChatDates(currentUserId)]).then(function () {
                                chrome.runtime.sendMessage({
                                    action: "ui",
                                    which: "user",
                                    currentUserId: AccountsManager.currentUserId,
                                    currentUserFio: AccountsManager.current ? AccountsManager.current.fio : null
                                });
                            });
                        }
                    }
                }
            };

            // все получили
            if (data.response === 0 || data.response instanceof Array && data.response.length === 1 || forceSkipSync) {
                dataSyncedFn();
                return;
            }

            syncingData[currentUserId][mailType][0] = data.response[0];

            if (uidsProcessing[currentUserId] === undefined) {
                uidsProcessing[currentUserId] = {};
            }

            // отсекаем общий счетчик сообщений
            _.forEach(data.response, function (msgData, index) {
                var coords;

                // пропускаем общий счетчик
                if (!index) return;

                if (msgData.mid === latestMessageId) {
                    timeToStopAfter = true;
                    return false;
                }

                // backwards-compatibility. До 4 версии при отсутствии вложений писался пустой объект
                // теперь мы определяем это на фронте при отрисовке
                msgData.attachments = msgData.attachments || [];

                // геоданные также пишем как вложение
                if (msgData.geo && msgData.geo.type === "point") {
                    coords = msgData.geo.coordinates.split(" ");

                    msgData.attachments.push({
                        type: "geopoint",
                        geopoint: {
                            lat: coords[0],
                            lng: coords[1]
                        }
                    });
                }

                msgData.chat_id = msgData.chat_id || 0;
                msgData.tags = [mailType];

                if (msgData.attachments.length) msgData.tags.push("attachments");

                // проверяем существует ли пользователь
                if (!uidsProcessing[currentUserId][msgData.uid]) {
                    __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].getContactById(currentUserId, msgData.uid, null, function (err) {
                        getUserProfile(currentUserId, msgData.uid);
                    });
                }

                messages.push(msgData);
                if (msgData.read_state === 0 && storageManager.get(permKey) === null) {
                    // FIXME: calculate number of new messages
                    // show notification afterwards
                }
            });

            __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].insertMessages(currentUserId, messages, function () {
                syncingData[currentUserId][mailType][1] += messages.length;

                chrome.runtime.sendMessage({
                    "action": "syncProgress",
                    "userId": currentUserId,
                    "type": mailType,
                    "total": syncingData[currentUserId][mailType][0],
                    "current": syncingData[currentUserId][mailType][1]
                });

                if (timeToStopAfter || syncingData[currentUserId][mailType][1] > data.response[0]) {
                    dataSyncedFn();
                    return;
                }

                mailSync(currentUserId, mailType, latestMessageId);
            }, _.noop);
        }, function (err) {
            if (err.name instanceof DOMError) {
                var errMsg = err.name + ": " + err.message;
                throw new Error(errMsg);
            }

            switch (err.code) {
                case ReqManager.ACCESS_DENIED:
                    // TODO error
                    break;

                default:
                    console.log('Error ', err);
                    window.setTimeout(mailSync, 5000, currentUserId, mailType, latestMessageId);
                    break;
            }
        });
    };

    /**
     * Должен запускаться только в четырех случаях: при старте приложения (то есть при загрузке ОС), при смене аккаунта,
     * при добавлении и при удалении аккаунта. При отрисовке UI ничего запускать не нужно - она должна работать с кэшем и событиями.
     * Отличие же friendsSync/eventsRegistrar/mailSync в том, что первые два независимы и работают только для текущего пользователя,
     * а mailSync должен уметь работать не зная кто является текущим
     */
    var startUserSession = function (callback) {
        var currentUserId = AccountsManager.currentUserId;

        // сбрасываем все XHR-запросы
        ReqManager.abortAll();

        // инициализируем БД
        __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].initUser(currentUserId, function () {
            if (AccountsManager.currentUserId !== currentUserId) return;

            // сбрасываем счетчики синхронизации
            clearSyncingDataCounters(AccountsManager.currentUserId);

            if (navigator.onLine) {
                friendsSync(AccountsManager.currentUserId);
                longPollEventsRegistrar.init(AccountsManager.currentUserId);

                mailSync(AccountsManager.currentUserId, "inbox");
                mailSync(AccountsManager.currentUserId, "sent");
            }

            if (typeof callback === "function") {
                callback();
            }
        }, function (errMsg) {
            LogManager.error(errMsg);
            CPA.sendEvent("Critical-Errors", "Database init user", errMsg);
        });

        // включаем статистику запросов ВК
        // @see http://vk.com/dev/stats.trackVisitor
        ReqManager.apiMethod("stats.trackVisitor", _.noop);
    };

    chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) {
        var sendAsyncResponse = false;

        switch (request.action) {
            case "addFirstAccount":
                AccountsManager.setData(request.uid, request.token, "...");
                AccountsManager.currentUserId = request.uid;

                var wallTokenUpdated = storageManager.get("wall_token_updated", { constructor: Object, strict: true, create: true });
                wallTokenUpdated[AccountsManager.currentUserId] = 1;
                storageManager.set("wall_token_updated", wallTokenUpdated);

                startUserSession(function () {
                    chrome.runtime.sendMessage({
                        action: "ui",
                        which: "syncing",
                        currentUserId: AccountsManager.currentUserId,
                        currentUserFio: AccountsManager.current ? AccountsManager.current.fio : null
                    });
                });

                break;

            case "addAnotherAccount":
                var newUserGranted = AccountsManager.list[request.uid] === undefined;
                if (!newUserGranted) {
                    AccountsManager.setData(request.uid, request.token);

                    // уведомляем об ошибке
                    chrome.runtime.sendMessage({
                        action: "tokenUpdatedInsteadOfAccountAdd",
                        uid: request.uid,
                        fio: AccountsManager.list[request.uid].fio
                    });

                    return;
                }

                CPA.sendEvent("App-Actions", "2+ account added");

                AccountsManager.setData(request.uid, request.token, "...");
                AccountsManager.currentUserId = request.uid;

                var wallTokenUpdated = storageManager.get("wall_token_updated", { constructor: Object, strict: true, create: true });
                wallTokenUpdated[AccountsManager.currentUserId] = 1;
                storageManager.set("wall_token_updated", wallTokenUpdated);

                startUserSession(function () {
                    chrome.runtime.sendMessage({
                        action: "ui",
                        which: "syncing"
                    });
                });

                break;

            case "updateExistingToken":
                var neededUserTokenUpdated = request.neededUid === request.uid;
                var newUserGranted = true;

                for (var listUserId in AccountsManager.list) {
                    listUserId = Number(listUserId);

                    if (listUserId === request.uid) {
                        newUserGranted = false;
                        break;
                    }
                }

                if (newUserGranted) {
                    // уведомляем об ошибке
                    chrome.runtime.sendMessage({
                        action: "tokenAddedInsteadOfUpdate",
                        uid: request.uid,
                        token: request.token
                    });

                    return;
                }

                AccountsManager.setData(request.uid, request.token);

                if (neededUserTokenUpdated) {
                    CPA.sendEvent("App-Actions", "Account token updated");

                    chrome.runtime.sendMessage({
                        action: "tokenUpdated"
                    });
                } else {
                    chrome.runtime.sendMessage({
                        action: "tokenUpdatedForWrongUser",
                        uid: request.uid,
                        fio: AccountsManager.list[request.uid].fio
                    });
                }

                break;

            case "getAccountsList":
                sendAsyncResponse = true;

                var accounts = {};
                var promises = [];

                var assignAvatar = function (account, uid) {
                    return new Promise(function (resolve, reject) {
                        __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].getContactById(AccountsManager.currentUserId, uid, function (contactData) {
                            account.avatar = contactData.photo;
                            resolve();
                        }, function (err) {
                            if (err) {
                                LogManager.error(err + '');
                            }

                            resolve();
                        });
                    });
                };

                _.forIn(AccountsManager.list, function (value, key) {
                    accounts[key] = value;
                    promises.push(assignAvatar(value, key));
                });

                Promise.all(promises).then(function () {
                    sendResponse(accounts);
                });

                break;

            case "saveSettings":
                _.forIn(request.settings, function (value, key) {
                    SettingsManager[key] = value;
                });

                // notify app windows
                chrome.runtime.sendMessage({
                    action: "settingsChanged",
                    settings: getFlatSettings()
                });

                break;

            case "tokenExpiredRequest":
                var tokenExpiredAlarmName = "tokenExpiredNotifyThrottle";
                chrome.alarms.get(tokenExpiredAlarmName, function (alarmInfo) {
                    // if alarm is set user has already seen notification about expired token
                    if (alarmInfo) {
                        return;
                    }

                    // create alarm to prevent notifying user too often
                    chrome.alarms.create(tokenExpiredAlarmName, {
                        delayInMinutes: 60 * 24
                    });

                    // show notification
                    showChromeNotification({
                        id: "tokenExpiredRequest",
                        title: chrome.i18n.getMessage("tokenExpiredNotificationTitle"),
                        message: chrome.i18n.getMessage("tokenExpiredNotificationMessage"),
                        icon: chrome.runtime.getURL("pic/icon48.png"),
                        sound: "error"
                    });

                    CPA.sendEvent("App-Data", "tokenExpired notification seen");
                });

                break;

            case "uiDraw":
                sendAsyncResponse = true;
                sendResponse(true);

                var uiType;
                var changelogNotified = storageManager.get("changelog_notified", { constructor: Array, strict: true, create: true });
                var inboxSynced, sentSynced, friendsSynced;
                var wallTokenUpdated;

                if (AccountsManager.currentUserId) {
                    inboxSynced = storageManager.get("perm_inbox_" + AccountsManager.currentUserId) !== null;
                    sentSynced = storageManager.get("perm_outbox_" + AccountsManager.currentUserId) !== null;
                    friendsSynced = storageManager.get("friends_sync_time", { constructor: Object, strict: true, create: true })[AccountsManager.currentUserId] !== undefined;

                    if (inboxSynced && sentSynced && friendsSynced) {
                        uiType = "user";
                    } else {
                        uiType = "syncing";
                    }
                } else {
                    uiType = "guest";
                }

                switch (uiType) {
                    case "user":
                        CPA.sendAppView("Users");
                        CPA.sendEvent("UI-Draw", "Users", AccountsManager.currentUserId);

                        chrome.storage.local.set({
                            "dayuse.dau": true,
                            "weekuse.wau": true
                        });

                        break;

                    case "syncing":
                        CPA.sendAppView("Syncing");
                        CPA.sendEvent("UI-Draw", "Syncing", AccountsManager.currentUserId);
                        break;

                    case "guest":
                        CPA.sendAppView("Guests");
                        CPA.sendEvent("UI-Draw", "Guests");
                        break;
                }

                // уведомляем фронт
                chrome.runtime.sendMessage({
                    action: "ui",
                    which: uiType,
                    currentUserId: AccountsManager.currentUserId,
                    currentUserFio: AccountsManager.current ? AccountsManager.current.fio : null
                });

                break;

            case "closeNotification":
                if (notificationHandlers[request.mid]) {
                    chrome.notifications.clear(request.mid, _.noop);
                    delete notificationHandlers[request.mid];
                }

                break;

            // NB. Есть баг, когда в некоторых версиях браузера сортировка работает слишком долго. Для определения этого момента в 4.4 внедрено следующее решение:
            // При первом запросе контактов проверяем, сколько времени работал запрос к бэкенду. Если это заняло больше 3 секунд, то меняем настройку сортировки.
            // Соответственно "забываем" запрос и порождаем новый.
            // 13.0.755.0 (83879) - долгая выборка контактов
            case "fetchContactList":
                var breakNeeded = false,
                    timeoutId,
                    onContactsListReady;

                sendAsyncResponse = true;
                onContactsListReady = function (contactsList) {
                    if (contactsList.length === 0) {
                        return;
                    }

                    var contactsIds = contactsList.map(function (contactData) {
                        return contactData.uid;
                    });

                    ReqManager.apiMethod("users.get", { "uids": contactsIds.join(","), "fields": "online" }, function (data) {
                        data.response.forEach(function (chunk) {
                            var isOnline = chunk.online === 1 || chunk.online_mobile === 1;
                            chrome.runtime.sendMessage({ "action": "contactOnlineStatus", "uid": chunk.uid, "online": isOnline });
                        });
                    });
                };

                timeoutId = window.setTimeout(function () {
                    var defaultSettingsUsed = storageManager.get("settings") === null;
                    if (defaultSettingsUsed === false) {
                        return;
                    }

                    breakNeeded = true;
                    SettingsManager.SortContacts = 2;

                    __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].getContactList("alpha", request.totalShown, function (contacts) {
                        sendResponse(contacts);

                        if (SettingsManager.ShowOnline === 1) {
                            onContactsListReady(contacts[0]);
                        }
                    }, function (errMsg) {
                        sendResponse([[], 0]);
                        LogManager.error(errMsg);
                    });
                }, 3000);

                __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].getContactList(request.type, request.totalShown, function (contacts) {
                    if (breakNeeded) {
                        return;
                    }

                    sendResponse(contacts);
                    window.clearTimeout(timeoutId);

                    if (SettingsManager.ShowOnline === 1) {
                        onContactsListReady(contacts[0]);
                    }
                }, function (errMsg) {
                    if (breakNeeded) {
                        return;
                    }

                    sendResponse([[], 0]);
                    LogManager.error(errMsg);

                    window.clearTimeout(timeoutId);
                });

                break;

            case "fetchConversations":
                sendAsyncResponse = true;
                __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].getConversations(request.totalShown, sendResponse, function (errMsg) {
                    sendResponse([[], 0]);
                    LogManager.error(errMsg);
                });

                break;

            case "getDialogThread":
                sendAsyncResponse = true;

                __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].getDialogThread(request.id, {
                    from: request.from !== undefined ? request.from : 0,
                    everything: Boolean(request.print)
                }, sendResponse, function (errMsg) {
                    sendResponse([[], 0]);
                    LogManager.error(errMsg);
                });

                break;

            case "getMessageInfo":
                sendAsyncResponse = true;
                __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].getMessageById(Number(request.mid), sendResponse, function (isDatabaseError, errMsg) {
                    sendResponse(undefined);

                    if (isDatabaseError) {
                        LogManager.error(errMsg);
                        CPA.sendEvent("Custom-Errors", "Database error", errMsg);
                    }
                });

                break;

            case "getConversationThreadsWithContact":
                sendAsyncResponse = true;
                __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].getConversationThreadsWithContact(request.uid, sendResponse, function (errMsg) {
                    sendResponse([]);
                    LogManager.error(errMsg);
                });

                break;

            case "getContactData":
                sendAsyncResponse = true;
                __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].getContactById(AccountsManager.currentUserId, request.uid, sendResponse, function (err) {
                    sendResponse(null);
                });

                if (SettingsManager.ShowOnline === 1 && request.includeOnlineStatus) {
                    ReqManager.apiMethod("users.get", { "uids": request.uid, "fields": "online" }, function (data) {
                        data.response.forEach(function (chunk) {
                            var isOnline = chunk.online === 1 || chunk.online_mobile === 1;
                            chrome.runtime.sendMessage({ "action": "contactOnlineStatus", "uid": chunk.uid, "online": isOnline });
                        });
                    });
                }

                break;

            // TODO как-то формализировать
            case "errorGot":
                CPA.sendEvent("Custom-Errors", request.error, request.message);
                break;

            case "sendMessage":
                var msgParams = {};
                sendAsyncResponse = true;

                if (request.body !== undefined) {
                    msgParams.message = request.body;
                }

                if (request.subject !== undefined) {
                    msgParams.title = request.subject;
                }

                if (request.sid !== undefined) {
                    msgParams.captcha_sid = request.sid;
                }

                if (request.key !== undefined) {
                    msgParams.captcha_key = request.key;
                }

                if (request.attachments.length) {
                    msgParams.attachment = request.attachments.join(",");
                }

                if (/^[\d]+$/.test(request.to)) {
                    msgParams.chat_id = request.to;
                } else {
                    msgParams.uid = request.to.split("_")[1];
                }

                if (request.coords !== undefined) {
                    msgParams.lat = request.coords.latitude;
                    msgParams.long = request.coords.longitude;
                }

                ReqManager.apiMethod("messages.send", msgParams, function (data) {
                    CPA.sendEvent("App-Actions", "Sent Message", AccountsManager.currentUserId);
                    SoundManager.play("sent");

                    sendResponse([0, data]);
                }, function (errCode, errData) {
                    CPA.sendEvent("Custom-Errors", "Failed to send message", errCode);
                    SoundManager.play("error");

                    switch (errCode) {
                        case ReqManager.CAPTCHA:
                            sendResponse([1, errData]);
                            break;

                        default:
                            if (errCode === ReqManager.RESPONSE_ERROR && errData.code === 7) {
                                sendResponse([2]);
                                return;
                            }

                            sendResponse([3]);
                            break;
                    }
                });

                break;

            case "getMessagesUploadServer":
                var sendRequest = function () {
                    ReqManager.apiMethod("photos.getMessagesUploadServer", sendResponse, function (errCode, errData) {
                        switch (errCode) {
                            case ReqManager.NO_INTERNET:
                            case ReqManager.NOT_JSON:
                            case ReqManager.TIMEOUT:
                            case ReqManager.RESPONSE_ERROR:
                                window.setTimeout(sendRequest, 5 * 1000);
                                break;

                            default:
                                sendResponse(null);
                        }
                    });
                };

                sendRequest();
                sendAsyncResponse = true;
                break;

            case "getDocsUploadServer":
                var sendRequest = function () {
                    ReqManager.apiMethod("docs.getUploadServer", sendResponse, function (errCode, errData) {
                        switch (errCode) {
                            case ReqManager.NO_INTERNET:
                            case ReqManager.NOT_JSON:
                            case ReqManager.TIMEOUT:
                            case ReqManager.RESPONSE_ERROR:
                                window.setTimeout(sendRequest, 5 * 1000);
                                break;

                            default:
                                sendResponse(null);
                        }
                    });
                };

                sendRequest();
                sendAsyncResponse = true;
                break;

            case "saveMessagesPhoto":
                var sendRequest = function (requestData) {
                    ReqManager.apiMethod("photos.saveMessagesPhoto", {
                        "server": requestData.server,
                        "photo": requestData.photo,
                        "hash": requestData.hash
                    }, sendResponse, function (errCode, errData) {
                        switch (errCode) {
                            case ReqManager.NO_INTERNET:
                            case ReqManager.NOT_JSON:
                            case ReqManager.TIMEOUT:
                            case ReqManager.RESPONSE_ERROR:
                                window.setTimeout(sendRequest, 5 * 1000, requestData);
                                break;

                            default:
                                sendResponse(null);
                        }
                    });
                };

                sendRequest(request);
                sendAsyncResponse = true;
                break;

            case "saveMessagesDoc":
                var sendRequest = function (requestData) {
                    ReqManager.apiMethod("docs.save", {
                        "file": requestData.file
                    }, sendResponse, function (errCode, errData) {
                        switch (errCode) {
                            case ReqManager.NO_INTERNET:
                            case ReqManager.NOT_JSON:
                            case ReqManager.TIMEOUT:
                            case ReqManager.RESPONSE_ERROR:
                                window.setTimeout(sendRequest, 5 * 1000, requestData);
                                break;

                            default:
                                sendResponse(null);
                        }
                    });
                };

                sendRequest(request);
                sendAsyncResponse = true;
                break;

            case "addLike":
                CPA.sendEvent("App-Actions", "Like and repost");
                sendAsyncResponse = true;

                var sendLikeRequest = function () {
                    ReqManager.apiMethod("wall.addLike", {
                        "owner_id": -29809053,
                        "post_id": 454,
                        "repost": 1
                    }, function (data) {
                        sendResponse(1);
                    }, function (errCode, errData) {
                        switch (errCode) {
                            case ReqManager.NO_INTERNET:
                            case ReqManager.NOT_JSON:
                            case ReqManager.TIMEOUT:
                                window.setTimeout(sendLikeRequest, 5 * 1000);
                                break;

                            case ReqManager.RESPONSE_ERROR:
                                if (errData.code === 217 || errData.code === 215) {
                                    sendResponse(1);
                                    return;
                                }

                                window.setTimeout(sendLikeRequest, 5 * 1000);
                                break;

                            default:
                                sendResponse(0);
                        }
                    });
                };

                var sendJoinGroupRequest = function () {
                    ReqManager.apiMethod("groups.join", {
                        "gid": 29809053
                    }, null, function (errCode, errData) {
                        switch (errCode) {
                            case ReqManager.NO_INTERNET:
                            case ReqManager.NOT_JSON:
                            case ReqManager.TIMEOUT:
                            case ReqManager.RESPONSE_ERROR:
                                window.setTimeout(sendJoinGroupRequest, 5 * 1000);
                                break;
                        }
                    });
                };

                sendLikeRequest();
                sendJoinGroupRequest();
                break;

            case "getDocById":
                // vk bug: метод docs.getById возвращает response: []
                // http://vkontakte.ru/topic-1_21972169?post=36014
                var sendRequest;

                sendAsyncResponse = true;

                if (request.mid !== undefined) {
                    sendRequest = function (requestData) {
                        requestData.ownerId = parseInt(requestData.ownerId, 10);
                        requestData.id = parseInt(requestData.id, 10);

                        ReqManager.apiMethod("messages.getById", { "mid": requestData.mid }, function (data) {
                            if (data.response instanceof Array === false || data.response.length !== 2 || data.response[1].attachments === undefined) {
                                CPA.sendEvent("Custom-Errors", "Attachment info missing", requestData);

                                sendResponse(null);
                                return;
                            }

                            var i;

                            for (i = 0; i < data.response[1].attachments.length; i++) {
                                if (data.response[1].attachments[i].type === "doc" && data.response[1].attachments[i].doc.owner_id === requestData.ownerId && data.response[1].attachments[i].doc.did === requestData.id) {
                                    sendResponse(data.response[1].attachments[i].doc);
                                    return;
                                }
                            }

                            CPA.sendEvent("Custom-Errors", "Attachment info missing", requestData);
                        }, function (errCode, errData) {
                            switch (errCode) {
                                case ReqManager.NO_INTERNET:
                                case ReqManager.NOT_JSON:
                                case ReqManager.TIMEOUT:
                                case ReqManager.RESPONSE_ERROR:
                                    window.setTimeout(sendRequest, 5 * 1000, requestData);
                                    break;

                                default:
                                    sendResponse(null);
                            }
                        });
                    };
                } else {
                    sendRequest = function (requestData) {
                        ReqManager.apiMethod("docs.getById", { "docs": requestData.ownerId + "_" + requestData.id }, function (data) {
                            var output = data.response.length ? data.response[0] : null;
                            if (output === null) {
                                CPA.sendEvent("Custom-Errors", "Attachment info missing", requestData);
                            }

                            sendResponse(output);
                        }, function (errCode, errData) {
                            switch (errCode) {
                                case ReqManager.NO_INTERNET:
                                case ReqManager.NOT_JSON:
                                case ReqManager.TIMEOUT:
                                case ReqManager.RESPONSE_ERROR:
                                    window.setTimeout(sendRequest, 5 * 1000, requestData);
                                    break;

                                default:
                                    sendResponse(null);
                            }
                        });
                    };
                }

                sendRequest(request);
                break;

            case "getGeopointById":
                sendAsyncResponse = true;

                var sendRequest = function (msgId) {
                    ReqManager.apiMethod("messages.getById", { "mid": msgId }, function (data) {
                        if (data.response instanceof Array === false || data.response.length !== 2 || data.response[1].geo === undefined) {
                            CPA.sendEvent("Custom-Errors", "Attachment info missing", request);

                            sendResponse(null);
                            return;
                        }

                        var coords = data.response[1].geo.coordinates.split(" ");
                        sendResponse(coords);
                    }, function (errCode, errData) {
                        switch (errCode) {
                            case ReqManager.NO_INTERNET:
                            case ReqManager.NOT_JSON:
                            case ReqManager.TIMEOUT:
                            case ReqManager.RESPONSE_ERROR:
                                window.setTimeout(sendRequest, 5 * 1000, msgId);
                                break;

                            default:
                                sendResponse(null);
                        }
                    });
                };

                sendRequest(request.mid);
                break;

            case "getAudioById":
                var sendRequest = function (requestData) {
                    ReqManager.apiMethod("audio.getById", { "audios": requestData.ownerId + "_" + requestData.id }, function (data) {
                        var output = data.response.length ? data.response[0] : null;
                        if (output === null) {
                            CPA.sendEvent("Custom-Errors", "Attachment info missing", requestData);
                        }

                        sendResponse(output);
                    }, function (errCode, errData) {
                        switch (errCode) {
                            case ReqManager.NO_INTERNET:
                            case ReqManager.NOT_JSON:
                            case ReqManager.TIMEOUT:
                            case ReqManager.RESPONSE_ERROR:
                                window.setTimeout(sendRequest, 5 * 1000, requestData);
                                break;

                            default:
                                sendResponse(null);
                        }
                    });
                };

                sendRequest(request);
                sendAsyncResponse = true;
                break;

            case "getVideoById":
                var sendRequest = function (requestData) {
                    ReqManager.apiMethod("video.get", { "videos": requestData.ownerId + "_" + requestData.id }, function (data) {
                        var output = data.response instanceof Array && data.response.length === 2 ? data.response[1] : null;
                        if (output === null) {
                            CPA.sendEvent("Custom-Errors", "Attachment info missing", requestData);
                        }

                        sendResponse(output);
                    }, function (errCode, errData) {
                        switch (errCode) {
                            case ReqManager.NO_INTERNET:
                            case ReqManager.NOT_JSON:
                            case ReqManager.TIMEOUT:
                            case ReqManager.RESPONSE_ERROR:
                                window.setTimeout(sendRequest, 5 * 1000, requestData);
                                break;

                            default:
                                sendResponse(null);
                        }
                    });
                };

                sendRequest(request);
                sendAsyncResponse = true;
                break;

            case "getPhotoById":
                var sendRequest;

                if (request.mid !== undefined) {
                    sendRequest = function (requestData) {
                        requestData.ownerId = parseInt(requestData.ownerId, 10);
                        requestData.id = parseInt(requestData.id, 10);

                        ReqManager.apiMethod("messages.getById", { "mid": requestData.mid }, function (data) {
                            if (data.response instanceof Array === false || data.response.length !== 2 || data.response[1].attachments === undefined) {
                                CPA.sendEvent("Custom-Errors", "Attachment info missing", requestData);

                                sendResponse(null);
                                return;
                            }

                            var i;

                            for (i = 0; i < data.response[1].attachments.length; i++) {
                                if (data.response[1].attachments[i].type === "photo" && data.response[1].attachments[i].photo.owner_id === requestData.ownerId && data.response[1].attachments[i].photo.pid === requestData.id) {
                                    sendResponse(data.response[1].attachments[i].photo);
                                    return;
                                }
                            }

                            CPA.sendEvent("Custom-Errors", "Attachment info missing", requestData);
                        }, function (errCode, errData) {
                            switch (errCode) {
                                case ReqManager.NO_INTERNET:
                                case ReqManager.NOT_JSON:
                                case ReqManager.TIMEOUT:
                                case ReqManager.RESPONSE_ERROR:
                                    window.setTimeout(sendRequest, 5 * 1000, requestData);
                                    break;

                                default:
                                    sendResponse(null);
                            }
                        });
                    };
                } else {
                    sendRequest = function (requestData) {
                        ReqManager.apiMethod("photos.getById", { "photos": requestData.ownerId + "_" + requestData.id }, function (data) {
                            var output = data.response.length ? data.response[0] : null;
                            if (output === null) {
                                CPA.sendEvent("Custom-Errors", "Attachment info missing", requestData);
                            }

                            sendResponse(output);
                        }, function (errCode, errData) {
                            switch (errCode) {
                                case ReqManager.NO_INTERNET:
                                case ReqManager.NOT_JSON:
                                case ReqManager.TIMEOUT:
                                case ReqManager.RESPONSE_ERROR:
                                    window.setTimeout(sendRequest, 5 * 1000, requestData);
                                    break;

                                default:
                                    sendResponse(null);
                            }
                        });
                    };
                }

                sendRequest(request);
                sendAsyncResponse = true;
                break;

            case "markMessageTag":
                __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].markMessageWithTag(request.mid, request.tag, function () {
                    sendResponse(true);
                }, function (isDatabaseError, errMsg) {
                    if (isDatabaseError) {
                        LogManager.error(errMsg);
                        CPA.sendEvent("Custom-Errors", "Database error", errMsg);
                    }

                    sendResponse(false);
                });

                sendAsyncResponse = true;
                break;

            case "migrateIntrested":
                openAppWindow();
                break;

            case "unmarkMessageTag":
                __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].unmarkMessageWithTag(request.mid, request.tag, function () {
                    sendResponse(true);
                }, function (isDatabaseError, errMsg) {
                    if (isDatabaseError) {
                        LogManager.error(errMsg);
                        CPA.sendEvent("Custom-Errors", "Database error", errMsg);
                    }

                    sendResponse(false);
                });

                sendAsyncResponse = true;
                break;

            case "serverDeleteMessage":
                var sendDropMessageRequest = function (msgId) {
                    ReqManager.apiMethod("messages.delete", { "mid": msgId }, function (data) {
                        sendResponse(true);
                    }, function (errCode, errData) {
                        switch (errCode) {
                            case ReqManager.NO_INTERNET:
                            case ReqManager.NOT_JSON:
                            case ReqManager.TIMEOUT:
                            case ReqManager.RESPONSE_ERROR:
                                window.setTimeout(sendDropMessageRequest, 60 * 1000, msgId);
                                break;
                        }

                        LogManager.error("Deleting message failed (got error code " + errCode + ")");
                        sendResponse(false);
                    });
                };

                sendDropMessageRequest(request.mid);
                sendAsyncResponse = true;
                break;

            case "serverRestoreMessage":
                CPA.sendEvent("App-Data", "Use restore messages");

                var sendRestoreMessageRequest = function (msgId) {
                    ReqManager.apiMethod("messages.restore", { "mid": msgId }, function (data) {
                        sendResponse(true);
                    }, function (errCode, errData) {
                        switch (errCode) {
                            case ReqManager.NO_INTERNET:
                            case ReqManager.NOT_JSON:
                            case ReqManager.TIMEOUT:
                                window.setTimeout(sendRestoreMessageRequest, 60 * 1000, msgId);
                                break;
                        }

                        LogManager.error("Restoring message failed (got error code " + errCode + ")");
                        sendResponse(false);
                    });
                };

                sendRestoreMessageRequest(request.mid);
                sendAsyncResponse = true;
                break;

            case "deleteMessageForever":
                var onDrop,
                    sendDropMessageRequest,
                    actionsToGo = request.serverToo ? 2 : 1,
                    actionsMade = 0;

                sendAsyncResponse = true;

                onDrop = function () {
                    actionsMade += 1;
                    if (actionsMade !== actionsToGo) {
                        return;
                    }

                    sendResponse(null);
                };

                sendDropMessageRequest = function (msgId) {
                    ReqManager.apiMethod("messages.delete", { "mid": msgId }, function (data) {
                        onDrop();
                    }, function (errCode, errData) {
                        switch (errCode) {
                            case ReqManager.NO_INTERNET:
                            case ReqManager.NOT_JSON:
                            case ReqManager.TIMEOUT:
                                window.setTimeout(sendDropMessageRequest, 60 * 1000, msgId);
                                break;
                        }

                        LogManager.error("Deleting message failed (got error code " + errCode + ")");
                        onDrop();
                    });
                };

                if (request.serverToo) {
                    // посылаем запрос на сервер
                    sendDropMessageRequest(request.mid);
                }

                // удаляем все данные о сообщении в БД
                __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].deleteMessage(request.mid, onDrop);
                break;

            case "speechChange":
                CPA.sendEvent("App-Actions", "Speech change", {
                    "chrome": process.versions.chrome,
                    "app": App.VERSION,
                    "uid": AccountsManager.currentUserId
                });

                break;

            case "newsPostSeen":
                CPA.sendEvent("App-Data", "News seen", request.id);
                break;

            case "newsLinkClicked":
                CPA.sendEvent("App-Actions", "News link clicked", [request.id, request.url]);
                break;

            case "newsAudioPlaying":
                CPA.sendEvent("App-Actions", "Audio playing", [request.id, request.owner_id, request.aid]);
                break;

            case "tourWatch":
                CPA.sendEvent("App-Data", "WP seen", request.step);
                break;

            case "useImportantTag":
                CPA.sendEvent("App-Data", "Use important tag", request.type);
                break;

            case "getTagsFrequency":
                sendAsyncResponse = true;
                __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].getTagsCount(sendResponse, function (errMsg) {
                    LogManager.error(errMsg);
                    CPA.sendEvent("Custom-Errors", "Database error", errMsg);

                    sendResponse({});
                });

                break;

            case "getMessagesByTagName":
                sendAsyncResponse = true;
                __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].getMessagesByType(request.tag, request.totalShown || 0, sendResponse, function (errMsg) {
                    LogManager.error(errMsg);
                    CPA.sendEvent("Custom-Errors", "Database error", errMsg);

                    sendResponse([[], 0]);
                });

                break;

            case "searchContact":
                __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].searchContact(request.value, request.totalShown, function (contacts, total) {
                    sendResponse([contacts, total, request.value]);

                    if (SettingsManager.ShowOnline === 1 && contacts.length) {
                        var uids = contacts.map(function (contactData) {
                            return contactData.uid;
                        });

                        ReqManager.apiMethod("users.get", { "uids": uids.join(","), "fields": "online" }, function (data) {
                            data.response.forEach(function (chunk) {
                                var isOnline = chunk.online === 1 || chunk.online_mobile === 1;
                                chrome.runtime.sendMessage({ "action": "contactOnlineStatus", "uid": chunk.uid, "online": isOnline });
                            });
                        });
                    }
                }, function (errMsg) {
                    LogManager.error(errMsg);
                    CPA.sendEvent("Custom-Errors", "Database error", errMsg);

                    sendResponse([[], 0, request.value]);
                });

                sendAsyncResponse = true;
                break;

            case "searchMail":
                sendAsyncResponse = true;

                __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].searchMail(request.params, request.value, request.totalShown, function (correspondence, total) {
                    sendResponse([correspondence, total, request.value]);
                }, function (errMsg) {
                    LogManager.error(errMsg);
                    CPA.sendEvent("Custom-Errors", "Database error", errMsg);

                    sendResponse([[], 0, request.value]);
                });

                break;

            case "skipSync":
                forceSkipSync = true;
                CPA.sendEvent("App-Actions", "Skip sync");
                break;

            case "currentSyncValues":
                var output = syncingData[AccountsManager.currentUserId];
                sendAsyncResponse = true;

                __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].getContactById(AccountsManager.currentUserId, AccountsManager.currentUserId, function (userData) {
                    sendResponse({
                        data: output,
                        avatar: userData.photo
                    });
                }, function () {
                    sendResponse({
                        data: output
                    });
                });

                break;

            case "switchToAccount":
                ReqManager.abortAll();
                AccountsManager.currentUserId = request.uid;

                var changelogNotified = storageManager.get("changelog_notified", { constructor: Array, strict: true, create: true });
                var wallTokenUpdated = storageManager.get("wall_token_updated", { constructor: Object, strict: true, create: true })[AccountsManager.currentUserId] !== undefined;
                var startUser = true;

                if (startUser) {
                    startUserSession(leaveOneAppWindowInstance);
                } else {
                    leaveOneAppWindowInstance();
                }

                break;

            case "deleteAccount":
                ReqManager.abortAll();
                AccountsManager.drop(request.uid);
                __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].dropUser(request.uid);

                var friendsSyncTime = storageManager.get("friends_sync_time", { constructor: Object, strict: true, create: true });
                delete friendsSyncTime[request.uid];
                storageManager.set("friends_sync_time", friendsSyncTime);

                var wallTokenUpdated = storageManager.get("wall_token_updated", { constructor: Object, strict: true, create: true });
                delete wallTokenUpdated[request.uid];
                storageManager.set("wall_token_updated", wallTokenUpdated);

                storageManager.remove("perm_inbox_" + request.uid);
                storageManager.remove("perm_outbox_" + request.uid);

                if (request.next !== false) {
                    AccountsManager.currentUserId = request.next;
                    startUserSession();
                }

                // закрываем все табы приложения кроме одного
                leaveOneAppWindowInstance();

                break;

            case "markAsRead":
                var sendReadMessageRequest = function (msgId) {
                    ReqManager.apiMethod("messages.markAsRead", { "mids": msgId }, null, function (errCode, errData) {
                        switch (errCode) {
                            case ReqManager.NO_INTERNET:
                            case ReqManager.NOT_JSON:
                            case ReqManager.TIMEOUT:
                                window.setTimeout(sendReadMessageRequest, 60 * 1000, msgId);
                                break;
                        }

                        LogManager.error("Marking message as read failed (got error code " + errCode + ")");
                    });
                };

                sendReadMessageRequest(request.mid);
                __WEBPACK_IMPORTED_MODULE_2__db__["a" /* default */].markAsRead(request.mid, null, function (errMsg) {
                    LogManager.error(errMsg);
                    CPA.sendEvent("Custom-Errors", "Database error", errMsg);
                });

                break;

            case "DNDhappened":
                CPA.sendEvent("App-Actions", "DND", request.num);
                break;
        }

        if (sendAsyncResponse) {
            return true;
        }
    });

    // при загрузке приложения...
    if (AccountsManager.currentUserId) {
        startUserSession();
    }
});

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_assert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_sklad__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_sklad___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_sklad__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__idb__ = __webpack_require__(5);
'use strict';

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }






const validateJSONString = (data, constr) => {
    let someData;

    try {
        someData = JSON.parse(data);
        __WEBPACK_IMPORTED_MODULE_0_assert___default()(someData instanceof constr);
    } catch (ex) {
        someData = new constr();
    }

    return someData;
};

const getMessageFulltext = msgBody => {
    return msgBody.replace(/<br\s?\/?\s?>/g, ' ').toLowerCase().split(' ').filter(word => word.length >= 3);
};

/* harmony default export */ exports["a"] = {
    /**
     * Migrate all WebDatabases into IndexedDB
     */
    migrateWebDatabase: function DatabaseManager_migrateWebDatabase(uids, callback) {
        console.log("Migrate WebDatabase into IndexedDB");
        console.log("UIDS", uids);

        var that = this;
        var webDatabaseLink = window.openDatabase("vkoffline", "1.0.1", null, 0);

        function getAllWebDatabaseData(table, uid) {
            console.log("Collect data from %s_%s", table, uid);

            return new Promise(function (resolve, reject) {
                webDatabaseLink.readTransaction(function (tx) {
                    tx.executeSql("SELECT rowid, * FROM " + table + "_" + uid + " ORDER BY rowid", [], function (tx, resultSet) {
                        var totalRecords = resultSet.rows.length;
                        var output = [];

                        console.log("%s records found in %s", totalRecords, table);

                        for (var i = 0; i < totalRecords; i++) {
                            output.push(resultSet.rows.item(i));
                        }

                        resolve(output);
                    }, function (tx, err) {
                        CPA.sendEvent("Migrate1", "WebDatabase warn", err.message);

                        // let it be
                        if (err.message.indexOf("no such table") !== -1) {
                            resolve([]);
                            return;
                        }

                        reject(err.message);
                    });
                });
            });
        }

        function migrateUserData(uid) {
            var that = this;
            var currentUserId = Number(uid);

            return new Promise(function (resolve, reject) {
                that.initUser(uid, function () {
                    console.log("User initialized");

                    Promise.all([getAllWebDatabaseData("contacts", uid), getAllWebDatabaseData("pm", uid)]).then(function (res) {
                        var fetchedContacts = res[0];
                        var fetchedMessages = res[1];

                        var contacts = {};
                        var messages = {};
                        var chats = {};

                        fetchedContacts.forEach(function (record) {
                            var otherData = validateJSONString(record.other_data, Object);
                            var uid = Number(record.uid);

                            contacts[record.uid] = {
                                uid: uid,
                                first_name: record.first_name,
                                last_name: record.last_name,
                                notes: record.notes,
                                last_message_ts: 0,
                                messages_num: 0,
                                fulltext: [record.first_name.toLowerCase(), record.last_name.toLowerCase(), uid]
                            };

                            if (otherData.domain) {
                                contacts[record.uid].fulltext.push(otherData.domain.toLowerCase());
                            }

                            ["photo", "bdate", "domain", "home_phone", "mobile_phone"].forEach(function (field) {
                                if (otherData[field]) {
                                    contacts[record.uid][field] = otherData[field];
                                }
                            });

                            if (otherData.sex) {
                                contacts[record.uid].sex = Number(otherData.sex) || 0;
                            }
                        });

                        fetchedMessages.forEach(function (record) {
                            var isMultiChat = Boolean(record.chatid);
                            var chatId = isMultiChat ? String(record.chatid) : "0_" + record.uid;
                            var userId = Number(record.uid);
                            var lastChatMessageDate = chats[chatId] ? chats[chatId].last_message_ts : 0;

                            chats[chatId] = chats[chatId] || {};
                            chats[chatId].id = chatId;
                            chats[chatId].title = record.title;
                            chats[chatId].last_message_ts = Math.max(record.date, lastChatMessageDate);

                            var attachments = validateJSONString(record.attachments, Array);
                            var tags = [];

                            App.INIT_TAGS.forEach(function (tag, i) {
                                if (record.tags & Math.pow(2, i)) {
                                    tags.push(tag);
                                }
                            });

                            var otherData = validateJSONString(record.other_data, Object);
                            var hasEmoji = Boolean(otherData.emoji);

                            messages[record.mid] = {
                                mid: Number(record.mid),
                                uid: userId,
                                title: record.title,
                                body: record.body,
                                date: record.date,
                                read: Boolean(record.status),
                                attachments: attachments,
                                tags: tags,
                                has_emoji: hasEmoji,
                                chat: chatId,
                                fulltext: getMessageFulltext(record.body)
                            };

                            if (!contacts[userId]) {
                                console.warn("No contact with such id: %s", userId);
                                return;
                            }

                            contacts[userId].messages_num += 1;
                            contacts[userId].last_message_ts = Math.max(contacts[userId].last_message_ts, record.date);
                        });

                        console.log("Start inserting data with uid %s", uid);

                        // insert data
                        that._conn[uid].insert({
                            "chats": _.values(chats),
                            "contacts": _.values(contacts),
                            "messages": _.values(messages)
                        }, function (err, insertedKeys) {
                            if (err) {
                                var errMsg = err.name + ": " + err.message;

                                try {
                                    that._conn[uid].close();
                                } catch (ex) {}

                                CPA.sendEvent("Migrate1", "IDB insert fail", errMsg);
                                reject(errMsg);

                                return;
                            }

                            console.log("Contacts and PMs inserted");

                            that._conn[uid].close();
                            resolve();
                        });
                    }, function (errMsg) {
                        CPA.sendEvent("Migrate1", "getAllWebDatabase fail", errMsg);
                        reject(errMsg);
                    });
                }, function (errMsg) {
                    CPA.sendEvent("Migrate1", "initUser fail", errMsg);
                    reject(errMsg);
                });
            });
        }

        var promises = uids.map(function (uid) {
            console.log("UID found: %s", uid);
            return migrateUserData.call(that, uid);
        });

        Promise.all(promises).then(function () {
            callback();
        }, callback);
    },

    /**
     * Create meta database with log object store
     * @return {Promise}
     */
    initMeta: (() => {
        var _ref = _asyncToGenerator(function* () {
            this._meta = yield __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__idb__["a" /* openMeta */])();
        });

        function DatabaseManager_initMeta() {
            return _ref.apply(this, arguments);
        }

        return DatabaseManager_initMeta;
    })(),

    /**
     * @param {Integer} userId
     * @param {Function} fnSuccess
     * @param {Function} fnFail принимает {String} текст ошибки
     * @return {Void}
     */
    initUser: (() => {
        var _ref2 = _asyncToGenerator(function* (userId, fnSuccess, fnFail) {
            this._userId = userId;

            try {
                this._conn[userId] = yield __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__idb__["b" /* openUser */])(userId);
                this._userId = userId;
            } catch (err) {
                fnFail(err.name + ': ' + err.message);
                return;
            }

            fnSuccess();
        });

        function DatabaseManager_initUser(_x, _x2, _x3) {
            return _ref2.apply(this, arguments);
        }

        return DatabaseManager_initUser;
    })(),

    /**
     *
     */
    dropUser: (() => {
        var _ref3 = _asyncToGenerator(function* (userId) {
            this._conn[userId].close();
            return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__idb__["c" /* dropUser */])(userId);
        });

        function DatabaseManager_dropUser(_x4) {
            return _ref3.apply(this, arguments);
        }

        return DatabaseManager_dropUser;
    })(),

    /**
     * @param {String} outputType - alpha (в алфавитном порядке), lastdate (по дате последнего сообщения), messagesnum (по общему количеству сообщений)
     * @param {Integer} startFrom
     * @param {Function} fnSuccess принимает:
     *     {Array} массив объектов-контактов
     *     {Number} общее количество контактов
     * @param {Function} fnFail принимает:
     *     {String} errorMessage
     */
    getContactList: function DatabaseManager_getContactList(outputType, startFrom, fnSuccess, fnFail) {
        var userId = this._userId;
        var conn = this._conn[userId];

        function countContacts() {
            return new Promise(function (resolve, reject) {
                conn.count("contacts", function (err, total) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(total);
                    }
                });
            });
        }

        function getContacts() {
            var indexName;
            var direction;

            switch (outputType) {
                case "alpha":
                    indexName = "name";
                    direction = __WEBPACK_IMPORTED_MODULE_2_sklad__["ASC"];
                    break;

                case "lastdate":
                    indexName = "last_message";
                    direction = __WEBPACK_IMPORTED_MODULE_2_sklad__["DESC"];
                    break;

                case "messagesnum":
                    indexName = "messages_num";
                    direction = __WEBPACK_IMPORTED_MODULE_2_sklad__["DESC"];
                    break;
            }

            return new Promise(function (resolve, reject) {
                conn.get("contacts", {
                    index: indexName,
                    limit: 30,
                    offset: startFrom,
                    direction: direction
                }, function (err, data) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(data.map(function (msgData) {
                            return msgData.value;
                        }));
                    }
                });
            });
        }

        Promise.all([getContacts(), countContacts()]).then(fnSuccess, function (err) {
            fnFail(err.name + ": " + err.message);
        });
    },

    /**
     * @param {Integer} uid
     * @param {Function} fnSuccess принимает параметр {Object} контакт
     * @param {Function} fnFail принимает параметры {Boolean} isDatabaseError и {String} errorMessage
     */
    getContactById: function DatabaseManager_getContactById(currentUserId, uid, fnSuccess, fnFail) {
        var userId = currentUserId;
        var searchUserId = Number(uid);

        fnSuccess = fnSuccess || _.noop;
        fnFail = fnFail || _.noop;

        this._conn[userId].get("contacts", {
            range: IDBKeyRange.only(searchUserId)
        }, function (err, records) {
            if (err) {
                fnFail(err.name + ": " + err.message);
                return;
            }

            if (!records.length) {
                fnFail(null);
                return;
            }

            fnSuccess(records[0].value);
        });
    },

    /**
     * Get chats list ordered descending by date
     * Need also to get chats' participants, chat id, title, date & body of the last message, total messages in chat
     *
     * @param {Number} startFrom
     * @param {Function} fnSuccess which invokes {Array} with {Number} total chats number and {Array} chats data
     * @param {Function} fnFail
     */
    getConversations: function DatabaseManager_getConversations(startFrom, fnSuccess, fnFail) {
        var userId = this._userId;
        var conn = this._conn[userId];

        function getChatsList(startFrom) {
            return new Promise(function (resolve, reject) {
                conn.get("chats", {
                    index: "last_message",
                    offset: startFrom,
                    direction: __WEBPACK_IMPORTED_MODULE_2_sklad__["DESC"],
                    limit: 30
                }, function (err, records) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(records);
                    }
                });
            });
        }

        function getTotalChats() {
            return new Promise(function (resolve, reject) {
                conn.count("chats", function (err, total) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(total);
                    }
                });
            });
        }

        function getContactById(id) {
            return new Promise(function (resolve, reject) {
                conn.get("contacts", {
                    range: IDBKeyRange.only(id)
                }, function (err, records) {
                    if (err) {
                        reject(err.name + ": " + err.message);
                    } else if (!records.length) {
                        console.warn("No such contact: " + id);
                        resolve(null);
                    } else {
                        resolve({
                            id: id,
                            first_name: records[0].value.first_name,
                            last_name: records[0].value.last_name
                        });
                    }
                });
            });
        }

        function getChatParticipants(record) {
            return new Promise(function (resolve, reject) {
                conn.get("messages", {
                    index: "chat_participants",
                    direction: __WEBPACK_IMPORTED_MODULE_2_sklad__["ASC_UNIQUE"],
                    range: IDBKeyRange.bound([record.id], [record.id, Date.now()])
                }, function (err, data) {
                    if (err) {
                        reject(err);
                    } else {
                        var promises = [];
                        var currentUserIsParticipant = false;

                        data.forEach(function (contact) {
                            if (contact.value.uid == userId) {
                                currentUserIsParticipant = true;
                                return;
                            }

                            promises.push(getContactById(contact.value.uid));
                        });

                        Promise.all(promises).then(function (res) {
                            record.participants = _.compact(res);

                            if (currentUserIsParticipant) {
                                record.participants.push({ uid: userId });
                            }

                            resolve();
                        }, function (err) {
                            record.participants = [];
                            resolve();
                        });
                    }
                });
            });
        }

        function getChatLastMessage(record) {
            return new Promise(function (resolve, reject) {
                conn.get("messages", {
                    index: "chat_messages",
                    range: IDBKeyRange.only(record.id),
                    direction: __WEBPACK_IMPORTED_MODULE_2_sklad__["DESC"],
                    limit: 1
                }, function (err, records) {
                    if (err) {
                        reject(err);
                    } else {
                        record.body = records[0].value.body;
                        record.uid = records[0].value.uid;

                        resolve();
                    }
                });
            });
        }

        function getChatTotalMessages(record) {
            return new Promise(function (resolve, reject) {
                conn.count("messages", {
                    index: "chat_messages",
                    range: IDBKeyRange.only(record.id)
                }, function (err, total) {
                    if (err) {
                        reject(err);
                    } else {
                        record.total = total;
                        resolve();
                    }
                });
            });
        }

        Promise.all([getChatsList(startFrom), getTotalChats()]).then(([chats, total]) => {
            var fillDataPromises = [];
            var output = res.chats.map(function (record) {
                var chatData = {
                    id: record.value.id,
                    title: record.value.title,
                    date: record.value.last_message_ts
                };

                fillDataPromises.push(getChatParticipants(chatData));
                fillDataPromises.push(getChatLastMessage(chatData));
                fillDataPromises.push(getChatTotalMessages(chatData));

                return chatData;
            });

            Promise.all(fillDataPromises).then(function () {
                fnSuccess([output, res.total]);
            }, function (err) {
                fnFail(err.name + ": " + err.message);
            });
        }, function (err) {
            fnFail(err.name + ": " + err.message);
        });
    },

    /**
     * @param {Integer} uid
     * @param {Function} fnSuccess принимает параметр {Array} список объектов
     * @param {Function} fnFail принимает параметр {String} errorMessage
     */
    getConversationThreadsWithContact: function DatabaseManager_getConversationThreadsWithContact(uid, fnSuccess, fnFail) {
        var userId = this._userId;
        var conn = this._conn[userId];

        uid = Number(uid);

        function getContactById(id) {
            return new Promise(function (resolve, reject) {
                conn.get("contacts", {
                    range: IDBKeyRange.only(id)
                }, function (err, records) {
                    if (err) {
                        reject(err);
                    } else if (!records.length) {
                        resolve(null);
                    } else {
                        resolve({
                            uid: records[0].key,
                            first_name: records[0].value.first_name,
                            last_name: records[0].value.last_name
                        });
                    }
                });
            });
        }

        function getChatParticipants(record) {
            return new Promise(function (resolve, reject) {
                var chatId = record.id;
                var to = chatId.substr(0, chatId.length - 1) + String.fromCharCode(chatId.charCodeAt(chatId.length - 1) + 1);
                var range = IDBKeyRange.bound([chatId], [to], true, true);

                conn.get("messages", {
                    index: "chat_participants",
                    range: range,
                    direction: __WEBPACK_IMPORTED_MODULE_2_sklad__["ASC_UNIQUE"]
                }, function (err, records) {
                    if (err) {
                        reject(err);
                    } else {
                        var promises = [];
                        records.forEach(function (record) {
                            promises.push(getContactById(record.value.uid));
                        });

                        Promise.all(promises).then(function (res) {
                            record.participants = _.compact(res);
                            resolve();
                        }, reject);
                    }
                });
            });
        }

        function getChatLastMessage(record) {
            return new Promise(function (resolve, reject) {
                conn.get("messages", {
                    index: "chat_messages",
                    range: IDBKeyRange.only(record.id),
                    direction: __WEBPACK_IMPORTED_MODULE_2_sklad__["DESC"]
                }, function (err, records) {
                    if (err) {
                        reject(err);
                    } else {
                        var title = records.length ? records[0].value.title : '';
                        var body = records.length ? records[0].value.body : '';
                        var date = records.length ? records[0].value.date : 0;
                        var uid = records.length ? records[0].value.uid : userId;

                        Object.assign(record, {
                            title: title,
                            body: body,
                            date: date,
                            uid: uid
                        });

                        resolve();
                    }
                });
            });
        }

        function countChatMessages(record) {
            return new Promise(function (resolve, reject) {
                conn.count("messages", {
                    index: "chat_messages",
                    range: IDBKeyRange.only(record.id)
                }, function (err, total) {
                    if (err) {
                        reject(err);
                    } else {
                        record.total = total;
                        resolve();
                    }
                });
            });
        }

        conn.get("messages", {
            index: "user_chats",
            range: IDBKeyRange.bound([uid], [uid + 1], true, true),
            direction: __WEBPACK_IMPORTED_MODULE_2_sklad__["ASC_UNIQUE"]
        }, function (err, records) {
            if (err) {
                fnFail(err.name + ": " + err.message);
                return;
            }

            var output = [];
            var promises = [];

            records.forEach(function (record) {
                var chatRecord = {
                    id: record.key[1]
                };

                output.push(chatRecord);

                promises.push(getChatLastMessage(chatRecord));
                promises.push(getChatParticipants(chatRecord));
                promises.push(countChatMessages(chatRecord));
            });

            Promise.all(promises).then(function () {
                // sort chats
                output.sort(function (a, b) {
                    return b.date - a.date;
                });

                fnSuccess(output);
            }, function (err) {
                fnFail(err.name + ": " + err.message);
            });
        });
    },

    /**
     * Получение сообщений из диалога
     *
     * @param {String} dialogId идентификатор диалога: [\d]+ в случае чата, 0_[\d]+ в случае переписки один на один
     * @param {Object} opts
     * @param {Number} [opts.from = undefined] с какой записи нужно все получить
     * @param {Boolean} [opts.everything = false] нужно ли получить все записи в диалоге
     * @param {Function} fnSuccess принимает:
     *     {Array} сообщения
     *     {Number} количество сообщений в диалоге
     * @param {Function} fnFail принимает:
     *     {String} строка ошибки
     */
    getDialogThread: function DatabaseManager_getDialogThread(dialogId, opts, fnSuccess, fnFail) {
        var userId = this._userId;
        var conn = this._conn[userId];

        opts.from = opts.from || 0;
        opts.everything = opts.everything || false;

        function getContactById(id) {
            id = Number(id);

            return new Promise(function (resolve, reject) {
                conn.get("contacts", {
                    range: IDBKeyRange.only(id)
                }, function (err, records) {
                    if (err) {
                        reject(err);
                    } else if (!records.length) {
                        resolve(null);
                    } else {
                        resolve({
                            uid: records[0].key,
                            photo: records[0].value.photo,
                            first_name: records[0].value.first_name,
                            last_name: records[0].value.last_name
                        });
                    }
                });
            });
        }

        function countChatMessages() {
            return new Promise(function (resolve, reject) {
                conn.count("messages", {
                    index: "chat_messages",
                    range: IDBKeyRange.only(dialogId)
                }, function (err, total) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(total);
                    }
                });
            });
        }

        function getChatMessages() {
            return new Promise(function (resolve, reject) {
                var getOpts = {
                    index: "chat_messages",
                    range: IDBKeyRange.only(dialogId),
                    direction: __WEBPACK_IMPORTED_MODULE_2_sklad__["DESC"],
                    offset: opts.from
                };

                if (!opts.everything) {
                    getOpts.limit = 30;
                }

                conn.get("messages", getOpts, function (err, records) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(records);
                    }
                });
            });
        }

        Promise.all([getChatMessages(), countChatMessages()]).then(function (res) {
            var messages = res[0].reverse();
            var total = res[1];
            var promises = {};
            var output = [];

            // get current user info
            promises[userId] = getContactById(userId);

            messages.forEach(function (record) {
                output.push({
                    mid: record.value.mid,
                    title: record.value.title,
                    body: record.value.body,
                    date: record.value.date,
                    status: Number(record.value.read),
                    uid: record.value.uid,
                    tags: record.value.tags,
                    has_emoji: record.value.has_emoji,
                    attachments: record.value.attachments
                });

                if (!promises[record.value.uid] && record.value.uid != userId) {
                    promises[record.value.uid] = getContactById(record.value.uid);
                }
            });

            KinoPromise.all(promises).then(function (res) {
                var currentUserPhoto = res[userId] ? res[userId].photo : null;
                output.forEach(function (message) {
                    if (!res[message.uid]) {
                        return;
                    }

                    message.first_name = res[message.uid].first_name;
                    message.last_name = res[message.uid].last_name;
                    message.photo = message.tags.indexOf("sent") === -1 ? res[message.uid].photo : currentUserPhoto;
                });

                fnSuccess([output, total]);
            }, function (err) {
                fnFail(err.name + ": " + err.message);
            });
        }, function (err) {
            fnFail(err.name + ": " + err.message);
        });
    },

    /**
     * @param {Number} mid
     * @param {Function} fnSuccess принимает параметр {Object}
     * @param {Function} fnFail принимает параметры {Boolean} isDatabaseError и {String} errorMessage
     */
    getMessageById: function DatabaseManager_getMessageById(mid, fnSuccess, fnFail) {
        var userId = this._userId;
        var conn = this._conn[userId];

        function getContactPhoto(uid) {
            return new Promise(function (resolve, reject) {
                conn.get("contacts", {
                    range: IDBKeyRange.only(uid)
                }, function (err, records) {
                    if (err) {
                        reject(err);
                    } else if (!records.length) {
                        resolve(null);
                    } else {
                        resolve(records[0].value.photo);
                    }
                });
            });
        }

        conn.get("messages", {
            range: IDBKeyRange.only(mid)
        }, function (err, records) {
            if (err) {
                fnFail(true, err.name + ": " + err.message);
                return;
            }

            if (!records.length) {
                fnFail(false, "No message with ID #" + mid);
                return;
            }

            var msg = records[0].value;
            getContactPhoto(msg.uid).then(function (photo) {
                msg.avatar = photo;
                fnSuccess(msg);
            }, function (err) {
                fnFail(true, err.name + ": " + err.message);
            });
        });
    },

    /**
     * Внесение и обновление контактов
     *
     * @param {Number} userId
     * @param {Array} data массив из массивов вида [uid, firstName, lastName, otherData, oldNames, notes]
     * @return {Promise}
     */
    replaceContacts: function DatabaseManager_replaceContacts(userId, data) {
        var conn = this._conn[userId];

        return new Promise(function (resolve, reject) {
            var searchOpts = {};
            var uids = data.map(function (userData) {
                return Number(userData[0]);
            });

            if (uids.length > 1) {
                searchOpts.index = "messages_num";
                searchOpts.range = IDBKeyRange.lowerBound(1);
            } else {
                searchOpts.range = IDBKeyRange.only(uids[0]);
            }

            conn.get("contacts", searchOpts, function (err, records) {
                if (err) {
                    reject(err);
                } else {
                    var currentContacts = {};
                    records.forEach(function (record) {
                        if (uids.indexOf(record.value.uid) !== -1) {
                            currentContacts[record.value.uid] = record.value;
                        }
                    });

                    var upsertContacts = data.map(function (userData) {
                        var otherData = userData[3];
                        var uid = Number(userData[0]);

                        var contact = {
                            uid: uid,
                            first_name: userData[1],
                            last_name: userData[2],
                            notes: "",
                            fulltext: [userData[1].toLowerCase(), userData[2].toLowerCase(), uid]
                        };

                        if (otherData.domain) {
                            contact.fulltext.push(otherData.domain.toLowerCase());
                        }

                        ["photo", "bdate", "domain", "home_phone", "mobile_phone"].forEach(function (field) {
                            if (otherData[field]) {
                                contact[field] = otherData[field];
                            }
                        });

                        if (otherData.sex) {
                            contact.sex = Number(otherData.sex) || 0;
                        }

                        contact.last_message_ts = currentContacts[uid] ? currentContacts[uid].last_message_ts : 0;
                        contact.messages_num = currentContacts[uid] ? currentContacts[uid].messages_num : 0;

                        return contact;
                    });

                    conn.upsert({
                        contacts: upsertContacts
                    }, function (err) {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(upsertContacts);
                        }
                    });
                }
            });
        });
    },

    /**
     * Внесение сообщений.
     * Есть интересная особенность API ВКонтакте: метод messages.get не поддерживает сортировку и отдает сперва самые новые сообщения.
     *
     * @param {Number} currentUserId ID аккаунта, для которого заносятся сообщения
     * @param {Array} messages - сообщения-объекты с ключами (mid, uid, date, title, body, read_state, attachments, chat_id, tags, emoji)
     * @param {Function} fnSuccess
     * @param {Function} fnFail
     */
    insertMessages: function DatabaseManager_insertMessages(currentUserId, messages, fnSuccess, fnFail) {
        var chats = {};
        var messagesToInsert = [];

        messages.forEach(function (message) {
            var chatId = message.chat_id ? String(message.chat_id) : "0_" + message.uid;

            // chat should be inserted only once
            if (!chats[chatId]) {
                chats[chatId] = {
                    id: chatId,
                    title: message.title,
                    last_message_ts: message.date
                };
            }

            var msgData = {
                mid: Number(message.mid),
                uid: Number(message.uid),
                title: message.title,
                body: message.body,
                date: message.date,
                read: Boolean(message.read_state),
                chat: chatId,
                attachments: Array.isArray(message.attachments) ? message.attachments : [],
                tags: message.tags,
                has_emoji: Boolean(message.emoji),
                fulltext: getMessageFulltext(message.body)
            };

            if (message.important) {
                msgData.tags.push("important");
            }

            if (message.deleted) {
                msgData.tags.push("trash");
            }

            messagesToInsert.push(msgData);
        });

        this._conn[currentUserId].upsert({
            chats: _.values(chats),
            messages: messagesToInsert
        }, function (err) {
            if (err) {
                fnFail(err.name + ": " + err.message);
                return;
            }

            fnSuccess();
        });
    },

    /**
     * @param {String} mailType - one of "inbox", "sent"
     * @return {Promise}
     */
    getLatestTagMessageId: function DatabaseManager_getLatestTagMessageId(mailType) {
        var userId = this._userId;
        var conn = this._conn[userId];

        return new Promise(function (resolve, reject) {
            conn.get("messages", {
                index: "tag",
                range: IDBKeyRange.only(mailType),
                direction: __WEBPACK_IMPORTED_MODULE_2_sklad__["DESC"],
                limit: 1
            }, function (err, records) {
                if (err) {
                    reject(err);
                } else {
                    var output = records.length ? records[0].value.mid : 0;
                    resolve(output);
                }
            });
        });
    },

    /**
     * Actualize chats' dates
     * @return {Promise}
     */
    actualizeChatDates: function DatabaseManager_actualizeChatDates(userId) {
        userId = userId || this._userId;
        var conn = this._conn[userId];

        function getChatLastDate(id) {
            return new Promise(function (resolve, reject) {
                conn.get("messages", {
                    index: "chat_messages",
                    range: IDBKeyRange.only(id),
                    direction: __WEBPACK_IMPORTED_MODULE_2_sklad__["DESC"],
                    limit: 1
                }, function (err, records) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve({
                            id: id,
                            title: records[0].value.title,
                            last_message_ts: records[0].value.date
                        });
                    }
                });
            });
        }

        // NB: can't search with {index: "chat_messages", direction: DESC_UNIQUE} here
        // because first record is not the last sorted by mid unfortunately :(
        return new Promise(function (resolve, reject) {
            // get all chats grouped by id
            conn.get("messages", {
                index: "chat_messages",
                direction: DESC_UNIQUE
            }, function (err, records) {
                if (err) {
                    reject(err.name + ": " + err.message);
                    return;
                }

                var promises = records.map(function (record) {
                    return getChatLastDate(record.key);
                });

                Promise.all(promises).then(function (upsertData) {
                    conn.upsert({
                        chats: upsertData
                    }, function (err) {
                        if (err) {
                            reject(err.name + ": " + err.message);
                            return;
                        }

                        resolve();
                    });
                }, function (err) {
                    reject(err.name + ": " + err.message);
                });
            });
        });
    },

    actualizeContacts: function DatabaseManager_actualizeContacts(userId) {
        userId = userId || this._userId;
        var conn = this._conn[userId];

        function getLastUserMessage(contact) {
            return new Promise(function (resolve, reject) {
                conn.get("messages", {
                    index: "user_messages",
                    range: IDBKeyRange.only(contact.uid),
                    direction: __WEBPACK_IMPORTED_MODULE_2_sklad__["DESC"],
                    limit: 1
                }, function (err, records) {
                    if (err) {
                        reject(err);
                    } else {
                        contact.last_message_ts = records.length ? records[0].value.date : 0;
                        resolve();
                    }
                });
            });
        }

        function countUserMessages(contact) {
            return new Promise(function (resolve, reject) {
                conn.count("messages", {
                    index: "user_messages",
                    range: IDBKeyRange.only(contact.uid)
                }, function (err, total) {
                    if (err) {
                        reject(err);
                    } else {
                        contact.messages_num = total;
                        resolve();
                    }
                });
            });
        }

        return new Promise(function (resolve, reject) {
            conn.get("contacts", function (err, records) {
                if (err) {
                    reject(err.name + ": " + err.message);
                    return;
                }

                var contacts = [];
                var promises = [];

                records.forEach(function (record) {
                    var contact = record.value;

                    promises.push(getLastUserMessage(contact));
                    promises.push(countUserMessages(contact));

                    contacts.push(contact);
                });

                Promise.all(promises).then(function () {
                    conn.upsert({
                        contacts: contacts
                    }, function (err) {
                        if (err) {
                            reject(err.name + ": " + err.message);
                            return;
                        }

                        resolve();
                    });
                }, function (err) {
                    reject(err.name + ": " + err.message);
                });
            });
        });
    },

    /**
     * @param {Integer} msgId
     * @param {Function} fnSuccess принимает {Void}
     * @param {Function} fnFail принимает {String} errorMessage
     */
    markAsRead: function DatabaseManager_markAsRead(msgId, fnSuccess, fnFail) {
        var userId = this._userId;
        var conn = this._conn[userId];

        conn.get("messages", {
            range: IDBKeyRange.only(Number(msgId))
        }, function (err, records) {
            if (err) {
                fnFail(err.name + ": " + err.message);
                return;
            }

            if (!records.length) {
                fnSuccess && fnSuccess();
                return;
            }

            var message = records[0].value;
            message.read = true;

            conn.upsert("messages", message, function (err) {
                if (err) {
                    fnFail(err.name + ": " + err.message);
                    return;
                }

                fnSuccess && fnSuccess();
            });
        });
    },

    /**
     * @param {Integer} msgId
     * @param {Function} fnSuccess принимает {Void}
     * @param {Function} fnFail принимает {String} errorMessage
     */
    markAsUnread: function DatabaseManager_markAsUnread(msgId, fnSuccess, fnFail) {
        var userId = this._userId;
        var conn = this._conn[userId];

        conn.get("messages", {
            range: IDBKeyRange.only(Number(msgId))
        }, function (err, records) {
            if (err) {
                fnFail(err.name + ": " + err.message);
                return;
            }

            if (!records.length) {
                fnSuccess && fnSuccess();
                return;
            }

            var message = records[0].value;
            message.read = false;

            conn.upsert("messages", message, function (err) {
                if (err) {
                    fnFail(err.name + ": " + err.message);
                    return;
                }

                fnSuccess && fnSuccess();
            });
        });
    },

    /**
     * Добавление метки к сообщению
     * @param {Number} msgId ID сообщения
     * @param {String} тэг
     * @param {Function} fnSuccess принимает {Void}
     * @param {Function} fnFail принимает {Boolean} isDatabaseError и {String} errorMessage
     */
    markMessageWithTag: function DatabaseManager_markMessageWithTag(msgId, tag, fnSuccess, fnFail) {
        var userId = this._userId;
        var conn = this._conn[userId];

        conn.get("messages", {
            range: IDBKeyRange.only(Number(msgId))
        }, function (err, records) {
            if (err) {
                fnFail(true, err.name + ": " + err.message);
                return;
            }

            if (!records.length) {
                fnFail(false, "No rows were affected when updating tags column (mid: " + msgId + ", tag: " + tag + ")");
                return;
            }

            var message = records[0].value;
            if (message.tags.indexOf(tag) !== -1) {
                fnFail(false, "No rows were affected when updating tags column (mid: " + msgId + ", tag: " + tag + ")");
                return;
            }

            message.tags.push(tag);
            conn.upsert("messages", message, function (err) {
                if (err) {
                    fnFail(true, err.name + ": " + err.message);
                    return;
                }

                fnSuccess();
            });
        });
    },

    /**
     * Удаление метки с сообщения
     * @param {Number} msgId ID сообщения
     * @param {String} тэг
     * @param {Function} fnSuccess принимает {Void}
     * @param {Function} fnFail принимает {Boolean} isDatabaseError и {String} errorMessage
     */
    unmarkMessageWithTag: function DatabaseManager_unmarkMessageWithTag(msgId, tag, fnSuccess, fnFail) {
        var userId = this._userId;
        var conn = this._conn[userId];

        conn.get("messages", {
            range: IDBKeyRange.only(Number(msgId))
        }, function (err, records) {
            if (err) {
                fnFail(true, err.name + ": " + err.message);
                return;
            }

            if (!records.length) {
                fnFail(false, "No rows were affected when updating tags column (mid: " + msgId + ", tag: " + tag + ")");
                return;
            }

            var message = records[0].value;
            var tagIndex = message.tags.indexOf(tag);

            if (tagIndex === -1) {
                fnFail(false, "No rows were affected when updating tags column (mid: " + msgId + ", tag: " + tag + ")");
                return;
            }

            message.tags.splice(tagIndex, 1);
            conn.upsert("messages", message, function (err) {
                if (err) {
                    fnFail(true, err.name + ": " + err.message);
                    return;
                }

                fnSuccess();
            });
        });
    },

    /**
     * Полное удаление сообщения из БД
     * @param {Integer} msgId ID сообщения
     * @param {Function} fn
     */
    deleteMessage: function DatabaseManager_deleteMessage(msgId, fn) {
        var userId = this._userId;

        // проблема здесь - рассинхронизация messages и chats.last_message_ts
        this._conn[userId].delete("messages", Number(msgId), fn);
    },

    /**
     * Получение частоты использования тэгов
     * @param {Function} fnSuccess принимает {Object} объект freq
     * @param {Function} fnFail принимает {String} errorMessage
     */
    getTagsCount: function DatabaseManager_getTagsCount(fnSuccess, fnFail) {
        var userId = this._userId;
        var conn = this._conn[userId];

        function countTagOccurrences(tag) {
            return new Promise(function (resolve, reject) {
                conn.count("messages", {
                    index: "tag",
                    range: IDBKeyRange.only(tag)
                }, function (err, total) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(total);
                    }
                });
            });
        }

        conn.get("messages", {
            index: "tag",
            direction: __WEBPACK_IMPORTED_MODULE_2_sklad__["ASC_UNIQUE"]
        }, function (err, records) {
            if (err) {
                fnFail(err.name + ": " + err.message);
                return;
            }

            var promises = {};
            records.forEach(function (record) {
                promises[record.key] = countTagOccurrences(record.key);
            });

            KinoPromise.all(promises).then(fnSuccess, function (err) {
                fnFail(err.name + ": " + err.message);
            });
        });
    },

    /**
     * Получение всех сообщений с вложениями, полученных с ошибками в версии 4.11
     * @return {Promise}
     */
    getMessagesWithFalsyAttachments: function DatabaseManager_getMessagesWithFalsyAttachments() {
        var userId = this._userId;
        var conn = this._conn[userId];

        return new Promise(function (resolve, reject) {
            conn.get("messages", {
                index: "tag",
                range: IDBKeyRange.only("attachments")
            }, function (err, records) {
                if (err) {
                    reject(err.name + ": " + err.message);
                } else {
                    var output = [];

                    records.forEach(function (record) {
                        if (record.value.attachments.length) {
                            return;
                        }

                        output.push(record.value.mid);
                    });

                    resolve(output);
                }
            });
        });
    },

    /**
     * Получение сообщений определенного типа
     *
     * @param {String} tag
     * @param {Number} startFrom
     * @param {Function} fnSuccess принимает {Array} [{Array} сообщения, {Integer} total]
     * @oaram {Function} fnFail принимает {String} errorMessage
     */
    getMessagesByType: function DatabaseManager_getMessagesByType(tag, startFrom, fnSuccess, fnFail) {
        var userId = this._userId;
        var conn = this._conn[userId];

        function countTagMessages() {
            return new Promise(function (resolve, reject) {
                conn.count("messages", {
                    index: "tag",
                    range: IDBKeyRange.only(tag)
                }, function (err, total) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(total);
                    }
                });
            });
        }

        function getContactData(message) {
            return new Promise(function (resolve, reject) {
                conn.get("contacts", {
                    range: IDBKeyRange.only(message.uid)
                }, function (err, records) {
                    if (err) {
                        reject(err);
                    } else {
                        // FIXME: WTF
                        message.first_name = records.length ? records[0].value.first_name : "Not";
                        message.last_name = records.length ? records[0].value.last_name : "Found";
                        message.avatar = records.length ? records[0].value.photo : null;

                        resolve();
                    }
                });
            });
        }

        function getTagMessages() {
            return new Promise(function (resolve, reject) {
                conn.get("messages", {
                    index: "tag",
                    range: IDBKeyRange.only(tag),
                    direction: __WEBPACK_IMPORTED_MODULE_2_sklad__["DESC"],
                    offset: startFrom,
                    limit: 20
                }, function (err, records) {
                    if (err) {
                        reject(err);
                    } else {
                        var promises = [];
                        var output = [];

                        records.forEach(function (record) {
                            var message = {
                                id: record.value.chat,
                                title: record.value.title,
                                body: record.value.body,
                                date: record.value.date,
                                uid: record.value.uid,
                                mid: record.value.mid,
                                tags: record.value.tags,
                                status: Number(record.value.read)
                            };

                            output.push(message);
                            promises.push(getContactData(message));
                        });

                        Promise.all(promises).then(function () {
                            resolve(output);
                        }, reject);
                    }
                });
            });
        }

        Promise.all([getTagMessages(), countTagMessages()]).then(fnSuccess, function (err) {
            fnFail(err.name + ": " + err.message);
        });
    },

    /**
     * Поиск контактов
     *
     * @param {String} q
     * @param {Number} startFrom
     * @param {Function} fnSuccess принимает:
     *     {Array} массив объектов-контактов
     *     {Number} общее количество найденных контактов
     * @param {Function} fnFail принимает:
     *     {String} errorMessage
     */
    searchContact: function DatabaseManager_searchContact(q, startFrom, fnSuccess, fnFail) {
        q = q.toLowerCase();

        var userId = this._userId;
        var conn = this._conn[userId];
        var to = q.substr(0, q.length - 1) + String.fromCharCode(q.charCodeAt(q.length - 1) + 1);
        var range = IDBKeyRange.bound(q, to, false, true);

        function countContacts() {
            return new Promise(function (resolve, reject) {
                conn.count("contacts", {
                    index: "fulltext",
                    range: range
                }, function (err, total) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(total);
                    }
                });
            });
        }

        function searchContacts() {
            return new Promise(function (resolve, reject) {
                conn.get("contacts", {
                    index: "fulltext",
                    range: range,
                    offset: startFrom,
                    limi: 20
                }, function (err, records) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(records.map(function (record) {
                            return record.value;
                        }));
                    }
                });
            });
        }

        Promise.all([searchContacts(), countContacts()]).then(function (res) {
            fnSuccess.apply(null, res);
        }, function (err) {
            fnFail(err.name + ": " + err.message);
        });
    },

    /**
     * Поиск писем
     * @param {Object} params
     * @param {String} q
     * @param {Number} startFrom
     * @param {Function} fnSuccess принимает:
     *     {Array} массив сообщений
     *     {Number} общее количество найденных сообщений
     * @param {Function} fnFail принимает:
     *     {String} текст ошибки
     */
    searchMail: function DatabaseManager_searchMail(params, q, startFrom, fnSuccess, fnFail) {
        q = q.toLowerCase();

        var userId = this._userId;
        var conn = this._conn[userId];
        var to = q.substr(0, q.length - 1) + String.fromCharCode(q.charCodeAt(q.length - 1) + 1);
        var range = IDBKeyRange.bound(q, to, false, true);

        function countMessages() {
            return new Promise(function (resolve, reject) {
                conn.count("messages", {
                    index: "fulltext",
                    range: range
                }, function (err, total) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(total);
                    }
                });
            });
        }

        function getMessages() {
            return new Promise(function (resolve, reject) {
                conn.get("messages", {
                    index: "fulltext",
                    range: range,
                    offset: startFrom,
                    limit: 20,
                    direction: __WEBPACK_IMPORTED_MODULE_2_sklad__["DESC"]
                }, function (err, records) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(records);
                    }
                });
            });
        }

        function getContactById(record) {
            return new Promise(function (resolve, reject) {
                conn.get("contacts", {
                    range: IDBKeyRange.only(record.uid)
                }, function (err, records) {
                    if (err) {
                        reject(err);
                    } else if (!records.length) {
                        resolve();
                    } else {
                        record.first_name = records[0].value.first_name;
                        record.last_name = records[0].value.last_name;
                        record.avatar = records[0].value.photo;

                        resolve();
                    }
                });
            });
        }

        /*
            FIXME: was dropped in 4.11
            params.id -> WHERE dialogId = ?
            params.tag -> WHERE tag &
         */
        Promise.all([countMessages(), getMessages()]).then(([total, messages]) => {
            var total = res.total;
            var promises = [];
            var output = [];

            res.messages.forEach(function (record) {
                var message = {
                    id: record.value.chat,
                    mid: record.value.mid,
                    uid: record.value.uid,
                    title: record.value.title,
                    body: record.value.body,
                    status: Number(record.value.read),
                    date: record.value.date,
                    tags: record.value.tags
                };

                if (message.uid != userId) {
                    promises.push(getContactById(message));
                }

                output.push(message);
            });

            Promise.all(promises).then(function () {
                fnSuccess(output, total);
            }, function (err) {
                fnFail(err.name + ": " + err.message);
            });
        }, function (err) {
            fnFail(err.name + ": " + err.message);
        });
    },

    /**
     * Запись данных в общий лог
     *
     * @param {String} data
     * @param {String} level
     */
    log: function DatabaseManager_log(data, level) {
        this._meta.insert("log", {
            data: data,
            ts: Date.now(),
            level: level
        }, _.noop);
    },

    /**
     * Выборка всех записей из лога
     *
     * @param {Function} fnSuccess принимает {Array} массив записей из лога, готовых к отправке, отсортированных по дате
     * @param {Function} fnFail текст ошибки
     */
    collectLogData: function DatabaseManager_collectLogData(fnSuccess, fnFail) {
        this._meta.get("log", function (err, records) {
            if (err) {
                fnFail(err.name + ": " + err.message);
                return;
            }

            var timeLast = 0;
            var logRecords = records.map(function (record, i) {
                var item = record.value;
                var date = new Date(item.ts);

                var timeDiff = item.ts - timeLast;
                timeLast = item.ts;

                return i > 0 ? "[" + date + " +" + timeDiff + "ms] " + item.data : "[" + date + "] " + item.data;
            });

            fnSuccess(logRecords);
        });
    },

    _dbLink: null,
    _userId: null,

    _conn: {},
    _meta: null
};

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * lodash <https://lodash.com/>
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */;(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined;/** Used as the semantic version number. */var VERSION='4.15.0';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Used as the `TypeError` message for "Functions" methods. */var FUNC_ERROR_TEXT='Expected a function';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for function metadata. */var BIND_FLAG=1,BIND_KEY_FLAG=2,CURRY_BOUND_FLAG=4,CURRY_FLAG=8,CURRY_RIGHT_FLAG=16,PARTIAL_FLAG=32,PARTIAL_RIGHT_FLAG=64,ARY_FLAG=128,REARG_FLAG=256,FLIP_FLAG=512;/** Used to compose bitmasks for comparison styles. */var UNORDERED_COMPARE_FLAG=1,PARTIAL_COMPARE_FLAG=2;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=150,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',ARY_FLAG],['bind',BIND_FLAG],['bindKey',BIND_KEY_FLAG],['curry',CURRY_FLAG],['curryRight',CURRY_RIGHT_FLAG],['flip',FLIP_FLAG],['partial',PARTIAL_FLAG],['partialRight',PARTIAL_RIGHT_FLAG],['rearg',REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',boolTag='[object Boolean]',dateTag='[object Date]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',objectTag='[object Object]',promiseTag='[object Promise]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39|#96);/g,reUnescapedHtml=/[&<>"'`]/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,reLeadingDot=/^\./,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading and trailing whitespace. */var reTrim=/^\s+|\s+$/g,reTrimStart=/^\s+/,reTrimEnd=/\s+$/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect hexadecimal string values. */var reHasHexPrefix=/^0x/i;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange='\\ud800-\\udfff',rsComboMarksRange='\\u0300-\\u036f\\ufe20-\\ufe23',rsComboSymbolsRange='\\u20d0-\\u20f0',rsDingbatRange='\\u2700-\\u27bf',rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange='\\u2000-\\u206f',rsSpaceRange=' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange='\\ufe0e\\ufe0f',rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos="['\u2019]",rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboMarksRange+rsComboSymbolsRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz='\\ud83c[\\udffb-\\udfff]',rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional='(?:\\ud83c[\\udde6-\\uddff]){2}',rsSurrPair='[\\ud800-\\udbff][\\udc00-\\udfff]',rsUpper='['+rsUpperRange+']',rsZWJ='\\u200d';/** Used to compose unicode regexes. */var rsLowerMisc='(?:'+rsLower+'|'+rsMisc+')',rsUpperMisc='(?:'+rsUpper+'|'+rsMisc+')',rsOptLowerContr='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptUpperContr='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptLowerContr+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsUpperMisc+'+'+rsOptUpperContr+'(?='+[rsBreak,rsUpper+rsLowerMisc,'$'].join('|')+')',rsUpper+'?'+rsLowerMisc+'+'+rsOptLowerContr,rsUpper+'+'+rsOptUpperContr,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboMarksRange+rsComboSymbolsRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
'\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
'\u0100':'A','\u0102':'A','\u0104':'A','\u0101':'a','\u0103':'a','\u0105':'a','\u0106':'C','\u0108':'C','\u010a':'C','\u010c':'C','\u0107':'c','\u0109':'c','\u010b':'c','\u010d':'c','\u010e':'D','\u0110':'D','\u010f':'d','\u0111':'d','\u0112':'E','\u0114':'E','\u0116':'E','\u0118':'E','\u011a':'E','\u0113':'e','\u0115':'e','\u0117':'e','\u0119':'e','\u011b':'e','\u011c':'G','\u011e':'G','\u0120':'G','\u0122':'G','\u011d':'g','\u011f':'g','\u0121':'g','\u0123':'g','\u0124':'H','\u0126':'H','\u0125':'h','\u0127':'h','\u0128':'I','\u012a':'I','\u012c':'I','\u012e':'I','\u0130':'I','\u0129':'i','\u012b':'i','\u012d':'i','\u012f':'i','\u0131':'i','\u0134':'J','\u0135':'j','\u0136':'K','\u0137':'k','\u0138':'k','\u0139':'L','\u013b':'L','\u013d':'L','\u013f':'L','\u0141':'L','\u013a':'l','\u013c':'l','\u013e':'l','\u0140':'l','\u0142':'l','\u0143':'N','\u0145':'N','\u0147':'N','\u014a':'N','\u0144':'n','\u0146':'n','\u0148':'n','\u014b':'n','\u014c':'O','\u014e':'O','\u0150':'O','\u014d':'o','\u014f':'o','\u0151':'o','\u0154':'R','\u0156':'R','\u0158':'R','\u0155':'r','\u0157':'r','\u0159':'r','\u015a':'S','\u015c':'S','\u015e':'S','\u0160':'S','\u015b':'s','\u015d':'s','\u015f':'s','\u0161':'s','\u0162':'T','\u0164':'T','\u0166':'T','\u0163':'t','\u0165':'t','\u0167':'t','\u0168':'U','\u016a':'U','\u016c':'U','\u016e':'U','\u0170':'U','\u0172':'U','\u0169':'u','\u016b':'u','\u016d':'u','\u016f':'u','\u0171':'u','\u0173':'u','\u0174':'W','\u0175':'w','\u0176':'Y','\u0177':'y','\u0178':'Y','\u0179':'Z','\u017b':'Z','\u017d':'Z','\u017a':'z','\u017c':'z','\u017e':'z','\u0132':'IJ','\u0133':'ij','\u0152':'Oe','\u0153':'oe','\u0149':"'n",'\u017f':'ss'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;','`':'&#96;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'",'&#96;':'`'};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r','\u2028':'u2028','\u2029':'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=typeof global=='object'&&global&&global.Object===Object&&global;/** Detect free variable `self`. */var freeSelf=typeof self=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports=typeof exports=='object'&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&typeof module=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{return freeProcess&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*//**
   * Adds the key-value `pair` to `map`.
   *
   * @private
   * @param {Object} map The map to modify.
   * @param {Array} pair The key-value pair to add.
   * @returns {Object} Returns `map`.
   */function addMapEntry(map,pair){// Don't return `map.set` because it's not chainable in IE 11.
map.set(pair[0],pair[1]);return map;}/**
   * Adds `value` to `set`.
   *
   * @private
   * @param {Object} set The set to modify.
   * @param {*} value The value to add.
   * @returns {Object} Returns `set`.
   */function addSetEntry(set,value){// Don't return `set.add` because it's not chainable in IE 11.
set.add(value);return set;}/**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array?array.length:0;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEach(array,iteratee){var index=-1,length=array?array.length:0;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEachRight(array,iteratee){var length=array?array.length:0;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */function arrayEvery(array,predicate){var index=-1,length=array?array.length:0;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */function arrayFilter(array,predicate){var index=-1,length=array?array.length:0,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludes(array,value){var length=array?array.length:0;return!!length&&baseIndexOf(array,value,0)>-1;}/**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludesWith(array,value,comparator){var index=-1,length=array?array.length:0;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */function arrayMap(array,iteratee){var index=-1,length=array?array.length:0,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array?array.length:0;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array?array.length:0;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */function arraySome(array,predicate){var index=-1,length=array?array.length:0;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */var asciiSize=baseProperty('length');/**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function asciiToArray(string){return string.split('');}/**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return-1;}/**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOf(array,value,fromIndex){if(value!==value){return baseFindIndex(array,baseIsNaN,fromIndex);}var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return-1;}/**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return-1;}/**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */function baseIsNaN(value){return value!==value;}/**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */function baseMean(array,iteratee){var length=array?array.length:0;return length?baseSum(array,iteratee)/length:NAN;}/**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */function baseProperty(key){return function(object){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */function basePropertyOf(object){return function(key){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined){result=result===undefined?current:result+current;}}return result;}/**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */function baseToPairs(object,props){return arrayMap(props,function(key){return[key,object[key]];});}/**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */function baseUnary(func){return function(value){return func(value);};}/**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
   * Checks if a cache value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */function cacheHas(cache,key){return cache.has(key);}/**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){result++;}}return result;}/**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */var deburrLetter=basePropertyOf(deburredLetters);/**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */function escapeStringChar(chr){return'\\'+stringEscapes[chr];}/**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */function getValue(object,key){return object==null?undefined:object[key];}/**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */function hasUnicode(string){return reHasUnicode.test(string);}/**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
   * Checks if `value` is a host object in IE < 9.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
   */function isHostObject(value){// Many host objects are `Object` objects that can coerce to strings
// despite having improperly defined `toString` methods.
var result=false;if(value!=null&&typeof value.toString!='function'){try{result=!!(value+'');}catch(e){}}return result;}/**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){result++;}return result;}/**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*//**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Use `context` to stub `Date#getTime` use in `_.now`.
   * var stubbed = _.runInContext({
   *   'Date': function() {
   *     return { 'getTime': stubGetTime };
   *   }
   * });
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */function runInContext(context){context=context?_.defaults(root.Object(),context,_.pick(root,contextProps)):root;/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */var objectToString=objectProto.toString;/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined,Symbol=context.Symbol,Uint8Array=context.Uint8Array,getPrototype=overArg(Object.getPrototypeOf,Object),iteratorSymbol=Symbol?Symbol.iterator:undefined,objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=Symbol?Symbol.isConcatSpreadable:undefined;/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/* Used to set `toString` methods. */var defineProperty=function(){var func=getNative(Object,'defineProperty'),name=getNative.name;return name&&name.length>2?func:undefined;}();/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */var nonEnumShadows=!propertyIsEnumerable.call({'valueOf':1},'valueOf');/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=Symbol?Symbol.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/*------------------------------------------------------------------------*//**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array of at least `200` elements
     * and any iteratees accept only one argument. The heuristic for whether a
     * section qualifies for shortcut fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */function baseLodash(){}// No operation performed.
/**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined;}/**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB). Change the following template settings to use
     * alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */lodash.templateSettings={/**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'escape':reEscape,/**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'evaluate':reEvaluate,/**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'interpolate':reInterpolate,/**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */'variable':'',/**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */'imports':{/**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*//**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else{result=this.clone();result.__dir__*=-1;}return result;}/**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||arrLength<LARGE_ARRAY_SIZE||arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else{break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*//**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Hash(entries){var index=-1,length=entries?entries.length:0;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};}/**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function hashDelete(key){return this.has(key)&&delete this.__data__[key];}/**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}/**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}/**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */function hashSet(key,value){var data=this.__data__;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*//**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function ListCache(entries){var index=-1,length=entries?entries.length:0;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */function listCacheClear(){this.__data__=[];}/**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}return true;}/**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}/**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){data.push([key,value]);}else{data[index][1]=value;}return this;}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*//**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function MapCache(entries){var index=-1,length=entries?entries.length:0;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */function mapCacheClear(){this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function mapCacheDelete(key){return getMapData(this,key)['delete'](key);}/**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */function mapCacheSet(key,value){getMapData(this,key).set(key,value);return this;}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*//**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */function SetCache(values){var index=-1,length=values?values.length:0;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*//**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Stack(entries){this.__data__=new ListCache(entries);}/**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */function stackClear(){this.__data__=new ListCache();}/**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function stackDelete(key){return this.__data__['delete'](key);}/**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function stackGet(key){return this.__data__.get(key);}/**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function stackHas(key){return this.__data__.has(key);}/**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */function stackSet(key,value){var cache=this.__data__;if(cache instanceof ListCache){var pairs=cache.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);return this;}cache=this.__data__=new MapCache(pairs);}cache.set(key,value);return this;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*//**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */function arrayLikeKeys(value,inherited){// Safari 8.1 makes `arguments.callee` enumerable in strict mode.
// Safari 9 makes `arguments.length` enumerable in strict mode.
var result=isArray(value)||isArguments(value)?baseTimes(value.length,String):[];var length=result.length,skipIndexes=!!length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(key=='length'||isIndex(key,length)))){result.push(key);}}return result;}/**
     * Used by `_.defaults` to customize its `_.assignIn` use.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */function assignInDefaults(objValue,srcValue,key,object){if(objValue===undefined||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignMergeValue(object,key,value){if(value!==undefined&&!eq(object[key],value)||typeof key=='number'&&value===undefined&&!(key in object)){object[key]=value;}}/**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){object[key]=value;}}/**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}/**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths of elements to pick.
     * @returns {Array} Returns the picked elements.
     */function baseAt(object,paths){var index=-1,isNil=object==null,length=paths.length,result=Array(length);while(++index<length){result[index]=isNil?undefined:get(object,paths[index]);}return result;}/**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}/**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {boolean} [isFull] Specify a clone including symbols.
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */function baseClone(value,isDeep,isFull,customizer,key,object,stack){var result;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else{var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){if(isHostObject(value)){return object?value:{};}result=initCloneObject(isFunc?{}:value);if(!isDeep){return copySymbols(value,baseAssign(result,value));}}else{if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,baseClone,isDeep);}}// Check for circular references and return its corresponding clone.
stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(!isArr){var props=isFull?getAllKeys(value):keys(value);}arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
assignValue(result,key,baseClone(subValue,isDeep,isFull,customizer,key,value,stack));});return result;}/**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return!length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined&&!(key in object)||!predicate(value)){return false;}}return true;}/**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */function baseCreate(proto){return isObject(proto)?objectCreate(proto):{};}/**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined,args);},wait);}/**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEach=createBaseEach(baseForOwn);/**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
baseFlatten(value,depth-1,predicate,isStrict,result);}else{arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseFor=createBaseFor();/**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseForRight=createBaseFor(true);/**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */function baseGet(object,path){path=isKey(path,object)?[path]:castPath(path);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined;}/**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
     * The base implementation of `getTag`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */function baseGetTag(value){return objectToString.call(value);}/**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */function baseGt(value,other){return value>other;}/**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */function baseInvoke(object,path,args){if(!isKey(path,object)){path=castPath(path);object=parent(object,path);path=last(path);}var func=object==null?object:object[toKey(path)];return func==null?undefined:apply(func,object,args);}/**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */function baseIsArrayBuffer(value){return isObjectLike(value)&&objectToString.call(value)==arrayBufferTag;}/**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */function baseIsDate(value){return isObjectLike(value)&&objectToString.call(value)==dateTag;}/**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {boolean} [bitmask] The bitmask of comparison flags.
     *  The bitmask may be composed of the following flags:
     *     1 - Unordered comparison
     *     2 - Partial comparison
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */function baseIsEqual(value,other,customizer,bitmask,stack){if(value===other){return true;}if(value==null||other==null||!isObject(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,baseIsEqual,customizer,bitmask,stack);}/**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function baseIsEqualDeep(object,other,equalFunc,customizer,bitmask,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=arrayTag,othTag=arrayTag;if(!objIsArr){objTag=getTag(object);objTag=objTag==argsTag?objectTag:objTag;}if(!othIsArr){othTag=getTag(other);othTag=othTag==argsTag?objectTag:othTag;}var objIsObj=objTag==objectTag&&!isHostObject(object),othIsObj=othTag==objectTag&&!isHostObject(other),isSameTag=objTag==othTag;if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,equalFunc,customizer,bitmask,stack):equalByTag(object,other,objTag,equalFunc,customizer,bitmask,stack);}if(!(bitmask&PARTIAL_COMPARE_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,customizer,bitmask,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,equalFunc,customizer,bitmask,stack);}/**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return!length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined&&!(key in object)){return false;}}else{var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined?baseIsEqual(srcValue,objValue,customizer,UNORDERED_COMPARE_FLAG|PARTIAL_COMPARE_FLAG,stack):result)){return false;}}}return true;}/**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)||isHostObject(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */function baseIsRegExp(value){return isObject(value)&&objectToString.call(value)==regexpTag;}/**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[objectToString.call(value)];}/**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
if(typeof value=='function'){return value;}if(value==null){return identity;}if(typeof value=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */function baseLt(value,other){return value<other;}/**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,undefined,UNORDERED_COMPARE_FLAG|PARTIAL_COMPARE_FLAG);};}/**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}if(!(isArray(source)||isTypedArray(source))){var props=baseKeysIn(source);}arrayEach(props||source,function(srcValue,key){if(props){key=srcValue;srcValue=source[key];}if(isObject(srcValue)){stack||(stack=new Stack());baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else{var newValue=customizer?customizer(object[key],srcValue,key+'',object,source,stack):undefined;if(newValue===undefined){newValue=srcValue;}assignMergeValue(object,key,newValue);}});}/**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=object[key],srcValue=source[key],stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined;var isCommon=newValue===undefined;if(isCommon){newValue=srcValue;if(isArray(srcValue)||isTypedArray(srcValue)){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else{isCommon=false;newValue=baseClone(srcValue,true);}}else if(isPlainObject(srcValue)||isArguments(srcValue)){if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||srcIndex&&isFunction(objValue)){isCommon=false;newValue=baseClone(srcValue,true);}else{newValue=objValue;}}else{isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined;}/**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */function baseOrderBy(collection,iteratees,orders){var index=-1;iteratees=arrayMap(iteratees.length?iteratees:[identity],baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return{'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} props The property identifiers to pick.
     * @returns {Object} Returns the new object.
     */function basePick(object,props){object=Object(object);return basePickBy(object,props,function(value,key){return key in object;});}/**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} props The property identifiers to pick from.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */function basePickBy(object,props,predicate){var index=-1,length=props.length,result={};while(++index<length){var key=props[index],value=object[key];if(predicate(value,key)){result[key]=value;}}return result;}/**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else if(!isKey(index,array)){var path=castPath(index),object=parent(array,path);if(object!=null){delete object[toKey(last(path))];}}else{delete array[toKey(index)];}}}return array;}/**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */function baseRest(func,start){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=array;return apply(func,this,otherArgs);};}/**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=isKey(path,object)?[path]:castPath(path);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined;if(newValue===undefined){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
     * The base implementation of `setData` without support for hot loop detection.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return!result;});return!!result;}/**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndex(array,value,retHighest){var low=0,high=array?array.length:low;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else{high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndexBy(array,value,iteratee,retHighest){value=iteratee(value);var low=0,high=array?array.length:0,valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else{setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else{high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return+value;}/**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
if(typeof value=='string'){return value;}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else{seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */function baseUnset(object,path){path=isKey(path,object)?[path]:castPath(path);object=parent(object,path);var key=toKey(last(path));return!(object!=null&&hasOwnProperty.call(object,key))||delete object[key];}/**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */function baseXor(arrays,iteratee,comparator){var index=-1,length=arrays.length;while(++index<length){var result=result?arrayPush(baseDifference(result,arrays[index],iteratee,comparator),baseDifference(arrays[index],result,iteratee,comparator)):arrays[index];}return result&&result.length?baseUniq(result,iteratee,comparator):[];}/**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined;assignFunc(result,props[index],value);}return result;}/**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */function castFunction(value){return typeof value=='function'?value:identity;}/**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast property path array.
     */function castPath(value){return isArray(value)?value:stringToPath(value);}/**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */function castSlice(array,start,end){var length=array.length;end=end===undefined?length:end;return!start&&end>=length?array:baseSlice(array,start,end);}/**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var result=new buffer.constructor(buffer.length);buffer.copy(result);return result;}/**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
     * Creates a clone of `map`.
     *
     * @private
     * @param {Object} map The map to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned map.
     */function cloneMap(map,isDeep,cloneFunc){var array=isDeep?cloneFunc(mapToArray(map),true):mapToArray(map);return arrayReduce(array,addMapEntry,new map.constructor());}/**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
     * Creates a clone of `set`.
     *
     * @private
     * @param {Object} set The set to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned set.
     */function cloneSet(set,isDeep,cloneFunc){var array=isDeep?cloneFunc(setToArray(set),true):setToArray(set);return arrayReduce(array,addSetEntry,new set.constructor());}/**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return-1;}}return 0;}/**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
// that causes it, under certain circumstances, to provide the same value for
// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
// for more details.
//
// This also ensures a stable sort in V8 and other engines.
// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
return object.index-other.index;}/**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */function copyObject(source,props,object,customizer){object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;assignValue(object,key,newValue===undefined?source[key]:newValue);}return object;}/**
     * Copies own symbol properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createBind(func,bitmask,thisArg){var isBind=bitmask&BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
// http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
// for more details.
var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
// See https://es5.github.io/#x13.2.2 for more details.
return isObject(result)?result:thisBinding;};}/**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined,args,holders,undefined,undefined,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined;};}/**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */function createFlow(fromRight){return baseRest(function(funcs){funcs=baseFlatten(funcs,1);var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined;if(data&&isLaziable(data[0])&&data[1]==(ARY_FLAG|CURRY_FLAG|PARTIAL_FLAG|REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else{wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)&&value.length>=LARGE_ARRAY_SIZE){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&ARY_FLAG,isBind=bitmask&BIND_FLAG,isBindKey=bitmask&BIND_KEY_FLAG,isCurried=bitmask&(CURRY_FLAG|CURRY_RIGHT_FLAG),isFlip=bitmask&FLIP_FLAG,Ctor=isBindKey?undefined:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined&&other===undefined){return defaultValue;}if(value!==undefined){result=value;}if(other!==undefined){if(result===undefined){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else{value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */function createOver(arrayFunc){return baseRest(function(iteratees){iteratees=iteratees.length==1&&isArray(iteratees[0])?arrayMap(iteratees[0],baseUnary(getIteratee())):arrayMap(baseFlatten(iteratees,1),baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */function createPadding(length,chars){chars=chars===undefined?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined;}// Ensure the sign of `-0` is preserved.
start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}step=step===undefined?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&CURRY_FLAG,newHolders=isCurry?holders:undefined,newHoldersRight=isCurry?undefined:holders,newPartials=isCurry?partials:undefined,newPartialsRight=isCurry?undefined:partials;bitmask|=isCurry?PARTIAL_FLAG:PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?PARTIAL_RIGHT_FLAG:PARTIAL_FLAG);if(!(bitmask&CURRY_BOUND_FLAG)){bitmask&=~(BIND_FLAG|BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=nativeMin(toInteger(precision),292);if(precision){// Shift with exponential notation to avoid floating-point issues.
// See [MDN](https://mdn.io/round#Examples) for more details.
var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return+(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *  The bitmask may be composed of the following flags:
     *     1 - `_.bind`
     *     2 - `_.bindKey`
     *     4 - `_.curry` or `_.curryRight` of a bound function
     *     8 - `_.curry`
     *    16 - `_.curryRight`
     *    32 - `_.partial`
     *    64 - `_.partialRight`
     *   128 - `_.rearg`
     *   256 - `_.ary`
     *   512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(PARTIAL_FLAG|PARTIAL_RIGHT_FLAG);partials=holders=undefined;}ary=ary===undefined?ary:nativeMax(toInteger(ary),0);arity=arity===undefined?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined;}var data=isBindKey?undefined:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]==null?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(CURRY_FLAG|CURRY_RIGHT_FLAG)){bitmask&=~(CURRY_FLAG|CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==CURRY_FLAG||bitmask==CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==PARTIAL_FLAG||bitmask==(BIND_FLAG|PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else{result=createHybrid.apply(undefined,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} customizer The function to customize comparisons.
     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */function equalArrays(array,other,equalFunc,customizer,bitmask,stack){var isPartial=bitmask&PARTIAL_COMPARE_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Assume cyclic values are equal.
var stacked=stack.get(array);if(stacked&&stack.get(other)){return stacked==other;}var index=-1,result=true,seen=bitmask&UNORDERED_COMPARE_FLAG?new SetCache():undefined;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
if(seen){if(!arraySome(other,function(othValue,othIndex){if(!seen.has(othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,customizer,bitmask,stack))){return seen.add(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,customizer,bitmask,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} customizer The function to customize comparisons.
     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalByTag(object,other,tag,equalFunc,customizer,bitmask,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
// Invalid dates are coerced to `NaN`.
return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
// for more details.
return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&PARTIAL_COMPARE_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=UNORDERED_COMPARE_FLAG;// Recursively compare objects (susceptible to call stack limits).
stack.set(object,other);var result=equalArrays(convert(object),convert(other),equalFunc,customizer,bitmask,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} customizer The function to customize comparisons.
     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalObjects(object,other,equalFunc,customizer,bitmask,stack){var isPartial=bitmask&PARTIAL_COMPARE_FLAG,objProps=keys(object),objLength=objProps.length,othProps=keys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked&&stack.get(other)){return stacked==other;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
if(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,customizer,bitmask,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}/**
     * Creates an array of the own enumerable symbol properties of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbols=nativeGetSymbols?overArg(nativeGetSymbols,Object):stubArray;/**
     * Creates an array of the own and inherited enumerable symbol properties
     * of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function(value){var result=objectToString.call(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):undefined;if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return{'start':start,'end':end};}/**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */function hasPath(object,path,hasFunc){path=isKey(path,object)?[path]:castPath(path);var result,index=-1,length=path.length;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result){return result;}var length=object?object.length:0;return!!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */function initCloneArray(array){var length=array.length,result=array.constructor(length);// Add properties assigned by `RegExp#exec`.
if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneByTag(object,tag,cloneFunc,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return cloneMap(object,isDeep,cloneFunc);case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return cloneSet(object,isDeep,cloneFunc);case symbolTag:return cloneSymbol(object);}}/**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */function insertWrapDetails(source,details){var length=details.length,lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */function isIndex(value,length){length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(typeof value=='number'||reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=typeof index;if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */function isKey(value,object){if(isArray(value)){return false;}var type=typeof value;if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */function isKeyable(value){var type=typeof value;return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return!!data&&func===data[0];}/**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */var isMaskable=coreJsData?isFunction:stubFalse;/**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */function isStrictComparable(value){return value===value&&!isObject(value);}/**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined||key in Object(object));};}/**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(BIND_FLAG|BIND_KEY_FLAG|ARY_FLAG);var isCombo=srcBitmask==ARY_FLAG&&bitmask==CURRY_FLAG||srcBitmask==ARY_FLAG&&bitmask==REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(ARY_FLAG|REARG_FLAG)&&source[7].length<=source[8]&&bitmask==CURRY_FLAG;// Exit early if metadata can't be merged.
if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
if(srcBitmask&BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
newBitmask|=bitmask&BIND_FLAG?0:CURRY_BOUND_FLAG;}// Compose partial arguments.
var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
if(srcBitmask&ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
data[0]=source[0];data[1]=newBitmask;return data;}/**
     * Used by `_.defaultsDeep` to customize its `_.merge` use.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */function mergeDefaults(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined,mergeDefaults,stack);stack['delete'](srcValue);}return objValue;}/**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */function parent(object,path){return path.length==1?object:baseGet(object,baseSlice(path,0,-1));}/**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined;}return array;}/**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var setData=function(){var count=0,lastCalled=0;return function(key,value){var stamp=now(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return key;}}else{count=0;}return baseSetData(key,value);};}();/**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */var setWrapToString=!defineProperty?identity:function(wrapper,reference,bitmask){var source=reference+'';return defineProperty(wrapper,'toString',{'configurable':true,'enumerable':false,'value':constant(insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)))});};/**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */var stringToPath=memoize(function(string){string=toString(string);var result=[];if(reLeadingDot.test(string)){result.push('');}string.replace(rePropName,function(match,number,quote,string){result.push(quote?string.replace(reEscapeChar,'$1'):number||match);});return result;});/**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to process.
     * @returns {string} Returns the source code.
     */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*//**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined){size=1;}else{size=nativeMax(toInteger(size),0);}var length=array?array.length:0;if(!length||size<1){return[];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */function compact(array){var index=-1,length=array?array.length:0,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */function concat(){var length=arguments.length,args=Array(length?length-1:0),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return length?arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1)):[];}/**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order of result values is determined by the
     * order they occur in the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. Result values are chosen from the first array.
     * The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. Result values
     * are chosen from the first array. The comparator is invoked with two arguments:
     * (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined,comparator):[];});/**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function drop(array,n,guard){var length=array?array.length:0;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function dropRight(array,n,guard){var length=array?array.length:0;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */function fill(array,value,start,end){var length=array?array.length:0;if(!length){return[];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */function findIndex(array,predicate,fromIndex){var length=array?array.length:0;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */function findLastIndex(array,predicate,fromIndex){var length=array?array.length:0;if(!length){return-1;}var index=length-1;if(fromIndex!==undefined){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */function flatten(array){var length=array?array.length:0;return length?baseFlatten(array,1):[];}/**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */function flattenDeep(array){var length=array?array.length:0;return length?baseFlatten(array,INFINITY):[];}/**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */function flattenDepth(array,depth){var length=array?array.length:0;if(!length){return[];}depth=depth===undefined?1:toInteger(depth);return baseFlatten(array,depth);}/**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */function fromPairs(pairs){var index=-1,length=pairs?pairs.length:0,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */function head(array){return array&&array.length?array[0]:undefined;}/**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */function indexOf(array,value,fromIndex){var length=array?array.length:0;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */function initial(array){var length=array?array.length:0;return length?baseSlice(array,0,-1):[];}/**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order of result values is determined by the
     * order they occur in the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. Result values are chosen from the first array.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined;}else{mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. Result values are chosen
     * from the first array. The comparator is invoked with two arguments:
     * (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(comparator===last(mapped)){comparator=undefined;}else{mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined,comparator):[];});/**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */function join(array,separator){return array?nativeJoin.call(array,separator):'';}/**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */function last(array){var length=array?array.length:0;return length?array[length-1]:undefined;}/**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */function lastIndexOf(array,value,fromIndex){var length=array?array.length:0;if(!length){return-1;}var index=length;if(fromIndex!==undefined){index=toInteger(fromIndex);index=(index<0?nativeMax(length+index,0):nativeMin(index,length-1))+1;}if(value!==value){return baseFindIndex(array,baseIsNaN,index-1,true);}while(index--){if(array[index]===value){return index;}}return-1;}/**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined;}/**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */var pull=baseRest(pullAll);/**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined,comparator):array;}/**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */var pullAt=baseRest(function(array,indexes){indexes=baseFlatten(indexes,1);var length=array?array.length:0,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function reverse(array){return array?nativeReverse.call(array):array;}/**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function slice(array,start,end){var length=array?array.length:0;if(!length){return[];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else{start=start==null?0:toInteger(start);end=end===undefined?length:toInteger(end);}return baseSlice(array,start,end);}/**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */function sortedIndexOf(array,value){var length=array?array.length:0;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */function sortedLastIndexOf(array,value){var length=array?array.length:0;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */function tail(array){var length=array?array.length:0;return length?baseSlice(array,1,length):[];}/**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */function take(array,n,guard){if(!(array&&array.length)){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */function takeRight(array,n,guard){var length=array?array.length:0;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false},
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var unionWith=baseRest(function(arrays){var comparator=last(arrays);if(isArrayLikeObject(comparator)){comparator=undefined;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined,comparator);});/**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each
     * element is kept.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The comparator is invoked with
     * two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */function uniqWith(array,comparator){return array&&array.length?baseUniq(array,undefined,comparator):[];}/**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */function unzip(array){if(!(array&&array.length)){return[];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */function unzipWith(array,iteratee){if(!(array&&array.length)){return[];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined,group);});}/**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The comparator is invoked with
     * two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var xorWith=baseRest(function(arrays){var comparator=last(arrays);if(isArrayLikeObject(comparator)){comparator=undefined;}return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined,comparator);});/**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */var zip=baseRest(unzip);/**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*//**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */function tap(value,interceptor){interceptor(value);return value;}/**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */function thru(value,interceptor){return interceptor(value);}/**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths of elements to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */var wrapperAt=baseRest(function(paths){paths=baseFlatten(paths,1);var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined);}return array;});});/**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */function wrapperChain(){return chain(this);}/**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */function wrapperNext(){if(this.__values__===undefined){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined:this.__values__[this.__index__++];return{'done':done,'value':value};}/**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */function wrapperToIterator(){return this;}/**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined;if(result){previous.__wrapped__=clone;}else{result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*//**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity]
     *  The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */var countBy=createAggregator(function(result,value,key){hasOwnProperty.call(result,key)?++result[key]:result[key]=1;});/**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */var find=createFind(findIndex);/**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity]
     *  The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */var findLast=createFind(findLastIndex);/**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity]
     *  The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _([1, 2]).forEach(function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity]
     *  The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else{result[key]=[value];}});/**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',isProp=isKey(path),result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){var func=isFunc?path:isProp&&value!=null?value[path]:undefined;result[++index]=func?apply(func,value,args):baseInvoke(value,path,args);});return result;});/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity]
     *  The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */var keyBy=createAggregator(function(result,value,key){result[key]=value;});/**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */function orderBy(collection,iteratees,orders,guard){if(collection==null){return[];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return[[],[]];});/**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */function sample(collection){var array=isArrayLike(collection)?collection:values(collection),length=array.length;return length>0?array[baseRandom(0,length-1)]:undefined;}/**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */function sampleSize(collection,n,guard){var index=-1,result=toArray(collection),length=result.length,lastIndex=length-1;if(guard?isIterateeCall(collection,n,guard):n===undefined){n=1;}else{n=baseClamp(toInteger(n),0,length);}while(++index<n){var rand=baseRandom(index,lastIndex),value=result[rand];result[rand]=result[index];result[index]=value;}result.length=n;return result;}/**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */function shuffle(collection){return sampleSize(collection,MAX_ARRAY_LENGTH);}/**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, function(o) { return o.user; });
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
     *
     * _.sortBy(users, 'user', function(o) {
     *   return Math.floor(o.age / 10);
     * });
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return[];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*//**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*//**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */function ary(func,n,guard){n=guard?undefined:n;n=func&&n==null?func.length:n;return createWrap(func,ARY_FLAG,undefined,undefined,undefined,undefined,n);}/**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined;}return result;};}/**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */var bind=baseRest(function(func,thisArg,partials){var bitmask=BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */var bindKey=baseRest(function(object,key,partials){var bitmask=BIND_FLAG|BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */function curry(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,CURRY_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curry.placeholder;return result;}/**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */function curryRight(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,CURRY_RIGHT_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curryRight.placeholder;return result;}/**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
lastInvokeTime=time;// Start the timer for the trailing edge.
timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,result=wait-timeSinceLastCall;return maxing?nativeMin(result,maxWait-timeSinceLastInvoke):result;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
// trailing edge, the system time has gone backwards and we're treating
// it as the trailing edge, or we've hit the `maxWait` limit.
return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;// Only invoke if we have `lastArgs` which means `func` has been
// debounced at least once.
if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one or more milliseconds.
     */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */function flip(func){return createWrap(func,FLIP_FLAG);}/**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */function memoize(func,resolver){if(typeof func!='function'||resolver&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result);return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Assign cache to `_.memoize`.
memoize.Cache=MapCache;/**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return!predicate.call(this);case 1:return!predicate.call(this,args[0]);case 2:return!predicate.call(this,args[0],args[1]);case 3:return!predicate.call(this,args[0],args[1],args[2]);}return!predicate.apply(this,args);};}/**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */function once(func){return before(2,func);}/**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */var overArgs=baseRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,PARTIAL_FLAG,undefined,partials,holders);});/**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,PARTIAL_RIGHT_FLAG,undefined,partials,holders);});/**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */var rearg=baseRest(function(func,indexes){return createWrap(func,REARG_FLAG,undefined,undefined,undefined,baseFlatten(indexes,1));});/**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined?start:toInteger(start);return baseRest(func,start);}/**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */function unary(func){return ary(func,1);}/**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */function wrap(value,wrapper){wrapper=wrapper==null?identity:wrapper;return partial(wrapper,value);}/*------------------------------------------------------------------------*//**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */function castArray(){if(!arguments.length){return[];}var value=arguments[0];return isArray(value)?value:[value];}/**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */function clone(value){return baseClone(value,false,true);}/**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */function cloneWith(value,customizer){return baseClone(value,false,true,customizer);}/**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */function cloneDeep(value){return baseClone(value,true,true);}/**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */function cloneDeepWith(value,customizer){return baseClone(value,true,true,customizer);}/**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */function eq(value,other){return value===other||value!==value&&other!==other;}/**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */var gt=createRelationalOperation(baseGt);/**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */function isArguments(value){// Safari 8.1 makes `arguments.callee` enumerable in strict mode.
return isArrayLikeObject(value)&&hasOwnProperty.call(value,'callee')&&(!propertyIsEnumerable.call(value,'callee')||objectToString.call(value)==argsTag);}/**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */var isArray=Array.isArray;/**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&objectToString.call(value)==boolTag;}/**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */var isBuffer=nativeIsBuffer||stubFalse;/**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */function isElement(value){return!!value&&value.nodeType===1&&isObjectLike(value)&&!isPlainObject(value);}/**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */function isEmpty(value){if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isArguments(value))){return!value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return!value.size;}if(nonEnumShadows||isPrototype(value)){return!nativeKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are **not** supported.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */function isEqual(value,other){return baseIsEqual(value,other);}/**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined;var result=customizer?customizer(value,other):undefined;return result===undefined?baseIsEqual(value,other,customizer):!!result;}/**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */function isError(value){if(!isObjectLike(value)){return false;}return objectToString.call(value)==errorTag||typeof value.message=='string'&&typeof value.name=='string';}/**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */function isFunction(value){// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 8-9 which returns 'object' for typed array and other constructors.
var tag=isObject(value)?objectToString.call(value):'';return tag==funcTag||tag==genTag;}/**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */function isObject(value){var type=typeof value;return!!value&&(type=='object'||type=='function');}/**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */function isObjectLike(value){return!!value&&typeof value=='object';}/**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
// Perform the `toStringTag` check first to avoid errors with some
// ActiveX objects in IE.
return isNumber(value)&&value!=+value;}/**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */function isNative(value){if(isMaskable(value)){throw new Error('This method is not supported with core-js. Try https://github.com/es-shims.');}return baseIsNative(value);}/**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */function isNull(value){return value===null;}/**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */function isNil(value){return value==null;}/**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&objectToString.call(value)==numberTag;}/**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */function isPlainObject(value){if(!isObjectLike(value)||objectToString.call(value)!=objectTag||isHostObject(value)){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&objectToString.call(value)==stringTag;}/**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */function isSymbol(value){return typeof value=='symbol'||isObjectLike(value)&&objectToString.call(value)==symbolTag;}/**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */function isUndefined(value){return value===undefined;}/**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */function isWeakSet(value){return isObjectLike(value)&&objectToString.call(value)==weakSetTag;}/**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */var lt=createRelationalOperation(baseLt);/**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */function toArray(value){if(!value){return[];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(iteratorSymbol&&value[iteratorSymbol]){return iteratorToArray(value[iteratorSymbol]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=value.replace(reTrim,'');var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */function toSafeInteger(value){return baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER);}/**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*//**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */var assign=createAssigner(function(object,source){if(nonEnumShadows||isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths of elements to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */var at=baseRest(function(object,paths){return baseAt(object,baseFlatten(paths,1));});/**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */function create(prototype,properties){var result=baseCreate(prototype);return properties?baseAssign(result,properties):result;}/**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var defaults=baseRest(function(args){args.push(undefined,assignInDefaults);return apply(assignInWith,undefined,args);});/**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */var defaultsDeep=baseRest(function(args){args.push(undefined,mergeDefaults);return apply(mergeWith,undefined,args);});/**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */function get(object,path,defaultValue){var result=object==null?undefined:baseGet(object,path);return result===undefined?defaultValue:result;}/**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */var invert=createInverter(function(result,value,key){result[value]=key;},constant(identity));/**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */var invertBy=createInverter(function(result,value,key){if(hasOwnProperty.call(result,value)){result[value].push(key);}else{result[value]=[key];}},getIteratee);/**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */var invoke=baseRest(baseInvoke);/**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){result[iteratee(value,key,object)]=value;});return result;}/**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){result[key]=iteratee(value,key,object);});return result;}/**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with seven arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable string keyed properties of `object` that are
     * not omitted.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [props] The property identifiers to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */var omit=baseRest(function(object,props){if(object==null){return{};}props=arrayMap(baseFlatten(props,1),toKey);return basePick(object,baseDifference(getAllKeysIn(object),props));});/**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [props] The property identifiers to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */var pick=baseRest(function(object,props){return object==null?{}:basePick(object,arrayMap(baseFlatten(props,1),toKey));});/**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */function pickBy(object,predicate){return object==null?{}:basePickBy(object,getAllKeysIn(object),getIteratee(predicate));}/**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */function result(object,path,defaultValue){path=isKey(path,object)?[path]:castPath(path);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
if(!length){object=undefined;length=1;}while(++index<length){var value=object==null?undefined:object[toKey(path[index])];if(value===undefined){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseSet(object,path,value,customizer);}/**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */var toPairs=createToPairs(keys);/**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */var toPairsIn=createToPairs(keysIn);/**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */function transform(object,iteratee,accumulator){var isArr=isArray(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){if(isArr||isObject(object)){var Ctor=object.constructor;if(isArr){accumulator=isArray(object)?new Ctor():[];}else{accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}}else{accumulator={};}}(isArr?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */function values(object){return object?baseValues(object,keys(object)):[];}/**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*//**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */function inRange(number,start,end){start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined;}if(floating===undefined){if(typeof upper=='boolean'){floating=upper;upper=undefined;}else if(typeof lower=='boolean'){floating=lower;lower=undefined;}}if(lower===undefined&&upper===undefined){lower=0;upper=1;}else{lower=toFinite(lower);if(upper===undefined){upper=lower;lower=0;}else{upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*//**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
     * Converts the characters "&", "<", ">", '"', "'", and "\`" in `string` to
     * their corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * Backticks are escaped because in IE < 9, they can break out of
     * attribute values or HTML comments. See [#59](https://html5sec.org/#59),
     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
     * [#133](https://html5sec.org/#133) of the
     * [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */var lowerFirst=createCaseFirst('toLowerCase');/**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */function parseInt(string,radix,guard){// Chrome fails to trim leading <BOM> whitespace characters.
// See https://bugs.chromium.org/p/v8/issues/detail?id=3109 for more details.
if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}string=toString(string).replace(reTrim,'');return nativeParseInt(string,radix||(reHasHexPrefix.test(string)?16:10));}/**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined){n=1;}else{n=toInteger(n);}return baseRepeat(toString(string),n);}/**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined;}limit=limit===undefined?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return[];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */function startsWith(string,target,position){string=toString(string);position=baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES delimiter as an alternative to the default "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
// (http://ejohn.org/blog/javascript-micro-templating/)
// and Laura Doktorova's doT.js (https://github.com/olado/doT).
var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined;}string=toString(string);options=assignInWith({},options,settings,assignInDefaults);var imports=assignInWith({},options.imports,settings.imports,assignInDefaults),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
var sourceURL='//# sourceURL='+('sourceURL'in options?options.sourceURL:'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
// order to produce the correct `offset` value.
return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
// code to add the data object to the top of the scope chain.
var variable=options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Cleanup code by stripping empty strings.
source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined,importsValues);});// Provide the compiled function's source by its `toString` method or
// the `source` property as a convenience for inlining compiled templates.
result.source=source;if(isError(result)){throw result;}return result;}/**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */function toLower(value){return toString(value).toLowerCase();}/**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */function toUpper(value){return toString(value).toUpperCase();}/**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrim,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimEnd,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */var upperFirst=createCaseFirst('toUpperCase');/**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined:pattern;if(pattern===undefined){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*//**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */var attempt=baseRest(function(func,args){try{return apply(func,undefined,args);}catch(e){return isError(e)?e:new Error(e);}});/**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */var bindAll=baseRest(function(object,methodNames){arrayEach(baseFlatten(methodNames,1),function(key){key=toKey(key);object[key]=bind(object[key],object);});return object;});/**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */function cond(pairs){var length=pairs?pairs.length:0,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return[toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */function conforms(source){return baseConforms(baseClone(source,true));}/**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */function constant(value){return function(){return value;};}/**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */var flow=createFlow();/**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */var flowRight=createFlow(true);/**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */function identity(value){return value;}/**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,true));}/**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     */function matches(source){return baseMatches(baseClone(source,true));}/**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,true));}/**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */function noop(){}// No operation performed.
/**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */var over=createOver(arrayMap);/**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */var overEvery=createOver(arrayEvery);/**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     */var overSome=createOver(arraySome);/**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */function propertyOf(object){return function(path){return object==null?undefined:baseGet(object,path);};}/**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */var range=createRange();/**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */var rangeRight=createRange(true);/**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */function stubArray(){return[];}/**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */function stubFalse(){return false;}/**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */function stubObject(){return{};}/**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */function stubString(){return'';}/**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */function stubTrue(){return true;}/**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return[];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(value));}/**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*//**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */var ceil=createRound('ceil');/**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */var floor=createRound('floor');/**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined;}/**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined;}/**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */function mean(array){return baseMean(array,identity);}/**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined;}/**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined;}/**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */var round=createRound('round');/**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/// Add methods that return wrapped values in chain sequences.
lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
mixin(lodash,lodash);/*------------------------------------------------------------------------*/// Add methods that return unwrapped values in chain sequences.
lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*//**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */lodash.VERSION=VERSION;// Assign default placeholders.
arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){var filtered=this.__filtered__;if(filtered&&!index){return new LazyWrapper(this);}n=n===undefined?1:nativeMax(toInteger(n),0);var result=this.clone();if(filtered){result.__takeCount__=nativeMin(n,result.__takeCount__);}else{result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'',names=realNames[key]||(realNames[key]=[]);names.push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined,BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined}];// Add methods to `LazyWrapper`.
LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
lodash.prototype.first=lodash.prototype.head;if(iteratorSymbol){lodash.prototype[iteratorSymbol]=wrapperToIterator;}return lodash;}/*--------------------------------------------------------------------------*/// Export lodash.
var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
if(true){// Expose Lodash on the global object to prevent errors when Lodash is
// loaded by a script tag in the presence of an AMD loader.
// See http://requirejs.org/docs/errors.html#mismatch for more details.
// Use `_.noConflict` to remove Lodash from the global object.
root._=_;// Define as an anonymous module so, through path mapping, it can be
// referenced as the "underscore" module.
!(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return _;}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}// Check for `exports` after `define` in case a build optimizer adds it.
else if(freeModule){// Export for Node.js.
(freeModule.exports=_)._=_;// Export for CommonJS support.
freeExports._=_;}else{// Export to the global object.
root._=_;}}).call(this);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)(module)))

/***/ },
/* 11 */
/***/ function(module, exports) {

module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			configurable: false,
			get: function () {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			configurable: false,
			get: function () {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMWE4NGZjZmU5Y2M0YmYwOWQ4MjIiLCJ3ZWJwYWNrOi8vLy4vc3JjX2VsZWN0cm9uL3VpL2pzL2Vycm9yaGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJlbGVjdHJvblwiIiwid2VicGFjazovLy8uL3NyY19lbGVjdHJvbi91aS9qcy9zdG9yYWdlLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly8vd2VicGFjazovd2VicGFjay9ib290c3RyYXAgODVjZjRjZTY3YTAyZGIyYTIzYjMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbGliL3NrbGFkLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL34va2lub3Byb21pc2UvYnVpbGQuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbGliL3V1aWQuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6Ly8vbGliL2Vycm9yLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi8vL2xpYi9lbnYuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjX2VsZWN0cm9uL3VpL2pzL2lkYi5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJhc3NlcnRcIiIsIndlYnBhY2s6Ly8vLi9zcmNfZWxlY3Ryb24vdWkvanMvc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9zcmNfZWxlY3Ryb24vdWkvanMvZGIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvbG9kYXNoLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiXSwibmFtZXMiOlsicHJlcGFyZVN0YWNrVGV4dCIsImVyclN0YWNrIiwic3BsaXQiLCJmbGF0dGVuRXJyb3IiLCJlcnIiLCJpc0Vycm9ySW5zdGFuY2UiLCJFcnJvciIsIm1lc3NhZ2UiLCJzdGFjayIsImZpbGUiLCJwcm9jZXNzIiwib24iLCJpcGNSZW5kZXJlciIsInNlbmQiLCJ0eXBlIiwicmVhc29uIiwiT0JKX1NUT1JFX05BTUUiLCJTdG9yYWdlIiwibG9hZCIsImNvbm4iLCJvcGVuTWV0YSIsInJlY29yZHMiLCJnZXQiLCJjb25zb2xlIiwibG9nIiwiX2RhdGEiLCJzZXQiLCJrZXkiLCJ2YWx1ZSIsIl9jaGVja0lzSW5pdGlhbGl6ZWQiLCJzdG9yYWdlRGF0YSIsImNocm9tZSIsInN0b3JhZ2UiLCJsb2NhbCIsIm9wZW5Db25uIiwidGhlbiIsInVwc2VydCIsInBhcmFtcyIsInZhbHVlQ3JlYXRlZCIsImNvbnN0cnVjdG9yIiwiU3RyaW5nIiwic3RyaWN0IiwiY3JlYXRlIiwiYXNzZXJ0IiwicmVtb3ZlIiwiZGVsZXRlIiwiX2luaXRpYWxpemVkIiwic2tsYWQiLCJvcGVuIiwidmVyc2lvbiIsIm1pZ3JhdGlvbiIsImRhdGFiYXNlIiwiY3JlYXRlT2JqZWN0U3RvcmUiLCJhdXRvSW5jcmVtZW50Iiwia2V5UGF0aCIsIm9wZW5Vc2VyIiwidXNlcklkIiwiY29udGFjdHNTdG9yZSIsImNyZWF0ZUluZGV4IiwibXVsdGlFbnRyeSIsIm1lc3NhZ2VzU3RvcmUiLCJjaGF0c1N0b3JlIiwiZHJvcFVzZXIiLCJkZWxldGVEYXRhYmFzZSIsInN0b3JhZ2VNYW5hZ2VyIiwiZXJyb3JoYW5kbGVyIiwiZ2xvYmFsIiwiX19maWxlbmFtZSIsImZvcmNlU2tpcFN5bmMiLCJzaG93Q2hyb21lTm90aWZpY2F0aW9uIiwiZGF0YSIsIm5vdGlmaWNhdGlvbnMiLCJwcm9taXNlIiwidWlkIiwiZ2V0QXZhdGFySW1hZ2UiLCJpY29uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzaG93Q2hyb21lTm90aWZpY2F0aW9uSW5uZXIiLCJ1cmkiLCJpZCIsIk1hdGgiLCJyYW5kb20iLCJpY29uVXJsIiwidGl0bGUiLCJpc0NsaWNrYWJsZSIsIm5vdGlmaWNhdGlvbklkIiwib25jbGljayIsIm5vdGlmaWNhdGlvbkhhbmRsZXJzIiwic291bmQiLCJTb3VuZE1hbmFnZXIiLCJwbGF5IiwidGltZW91dCIsInNldFRpbWVvdXQiLCJjbGVhciIsIl8iLCJub29wIiwiZ2V0RmxhdFNldHRpbmdzIiwiZmxhdFNldHRpbmdzIiwiU2V0dGluZ3NNYW5hZ2VyIiwiZ2V0QXZhaWxhYmxlIiwiZm9yRWFjaCIsImxlYXZlT25lQXBwV2luZG93SW5zdGFuY2UiLCJvcGVuSWZOb0V4aXN0IiwiYXBwV2luZG93cyIsImFwcCIsIndpbmRvdyIsImdldEFsbCIsIndpbiIsImlzTm90Rmlyc3QiLCJjbG9zZSIsImZvY3VzIiwic2hvdyIsImxlbmd0aCIsIm9wZW5BcHBXaW5kb3ciLCJhbGwiLCJEYXRhYmFzZU1hbmFnZXIiLCJpbml0TWV0YSIsInJlYWR5VG9HbyIsImluaXQiLCJMb2dNYW5hZ2VyIiwiY29uZmlnIiwic3luY2luZ0RhdGEiLCJ1aWRzUHJvY2Vzc2luZyIsImNsZWFyU3luY2luZ0RhdGFDb3VudGVycyIsInVuZGVmaW5lZCIsImNvbnRhY3RzIiwiaW5ib3giLCJzZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJydW50aW1lIiwic2VuZE1lc3NhZ2UiLCJBY2NvdW50c01hbmFnZXIiLCJjdXJyZW50VXNlcklkIiwic3RhcnRVc2VyU2Vzc2lvbiIsIlJlcU1hbmFnZXIiLCJhYm9ydEFsbCIsImxvbmdQb2xsRXZlbnRzUmVnaXN0cmFyIiwiX2xvbmdQb2xsWGhySWRzIiwiYWJvcnQiLCJfZ2V0Q3JlZGVudGlhbHMiLCJfb25Mb2FkIiwicmVzIiwic2VsZiIsImZhaWxlZCIsIndhcm4iLCJlcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJpbmZvIiwidXBkYXRlcyIsIm1hcmtNZXNzYWdlV2l0aFRhZyIsImlzRGF0YWJhc2VFcnJvciIsImVyck1zZyIsIkNQQSIsInNlbmRFdmVudCIsIm1hcmtBc1VucmVhZCIsInVubWFya01lc3NhZ2VXaXRoVGFnIiwibWFya0FzUmVhZCIsImZyb20iLCJtYWlsVHlwZSIsIm9uVXNlckRhdGFSZWFkeSIsInVzZXJEYXRhIiwiYXR0YWNobWVudHMiLCJtc2dEYXRhIiwiZmllbGQiLCJtYXRjaGVzIiwibWF0Y2giLCJhdHRhY2hUeXBlIiwicHVzaCIsImNvbmNhdCIsImdlbyIsIm1pZCIsImRhdGUiLCJib2R5IiwicmVhZF9zdGF0ZSIsImNoYXRfaWQiLCJ0YWdzIiwiZW1vamkiLCJpbnNlcnRNZXNzYWdlcyIsImFjdGlvbiIsInVzZXJkYXRhIiwiYXZhdGFyIiwicGhvdG8iLCJnZXRVUkwiLCJzaG93Tm90aWZpY2F0aW9uIiwiYXZhdGFyVXJsIiwiTm90aWZpY2F0aW9uc1RpbWUiLCJmaXJzdF9uYW1lIiwibGFzdF9uYW1lIiwicmVwbGFjZSIsImdldENvbnRhY3RCeUlkIiwiZ2V0VXNlclByb2ZpbGUiLCJwYXJzZUludCIsIlNob3dPbmxpbmUiLCJfbG9uZ1BvbGxEYXRhIiwidHMiLCJfbG9uZ1BvbGxJbml0IiwiX29uRXJyb3IiLCJlcnJvckNvZGUiLCJlcnJvckRhdGEiLCJBQk9SVCIsIm1haWxTeW5jIiwiYXBpTWV0aG9kIiwicmVzcG9uc2UiLCJlcnJDb2RlIiwiQUNDRVNTX0RFTklFRCIsImJpbmQiLCJkb21haW4iLCJzZXJ2ZXIiLCJmb3JjZVVybEdldCIsIl90YWdzIiwiY2FsbGJhY2siLCJ0b2tlbkZvclJlcXVlc3QiLCJsaXN0IiwidG9rZW4iLCJ1aWRzIiwiZmllbGRzIiwiYWNjZXNzX3Rva2VuIiwidXBkYXRlVXNlcnNEYXRhIiwidXNlcnMiLCJlcnJEYXRhIiwiZnJpZW5kc1N5bmMiLCJydW5uaW5nIiwiZnJpZW5kc1N5bmNUaW1lcyIsIk9iamVjdCIsIm1pbGxpU2Vjb25kc1RpbWVvdXQiLCJBcHAiLCJGUklFTkRTX1VQREFURV9USU1FT1VUIiwibmV4dFJlcXVlc3RUaW1lb3V0IiwibWF4IiwiYWJzIiwiRGF0ZSIsIm5vdyIsImN1cnJlbnRVc2VyRGF0YSIsIm5vd0RhdGUiLCJub3dEYXkiLCJnZXREYXRlIiwibm93WWVhciIsImdldEZ1bGxZZWFyIiwibm93TW9udGgiLCJnZXRNb250aCIsImJEYXRlIiwiaSIsIm5vdGlmaWNhdGlvbiIsIm1zZyIsImJkYXRlIiwiTkFNRSIsImkxOG4iLCJnZXRNZXNzYWdlIiwidXNlckRvYyIsInRvdGFsIiwiY3VycmVudCIsIlNob3dCaXJ0aGRheU5vdGlmaWNhdGlvbnMiLCJpMThuQmlydGhEYXkiLCJpMThuWWVhcnMiLCJoaXNIZXJNYXRjaGVzIiwieW9Ob3ciLCJzZXgiLCJVdGlscyIsInN0cmluZyIsInBsdXJhbCIsImluYm94U3luY2VkIiwic2VudFN5bmNlZCIsImFjdHVhbGl6ZUNvbnRhY3RzIiwiYWN0dWFsaXplQ2hhdERhdGVzIiwid2hpY2giLCJjdXJyZW50VXNlckZpbyIsImZpbyIsInJlamVjdCIsImRhdGFUb1JlcGxhY2UiLCJzZXRGaW8iLCJyZXBsYWNlQ29udGFjdHMiLCJlcnJNZXNzYWdlIiwibmFtZSIsImxhdGVzdE1lc3NhZ2VJZCIsIm9mZnNldCIsInVzZXJEYXRhRm9yUmVxdWVzdCIsImNvbXBhdE5hbWUiLCJwZXJtS2V5IiwiZmlyc3RTeW5jIiwibGF0ZXN0TXNnIiwiZ2V0TGF0ZXN0VGFnTWVzc2FnZUlkIiwiZ2V0TWVzc2FnZXMiLCJyZXFEYXRhIiwiY291bnQiLCJwcmV2aWV3X2xlbmd0aCIsIm91dCIsImNvZGUiLCJ0aW1lVG9TdG9wQWZ0ZXIiLCJtZXNzYWdlcyIsImRhdGFTeW5jZWRGbiIsImZyaWVuZHNTeW5jZWQiLCJ3YWxsVG9rZW5VcGRhdGVkIiwiQXJyYXkiLCJpbmRleCIsImNvb3JkcyIsImNvb3JkaW5hdGVzIiwiZ2VvcG9pbnQiLCJsYXQiLCJsbmciLCJET01FcnJvciIsImluaXRVc2VyIiwibmF2aWdhdG9yIiwib25MaW5lIiwib25NZXNzYWdlIiwiYWRkTGlzdGVuZXIiLCJyZXF1ZXN0Iiwic2VuZGVyIiwic2VuZFJlc3BvbnNlIiwic2VuZEFzeW5jUmVzcG9uc2UiLCJzZXREYXRhIiwibmV3VXNlckdyYW50ZWQiLCJuZWVkZWRVc2VyVG9rZW5VcGRhdGVkIiwibmVlZGVkVWlkIiwibGlzdFVzZXJJZCIsIk51bWJlciIsImFjY291bnRzIiwicHJvbWlzZXMiLCJhc3NpZ25BdmF0YXIiLCJhY2NvdW50IiwiY29udGFjdERhdGEiLCJmb3JJbiIsInNldHRpbmdzIiwidG9rZW5FeHBpcmVkQWxhcm1OYW1lIiwiYWxhcm1zIiwiYWxhcm1JbmZvIiwiZGVsYXlJbk1pbnV0ZXMiLCJ1aVR5cGUiLCJjaGFuZ2Vsb2dOb3RpZmllZCIsInNlbmRBcHBWaWV3IiwiYnJlYWtOZWVkZWQiLCJ0aW1lb3V0SWQiLCJvbkNvbnRhY3RzTGlzdFJlYWR5IiwiY29udGFjdHNMaXN0IiwiY29udGFjdHNJZHMiLCJtYXAiLCJqb2luIiwiY2h1bmsiLCJpc09ubGluZSIsIm9ubGluZSIsIm9ubGluZV9tb2JpbGUiLCJkZWZhdWx0U2V0dGluZ3NVc2VkIiwiU29ydENvbnRhY3RzIiwiZ2V0Q29udGFjdExpc3QiLCJ0b3RhbFNob3duIiwiY2xlYXJUaW1lb3V0IiwiZ2V0Q29udmVyc2F0aW9ucyIsImdldERpYWxvZ1RocmVhZCIsImV2ZXJ5dGhpbmciLCJCb29sZWFuIiwicHJpbnQiLCJnZXRNZXNzYWdlQnlJZCIsImdldENvbnZlcnNhdGlvblRocmVhZHNXaXRoQ29udGFjdCIsImluY2x1ZGVPbmxpbmVTdGF0dXMiLCJtc2dQYXJhbXMiLCJzdWJqZWN0Iiwic2lkIiwiY2FwdGNoYV9zaWQiLCJjYXB0Y2hhX2tleSIsImF0dGFjaG1lbnQiLCJ0ZXN0IiwidG8iLCJsYXRpdHVkZSIsImxvbmciLCJsb25naXR1ZGUiLCJDQVBUQ0hBIiwiUkVTUE9OU0VfRVJST1IiLCJzZW5kUmVxdWVzdCIsIk5PX0lOVEVSTkVUIiwiTk9UX0pTT04iLCJUSU1FT1VUIiwicmVxdWVzdERhdGEiLCJoYXNoIiwic2VuZExpa2VSZXF1ZXN0Iiwic2VuZEpvaW5Hcm91cFJlcXVlc3QiLCJvd25lcklkIiwiZG9jIiwib3duZXJfaWQiLCJkaWQiLCJvdXRwdXQiLCJtc2dJZCIsInBpZCIsInRhZyIsInNlbmREcm9wTWVzc2FnZVJlcXVlc3QiLCJzZW5kUmVzdG9yZU1lc3NhZ2VSZXF1ZXN0Iiwib25Ecm9wIiwiYWN0aW9uc1RvR28iLCJzZXJ2ZXJUb28iLCJhY3Rpb25zTWFkZSIsImRlbGV0ZU1lc3NhZ2UiLCJ2ZXJzaW9ucyIsIlZFUlNJT04iLCJ1cmwiLCJhaWQiLCJzdGVwIiwiZ2V0VGFnc0NvdW50IiwiZ2V0TWVzc2FnZXNCeVR5cGUiLCJzZWFyY2hDb250YWN0Iiwic2VhcmNoTWFpbCIsImNvcnJlc3BvbmRlbmNlIiwic3RhcnRVc2VyIiwiZHJvcCIsImZyaWVuZHNTeW5jVGltZSIsIm5leHQiLCJzZW5kUmVhZE1lc3NhZ2VSZXF1ZXN0IiwibnVtIiwidmFsaWRhdGVKU09OU3RyaW5nIiwiY29uc3RyIiwic29tZURhdGEiLCJwYXJzZSIsImV4IiwiZ2V0TWVzc2FnZUZ1bGx0ZXh0IiwibXNnQm9keSIsInRvTG93ZXJDYXNlIiwiZmlsdGVyIiwid29yZCIsIm1pZ3JhdGVXZWJEYXRhYmFzZSIsIkRhdGFiYXNlTWFuYWdlcl9taWdyYXRlV2ViRGF0YWJhc2UiLCJ0aGF0Iiwid2ViRGF0YWJhc2VMaW5rIiwib3BlbkRhdGFiYXNlIiwiZ2V0QWxsV2ViRGF0YWJhc2VEYXRhIiwidGFibGUiLCJyZWFkVHJhbnNhY3Rpb24iLCJ0eCIsImV4ZWN1dGVTcWwiLCJyZXN1bHRTZXQiLCJ0b3RhbFJlY29yZHMiLCJyb3dzIiwiaXRlbSIsImluZGV4T2YiLCJtaWdyYXRlVXNlckRhdGEiLCJmZXRjaGVkQ29udGFjdHMiLCJmZXRjaGVkTWVzc2FnZXMiLCJjaGF0cyIsInJlY29yZCIsIm90aGVyRGF0YSIsIm90aGVyX2RhdGEiLCJub3RlcyIsImxhc3RfbWVzc2FnZV90cyIsIm1lc3NhZ2VzX251bSIsImZ1bGx0ZXh0IiwiaXNNdWx0aUNoYXQiLCJjaGF0aWQiLCJjaGF0SWQiLCJsYXN0Q2hhdE1lc3NhZ2VEYXRlIiwiSU5JVF9UQUdTIiwicG93IiwiaGFzRW1vamkiLCJyZWFkIiwic3RhdHVzIiwiaGFzX2Vtb2ppIiwiY2hhdCIsIl9jb25uIiwiaW5zZXJ0IiwidmFsdWVzIiwiaW5zZXJ0ZWRLZXlzIiwiY2FsbCIsIl9tZXRhIiwiRGF0YWJhc2VNYW5hZ2VyX2luaXRNZXRhIiwiZm5TdWNjZXNzIiwiZm5GYWlsIiwiX3VzZXJJZCIsIkRhdGFiYXNlTWFuYWdlcl9pbml0VXNlciIsIkRhdGFiYXNlTWFuYWdlcl9kcm9wVXNlciIsIkRhdGFiYXNlTWFuYWdlcl9nZXRDb250YWN0TGlzdCIsIm91dHB1dFR5cGUiLCJzdGFydEZyb20iLCJjb3VudENvbnRhY3RzIiwiZ2V0Q29udGFjdHMiLCJpbmRleE5hbWUiLCJkaXJlY3Rpb24iLCJsaW1pdCIsIkRhdGFiYXNlTWFuYWdlcl9nZXRDb250YWN0QnlJZCIsInNlYXJjaFVzZXJJZCIsInJhbmdlIiwiSURCS2V5UmFuZ2UiLCJvbmx5IiwiRGF0YWJhc2VNYW5hZ2VyX2dldENvbnZlcnNhdGlvbnMiLCJnZXRDaGF0c0xpc3QiLCJnZXRUb3RhbENoYXRzIiwiZ2V0Q2hhdFBhcnRpY2lwYW50cyIsImJvdW5kIiwiY3VycmVudFVzZXJJc1BhcnRpY2lwYW50IiwiY29udGFjdCIsInBhcnRpY2lwYW50cyIsImNvbXBhY3QiLCJnZXRDaGF0TGFzdE1lc3NhZ2UiLCJnZXRDaGF0VG90YWxNZXNzYWdlcyIsImZpbGxEYXRhUHJvbWlzZXMiLCJjaGF0RGF0YSIsIkRhdGFiYXNlTWFuYWdlcl9nZXRDb252ZXJzYXRpb25UaHJlYWRzV2l0aENvbnRhY3QiLCJzdWJzdHIiLCJmcm9tQ2hhckNvZGUiLCJjaGFyQ29kZUF0IiwiQVNDX1VOSVFVRSIsIkRFU0MiLCJhc3NpZ24iLCJjb3VudENoYXRNZXNzYWdlcyIsImNoYXRSZWNvcmQiLCJzb3J0IiwiYSIsImIiLCJEYXRhYmFzZU1hbmFnZXJfZ2V0RGlhbG9nVGhyZWFkIiwiZGlhbG9nSWQiLCJvcHRzIiwiZ2V0Q2hhdE1lc3NhZ2VzIiwiZ2V0T3B0cyIsInJldmVyc2UiLCJLaW5vUHJvbWlzZSIsImN1cnJlbnRVc2VyUGhvdG8iLCJEYXRhYmFzZU1hbmFnZXJfZ2V0TWVzc2FnZUJ5SWQiLCJnZXRDb250YWN0UGhvdG8iLCJEYXRhYmFzZU1hbmFnZXJfcmVwbGFjZUNvbnRhY3RzIiwic2VhcmNoT3B0cyIsImxvd2VyQm91bmQiLCJjdXJyZW50Q29udGFjdHMiLCJ1cHNlcnRDb250YWN0cyIsIkRhdGFiYXNlTWFuYWdlcl9pbnNlcnRNZXNzYWdlcyIsIm1lc3NhZ2VzVG9JbnNlcnQiLCJpc0FycmF5IiwiaW1wb3J0YW50IiwiZGVsZXRlZCIsIkRhdGFiYXNlTWFuYWdlcl9nZXRMYXRlc3RUYWdNZXNzYWdlSWQiLCJEYXRhYmFzZU1hbmFnZXJfYWN0dWFsaXplQ2hhdERhdGVzIiwiZ2V0Q2hhdExhc3REYXRlIiwiREVTQ19VTklRVUUiLCJ1cHNlcnREYXRhIiwiRGF0YWJhc2VNYW5hZ2VyX2FjdHVhbGl6ZUNvbnRhY3RzIiwiZ2V0TGFzdFVzZXJNZXNzYWdlIiwiY291bnRVc2VyTWVzc2FnZXMiLCJEYXRhYmFzZU1hbmFnZXJfbWFya0FzUmVhZCIsIkRhdGFiYXNlTWFuYWdlcl9tYXJrQXNVbnJlYWQiLCJEYXRhYmFzZU1hbmFnZXJfbWFya01lc3NhZ2VXaXRoVGFnIiwiRGF0YWJhc2VNYW5hZ2VyX3VubWFya01lc3NhZ2VXaXRoVGFnIiwidGFnSW5kZXgiLCJzcGxpY2UiLCJEYXRhYmFzZU1hbmFnZXJfZGVsZXRlTWVzc2FnZSIsImZuIiwiRGF0YWJhc2VNYW5hZ2VyX2dldFRhZ3NDb3VudCIsImNvdW50VGFnT2NjdXJyZW5jZXMiLCJnZXRNZXNzYWdlc1dpdGhGYWxzeUF0dGFjaG1lbnRzIiwiRGF0YWJhc2VNYW5hZ2VyX2dldE1lc3NhZ2VzV2l0aEZhbHN5QXR0YWNobWVudHMiLCJEYXRhYmFzZU1hbmFnZXJfZ2V0TWVzc2FnZXNCeVR5cGUiLCJjb3VudFRhZ01lc3NhZ2VzIiwiZ2V0Q29udGFjdERhdGEiLCJnZXRUYWdNZXNzYWdlcyIsIkRhdGFiYXNlTWFuYWdlcl9zZWFyY2hDb250YWN0IiwicSIsInNlYXJjaENvbnRhY3RzIiwibGltaSIsImFwcGx5IiwiRGF0YWJhc2VNYW5hZ2VyX3NlYXJjaE1haWwiLCJjb3VudE1lc3NhZ2VzIiwiRGF0YWJhc2VNYW5hZ2VyX2xvZyIsImxldmVsIiwiY29sbGVjdExvZ0RhdGEiLCJEYXRhYmFzZU1hbmFnZXJfY29sbGVjdExvZ0RhdGEiLCJ0aW1lTGFzdCIsImxvZ1JlY29yZHMiLCJ0aW1lRGlmZiIsIl9kYkxpbmsiLCJMQVJHRV9BUlJBWV9TSVpFIiwiRlVOQ19FUlJPUl9URVhUIiwiSEFTSF9VTkRFRklORUQiLCJQTEFDRUhPTERFUiIsIkJJTkRfRkxBRyIsIkJJTkRfS0VZX0ZMQUciLCJDVVJSWV9CT1VORF9GTEFHIiwiQ1VSUllfRkxBRyIsIkNVUlJZX1JJR0hUX0ZMQUciLCJQQVJUSUFMX0ZMQUciLCJQQVJUSUFMX1JJR0hUX0ZMQUciLCJBUllfRkxBRyIsIlJFQVJHX0ZMQUciLCJGTElQX0ZMQUciLCJVTk9SREVSRURfQ09NUEFSRV9GTEFHIiwiUEFSVElBTF9DT01QQVJFX0ZMQUciLCJERUZBVUxUX1RSVU5DX0xFTkdUSCIsIkRFRkFVTFRfVFJVTkNfT01JU1NJT04iLCJIT1RfQ09VTlQiLCJIT1RfU1BBTiIsIkxBWllfRklMVEVSX0ZMQUciLCJMQVpZX01BUF9GTEFHIiwiTEFaWV9XSElMRV9GTEFHIiwiSU5GSU5JVFkiLCJNQVhfU0FGRV9JTlRFR0VSIiwiTUFYX0lOVEVHRVIiLCJOQU4iLCJNQVhfQVJSQVlfTEVOR1RIIiwiTUFYX0FSUkFZX0lOREVYIiwiSEFMRl9NQVhfQVJSQVlfTEVOR1RIIiwid3JhcEZsYWdzIiwiYXJnc1RhZyIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsImZ1bmNUYWciLCJnZW5UYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJvYmplY3RUYWciLCJwcm9taXNlVGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwic3ltYm9sVGFnIiwid2Vha01hcFRhZyIsIndlYWtTZXRUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwicmVFbXB0eVN0cmluZ0xlYWRpbmciLCJyZUVtcHR5U3RyaW5nTWlkZGxlIiwicmVFbXB0eVN0cmluZ1RyYWlsaW5nIiwicmVFc2NhcGVkSHRtbCIsInJlVW5lc2NhcGVkSHRtbCIsInJlSGFzRXNjYXBlZEh0bWwiLCJSZWdFeHAiLCJzb3VyY2UiLCJyZUhhc1VuZXNjYXBlZEh0bWwiLCJyZUVzY2FwZSIsInJlRXZhbHVhdGUiLCJyZUludGVycG9sYXRlIiwicmVJc0RlZXBQcm9wIiwicmVJc1BsYWluUHJvcCIsInJlTGVhZGluZ0RvdCIsInJlUHJvcE5hbWUiLCJyZVJlZ0V4cENoYXIiLCJyZUhhc1JlZ0V4cENoYXIiLCJyZVRyaW0iLCJyZVRyaW1TdGFydCIsInJlVHJpbUVuZCIsInJlV3JhcENvbW1lbnQiLCJyZVdyYXBEZXRhaWxzIiwicmVTcGxpdERldGFpbHMiLCJyZUFzY2lpV29yZCIsInJlRXNjYXBlQ2hhciIsInJlRXNUZW1wbGF0ZSIsInJlRmxhZ3MiLCJyZUhhc0hleFByZWZpeCIsInJlSXNCYWRIZXgiLCJyZUlzQmluYXJ5IiwicmVJc0hvc3RDdG9yIiwicmVJc09jdGFsIiwicmVJc1VpbnQiLCJyZUxhdGluIiwicmVOb01hdGNoIiwicmVVbmVzY2FwZWRTdHJpbmciLCJyc0FzdHJhbFJhbmdlIiwicnNDb21ib01hcmtzUmFuZ2UiLCJyc0NvbWJvU3ltYm9sc1JhbmdlIiwicnNEaW5nYmF0UmFuZ2UiLCJyc0xvd2VyUmFuZ2UiLCJyc01hdGhPcFJhbmdlIiwicnNOb25DaGFyUmFuZ2UiLCJyc1B1bmN0dWF0aW9uUmFuZ2UiLCJyc1NwYWNlUmFuZ2UiLCJyc1VwcGVyUmFuZ2UiLCJyc1ZhclJhbmdlIiwicnNCcmVha1JhbmdlIiwicnNBcG9zIiwicnNBc3RyYWwiLCJyc0JyZWFrIiwicnNDb21ibyIsInJzRGlnaXRzIiwicnNEaW5nYmF0IiwicnNMb3dlciIsInJzTWlzYyIsInJzRml0eiIsInJzTW9kaWZpZXIiLCJyc05vbkFzdHJhbCIsInJzUmVnaW9uYWwiLCJyc1N1cnJQYWlyIiwicnNVcHBlciIsInJzWldKIiwicnNMb3dlck1pc2MiLCJyc1VwcGVyTWlzYyIsInJzT3B0TG93ZXJDb250ciIsInJzT3B0VXBwZXJDb250ciIsInJlT3B0TW9kIiwicnNPcHRWYXIiLCJyc09wdEpvaW4iLCJyc1NlcSIsInJzRW1vamkiLCJyc1N5bWJvbCIsInJlQXBvcyIsInJlQ29tYm9NYXJrIiwicmVVbmljb2RlIiwicmVVbmljb2RlV29yZCIsInJlSGFzVW5pY29kZSIsInJlSGFzVW5pY29kZVdvcmQiLCJjb250ZXh0UHJvcHMiLCJ0ZW1wbGF0ZUNvdW50ZXIiLCJ0eXBlZEFycmF5VGFncyIsImNsb25lYWJsZVRhZ3MiLCJkZWJ1cnJlZExldHRlcnMiLCJodG1sRXNjYXBlcyIsImh0bWxVbmVzY2FwZXMiLCJzdHJpbmdFc2NhcGVzIiwiZnJlZVBhcnNlRmxvYXQiLCJwYXJzZUZsb2F0IiwiZnJlZVBhcnNlSW50IiwiZnJlZUdsb2JhbCIsImZyZWVTZWxmIiwicm9vdCIsIkZ1bmN0aW9uIiwiZnJlZUV4cG9ydHMiLCJleHBvcnRzIiwibm9kZVR5cGUiLCJmcmVlTW9kdWxlIiwibW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsImZyZWVQcm9jZXNzIiwibm9kZVV0aWwiLCJiaW5kaW5nIiwibm9kZUlzQXJyYXlCdWZmZXIiLCJpc0FycmF5QnVmZmVyIiwibm9kZUlzRGF0ZSIsImlzRGF0ZSIsIm5vZGVJc01hcCIsImlzTWFwIiwibm9kZUlzUmVnRXhwIiwiaXNSZWdFeHAiLCJub2RlSXNTZXQiLCJpc1NldCIsIm5vZGVJc1R5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJhZGRNYXBFbnRyeSIsInBhaXIiLCJhZGRTZXRFbnRyeSIsImFkZCIsImZ1bmMiLCJ0aGlzQXJnIiwiYXJncyIsImFycmF5QWdncmVnYXRvciIsImFycmF5Iiwic2V0dGVyIiwiaXRlcmF0ZWUiLCJhY2N1bXVsYXRvciIsImFycmF5RWFjaCIsImFycmF5RWFjaFJpZ2h0IiwiYXJyYXlFdmVyeSIsInByZWRpY2F0ZSIsImFycmF5RmlsdGVyIiwicmVzSW5kZXgiLCJyZXN1bHQiLCJhcnJheUluY2x1ZGVzIiwiYmFzZUluZGV4T2YiLCJhcnJheUluY2x1ZGVzV2l0aCIsImNvbXBhcmF0b3IiLCJhcnJheU1hcCIsImFycmF5UHVzaCIsImFycmF5UmVkdWNlIiwiaW5pdEFjY3VtIiwiYXJyYXlSZWR1Y2VSaWdodCIsImFycmF5U29tZSIsImFzY2lpU2l6ZSIsImJhc2VQcm9wZXJ0eSIsImFzY2lpVG9BcnJheSIsImFzY2lpV29yZHMiLCJiYXNlRmluZEtleSIsImNvbGxlY3Rpb24iLCJlYWNoRnVuYyIsImJhc2VGaW5kSW5kZXgiLCJmcm9tSW5kZXgiLCJmcm9tUmlnaHQiLCJiYXNlSXNOYU4iLCJiYXNlSW5kZXhPZldpdGgiLCJiYXNlTWVhbiIsImJhc2VTdW0iLCJvYmplY3QiLCJiYXNlUHJvcGVydHlPZiIsImJhc2VSZWR1Y2UiLCJiYXNlU29ydEJ5IiwiY29tcGFyZXIiLCJiYXNlVGltZXMiLCJuIiwiYmFzZVRvUGFpcnMiLCJwcm9wcyIsImJhc2VVbmFyeSIsImJhc2VWYWx1ZXMiLCJjYWNoZUhhcyIsImNhY2hlIiwiaGFzIiwiY2hhcnNTdGFydEluZGV4Iiwic3RyU3ltYm9scyIsImNoclN5bWJvbHMiLCJjaGFyc0VuZEluZGV4IiwiY291bnRIb2xkZXJzIiwicGxhY2Vob2xkZXIiLCJkZWJ1cnJMZXR0ZXIiLCJlc2NhcGVIdG1sQ2hhciIsImVzY2FwZVN0cmluZ0NoYXIiLCJjaHIiLCJnZXRWYWx1ZSIsImhhc1VuaWNvZGUiLCJoYXNVbmljb2RlV29yZCIsImlzSG9zdE9iamVjdCIsInRvU3RyaW5nIiwiaXRlcmF0b3JUb0FycmF5IiwiaXRlcmF0b3IiLCJkb25lIiwibWFwVG9BcnJheSIsInNpemUiLCJvdmVyQXJnIiwidHJhbnNmb3JtIiwiYXJnIiwicmVwbGFjZUhvbGRlcnMiLCJzZXRUb0FycmF5Iiwic2V0VG9QYWlycyIsInN0cmluZ1NpemUiLCJ1bmljb2RlU2l6ZSIsInN0cmluZ1RvQXJyYXkiLCJ1bmljb2RlVG9BcnJheSIsInVuZXNjYXBlSHRtbENoYXIiLCJsYXN0SW5kZXgiLCJ1bmljb2RlV29yZHMiLCJydW5JbkNvbnRleHQiLCJjb250ZXh0IiwiZGVmYXVsdHMiLCJwaWNrIiwiVHlwZUVycm9yIiwiYXJyYXlQcm90byIsInByb3RvdHlwZSIsImZ1bmNQcm90byIsIm9iamVjdFByb3RvIiwiY29yZUpzRGF0YSIsIm1hc2tTcmNLZXkiLCJleGVjIiwia2V5cyIsIklFX1BST1RPIiwiZnVuY1RvU3RyaW5nIiwiaGFzT3duUHJvcGVydHkiLCJpZENvdW50ZXIiLCJvYmplY3RDdG9yU3RyaW5nIiwib2JqZWN0VG9TdHJpbmciLCJvbGREYXNoIiwicmVJc05hdGl2ZSIsIkJ1ZmZlciIsIlN5bWJvbCIsIlVpbnQ4QXJyYXkiLCJnZXRQcm90b3R5cGUiLCJnZXRQcm90b3R5cGVPZiIsIml0ZXJhdG9yU3ltYm9sIiwib2JqZWN0Q3JlYXRlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJzcHJlYWRhYmxlU3ltYm9sIiwiaXNDb25jYXRTcHJlYWRhYmxlIiwiY3R4Q2xlYXJUaW1lb3V0IiwiY3R4Tm93IiwiY3R4U2V0VGltZW91dCIsIm5hdGl2ZUNlaWwiLCJjZWlsIiwibmF0aXZlRmxvb3IiLCJmbG9vciIsIm5hdGl2ZUdldFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJuYXRpdmVJc0J1ZmZlciIsImlzQnVmZmVyIiwibmF0aXZlSXNGaW5pdGUiLCJpc0Zpbml0ZSIsIm5hdGl2ZUpvaW4iLCJuYXRpdmVLZXlzIiwibmF0aXZlTWF4IiwibmF0aXZlTWluIiwibWluIiwibmF0aXZlUGFyc2VJbnQiLCJuYXRpdmVSYW5kb20iLCJuYXRpdmVSZXZlcnNlIiwiRGF0YVZpZXciLCJnZXROYXRpdmUiLCJNYXAiLCJTZXQiLCJXZWFrTWFwIiwibmF0aXZlQ3JlYXRlIiwiZGVmaW5lUHJvcGVydHkiLCJtZXRhTWFwIiwibm9uRW51bVNoYWRvd3MiLCJyZWFsTmFtZXMiLCJkYXRhVmlld0N0b3JTdHJpbmciLCJ0b1NvdXJjZSIsIm1hcEN0b3JTdHJpbmciLCJwcm9taXNlQ3RvclN0cmluZyIsInNldEN0b3JTdHJpbmciLCJ3ZWFrTWFwQ3RvclN0cmluZyIsInN5bWJvbFByb3RvIiwic3ltYm9sVmFsdWVPZiIsInZhbHVlT2YiLCJzeW1ib2xUb1N0cmluZyIsImxvZGFzaCIsImlzT2JqZWN0TGlrZSIsIkxhenlXcmFwcGVyIiwiTG9kYXNoV3JhcHBlciIsIndyYXBwZXJDbG9uZSIsImJhc2VMb2Rhc2giLCJjaGFpbkFsbCIsIl9fd3JhcHBlZF9fIiwiX19hY3Rpb25zX18iLCJfX2NoYWluX18iLCJfX2luZGV4X18iLCJfX3ZhbHVlc19fIiwidGVtcGxhdGVTZXR0aW5ncyIsImJhc2VDcmVhdGUiLCJfX2Rpcl9fIiwiX19maWx0ZXJlZF9fIiwiX19pdGVyYXRlZXNfXyIsIl9fdGFrZUNvdW50X18iLCJfX3ZpZXdzX18iLCJsYXp5Q2xvbmUiLCJjb3B5QXJyYXkiLCJsYXp5UmV2ZXJzZSIsImNsb25lIiwibGF6eVZhbHVlIiwiZGlyIiwiaXNBcnIiLCJpc1JpZ2h0IiwiYXJyTGVuZ3RoIiwidmlldyIsImdldFZpZXciLCJzdGFydCIsImVuZCIsIml0ZXJhdGVlcyIsIml0ZXJMZW5ndGgiLCJ0YWtlQ291bnQiLCJiYXNlV3JhcHBlclZhbHVlIiwib3V0ZXIiLCJpdGVySW5kZXgiLCJjb21wdXRlZCIsIkhhc2giLCJlbnRyaWVzIiwiZW50cnkiLCJoYXNoQ2xlYXIiLCJfX2RhdGFfXyIsImhhc2hEZWxldGUiLCJoYXNoR2V0IiwiaGFzaEhhcyIsImhhc2hTZXQiLCJMaXN0Q2FjaGUiLCJsaXN0Q2FjaGVDbGVhciIsImxpc3RDYWNoZURlbGV0ZSIsImFzc29jSW5kZXhPZiIsInBvcCIsImxpc3RDYWNoZUdldCIsImxpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIk1hcENhY2hlIiwibWFwQ2FjaGVDbGVhciIsIm1hcENhY2hlRGVsZXRlIiwiZ2V0TWFwRGF0YSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsIlNldENhY2hlIiwic2V0Q2FjaGVBZGQiLCJzZXRDYWNoZUhhcyIsIlN0YWNrIiwic3RhY2tDbGVhciIsInN0YWNrRGVsZXRlIiwic3RhY2tHZXQiLCJzdGFja0hhcyIsInN0YWNrU2V0IiwicGFpcnMiLCJhcnJheUxpa2VLZXlzIiwiaW5oZXJpdGVkIiwiaXNBcmd1bWVudHMiLCJza2lwSW5kZXhlcyIsImlzSW5kZXgiLCJhc3NpZ25JbkRlZmF1bHRzIiwib2JqVmFsdWUiLCJzcmNWYWx1ZSIsImVxIiwiYXNzaWduTWVyZ2VWYWx1ZSIsImFzc2lnblZhbHVlIiwiYmFzZUFnZ3JlZ2F0b3IiLCJiYXNlRWFjaCIsImJhc2VBc3NpZ24iLCJjb3B5T2JqZWN0IiwiYmFzZUF0IiwicGF0aHMiLCJpc05pbCIsImJhc2VDbGFtcCIsIm51bWJlciIsImxvd2VyIiwidXBwZXIiLCJiYXNlQ2xvbmUiLCJpc0RlZXAiLCJpc0Z1bGwiLCJjdXN0b21pemVyIiwiaXNPYmplY3QiLCJpbml0Q2xvbmVBcnJheSIsImdldFRhZyIsImlzRnVuYyIsImNsb25lQnVmZmVyIiwiaW5pdENsb25lT2JqZWN0IiwiY29weVN5bWJvbHMiLCJpbml0Q2xvbmVCeVRhZyIsInN0YWNrZWQiLCJnZXRBbGxLZXlzIiwic3ViVmFsdWUiLCJiYXNlQ29uZm9ybXMiLCJiYXNlQ29uZm9ybXNUbyIsInByb3RvIiwiYmFzZURlbGF5Iiwid2FpdCIsImJhc2VEaWZmZXJlbmNlIiwiaW5jbHVkZXMiLCJpc0NvbW1vbiIsInZhbHVlc0xlbmd0aCIsInZhbHVlc0luZGV4IiwiY3JlYXRlQmFzZUVhY2giLCJiYXNlRm9yT3duIiwiYmFzZUVhY2hSaWdodCIsImJhc2VGb3JPd25SaWdodCIsImJhc2VFdmVyeSIsImJhc2VFeHRyZW11bSIsImlzU3ltYm9sIiwiYmFzZUZpbGwiLCJ0b0ludGVnZXIiLCJ0b0xlbmd0aCIsImJhc2VGaWx0ZXIiLCJiYXNlRmxhdHRlbiIsImRlcHRoIiwiaXNTdHJpY3QiLCJpc0ZsYXR0ZW5hYmxlIiwiYmFzZUZvciIsImNyZWF0ZUJhc2VGb3IiLCJiYXNlRm9yUmlnaHQiLCJiYXNlRnVuY3Rpb25zIiwiaXNGdW5jdGlvbiIsImJhc2VHZXQiLCJwYXRoIiwiaXNLZXkiLCJjYXN0UGF0aCIsInRvS2V5IiwiYmFzZUdldEFsbEtleXMiLCJrZXlzRnVuYyIsInN5bWJvbHNGdW5jIiwiYmFzZUdldFRhZyIsImJhc2VHdCIsIm90aGVyIiwiYmFzZUhhcyIsImJhc2VIYXNJbiIsImJhc2VJblJhbmdlIiwiYmFzZUludGVyc2VjdGlvbiIsImFycmF5cyIsIm90aExlbmd0aCIsIm90aEluZGV4IiwiY2FjaGVzIiwibWF4TGVuZ3RoIiwiSW5maW5pdHkiLCJzZWVuIiwiYmFzZUludmVydGVyIiwiYmFzZUludm9rZSIsInBhcmVudCIsImxhc3QiLCJiYXNlSXNBcnJheUJ1ZmZlciIsImJhc2VJc0RhdGUiLCJiYXNlSXNFcXVhbCIsImJpdG1hc2siLCJiYXNlSXNFcXVhbERlZXAiLCJlcXVhbEZ1bmMiLCJvYmpJc0FyciIsIm90aElzQXJyIiwib2JqVGFnIiwib3RoVGFnIiwib2JqSXNPYmoiLCJvdGhJc09iaiIsImlzU2FtZVRhZyIsImVxdWFsQXJyYXlzIiwiZXF1YWxCeVRhZyIsIm9iaklzV3JhcHBlZCIsIm90aElzV3JhcHBlZCIsIm9ialVud3JhcHBlZCIsIm90aFVud3JhcHBlZCIsImVxdWFsT2JqZWN0cyIsImJhc2VJc01hcCIsImJhc2VJc01hdGNoIiwibWF0Y2hEYXRhIiwibm9DdXN0b21pemVyIiwiYmFzZUlzTmF0aXZlIiwiaXNNYXNrZWQiLCJwYXR0ZXJuIiwiYmFzZUlzUmVnRXhwIiwiYmFzZUlzU2V0IiwiYmFzZUlzVHlwZWRBcnJheSIsImlzTGVuZ3RoIiwiYmFzZUl0ZXJhdGVlIiwiaWRlbnRpdHkiLCJiYXNlTWF0Y2hlc1Byb3BlcnR5IiwiYmFzZU1hdGNoZXMiLCJwcm9wZXJ0eSIsImJhc2VLZXlzIiwiaXNQcm90b3R5cGUiLCJiYXNlS2V5c0luIiwibmF0aXZlS2V5c0luIiwiaXNQcm90byIsImJhc2VMdCIsImJhc2VNYXAiLCJpc0FycmF5TGlrZSIsImdldE1hdGNoRGF0YSIsIm1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIiwiaXNTdHJpY3RDb21wYXJhYmxlIiwiaGFzSW4iLCJiYXNlTWVyZ2UiLCJzcmNJbmRleCIsImJhc2VNZXJnZURlZXAiLCJuZXdWYWx1ZSIsIm1lcmdlRnVuYyIsImlzQXJyYXlMaWtlT2JqZWN0IiwiaXNQbGFpbk9iamVjdCIsInRvUGxhaW5PYmplY3QiLCJiYXNlTnRoIiwiYmFzZU9yZGVyQnkiLCJvcmRlcnMiLCJnZXRJdGVyYXRlZSIsImNyaXRlcmlhIiwiY29tcGFyZU11bHRpcGxlIiwiYmFzZVBpY2siLCJiYXNlUGlja0J5IiwiYmFzZVByb3BlcnR5RGVlcCIsImJhc2VQdWxsQWxsIiwiYmFzZVB1bGxBdCIsImluZGV4ZXMiLCJwcmV2aW91cyIsImJhc2VSYW5kb20iLCJiYXNlUmFuZ2UiLCJiYXNlUmVwZWF0IiwiYmFzZVJlc3QiLCJhcmd1bWVudHMiLCJvdGhlckFyZ3MiLCJiYXNlU2V0IiwibmVzdGVkIiwiYmFzZVNldERhdGEiLCJiYXNlU2xpY2UiLCJiYXNlU29tZSIsImJhc2VTb3J0ZWRJbmRleCIsInJldEhpZ2hlc3QiLCJsb3ciLCJoaWdoIiwiYmFzZVNvcnRlZEluZGV4QnkiLCJ2YWxJc05hTiIsInZhbElzTnVsbCIsInZhbElzU3ltYm9sIiwidmFsSXNVbmRlZmluZWQiLCJvdGhJc0RlZmluZWQiLCJvdGhJc051bGwiLCJvdGhJc1JlZmxleGl2ZSIsIm90aElzU3ltYm9sIiwic2V0TG93IiwiYmFzZVNvcnRlZFVuaXEiLCJiYXNlVG9OdW1iZXIiLCJiYXNlVG9TdHJpbmciLCJiYXNlVW5pcSIsImNyZWF0ZVNldCIsInNlZW5JbmRleCIsImJhc2VVbnNldCIsImJhc2VVcGRhdGUiLCJ1cGRhdGVyIiwiYmFzZVdoaWxlIiwiaXNEcm9wIiwiYWN0aW9ucyIsImJhc2VYb3IiLCJiYXNlWmlwT2JqZWN0IiwiYXNzaWduRnVuYyIsInZhbHNMZW5ndGgiLCJjYXN0QXJyYXlMaWtlT2JqZWN0IiwiY2FzdEZ1bmN0aW9uIiwic3RyaW5nVG9QYXRoIiwiY2FzdFNsaWNlIiwiYnVmZmVyIiwic2xpY2UiLCJjb3B5IiwiY2xvbmVBcnJheUJ1ZmZlciIsImFycmF5QnVmZmVyIiwiYnl0ZUxlbmd0aCIsImNsb25lRGF0YVZpZXciLCJkYXRhVmlldyIsImJ5dGVPZmZzZXQiLCJjbG9uZU1hcCIsImNsb25lRnVuYyIsImNsb25lUmVnRXhwIiwicmVnZXhwIiwiY2xvbmVTZXQiLCJjbG9uZVN5bWJvbCIsInN5bWJvbCIsImNsb25lVHlwZWRBcnJheSIsInR5cGVkQXJyYXkiLCJjb21wYXJlQXNjZW5kaW5nIiwidmFsSXNEZWZpbmVkIiwidmFsSXNSZWZsZXhpdmUiLCJvYmpDcml0ZXJpYSIsIm90aENyaXRlcmlhIiwib3JkZXJzTGVuZ3RoIiwib3JkZXIiLCJjb21wb3NlQXJncyIsInBhcnRpYWxzIiwiaG9sZGVycyIsImlzQ3VycmllZCIsImFyZ3NJbmRleCIsImFyZ3NMZW5ndGgiLCJob2xkZXJzTGVuZ3RoIiwibGVmdEluZGV4IiwibGVmdExlbmd0aCIsInJhbmdlTGVuZ3RoIiwiaXNVbmN1cnJpZWQiLCJjb21wb3NlQXJnc1JpZ2h0IiwiaG9sZGVyc0luZGV4IiwicmlnaHRJbmRleCIsInJpZ2h0TGVuZ3RoIiwiZ2V0U3ltYm9scyIsImNyZWF0ZUFnZ3JlZ2F0b3IiLCJpbml0aWFsaXplciIsImNyZWF0ZUFzc2lnbmVyIiwiYXNzaWduZXIiLCJzb3VyY2VzIiwiZ3VhcmQiLCJpc0l0ZXJhdGVlQ2FsbCIsIml0ZXJhYmxlIiwiY3JlYXRlQmluZCIsImlzQmluZCIsIkN0b3IiLCJjcmVhdGVDdG9yIiwid3JhcHBlciIsImNyZWF0ZUNhc2VGaXJzdCIsIm1ldGhvZE5hbWUiLCJjaGFyQXQiLCJ0cmFpbGluZyIsImNyZWF0ZUNvbXBvdW5kZXIiLCJ3b3JkcyIsImRlYnVyciIsInRoaXNCaW5kaW5nIiwiY3JlYXRlQ3VycnkiLCJhcml0eSIsImdldEhvbGRlciIsImNyZWF0ZVJlY3VycnkiLCJjcmVhdGVIeWJyaWQiLCJjcmVhdGVGaW5kIiwiZmluZEluZGV4RnVuYyIsImNyZWF0ZUZsb3ciLCJmdW5jcyIsInByZXJlcSIsInRocnUiLCJnZXRGdW5jTmFtZSIsImZ1bmNOYW1lIiwiZ2V0RGF0YSIsImlzTGF6aWFibGUiLCJwbGFudCIsInBhcnRpYWxzUmlnaHQiLCJob2xkZXJzUmlnaHQiLCJhcmdQb3MiLCJhcnkiLCJpc0FyeSIsImlzQmluZEtleSIsImlzRmxpcCIsImhvbGRlcnNDb3VudCIsIm5ld0hvbGRlcnMiLCJyZW9yZGVyIiwiY3JlYXRlSW52ZXJ0ZXIiLCJ0b0l0ZXJhdGVlIiwiY3JlYXRlTWF0aE9wZXJhdGlvbiIsIm9wZXJhdG9yIiwiZGVmYXVsdFZhbHVlIiwiY3JlYXRlT3ZlciIsImFycmF5RnVuYyIsImNyZWF0ZVBhZGRpbmciLCJjaGFycyIsImNoYXJzTGVuZ3RoIiwiY3JlYXRlUGFydGlhbCIsImNyZWF0ZVJhbmdlIiwidG9GaW5pdGUiLCJjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uIiwidG9OdW1iZXIiLCJ3cmFwRnVuYyIsImlzQ3VycnkiLCJuZXdIb2xkZXJzUmlnaHQiLCJuZXdQYXJ0aWFscyIsIm5ld1BhcnRpYWxzUmlnaHQiLCJuZXdEYXRhIiwic2V0V3JhcFRvU3RyaW5nIiwiY3JlYXRlUm91bmQiLCJwcmVjaXNpb24iLCJjcmVhdGVUb1BhaXJzIiwiY3JlYXRlV3JhcCIsIm1lcmdlRGF0YSIsImlzUGFydGlhbCIsImFyclZhbHVlIiwib3RoVmFsdWUiLCJjb21wYXJlZCIsImNvbnZlcnQiLCJvYmpQcm9wcyIsIm9iakxlbmd0aCIsIm90aFByb3BzIiwic2tpcEN0b3IiLCJvYmpDdG9yIiwib3RoQ3RvciIsImdldEFsbEtleXNJbiIsImtleXNJbiIsImdldFN5bWJvbHNJbiIsIm90aGVyRnVuYyIsImlzS2V5YWJsZSIsInN0dWJBcnJheSIsIkFycmF5QnVmZmVyIiwiY3RvclN0cmluZyIsInRyYW5zZm9ybXMiLCJnZXRXcmFwRGV0YWlscyIsImhhc1BhdGgiLCJoYXNGdW5jIiwiaW5wdXQiLCJpbnNlcnRXcmFwRGV0YWlscyIsImRldGFpbHMiLCJpc01hc2thYmxlIiwic3R1YkZhbHNlIiwic3JjQml0bWFzayIsIm5ld0JpdG1hc2siLCJpc0NvbWJvIiwibWVyZ2VEZWZhdWx0cyIsIm9sZEFycmF5IiwibGFzdENhbGxlZCIsInN0YW1wIiwicmVtYWluaW5nIiwicmVmZXJlbmNlIiwiY29uc3RhbnQiLCJ1cGRhdGVXcmFwRGV0YWlscyIsIm1lbW9pemUiLCJxdW90ZSIsImRpZmZlcmVuY2UiLCJkaWZmZXJlbmNlQnkiLCJkaWZmZXJlbmNlV2l0aCIsImRyb3BSaWdodCIsImRyb3BSaWdodFdoaWxlIiwiZHJvcFdoaWxlIiwiZmlsbCIsImZpbmRJbmRleCIsImZpbmRMYXN0SW5kZXgiLCJmbGF0dGVuIiwiZmxhdHRlbkRlZXAiLCJmbGF0dGVuRGVwdGgiLCJmcm9tUGFpcnMiLCJoZWFkIiwiaW5pdGlhbCIsImludGVyc2VjdGlvbiIsIm1hcHBlZCIsImludGVyc2VjdGlvbkJ5IiwiaW50ZXJzZWN0aW9uV2l0aCIsInNlcGFyYXRvciIsImxhc3RJbmRleE9mIiwibnRoIiwicHVsbCIsInB1bGxBbGwiLCJwdWxsQWxsQnkiLCJwdWxsQWxsV2l0aCIsInB1bGxBdCIsInNvcnRlZEluZGV4Iiwic29ydGVkSW5kZXhCeSIsInNvcnRlZEluZGV4T2YiLCJzb3J0ZWRMYXN0SW5kZXgiLCJzb3J0ZWRMYXN0SW5kZXhCeSIsInNvcnRlZExhc3RJbmRleE9mIiwic29ydGVkVW5pcSIsInNvcnRlZFVuaXFCeSIsInRhaWwiLCJ0YWtlIiwidGFrZVJpZ2h0IiwidGFrZVJpZ2h0V2hpbGUiLCJ0YWtlV2hpbGUiLCJ1bmlvbiIsInVuaW9uQnkiLCJ1bmlvbldpdGgiLCJ1bmlxIiwidW5pcUJ5IiwidW5pcVdpdGgiLCJ1bnppcCIsImdyb3VwIiwidW56aXBXaXRoIiwid2l0aG91dCIsInhvciIsInhvckJ5IiwieG9yV2l0aCIsInppcCIsInppcE9iamVjdCIsInppcE9iamVjdERlZXAiLCJ6aXBXaXRoIiwiY2hhaW4iLCJ0YXAiLCJpbnRlcmNlcHRvciIsIndyYXBwZXJBdCIsIndyYXBwZXJDaGFpbiIsIndyYXBwZXJDb21taXQiLCJ3cmFwcGVyTmV4dCIsInRvQXJyYXkiLCJ3cmFwcGVyVG9JdGVyYXRvciIsIndyYXBwZXJQbGFudCIsIndyYXBwZXJSZXZlcnNlIiwid3JhcHBlZCIsIndyYXBwZXJWYWx1ZSIsImNvdW50QnkiLCJldmVyeSIsImZpbmQiLCJmaW5kTGFzdCIsImZsYXRNYXAiLCJmbGF0TWFwRGVlcCIsImZsYXRNYXBEZXB0aCIsImZvckVhY2hSaWdodCIsImdyb3VwQnkiLCJpc1N0cmluZyIsImludm9rZU1hcCIsImlzUHJvcCIsImtleUJ5Iiwib3JkZXJCeSIsInBhcnRpdGlvbiIsInJlZHVjZSIsInJlZHVjZVJpZ2h0IiwibmVnYXRlIiwic2FtcGxlIiwic2FtcGxlU2l6ZSIsInJhbmQiLCJzaHVmZmxlIiwic29tZSIsInNvcnRCeSIsImFmdGVyIiwiYmVmb3JlIiwiYmluZEtleSIsImN1cnJ5IiwiY3VycnlSaWdodCIsImRlYm91bmNlIiwib3B0aW9ucyIsImxhc3RBcmdzIiwibGFzdFRoaXMiLCJtYXhXYWl0IiwidGltZXJJZCIsImxhc3RDYWxsVGltZSIsImxhc3RJbnZva2VUaW1lIiwibGVhZGluZyIsIm1heGluZyIsImludm9rZUZ1bmMiLCJ0aW1lIiwibGVhZGluZ0VkZ2UiLCJ0aW1lckV4cGlyZWQiLCJyZW1haW5pbmdXYWl0IiwidGltZVNpbmNlTGFzdENhbGwiLCJ0aW1lU2luY2VMYXN0SW52b2tlIiwic2hvdWxkSW52b2tlIiwidHJhaWxpbmdFZGdlIiwiY2FuY2VsIiwiZmx1c2giLCJkZWJvdW5jZWQiLCJpc0ludm9raW5nIiwiZGVmZXIiLCJkZWxheSIsImZsaXAiLCJyZXNvbHZlciIsIm1lbW9pemVkIiwiQ2FjaGUiLCJvbmNlIiwib3ZlckFyZ3MiLCJmdW5jc0xlbmd0aCIsInBhcnRpYWwiLCJwYXJ0aWFsUmlnaHQiLCJyZWFyZyIsInJlc3QiLCJzcHJlYWQiLCJ0aHJvdHRsZSIsInVuYXJ5Iiwid3JhcCIsImNhc3RBcnJheSIsImNsb25lV2l0aCIsImNsb25lRGVlcCIsImNsb25lRGVlcFdpdGgiLCJjb25mb3Jtc1RvIiwiZ3QiLCJndGUiLCJpc0Jvb2xlYW4iLCJpc0VsZW1lbnQiLCJpc0VtcHR5IiwiaXNFcXVhbCIsImlzRXF1YWxXaXRoIiwiaXNFcnJvciIsImlzSW50ZWdlciIsImlzTWF0Y2giLCJpc01hdGNoV2l0aCIsImlzTmFOIiwiaXNOdW1iZXIiLCJpc05hdGl2ZSIsImlzTnVsbCIsImlzU2FmZUludGVnZXIiLCJpc1VuZGVmaW5lZCIsImlzV2Vha01hcCIsImlzV2Vha1NldCIsImx0IiwibHRlIiwic2lnbiIsInJlbWFpbmRlciIsImlzQmluYXJ5IiwidG9TYWZlSW50ZWdlciIsImFzc2lnbkluIiwiYXNzaWduSW5XaXRoIiwiYXNzaWduV2l0aCIsImF0IiwicHJvcGVydGllcyIsImRlZmF1bHRzRGVlcCIsIm1lcmdlV2l0aCIsImZpbmRLZXkiLCJmaW5kTGFzdEtleSIsImZvckluUmlnaHQiLCJmb3JPd24iLCJmb3JPd25SaWdodCIsImZ1bmN0aW9ucyIsImZ1bmN0aW9uc0luIiwiaW52ZXJ0IiwiaW52ZXJ0QnkiLCJpbnZva2UiLCJtYXBLZXlzIiwibWFwVmFsdWVzIiwibWVyZ2UiLCJvbWl0Iiwib21pdEJ5IiwicGlja0J5Iiwic2V0V2l0aCIsInRvUGFpcnMiLCJ0b1BhaXJzSW4iLCJ1bnNldCIsInVwZGF0ZSIsInVwZGF0ZVdpdGgiLCJ2YWx1ZXNJbiIsImNsYW1wIiwiaW5SYW5nZSIsImZsb2F0aW5nIiwidGVtcCIsImNhbWVsQ2FzZSIsImNhcGl0YWxpemUiLCJ1cHBlckZpcnN0IiwiZW5kc1dpdGgiLCJ0YXJnZXQiLCJwb3NpdGlvbiIsImVzY2FwZSIsImVzY2FwZVJlZ0V4cCIsImtlYmFiQ2FzZSIsImxvd2VyQ2FzZSIsImxvd2VyRmlyc3QiLCJwYWQiLCJzdHJMZW5ndGgiLCJwYWRFbmQiLCJwYWRTdGFydCIsInJhZGl4IiwicmVwZWF0Iiwic25ha2VDYXNlIiwic3RhcnRDYXNlIiwic3RhcnRzV2l0aCIsInRlbXBsYXRlIiwiaW1wb3J0cyIsImltcG9ydHNLZXlzIiwiaW1wb3J0c1ZhbHVlcyIsImlzRXNjYXBpbmciLCJpc0V2YWx1YXRpbmciLCJpbnRlcnBvbGF0ZSIsInJlRGVsaW1pdGVycyIsImV2YWx1YXRlIiwic291cmNlVVJMIiwiZXNjYXBlVmFsdWUiLCJpbnRlcnBvbGF0ZVZhbHVlIiwiZXNUZW1wbGF0ZVZhbHVlIiwiZXZhbHVhdGVWYWx1ZSIsInZhcmlhYmxlIiwiYXR0ZW1wdCIsInRvTG93ZXIiLCJ0b1VwcGVyIiwidG9VcHBlckNhc2UiLCJ0cmltIiwidHJpbUVuZCIsInRyaW1TdGFydCIsInRydW5jYXRlIiwib21pc3Npb24iLCJzZWFyY2giLCJzdWJzdHJpbmciLCJuZXdFbmQiLCJ1bmVzY2FwZSIsInVwcGVyQ2FzZSIsImJpbmRBbGwiLCJtZXRob2ROYW1lcyIsImNvbmQiLCJjb25mb3JtcyIsImRlZmF1bHRUbyIsImZsb3ciLCJmbG93UmlnaHQiLCJtYXRjaGVzUHJvcGVydHkiLCJtZXRob2QiLCJtZXRob2RPZiIsIm1peGluIiwibm9Db25mbGljdCIsIm50aEFyZyIsIm92ZXIiLCJvdmVyRXZlcnkiLCJvdmVyU29tZSIsInByb3BlcnR5T2YiLCJyYW5nZVJpZ2h0Iiwic3R1Yk9iamVjdCIsInN0dWJTdHJpbmciLCJzdHViVHJ1ZSIsInRpbWVzIiwidG9QYXRoIiwidW5pcXVlSWQiLCJwcmVmaXgiLCJhdWdlbmQiLCJhZGRlbmQiLCJkaXZpZGUiLCJkaXZpZGVuZCIsImRpdmlzb3IiLCJtYXhCeSIsIm1lYW4iLCJtZWFuQnkiLCJtaW5CeSIsIm11bHRpcGx5IiwibXVsdGlwbGllciIsIm11bHRpcGxpY2FuZCIsInJvdW5kIiwic3VidHJhY3QiLCJtaW51ZW5kIiwic3VidHJhaGVuZCIsInN1bSIsInN1bUJ5IiwiZW50cmllc0luIiwiZXh0ZW5kIiwiZXh0ZW5kV2l0aCIsImVhY2giLCJlYWNoUmlnaHQiLCJmaXJzdCIsImZpbHRlcmVkIiwiaXNGaWx0ZXIiLCJ0YWtlTmFtZSIsImRyb3BOYW1lIiwiY2hlY2tJdGVyYXRlZSIsImlzVGFrZXIiLCJsb2Rhc2hGdW5jIiwicmV0VW53cmFwcGVkIiwiaXNMYXp5IiwidXNlTGF6eSIsImlzSHlicmlkIiwiaXNVbndyYXBwZWQiLCJvbmx5TGF6eSIsImNoYWluTmFtZSIsIm5hbWVzIiwiY29tbWl0IiwidG9KU09OIiwid2VicGFja1BvbHlmaWxsIiwiZGVwcmVjYXRlIiwiY2hpbGRyZW4iLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwibCJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1EQUEyQyxjQUFjOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUM5REE7QUFBQTtBQUFBOztBQUVBOztBQUVBLE1BQU1BLG1CQUFvQkMsUUFBRCxJQUFjO0FBQ3RDLFFBQU9BLFNBQVNDLEtBQVQsQ0FBZSxRQUFmLENBQVA7QUFDQSxDQUZEOztBQUlBLE1BQU1DLGVBQWdCQyxHQUFELElBQVM7QUFDN0IsT0FBTUMsa0JBQWtCRCxlQUFlRSxLQUF2QztBQUNBLE9BQU1DLFVBQVVGLGtCQUFrQkQsSUFBSUcsT0FBdEIsR0FBZ0NILEdBQWhEO0FBQ0EsT0FBTUksUUFBUUgsa0JBQWtCTCxpQkFBaUJJLElBQUlJLEtBQXJCLENBQWxCLEdBQWdELElBQTlEOztBQUVBLFFBQU8sRUFBQ0QsT0FBRCxFQUFVQyxLQUFWLEVBQVA7QUFDQSxDQU5EOztBQVFBLDRDQUFnQkMsSUFBRCxJQUFVO0FBQ3hCO0FBQ0FDLFNBQVFDLEVBQVIsQ0FBVyxtQkFBWCxFQUFnQ1AsT0FBTztBQUN0QztBQUNBOztBQUVBUSxFQUFBLHFEQUFBQSxDQUFZQyxJQUFaLENBQWlCLGVBQWpCLEVBQWtDO0FBQ2pDSixPQURpQztBQUVqQ0wsUUFBS0QsYUFBYUMsR0FBYixDQUY0QjtBQUdqQ1UsU0FBTTtBQUgyQixHQUFsQztBQUtBLEVBVEQ7O0FBV0E7QUFDQUosU0FBUUMsRUFBUixDQUFXLG9CQUFYLEVBQWlDSSxVQUFVO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQUgsRUFBQSxxREFBQUEsQ0FBWUMsSUFBWixDQUFpQixlQUFqQixFQUFrQztBQUNqQ0osT0FEaUM7QUFFakNMLFFBQUtELGFBQWFDLEdBQWIsQ0FGNEI7QUFHakNVLFNBQU07QUFIMkIsR0FBbEM7QUFLQSxFQVZEO0FBV0EsQ0F6QkQsQzs7Ozs7O0FDaEJBLHFDOzs7Ozs7Ozs7QUNBQTtBQUFBOzs7O0FBRUE7QUFDQTs7QUFFQSxNQUFNRSxpQkFBaUIsV0FBdkI7O0FBRUEsTUFBTUMsT0FBTixDQUFjO0FBQ1Y7QUFDQTtBQUNNQyxRQUFOLEdBQWE7QUFBQTs7QUFBQTtBQUNULGtCQUFNQyxPQUFPLE1BQU0sNkVBQUFDLEVBQW5CO0FBQ0Esa0JBQU1DLFVBQVUsTUFBTUYsS0FBS0csR0FBTCxDQUFTTixjQUFULENBQXRCOztBQUVBTyxvQkFBUUMsR0FBUixDQUFZSCxPQUFaO0FBQ0Esa0JBQUtJLEtBQUwsR0FBYUosT0FBYjtBQUxTO0FBTVo7O0FBRURLLFFBQUlDLEdBQUosRUFBU0MsS0FBVCxFQUFnQjtBQUNaLGFBQUtDLG1CQUFMOztBQUlBLFlBQUlDLGNBQWMsRUFBbEI7QUFDQUEsb0JBQVlILEdBQVosSUFBbUJDLEtBQW5CO0FBQ0FHLGVBQU9DLE9BQVAsQ0FBZUMsS0FBZixDQUFxQlAsR0FBckIsQ0FBeUJJLFdBQXpCOztBQUVBLGFBQUtMLEtBQUwsQ0FBV0UsR0FBWCxJQUFrQkMsS0FBbEI7O0FBRUE7QUFDQU0sbUJBQVdDLElBQVgsQ0FBZ0JoQixRQUFRQSxLQUFLaUIsTUFBTCxDQUFZcEIsY0FBWixFQUE0QixFQUFDVyxHQUFELEVBQU1DLEtBQU4sRUFBNUIsQ0FBeEI7QUFDSDs7QUFFRE4sUUFBSUssR0FBSixFQUFTVSxNQUFULEVBQWlCO0FBQ2IsYUFBS1IsbUJBQUw7O0FBRUEsWUFBSUQsUUFBUSxLQUFLSCxLQUFMLENBQVdFLEdBQVgsS0FBbUIsSUFBL0I7QUFDQSxZQUFJVyxlQUFlLEtBQW5COztBQUVBRCxpQkFBU0EsVUFBVSxFQUFuQjtBQUNBQSxlQUFPRSxXQUFQLEdBQXFCRixPQUFPRSxXQUFQLElBQXNCQyxNQUEzQztBQUNBSCxlQUFPSSxNQUFQLEdBQWdCSixPQUFPSSxNQUFQLElBQWlCLEtBQWpDO0FBQ0FKLGVBQU9LLE1BQVAsR0FBZ0JMLE9BQU9LLE1BQVAsSUFBaUIsS0FBakM7O0FBRUEsWUFBSWQsVUFBVSxJQUFWLElBQWtCUyxPQUFPSyxNQUE3QixFQUFxQztBQUNqQ2Qsb0JBQVNTLE9BQU9FLFdBQVAsS0FBdUJDLE1BQXhCLEdBQWtDLEVBQWxDLEdBQXVDLElBQUlILE9BQU9FLFdBQVgsRUFBL0M7QUFDQUQsMkJBQWUsSUFBZjtBQUNIOztBQUVELFlBQUlELE9BQU9JLE1BQVAsSUFBaUJKLE9BQU9FLFdBQVAsS0FBdUJDLE1BQXhDLElBQWtERixpQkFBaUIsS0FBdkUsRUFBOEU7QUFDMUU7QUFDQUssWUFBQSw4Q0FBQUEsQ0FBT2YsaUJBQWlCUyxPQUFPRSxXQUEvQixFQUE2QyxvQ0FBa0NaLEdBQUksSUFBbkY7QUFDSDs7QUFFRCxlQUFPQyxLQUFQO0FBQ0g7O0FBRURnQixXQUFPakIsR0FBUCxFQUFZO0FBQ1IsYUFBS0UsbUJBQUw7O0FBRUEsZUFBTyxLQUFLSixLQUFMLENBQVdFLEdBQVgsQ0FBUDs7QUFFQTtBQUNBTyxtQkFBV0MsSUFBWCxDQUFnQmhCLFFBQVFBLEtBQUswQixNQUFMLENBQVk3QixjQUFaLEVBQTRCVyxHQUE1QixDQUF4QjtBQUNIOztBQUVERSwwQkFBc0I7QUFDbEJjLFFBQUEsOENBQUFBLENBQU8sS0FBS0csWUFBWixFQUEwQixzQ0FBMUI7QUFDSDtBQTdEUzs7QUFnRWQsNENBQWU3QixPQUFmLEM7Ozs7Ozs7QUN2RUEsMERBQ0E7U0FDQSxtQkFDQSwwREFDQSxnQkFDQSxxQ0FDQSw2QkFFQSwrQkFDQTtBQUFDO0FBQ0QsUTs7QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUNiQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7Ozs4Q0FDQTs7Ozt1Q0FDQTs7b0NBRUE7Ozs7Ozs7Ozs7Ozs7O0FBV0E7O09BQU0sV0FDTjtZQUFTLFdBQ1Q7WUFBUyxrQkFDVDtZQUFTLFlBQ1Q7WUFBUzs7O0FBSVQ7T0FBTSxVQUFVLE1BQU0sVUFDdEI7T0FBTSx5QkFBeUIsT0FBTyxlQUFlLFVBQVUsV0FBVyxjQUFjLE9BQU8sZUFBZSxVQUFVLGVBQ3hIO09BQU0sZ0JBQWdCLElBQUk7O0FBTTFCOzs7O09BQU0seUJBQXlCLE9BQU8sT0FBTzs7QUFNN0M7Ozs7WUFBUyxlQUFlLFFBQVEsVUFBVSxNQUN0QztRQUFNLG9CQUFvQixPQUFPLFVBQVUsY0FBYyxLQUFLLHdCQUM5RDtRQUFNLFFBQVEsb0JBQW9CLEtBQUssUUFDdkM7UUFBTSxlQUFlLGNBQWMsSUFBSSxRQUFRLElBQUksU0FDbkQ7UUFBSSxNQUFNLG9CQUFvQixLQUFLLE1BRW5DOztRQUFNLFVBQVUsU0FBUyxXQUFXLGFBQ3BDO1FBQU0sZ0JBQWdCLFNBQVMsaUJBQWlCLGFBRWhEOztRQUFJLFlBQVksTUFDWjtTQUFJLENBQUMsaUJBQWlCLFFBQVEsV0FDMUI7WUFBTSxXQUNUO0FBQ0o7QUFKRCxXQUtJO1NBQUksUUFBTyx3REFBUyxVQUNoQjthQUNIOzs7QUFHRDtTQUFJLENBQUMsaUJBQWlCLEtBQUssYUFBYSxXQUNwQztXQUFLLFdBQVcsV0FDbkI7QUFDSjtBQUVEOztXQUFPLE1BQU0sQ0FBQyxPQUFPLE9BQU8sQ0FDL0I7OztBQVFEOzs7Ozs7WUFBUyxzQkFBc0IsZUFDM0I7eUJBQXFCLE1BQU0sVUFBVSxXQUNqQztZQUFRLFFBQVEsS0FBSyxLQUFLLFNBQVMsa0JBQWtCLGVBQWUsQ0FDdkU7QUFGTSxPQUdWOzs7QUFhRDs7Ozs7Ozs7Ozs7WUFBUyxpQkFBaUIsSUFBSSxlQUMxQjtRQUFNLFNBQVMsY0FBYyxJQUFJLEdBQ2pDO1FBQU0sV0FFTjs7a0JBQWMsUUFBUSx3QkFDbEI7U0FBSSxPQUFPLElBQUksZUFDWDtBQUNIO0FBRUQ7O1NBQU0sY0FBYyxRQUFRLG1CQUN4QjtVQUFNLGNBQWMsR0FBRyxZQUFZLENBQUMsb0JBQ3BDO2tCQUFZLGFBQ1o7a0JBQVksVUFFWjs7VUFBTSxXQUFXLFlBQVksWUFFN0I7O1VBQUksU0FBUyxrQkFBa0IsV0FDM0I7Y0FBTyxJQUFJO3VCQUNRLFNBQ2Y7aUJBQVMsU0FHYjtBQUpJOztBQUtQO0FBRUQ7O1VBQUkscUJBRUo7O1VBQUksU0FBUyxZQUFZLE1BQU07Ozs7OztBQU8zQjtXQUFJLE1BQU0sUUFBUSxTQUFTLFVBQ3ZCO3dCQUNIO0FBRkQsY0FHSTtZQUNJO2tCQUFTLElBQ1Q7eUJBQ0g7QUFIRCxVQUdFLE9BQU8sSUFDTDt5QkFDSDtBQUNKO0FBQ0o7QUFqQkQsYUFpQk87Ozs7QUFLSDtXQUNJO2lCQUFTLElBQ1Q7d0JBQ0g7QUFIRCxTQUdFLE9BQU8sSUFDTDt3QkFDSDtBQUNKOzs7QUFHRDthQUFPLElBQUk7c0JBRVA7Z0JBQVMsU0FBUztBQURsQjs7QUFLSjtrQkFDSDtBQUVELE1BMURnQjs7Y0EwRFAsS0FDWjtBQUVEOztXQUFPLFFBQVEsSUFDbEI7QUFFRDs7T0FBTTtBQWVGOzs7Ozs7Ozs7Ozs7OztZQUFRLFNBQVMseUJBQXlCO2lCQUN0Qzs7U0FBTSxVQUFXLFVBQVUsV0FDM0I7U0FBTSxnQkFBZ0IsVUFBVSxPQUFPLEtBQUssVUFBVSxNQUFNLENBQUMsVUFFN0Q7O1NBQU0sb0JBQW9CLHNCQUFzQixLQUFLLE1BQ3JEO1NBQUksQ0FBQyxtQkFDRDtVQUFNLE1BQU0sd0JBQVksK0JBQTZCLEtBQUssU0FBUyxzQkFBaUIsS0FBSyxTQUFTLFVBQ2xHO2FBQU8sUUFBUSxPQUNsQjtBQUVEOztTQUFJLFlBQ0o7U0FBSSxTQUNBO2FBQU8sVUFDVjtBQUZELFlBR0k7YUFDQTtXQUFLLFVBQVUsTUFBTSxDQUFDLFVBQ3pCO0FBRUQ7OzZCQUF3QixLQUFLLFVBQVUsZUFBZSxLQUFLLFlBQ3ZEO2lCQUFXLFFBQVEsVUFBQyxTQUFTLFFBQ3pCO1dBQU0sU0FDTjtXQUFJLG1CQUNKO1dBQUksZ0JBQUo7OztBQUlBO1dBQ0k7c0JBQWMsTUFBSyxTQUFTLFlBQVksb0JBQzNDO0FBRkQsU0FFRSxPQUFPLElBQ0w7WUFBSSxHQUFHLFNBQVMsaUJBQWlCO3NCQUM3QjtjQUFNLFdBRU47O3dCQUFjLFFBQVEsd0JBQ2xCO2VBQU0sZ0JBQWUsMkJBQ2hCLGNBQWUsTUFBTSxRQUFRLEtBQUssaUJBQWlCLEtBQUssZ0JBQWdCLENBQUMsS0FBSyxpQkFDaEYsS0FBSzttQkFBTyxJQUFJO0FBRW5CLFlBSmdCOztvQkFJUCxnQkFDWjtBQUVEOztnQ0FBWSxJQUFJLFVBQVUsS0FBSyxTQUFTLE1BQU07QUFDakQ7QUFaRCxlQWFJO2dCQUNIO0FBRUQ7O0FBQ0g7QUFFRDs7bUJBQVksYUFBYSxZQUFZLFVBQVUsWUFBWSxVQUFVLFNBQVMsZ0NBQWdDLEtBQzFHO1lBQU0sTUFBTSxZQUFZLElBQUksT0FDNUI7WUFBTSxZQUFZLENBQUMsT0FBTyxJQUFJLFNBRTlCOztZQUFJLFdBQ0E7aUJBQVEsVUFBVSxTQUFTLE9BQU8sY0FBYyxJQUNuRDtBQUZELGVBR0k7Z0JBQU8sd0JBQ1Y7QUFFRDs7WUFBSSxJQUFJLFNBQVMsU0FDYjthQUNIO0FBQ0o7QUFiRDs7a0NBZVMsY0FDTDtZQUFNLFdBQVcsWUFBWSxZQUFZOztxQ0FFaEMsR0FDTDthQUFNLGNBQWMsZUFBZSxNQUFLLFNBQVMsTUFBTSxVQUFVLEtBQUssY0FFdEU7O2FBQUksQ0FBQyxhQUNEO3FCQUFXLHdCQUFZLHFCQUN2Qjs7O29CQUNIO0FBREc7QUFBQTtBQUdKOzthQUFJLFdBQ0o7YUFDSTtnQkFBTSxTQUFTLElBQUksTUFBTSxVQUM1QjtBQUZELFdBRUUsT0FBTyxJQUNMO3FCQUNBO2lCQUNIO0FBRUQ7O2FBQUksWUFBWSxVQUFVLEtBQ3RCO2lCQUFPLGdCQUFnQixPQUFPLGlCQUM5QjtpQkFBTyxjQUFjLEtBQUssSUFBSSxPQUNqQztBQUhEO0FBaEJKOzthQUFLLElBQUksSUFBSSxHQUFHLElBQUksS0FBSyxjQUFjLFFBQVEsS0FBSzs0QkFBQTs7aUJBQUE7ZUFhNUM7QUFiNEM7O0FBQUE7d0dBb0JuRDs7QUFuRStCO0FBNENwQzs7WUFBSyxJQUFJLGdCQUFnQixNQUFNOzBCQUFBOztxR0F3QjlCO0FBQ0o7QUFDSixPQXRFVTtBQXVFZCxNQXhFVTtBQWpDUzs7QUF5SHBCOzs7Ozs7Ozs7Ozs7OztZQUFRLFNBQVMseUJBQXlCO2tCQUN0Qzs7U0FBTSxVQUFXLFVBQVUsV0FDM0I7U0FBTSxnQkFBZ0IsVUFBVSxPQUFPLEtBQUssVUFBVSxNQUFNLENBQUMsVUFFN0Q7O1NBQU0sb0JBQW9CLHNCQUFzQixLQUFLLE1BQ3JEO1NBQUksQ0FBQyxtQkFDRDtVQUFNLE1BQU0sd0JBQVksK0JBQTZCLEtBQUssU0FBUyxzQkFBaUIsS0FBSyxTQUFTLFVBQ2xHO2FBQU8sUUFBUSxPQUNsQjtBQUVEOztTQUFJLFlBQ0o7U0FBSSxTQUNBO2FBQU8sVUFDVjtBQUZELFlBR0k7YUFDQTtXQUFLLFVBQVUsTUFBTSxDQUFDLFVBQ3pCO0FBRUQ7OzZCQUF3QixLQUFLLFVBQVUsZUFBZSxLQUFLLFlBQ3ZEO2lCQUFXLFFBQVEsVUFBQyxTQUFTLFFBQ3pCO1dBQU0sU0FDTjtXQUFJLG1CQUNKO1dBQUksZ0JBQUo7OztBQUlBO1dBQ0k7c0JBQWMsT0FBSyxTQUFTLFlBQVksb0JBQzNDO0FBRkQsU0FFRSxPQUFPLElBQ0w7WUFBSSxHQUFHLFNBQVMsaUJBQWlCO3NCQUM3QjtjQUFNLFdBRU47O3dCQUFjLFFBQVEsd0JBQ2xCO2VBQU0saUJBQWUsMkJBQ2hCLGNBQWUsTUFBTSxRQUFRLEtBQUssaUJBQWlCLEtBQUssZ0JBQWdCLENBQUMsS0FBSyxpQkFDaEYsS0FBSzttQkFBTyxJQUFJO0FBRW5CLFlBSmdCOztvQkFJUCxnQkFDWjtBQUVEOztnQ0FBWSxJQUFJLFVBQVUsS0FBSyxTQUFTLE1BQU07QUFDakQ7QUFaRCxlQWFJO2dCQUNIO0FBRUQ7O0FBQ0g7QUFFRDs7bUJBQVksYUFBYSxZQUFZLFVBQVUsWUFBWSxVQUFVLFNBQVMsZ0NBQWdDLEtBQzFHO1lBQU0sTUFBTSxZQUFZLElBQUksT0FDNUI7WUFBTSxZQUFZLENBQUMsT0FBTyxJQUFJLFNBRTlCOztZQUFJLFdBQ0E7aUJBQVEsVUFBVSxTQUFTLE9BQU8sY0FBYyxJQUNuRDtBQUZELGVBR0k7Z0JBQU8sd0JBQ1Y7QUFFRDs7WUFBSSxJQUFJLFNBQVMsU0FDYjthQUNIO0FBQ0o7QUFiRDs7b0NBZVMsY0FDTDtZQUFNLFdBQVcsWUFBWSxZQUFZOztxQ0FFaEMsR0FDTDthQUFNLGNBQWMsZUFBZSxPQUFLLFNBQVMsTUFBTSxVQUFVLEtBQUssY0FFdEU7O2FBQUksQ0FBQyxhQUNEO3FCQUFXLHdCQUFZLHFCQUN2Qjs7O29CQUNIO0FBREc7QUFBQTtBQUdKOzthQUFJLFdBQ0o7YUFDSTtnQkFBTSxTQUFTLElBQUksTUFBTSxVQUM1QjtBQUZELFdBRUUsT0FBTyxJQUNMO3FCQUNBO2lCQUNIO0FBRUQ7O2FBQUksWUFBWSxVQUFVLEtBQ3RCO2lCQUFPLGdCQUFnQixPQUFPLGlCQUM5QjtpQkFBTyxjQUFjLEtBQUssSUFBSSxPQUNqQztBQUhEO0FBaEJKOzthQUFLLElBQUksSUFBSSxHQUFHLElBQUksS0FBSyxjQUFjLFFBQVEsS0FBSzs0QkFBQTs7aUJBQUE7ZUFhNUM7QUFiNEM7O0FBQUE7d0dBb0JuRDs7QUFuRStCO0FBNENwQzs7WUFBSyxJQUFJLGdCQUFnQixNQUFNOzJCQUFBOztxR0F3QjlCO0FBQ0o7QUFDSixPQXRFVTtBQXVFZCxNQXhFVTtBQTNJUzs7QUFxT3BCOzs7Ozs7Ozs7Ozs7Ozs7O1lBQVEsU0FBUyx5QkFBeUI7a0JBQ3RDOztTQUFNLFVBQVcsVUFBVSxXQUMzQjtTQUFNLGdCQUFnQixVQUFVLE9BQU8sS0FBSyxVQUFVLE1BQU0sQ0FBQyxVQUU3RDs7U0FBTSxvQkFBb0Isc0JBQXNCLEtBQUssTUFDckQ7U0FBSSxDQUFDLG1CQUNEO1VBQU0sTUFBTSx3QkFBWSwrQkFBNkIsS0FBSyxTQUFTLHNCQUFpQixLQUFLLFNBQVMsVUFDbEc7YUFBTyxRQUFRLE9BQ2xCO0FBRUQ7O1NBQUksWUFDSjtTQUFJLFNBQ0E7YUFBTyxVQUNWO0FBRkQsWUFHSTthQUNBO1dBQUssVUFBVSxNQUFNLENBQUMsVUFDekI7QUFFRDs7Z0JBQVcsUUFBUSxVQUFDLFNBQVMsUUFDekI7VUFBSSxtQkFDSjtVQUFJLGdCQUFKOzs7QUFJQTtVQUNJO3FCQUFjLE9BQUssU0FBUyxZQUFZLG9CQUMzQztBQUZELFFBRUUsT0FBTyxJQUNMO1dBQUksR0FBRyxTQUFTLGlCQUNaO1lBQU0seUJBQXlCLElBQUk7Z0JBQWdCLE9BQUssT0FBTyxjQUFjLEtBQUs7QUFDbEYsU0FEaUI7Z0JBQ1QsSUFBSSxVQUFVLEtBQUs7Z0JBQU07QUFBakMsV0FBNEMsTUFDL0M7QUFIRCxjQUlJO2VBQ0g7QUFFRDs7QUFDSDtBQUVEOztrQkFBWSxhQUFhLFlBQVksVUFBVSxZQUFZLFVBQVUsU0FBUyxnQ0FBZ0MsS0FDMUc7V0FBTSxNQUFNLFlBQVksSUFBSSxPQUU1Qjs7V0FBSSxLQUNBO2VBQU8sd0JBQ1Y7QUFGRCxjQUdJO0FBQ0g7QUFFRDs7V0FBSSxJQUFJLFNBQVMsU0FDYjtZQUNIO0FBQ0o7QUFaRDs7bUNBY1MsY0FDTDtXQUFNLFdBQVcsWUFBWSxZQUU3Qjs7WUFBSyxjQUFjLFFBQVEscUJBQ3ZCO1lBQUksVUFDQTtBQUNIO0FBRUQ7O1lBQ0k7a0JBQVMsT0FDWjtBQUZELFVBRUUsT0FBTyxJQUNMO29CQUNIO0FBQ0o7QUFWRDtBQUhKOztXQUFLLElBQUksZ0JBQWdCLE1BQU07Y0FjOUI7QUFDSjtBQUNKLE1BakRVO0FBdlBTOztBQWlUcEI7Ozs7Ozs7V0FBTyxTQUFTLHNCQUFzQixlQUFlO2tCQUNqRDs7cUJBQWdCLE1BQU0sUUFBUSxpQkFBaUIsZ0JBQWdCLENBRS9EOztTQUFNLG9CQUFvQixzQkFBc0IsS0FBSyxNQUNyRDtTQUFJLENBQUMsbUJBQ0Q7VUFBTSxNQUFNLHdCQUFZLCtCQUE2QixLQUFLLFNBQVMsc0JBQWlCLEtBQUssU0FBUyxVQUNsRzthQUFPLFFBQVEsT0FDbEI7QUFFRDs7Z0JBQVcsUUFBUSxVQUFDLFNBQVMsUUFDekI7VUFBSSxtQkFDSjtVQUFJLGdCQUFKOzs7QUFJQTtVQUNJO3FCQUFjLE9BQUssU0FBUyxZQUFZLG9CQUMzQztBQUZELFFBRUUsT0FBTyxJQUNMO1dBQUksR0FBRyxTQUFTLGlCQUNaO1lBQU0seUJBQXlCLElBQUk7Z0JBQWdCLE9BQUssTUFBTSxDQUFDO0FBQy9ELFNBRGlCO2dCQUNULElBQUksVUFBVSxLQUFLO2dCQUFNO0FBQWpDLFdBQTRDLE1BQy9DO0FBSEQsY0FJSTtlQUNIO0FBRUQ7O0FBQ0g7QUFFRDs7a0JBQVksYUFBYSxZQUFZLFVBQVUsWUFBWSxVQUFVLFNBQVMsK0JBQStCLEtBQ3pHO1dBQU0sTUFBTSxZQUFZLElBQUksT0FFNUI7O1dBQUksS0FDQTtlQUFPLHdCQUNWO0FBRkQsY0FHSTtBQUNIO0FBRUQ7O1dBQUksSUFBSSxTQUFTLFNBQ2I7WUFDSDtBQUNKO0FBRUQ7O29CQUFjLFFBQVEsd0JBQ2xCO1dBQU0sV0FBVyxZQUFZLFlBRTdCOztXQUFJLFVBQ0E7QUFDSDtBQUVEOztXQUNJO2lCQUNIO0FBRkQsU0FFRSxPQUFPLElBQ0w7bUJBQ0g7QUFDSjtBQUNKO0FBQ0osTUEvQ1U7QUExVFM7O0FBeVhwQjs7Ozs7Ozs7Ozs7Ozs7U0FBSyxTQUFTLHNCQUFzQjtrQkFDaEM7O1NBQU0sVUFBVyxVQUFVLFdBQVcsS0FBSyxRQUFPLFVBQVUsUUFDNUQ7U0FBTSxnQkFBZ0IsVUFBVSxPQUFPLEtBQUssVUFBVSxNQUFNLENBQUMsVUFFN0Q7O1NBQU0sb0JBQW9CLHNCQUFzQixLQUFLLE1BQ3JEO1NBQUksQ0FBQyxtQkFDRDtVQUFNLE1BQU0sd0JBQVksK0JBQTZCLEtBQUssU0FBUyxzQkFBaUIsS0FBSyxTQUFTLFVBQ2xHO2FBQU8sUUFBUSxPQUNsQjtBQUVEOztTQUFJLFNBQ0o7U0FBSSxZQUFKO1NBQVUsZ0JBRVY7O1NBQUksU0FDQTthQUFPLFVBQ1Y7QUFGRCxZQUdJO2FBQ0E7V0FBSyxVQUFVLE1BQU0sVUFDeEI7QUFFRDs7bUJBQWMsUUFBUSxVQUFVLGNBQzVCO2FBQU8sZ0JBQ1Y7QUFFRDs7Z0JBQVcsUUFBUSxVQUFDLFNBQVMsUUFDekI7VUFBSSxtQkFBSjs7O0FBSUE7VUFDSTtxQkFBYyxPQUFLLFNBQVMsWUFBWSxvQkFDM0M7QUFGRCxRQUVFLE9BQU8sSUFDTDtXQUFJLEdBQUcsU0FBUyxpQkFBaUI7cUJBQzdCO2FBQU0sV0FFTjs7dUJBQWMsUUFBUSx3QkFDbEI7Y0FBTSxVQUFVLE9BQUssSUFBSSxjQUFjLEtBQ3ZDO21CQUFTLGdCQUNaO0FBRUQ7OytCQUFZLElBQUksVUFBVSxLQUFLLFNBQVMsTUFBTTtBQUNqRDtBQVRELGNBVUk7ZUFDSDtBQUVEOztBQUNIO0FBRUQ7O2tCQUFZLGFBQWEsWUFBWSxVQUFVLFlBQVksVUFBVSxTQUFTLDZCQUE2QixLQUN2RztXQUFNLE1BQU0sWUFBWSxJQUFJLE9BQzVCO1dBQU0sWUFBWSxDQUFDLE9BQU8sSUFBSSxTQUU5Qjs7V0FBSSxXQUNBO2dCQUFRLFVBQVUsU0FBUyxPQUFPLGNBQ3JDO0FBRkQsY0FHSTtlQUFPLHdCQUNWO0FBRUQ7O1dBQUksSUFBSSxTQUFTLFNBQ2I7WUFDSDtBQUNKO0FBYkQ7O21DQWVTLGNBQ0w7V0FBTSxXQUFXLFlBQVksWUFDN0I7V0FBTSxVQUFVLEtBQUssaUJBQ3JCO1dBQU0sWUFBWSxRQUFRLGFBQWEsU0FDdkM7V0FBTSxRQUFRLFFBQVEsdUNBQWtDLFFBQVEsUUFFaEU7O1dBQUksWUFDSjtXQUFJLHNCQUVKOztXQUFJLHdCQUF3Qjs7QUFHeEI7MkJBQW1CLEtBQUssU0FBUyxNQUFNO2dCQUFRLFFBQVEsV0FBVyxRQUFRO0FBQzdFLFNBRGU7QUFHaEI7O1dBQUksUUFBUSxPQUNSO1lBQUksQ0FBQyxTQUFTLFdBQVcsU0FBUyxRQUFRLFFBQ3RDO29CQUFXLHdCQUFZLG1DQUFpQyxTQUFTLCtCQUF5QixRQUFRLFFBQ2xHOztrQkFDSDtBQURHO0FBR0o7O1lBQ0k7MEJBQWlCLFNBQVMsTUFBTSxRQUFRLE9BQU8sV0FBVyxPQUM3RDtBQUZELFVBRUUsT0FBTyxJQUNMO29CQUNBOztrQkFDSDtBQURHO0FBRVA7QUFaRCxrQkFZVyxXQUFXOzs7Ozs7Ozs7OztBQVdsQjthQUFNLE9BQU8sQ0FDYjthQUFJLFNBRUo7O2FBQUksUUFBUSxPQUNSO2VBQUssS0FBSyxRQUVWOztjQUFJLFFBQVEsUUFDUjtnQkFBSyxNQUFNLFFBQ1g7b0JBQVMsUUFDWjtBQUNKO0FBRUQ7O2FBQUk7QUFFQTttQkFBUyx1QkFBVSxNQUFNLFlBQVksVUFBVSxLQUMzQztlQUFNLFNBQVMsSUFBSSxPQUVuQjs7a0JBQU8sUUFBUSxVQUFDLE9BQU8sT0FDbkI7Z0JBQUksUUFBUSxRQUNSO0FBQ0g7QUFFRDs7Z0JBQU0sY0FBYyxRQUNwQjttQkFBTyxjQUFjLGVBQWUsT0FBTyxjQUFjLGdCQUN6RDttQkFBTyxjQUFjLGFBQWEsUUFDckM7QUFDSjtBQVpEOztBQWVBO21CQUFTLDJCQUFjLE1BQU0sWUFBWSxVQUFVLEtBQy9DO2VBQU0sT0FBTyxJQUFJLE9BRWpCOztnQkFBSyxRQUFRLFVBQUMsS0FBSyxPQUNmO2dCQUFJLFFBQVEsUUFDUjtBQUNIO0FBRUQ7O2dCQUFNLGNBQWMsUUFDcEI7bUJBQU8sY0FBYyxlQUFlLE9BQU8sY0FBYyxnQkFDekQ7bUJBQU8sY0FBYyxhQUFhLE1BQ3JDO0FBQ0o7QUFDSjtBQTlCRCxXQThCRSxPQUFPLElBQ0w7cUJBQ0g7QUFoQ0QsbUJBZ0NVOztBQUdOOztjQUNIO0FBREc7QUExRGM7QUFBQTs7d0dBNERyQjtBQTVETSxjQTZESDtZQUNJOzBCQUFpQixTQUFTLFdBQVcsT0FDeEM7QUFGRCxVQUVFLE9BQU8sSUFDTDtvQkFDQTs7a0JBQ0g7QUFERztBQUVQO0FBRUQ7O1dBQUksc0JBRUo7O3NCQUFlLFlBQVksVUFBVSxLQUNqQztZQUFNLFNBQVMsSUFBSSxPQUFPOztBQUcxQjtZQUFJLENBQUMsUUFDRDtBQUNIO0FBRUQ7O1lBQUksUUFBUSxVQUFVLENBQUMscUJBQ25COytCQUNBO2dCQUFPLFFBQVEsUUFFZjs7QUFDSDtBQUVEOztlQUFPLGNBQWM7Y0FDWixPQUNMO2dCQUFPLE9BR1g7QUFKSTs7WUFJQSxRQUFRLFNBQVMsUUFBUSxVQUFVLE9BQU8sY0FBYyxRQUN4RDtBQUNIO0FBRUQ7O2VBQ0g7QUF6QkQ7QUFsR0o7O1dBQUssSUFBSSxnQkFBZ0IsTUFBTTswQkFBQTs7ZUFBQTthQXFGbkI7QUFyRm1COztBQUFBO3NHQTRIOUI7O0FBQ0o7QUFDSixNQXJLVTtBQWpaUzs7QUFza0JwQjs7Ozs7Ozs7Ozs7Ozs7V0FBTyxTQUFTLHdCQUF3QjtrQkFDcEM7O1NBQU0sVUFBVyxVQUFVLFdBQVcsS0FBSyxRQUFPLFVBQVUsUUFDNUQ7U0FBTSxnQkFBZ0IsVUFBVSxPQUFPLEtBQUssVUFBVSxNQUFNLENBQUMsVUFDN0Q7U0FBSSxZQUVKOztTQUFJLFNBQ0E7YUFBTyxVQUNWO0FBRkQsWUFHSTthQUNBO1dBQUssVUFBVSxNQUFPLE9BQU8sVUFBVSxPQUFPLGFBQWMsT0FBTyxVQUN0RTtBQUVEOztTQUFNLG9CQUFvQixzQkFBc0IsS0FBSyxNQUNyRDtTQUFJLENBQUMsbUJBQ0Q7VUFBTSxNQUFNLHdCQUFZLCtCQUE2QixLQUFLLFNBQVMsc0JBQWlCLEtBQUssU0FBUyxVQUNsRzthQUFPLFFBQVEsT0FDbEI7QUFFRDs7Z0JBQVcsUUFBUSxVQUFDLFNBQVMsUUFDekI7VUFBTSxTQUNOO1VBQUksbUJBQ0o7VUFBSSxvQkFDSjtVQUFJLGdCQUFKOzs7QUFJQTtVQUNJO3FCQUFjLE9BQUssU0FBUyxZQUFZLG9CQUMzQztBQUZELFFBRUUsT0FBTyxJQUNMO1dBQUksR0FBRyxTQUFTLGlCQUFpQjtxQkFDN0I7YUFBTSxXQUVOOzt1QkFBYyxRQUFRLHdCQUNsQjtjQUFNLFVBQVUsT0FBSyxNQUFNLGNBQWMsS0FDekM7bUJBQVMsZ0JBQ1o7QUFFRDs7K0JBQVksSUFBSSxVQUFVLEtBQUssU0FBUyxNQUFNO0FBQ2pEO0FBVEQsY0FVSTtlQUNIO0FBRUQ7O0FBQ0g7QUFFRDs7a0JBQVksYUFBYSxZQUFZLFVBQVUsWUFBWSxVQUFVLFNBQVMsK0JBQStCLEtBQ3pHO1dBQU0sTUFBTSxZQUFZLElBQUksT0FDNUI7V0FBTSxZQUFZLENBQUMsT0FBTyxJQUFJLFNBRTlCOztXQUFJLFdBQ0E7Z0JBQVEsVUFBVSxTQUFTLE9BQU8sY0FDckM7QUFGRCxjQUdJO2VBQU8sd0JBQ1Y7QUFFRDs7V0FBSSxJQUFJLFNBQVMsU0FDYjtZQUNIO0FBQ0o7QUFiRDs7bUNBZVMsY0FDTDtXQUFNLFdBQVcsWUFBWSxZQUM3QjtXQUFNLFVBQVUsS0FBSyxpQkFDckI7V0FBTSxZQUFhLFFBQVEsc0JBQVQsaUJBQTRDLENBQUMsUUFBUSxTQUV2RTs7V0FBSSxRQUFRLE9BQ1I7WUFBSSxDQUFDLFNBQVMsV0FBVyxTQUFTLFFBQVEsUUFDdEM7b0JBQVcsd0JBQVksbUNBQWlDLFNBQVMsK0JBQXlCLFFBQVEsUUFDbEc7O2tCQUNIO0FBREc7QUFHSjs7WUFDSTthQUFNLFFBQVEsU0FBUyxNQUFNLFFBQzdCO3dCQUFlLE1BQU0sbUJBQ3hCO0FBSEQsVUFHRSxPQUFPLElBQ0w7b0JBQ0E7O2tCQUNIO0FBREc7QUFFUDtBQWJELGNBY0k7WUFDSTt3QkFBZSxTQUFTLHNCQUMzQjtBQUZELFVBRUUsT0FBTyxJQUNMO29CQUNBOztrQkFDSDtBQURHO0FBRVA7QUFFRDs7b0JBQWEsWUFBWSxVQUFVLEtBQy9CO2VBQU8sZ0JBQWdCLElBQUksT0FBTyxVQUNyQztBQUZEO0FBM0JKOztXQUFLLElBQUksZ0JBQWdCLE1BQU07MkJBQUE7O3VHQThCOUI7QUFDSjtBQUNKLE1BMUVVO0FBeGxCUzs7QUF1cUJwQjs7O1dBQU8sU0FBUyx3QkFDWjtVQUFLLFNBQ0w7WUFBTyxLQUNWO0FBMXFCbUI7QUFBQTs7QUF3ckJ4Qjs7Ozs7Ozs7Ozs7WUFBUyxPQUFPLFNBQVMsV0FBVyxRQUFnQztRQUFBLGdFQUFkLEVBQUMsU0FBYSxnQkFDaEU7O2VBQVcsUUFBUSxVQUFDLFNBQVMsUUFDekI7U0FBSSxNQUFKLGNBQ0k7YUFBTyx3QkFBWSxxQkFDbkI7QUFDSDtBQUVEOztTQUFNLGtCQUFrQixrQkFBYSxLQUFLLFFBQVEsUUFDbEQ7U0FBSSx1QkFFSjs7cUJBQWdCLGtCQUFrQixVQUFVLEtBQ3hDO1VBQUksc0JBQ0E7QUFDSDtBQUVEOztjQUFRLFlBQVksUUFBUSxhQUM1QjtXQUFLLElBQUksSUFBSSxJQUFJLGFBQWEsR0FBRyxLQUFLLElBQUksWUFBWSxLQUNsRDtXQUFJLENBQUMsUUFBUSxVQUFVLElBR3ZCOztlQUFRLFVBQVUsR0FBRyxLQUFLLE1BQU0sS0FDbkM7QUFDSjtBQUVEOztxQkFBZ0IsVUFBVSxVQUFVLEtBQ2hDO1VBQUksc0JBQ0E7QUFDSDtBQUVEOztVQUNBO2FBQU8sd0JBQVksSUFBSSxPQUV2Qjs7NkJBQ0g7QUFFRDs7cUJBQWdCLFlBQVksVUFBVSxLQUNsQztVQUFJLHNCQUNBO0FBQ0g7QUFFRDs7VUFBTSxXQUFXLEtBQ2pCO1VBQU0sYUFBYSxTQUFTLFNBQVMsV0FBVyxHQUVoRDs7VUFBSSxPQUFPLFNBQVMsZUFBZSxjQUFjLGFBQWEsUUFBUSxTQUNsRTtXQUFNLG1CQUFtQixTQUFTLFdBQVcsUUFFN0M7O3dCQUFpQixZQUFZLFVBQVUsS0FDbkM7WUFBTSx5QkFBeUIsSUFBSSxNQUNuQzsrQkFBdUIsYUFDdkI7K0JBQXVCLGFBQWEsUUFDcEM7d0JBQWdCLGdCQUFnQixLQUFLLEVBQUMsUUFBUSxJQUFJLE9BQU8sVUFFekQ7O2lCQUNBO2lCQUFTLEtBQUssUUFBUSxTQUFTLEtBQUssU0FDdkM7QUFFRDs7d0JBQWlCLFVBQVUsVUFBVSxLQUNqQztZQUFNLE1BQU0sSUFBSSxPQUFPLGdCQUFnQixJQUFJLE9BQU8sc0JBQXNCLElBQUksT0FBTyxtQkFBbUIsSUFBSSxPQUFPLGtCQUFrQixJQUFJLE9BQU8sTUFDOUk7ZUFBTyx3QkFDVjtBQUVEOztBQUNIOzs7QUFHRDtvQkFBYyxJQUFJLFFBQVEsSUFFMUI7O3FCQUFlLE9BQU87O3NCQUdkO29CQUNBO2VBQ0E7a0JBSVI7QUFQUTtBQURKLE9BREk7OzZCQVVYO0FBRUQ7O3FCQUFnQixZQUFZLFVBQVUsS0FDbEM7VUFBSSxzQkFDQTtBQUNIO0FBRUQ7O1VBRUE7O2FBQU8sd0JBQVksbUNBQWlDLFNBQ3BEOzZCQUNIO0FBQ0o7QUFDSixLQXpGVTtBQURYOztBQW1HQTs7Ozs7OztZQUFTLGlCQUFpQixTQUFTLHFCQUFxQixRQUNwRDtlQUFXLFFBQVEsVUFBQyxTQUFTLFFBQ3pCO1NBQUksTUFBSixjQUNJO2FBQU8sd0JBQVkscUJBQ25CO0FBQ0g7QUFFRDs7U0FBTSxnQkFBZ0Isa0JBQWEsZUFFbkM7O21CQUFjLFlBQVksY0FBYyxVQUFVLGNBQWMsWUFBWSxTQUFTLDhCQUE4QixLQUMvRztVQUFNLE1BQU8sSUFBSSxTQUFTLFlBQ3BCLHdCQUFZLG1DQUFpQyxTQUR2QyxpQkFFTixJQUFJLE9BRVY7O1VBQUksS0FDQTtjQUFPLHdCQUNWO0FBRkQsYUFHSTtBQUNIO0FBRUQ7O1VBQUksSUFBSSxTQUFTLFdBQ2I7V0FDSDtBQUNKO0FBQ0o7QUFDSixLQXhCVTtBQTBCWDs7WUFBUyxXQUFXLFNBQVMsZUFBZSxLQUFLLE9BQzdDO2tCQUFjLE9BQU87VUFDWixFQUFDLE9BQU8sS0FBSyxjQUFjLE9BQU8sVUFDdkM7WUFBTyxFQUFDLE9BQU8sT0FBTyxjQUFjLE9BQU8sVUFFbEQ7QUFITyxLQURHO0FBRFg7O3FCQU9lOzs7Ozs7a0NDeC9CZjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7O1VBQU8sZUFBZSxTQUFTO1dBSS9CO0FBSEk7O1lBR0ssbUJBQW1CLEtBQU87UUFBSSxNQUFNLFFBQVEsTUFBUTtVQUFLLElBQUksSUFBSSxHQUFHLE9BQU8sTUFBTSxJQUFJLFNBQVMsSUFBSSxJQUFJLFFBQVEsS0FBSztXQUFLLEtBQUssSUFBSTtBQUFJLGFBQWM7QUFBekgsV0FBaUk7WUFBTyxNQUFNLEtBQVk7QUFBRTs7O09BRXpMOzs7Ozs7Ozs7Ozs0QkFDSyxhQUFhLFlBQ2hCO2VBQVMsb0JBQW9CLEtBQ3pCO1dBQUksTUFBTSxRQUFRLE1BQ2Q7ZUFBTyxZQUFZLE1BQU0sV0FBVyxtQkFDdkM7QUFDSjtBQUVEOzthQUFPLEtBQUssS0FBSyxxQkFDcEI7Ozs7O0tBR0w7O2VBQVksTUFBTSxTQUFTLHVCQUF1QixVQUM5QztRQUFJLFVBQVUsU0FBUyxLQUFLLFFBQU8sZ0VBQWEsVUFDNUM7WUFBTyxRQUFRLElBQUksTUFBTSxTQUM1QjtBQUVEOztlQUFXLFlBQVksVUFBQyxTQUFTLFFBQzdCO1NBQU0saUJBQWlCLE1BQU0sUUFDN0I7U0FBSSxxQkFDSjtTQUFJLG9CQUVKOztTQUFJLGdCQUNBO3NCQUNIO0FBRkQsWUFHSTtxQkFBZSxPQUFPLEtBQ3RCO21DQUE2QixJQUFJO2NBQU8sU0FBUztBQUNwRCxPQURtQjtBQUdwQjs7YUFBUSxJQUFJLGVBQWUsS0FBSyxlQUFPO0FBRW5DO1VBQUksY0FFSjs7VUFBSSxnQkFDQTtnQkFDSDtBQUZELGFBR0k7b0JBQWEsT0FBTyxVQUFDLFFBQVEsT0FBTyxPQUNoQztlQUFPLGFBQWEsVUFDcEI7ZUFDSDtBQUhRLFVBSVo7QUFFRDs7Y0FDSDtBQWRELFFBY0csTUFDTjtBQUNKLEtBNUJVO0FBOEJYOztXQUFRLFVBQ1I7VUFBTyxVQUFVLFFBQVE7Ozs7O2tDQ3hEekI7Ozs7Ozs7Ozs7OztxQkFNd0I7WUFBQSxPQUNwQjtrREFBOEMsUUFBUSxTQUFTLFVBQVMsR0FDcEU7U0FBTSxJQUFJLEtBQUssV0FBVyxLQUMxQjtTQUFNLElBQUssTUFBTSxNQUFPLElBQUssSUFBRSxNQUUvQjs7WUFBTyxFQUFFLFNBQ1o7QUFDSixLQU5VOzs7Ozs7O2tDQ1BYOzs7Ozs7O1dBRWdCO1dBT0E7WUFQQSxZQUFZLE1BQU0sU0FDOUI7UUFBTSxTQUFTLElBQUksTUFDbkI7V0FBTyxPQUVQOztXQUNIO0FBRU07O1lBQVMsWUFBWSxLQUN4QjtRQUFJLGVBQWUsT0FDZjtZQUNIO0FBRUQ7O1dBQU8sWUFBWSxJQUFJLE1BQU0sSUFDaEM7Ozs7OztrQ0NmRDs7Ozs7OztXQUdBOztPQUFNLGNBQWUsT0FBTyxXQUVyQjs7T0FBTSxzQ0FBZSxjQUN0QixPQUFPLGFBQWEsT0FBTyxnQkFBZ0IsT0FBTyxtQkFBbUIsT0FBTyxjQUczRTs7T0FBTSwwQ0FBaUIsY0FDeEIsT0FBTyxlQUFlLE9BQU8sa0JBQWtCLE9BQU8scUJBQXFCLE9BQU8sZ0JBR2pGOztPQUFNLHNEQUF1QixjQUM5QixPQUFPLGVBQWUsYUFBYSxhQUdsQzs7T0FBTSx3REFBd0IsY0FDL0IsT0FBTyxlQUFlLGNBQWMsY0FHbkM7O09BQU0sOEJBQVcsY0FDbEIsT0FBTyxVQUFVLFFBQVEsU0FHeEI7O09BQU0sNENBQWtCLGNBQ3pCLE9BQU8sVUFBVSxxQkFBcUIsZUFHckM7O09BQU0sZ0NBQVksY0FDbkIsT0FBTyxVQUFVLFFBQVEsU0FHeEI7O09BQU0sOENBQW1CLGNBQzFCLE9BQU8sVUFBVSxxQkFBcUIsZUFDdEM7Ozs7Ozs7Ozs7Ozs7O0FDbkNOO0FBQUE7QUFBQTs7OztBQUVBOztBQUVPLE1BQU1HO0FBQUEsaUNBQVcsYUFBWTtBQUNoQyxlQUFPLE1BQU0sNkNBQUEyQixDQUFNQyxJQUFOLENBQVcsTUFBWCxFQUFtQjtBQUM1QkMscUJBQVMsQ0FEbUI7QUFFNUJDLHVCQUFXO0FBQ1AscUJBQUssVUFBQ0MsUUFBRCxFQUFjO0FBQ2Y7QUFDQUEsNkJBQVNDLGlCQUFULENBQTJCLEtBQTNCLEVBQWtDLEVBQUNDLGVBQWUsSUFBaEIsRUFBbEM7O0FBRUE7QUFDQTtBQUNBRiw2QkFBU0MsaUJBQVQsQ0FBMkIsV0FBM0IsRUFBd0MsRUFBQ0UsU0FBUyxLQUFWLEVBQXhDO0FBQ0g7QUFSTTtBQUZpQixTQUFuQixDQUFiO0FBYUgsS0FkWTs7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFOO0FBQUE7QUFBQTs7QUFnQkEsTUFBTUM7QUFBQSxrQ0FBVyxXQUFPQyxNQUFQLEVBQWtCO0FBQ3RDLGVBQU8sTUFBTSw2Q0FBQVQsQ0FBTUMsSUFBTixDQUFZLE9BQUtRLE1BQU8sR0FBeEIsRUFBMkI7QUFDcENQLHFCQUFTLENBRDJCO0FBRXBDQyx1QkFBVztBQUNQLHFCQUFLLFVBQUNDLFFBQUQsRUFBYztBQUNmLDBCQUFNTSxnQkFBZ0JOLFNBQVNDLGlCQUFULENBQTJCLFVBQTNCLEVBQXVDLEVBQUNFLFNBQVMsS0FBVixFQUF2QyxDQUF0QjtBQUNBRyxrQ0FBY0MsV0FBZCxDQUEwQixjQUExQixFQUEwQyxpQkFBMUM7QUFDQUQsa0NBQWNDLFdBQWQsQ0FBMEIsY0FBMUIsRUFBMEMsY0FBMUM7QUFDQUQsa0NBQWNDLFdBQWQsQ0FBMEIsTUFBMUIsRUFBa0MsQ0FBQyxZQUFELEVBQWUsV0FBZixDQUFsQztBQUNBRCxrQ0FBY0MsV0FBZCxDQUEwQixVQUExQixFQUFzQyxVQUF0QyxFQUFrRCxFQUFDQyxZQUFZLElBQWIsRUFBbEQ7O0FBRUEsMEJBQU1DLGdCQUFnQlQsU0FBU0MsaUJBQVQsQ0FBMkIsVUFBM0IsRUFBdUMsRUFBQ0UsU0FBUyxLQUFWLEVBQXZDLENBQXRCO0FBQ0FNLGtDQUFjRixXQUFkLENBQTBCLFlBQTFCLEVBQXdDLENBQUMsS0FBRCxFQUFRLE1BQVIsQ0FBeEMsRUFSZSxDQVEyQztBQUMxREUsa0NBQWNGLFdBQWQsQ0FBMEIsZUFBMUIsRUFBMkMsS0FBM0MsRUFUZSxDQVNvQztBQUNuREUsa0NBQWNGLFdBQWQsQ0FBMEIsbUJBQTFCLEVBQStDLENBQUMsTUFBRCxFQUFTLEtBQVQsQ0FBL0MsRUFWZSxDQVVrRDtBQUNqRUUsa0NBQWNGLFdBQWQsQ0FBMEIsZUFBMUIsRUFBMkMsTUFBM0MsRUFYZSxDQVdxQztBQUNwREUsa0NBQWNGLFdBQWQsQ0FBMEIsS0FBMUIsRUFBaUMsTUFBakMsRUFBeUMsRUFBQ0MsWUFBWSxJQUFiLEVBQXpDO0FBQ0FDLGtDQUFjRixXQUFkLENBQTBCLFVBQTFCLEVBQXNDLFVBQXRDLEVBQWtELEVBQUNDLFlBQVksSUFBYixFQUFsRDs7QUFFQSwwQkFBTUUsYUFBYVYsU0FBU0MsaUJBQVQsQ0FBMkIsT0FBM0IsRUFBb0MsRUFBQ0UsU0FBUyxJQUFWLEVBQXBDLENBQW5CO0FBQ0FPLCtCQUFXSCxXQUFYLENBQXVCLGNBQXZCLEVBQXVDLGlCQUF2QztBQUNIO0FBbEJNO0FBRnlCLFNBQTNCLENBQWI7QUF1QkgsS0F4Qlk7O0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBTjtBQUFBO0FBQUE7O0FBMEJBLE1BQU1JO0FBQUEsa0NBQVcsV0FBT04sTUFBUCxFQUFrQjtBQUN0QyxlQUFPLE1BQU0sNkNBQUFULENBQU1nQixjQUFOLENBQXNCLE9BQUtQLE1BQU8sR0FBbEMsQ0FBYjtBQUNILEtBRlk7O0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBTixDOzs7Ozs7OztBQzlDUCxtQzs7Ozs7Ozs7OztBQ0FBO0FBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU1RLGlCQUFpQixJQUFJLHlEQUFKLEVBQXZCOztBQUVBO0FBQ0EscUZBQUFDLENBQWFDLE9BQU9DLFVBQXBCOztBQUVBLElBQUlDLGdCQUFnQixLQUFwQjs7QUFFQTs7Ozs7Ozs7Ozs7OztBQWFBLFNBQVNDLHNCQUFULENBQWdDQyxJQUFoQyxFQUFzQztBQUNsQztBQUNBO0FBQ0EsUUFBSSxDQUFDdkMsT0FBT3dDLGFBQVosRUFDSTs7QUFFSixRQUFJQyxVQUFVRixLQUFLRyxHQUFMLEdBQ1JDLGVBQWVKLEtBQUtLLElBQXBCLEVBQTBCTCxLQUFLRyxHQUEvQixDQURRLEdBRVJHLFFBQVFDLE9BQVIsQ0FBZ0JQLEtBQUtLLElBQXJCLENBRk47O0FBSUEsUUFBSUcsOEJBQThCLFVBQVVDLEdBQVYsRUFBZTtBQUM3Q0EsY0FBTUEsT0FBT1QsS0FBS0ssSUFBbEI7O0FBRUE1QyxlQUFPd0MsYUFBUCxDQUFxQjdCLE1BQXJCLENBQTRCLENBQUM0QixLQUFLVSxFQUFMLElBQVdDLEtBQUtDLE1BQUwsRUFBWixJQUE2QixFQUF6RCxFQUE2RDtBQUN6RHBFLGtCQUFNLE9BRG1EO0FBRXpEcUUscUJBQVNKLEdBRmdEO0FBR3pESyxtQkFBT2QsS0FBS2MsS0FINkM7QUFJekQ3RSxxQkFBUytELEtBQUsvRCxPQUoyQztBQUt6RDhFLHlCQUFhO0FBTDRDLFNBQTdELEVBTUcsVUFBVUMsY0FBVixFQUEwQjtBQUN6QixnQkFBSWhCLEtBQUtpQixPQUFULEVBQWtCO0FBQ2RDLHFDQUFxQkYsY0FBckIsSUFBdUNoQixLQUFLaUIsT0FBNUM7QUFDSDs7QUFFRCxnQkFBSWpCLEtBQUttQixLQUFULEVBQWdCO0FBQ1pDLDZCQUFhQyxJQUFiLENBQWtCckIsS0FBS21CLEtBQXZCO0FBQ0g7O0FBRUQsZ0JBQUluQixLQUFLc0IsT0FBVCxFQUFrQjtBQUNkQywyQkFBVyxZQUFZO0FBQ25COUQsMkJBQU93QyxhQUFQLENBQXFCdUIsS0FBckIsQ0FBMkJSLGNBQTNCLEVBQTJDUyxFQUFFQyxJQUE3QztBQUNILGlCQUZELEVBRUcxQixLQUFLc0IsT0FBTCxHQUFlLElBRmxCO0FBR0g7QUFDSixTQXBCRDtBQXFCSCxLQXhCRDs7QUEwQkFwQixZQUFRckMsSUFBUixDQUFhMkMsMkJBQWIsRUFBMEMsWUFBWTtBQUNsREE7QUFDSCxLQUZEO0FBR0g7O0FBRUQ7Ozs7QUFJQSxTQUFTbUIsZUFBVCxHQUEyQjtBQUN2QixRQUFJQyxlQUFlLEVBQW5CO0FBQ0FDLG9CQUFnQkMsWUFBaEIsR0FBK0JDLE9BQS9CLENBQXVDLFVBQVUxRSxHQUFWLEVBQWU7QUFDbER1RSxxQkFBYXZFLEdBQWIsSUFBb0J3RSxnQkFBZ0J4RSxHQUFoQixDQUFwQjtBQUNILEtBRkQ7O0FBSUEsV0FBT3VFLFlBQVA7QUFDSDs7QUFFRCxTQUFTSSx5QkFBVCxDQUFtQ0MsYUFBbkMsRUFBa0Q7QUFDOUMsUUFBSUMsYUFBYXpFLE9BQU8wRSxHQUFQLENBQVdDLE1BQVgsQ0FBa0JDLE1BQWxCLEVBQWpCO0FBQ0FILGVBQVdILE9BQVgsQ0FBbUIsVUFBVU8sR0FBVixFQUFlQyxVQUFmLEVBQTJCO0FBQzFDLFlBQUlBLFVBQUosRUFBZ0I7QUFDWkQsZ0JBQUlFLEtBQUo7QUFDSCxTQUZELE1BRU87QUFDSEYsZ0JBQUlHLEtBQUo7QUFDQUgsZ0JBQUlJLElBQUo7QUFDSDtBQUNKLEtBUEQ7O0FBU0EsUUFBSSxDQUFDUixXQUFXUyxNQUFaLElBQXNCVixhQUExQixFQUF5QztBQUNyQ1c7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc1BBdEMsUUFBUXVDLEdBQVIsQ0FBWSxDQUNSbkQsZUFBZTlDLElBQWYsRUFEUSxFQUVSLG9EQUFBa0csQ0FBZ0JDLFFBQWhCLEVBRlEsQ0FBWixFQUdHbEYsSUFISCxDQUdRLFNBQVNtRixTQUFULENBQW1CbEgsR0FBbkIsRUFBd0I7QUFDNUIrRixvQkFBZ0JvQixJQUFoQjtBQUNBQyxlQUFXQyxNQUFYLENBQWtCLGFBQWxCOztBQUVBLFFBQUlDLGNBQWMsRUFBbEI7QUFBQSxRQUFzQjtBQUNsQkMscUJBQWlCLEVBRHJCLENBSjRCLENBS0g7O0FBRXpCLFFBQUlDLDJCQUEyQixVQUFTcEUsTUFBVCxFQUFpQjtBQUM1QyxZQUFJa0UsWUFBWWxFLE1BQVosTUFBd0JxRSxTQUE1QixFQUF1QztBQUNuQ0gsd0JBQVlsRSxNQUFaLEVBQW9Cc0UsUUFBcEIsQ0FBNkIsQ0FBN0IsSUFBa0MsQ0FBbEM7QUFDQUosd0JBQVlsRSxNQUFaLEVBQW9Cc0UsUUFBcEIsQ0FBNkIsQ0FBN0IsSUFBa0MsQ0FBbEM7O0FBRUFKLHdCQUFZbEUsTUFBWixFQUFvQnVFLEtBQXBCLENBQTBCLENBQTFCLElBQStCLENBQS9CO0FBQ0FMLHdCQUFZbEUsTUFBWixFQUFvQnVFLEtBQXBCLENBQTBCLENBQTFCLElBQStCLENBQS9COztBQUVBTCx3QkFBWWxFLE1BQVosRUFBb0J3RSxJQUFwQixDQUF5QixDQUF6QixJQUE4QixDQUE5QjtBQUNBTix3QkFBWWxFLE1BQVosRUFBb0J3RSxJQUFwQixDQUF5QixDQUF6QixJQUE4QixDQUE5QjtBQUNILFNBVEQsTUFTTztBQUNITix3QkFBWWxFLE1BQVosSUFBc0I7QUFDbEIsNEJBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixDQURLLEVBQ0c7QUFDckIseUJBQVUsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUZRO0FBR2xCLHdCQUFTLENBQUMsQ0FBRCxFQUFJLENBQUo7QUFIUyxhQUF0QjtBQUtIO0FBQ0osS0FqQkQ7O0FBb0JBO0FBQ0FrRCxXQUFPdUIsZ0JBQVAsQ0FBd0IsUUFBeEIsRUFBa0MsVUFBVUMsQ0FBVixFQUFhO0FBQzNDbkcsZUFBT29HLE9BQVAsQ0FBZUMsV0FBZixDQUEyQixFQUFDLFVBQVcscUJBQVosRUFBbUMsVUFBVyxRQUE5QyxFQUEzQjs7QUFFQTtBQUNBLFlBQUlDLGdCQUFnQkMsYUFBcEIsRUFBbUM7QUFDL0JDO0FBQ0g7QUFDSixLQVBELEVBT0csS0FQSDs7QUFTQTdCLFdBQU91QixnQkFBUCxDQUF3QixTQUF4QixFQUFtQyxVQUFVQyxDQUFWLEVBQWE7QUFDNUNNLG1CQUFXQyxRQUFYO0FBQ0ExRyxlQUFPb0csT0FBUCxDQUFlQyxXQUFmLENBQTJCLEVBQUMsVUFBVyxxQkFBWixFQUFtQyxVQUFXLFNBQTlDLEVBQTNCO0FBQ0gsS0FIRCxFQUdHLEtBSEg7O0FBS0EsUUFBSU0sMEJBQTBCO0FBQzFCbkIsY0FBTSxVQUFTZSxhQUFULEVBQXdCO0FBQzFCO0FBQ0EsZ0JBQUksS0FBS0ssZUFBTCxDQUFxQkwsYUFBckIsQ0FBSixFQUF5QztBQUNyQ0UsMkJBQVdJLEtBQVgsQ0FBaUIsS0FBS0QsZUFBTCxDQUFxQkwsYUFBckIsQ0FBakI7QUFDQSx1QkFBTyxLQUFLSyxlQUFMLENBQXFCTCxhQUFyQixDQUFQO0FBQ0g7O0FBRUQ7QUFDQSxpQkFBS0ssZUFBTCxDQUFxQkwsYUFBckIsSUFBc0MsSUFBdEM7QUFDQSxpQkFBS08sZUFBTCxDQUFxQlAsYUFBckI7QUFDSCxTQVh5Qjs7QUFhMUJRLGlCQUFTLFVBQVNSLGFBQVQsRUFBd0JTLEdBQXhCLEVBQTZCO0FBQ2xDLGdCQUFJQyxPQUFPLElBQVg7O0FBRUEsZ0JBQUlELElBQUlFLE1BQUosS0FBZXBCLFNBQW5CLEVBQThCO0FBQzFCLG9CQUFJa0IsSUFBSUUsTUFBSixLQUFlLENBQW5CLEVBQXNCO0FBQUU7QUFDcEJ6QiwrQkFBVzBCLElBQVgsQ0FBZ0Isb0VBQW9FLElBQXBFLEdBQTJFLEtBQUtQLGVBQUwsQ0FBcUJMLGFBQXJCLENBQTNFLEdBQWlILEdBQWpJO0FBQ0gsaUJBRkQsTUFFTztBQUNIZCwrQkFBVzJCLEtBQVgsQ0FBaUIscUNBQXFDQyxLQUFLQyxTQUFMLENBQWVOLEdBQWYsQ0FBckMsR0FBMkQsSUFBM0QsR0FBa0UsS0FBS0osZUFBTCxDQUFxQkwsYUFBckIsQ0FBbEUsR0FBd0csR0FBekg7QUFDSDs7QUFFRCx1QkFBTyxLQUFLSyxlQUFMLENBQXFCTCxhQUFyQixDQUFQOztBQUVBLHFCQUFLZixJQUFMLENBQVVlLGFBQVY7QUFDQTtBQUNIOztBQUVEZCx1QkFBVzhCLElBQVgsQ0FBZ0JGLEtBQUtDLFNBQUwsQ0FBZU4sR0FBZixDQUFoQjs7QUFFQUEsZ0JBQUlRLE9BQUosQ0FBWWxELE9BQVosQ0FBb0IsVUFBVS9CLElBQVYsRUFBZ0I7QUFDaEMsd0JBQVFBLEtBQUssQ0FBTCxDQUFSO0FBQ0kseUJBQUssQ0FBTDtBQUNJLDRCQUFJQSxLQUFLLENBQUwsSUFBVSxHQUFkLEVBQW1CO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDSCx5QkFMRCxNQUtPLElBQUlBLEtBQUssQ0FBTCxJQUFVLENBQWQsRUFBaUI7QUFDcEI7QUFDQThDLDRCQUFBLG9EQUFBQSxDQUFnQm9DLGtCQUFoQixDQUFtQ2xGLEtBQUssQ0FBTCxDQUFuQyxFQUE0QyxXQUE1QyxFQUF5RHlCLEVBQUVDLElBQTNELEVBQWlFLFVBQVV5RCxlQUFWLEVBQTJCQyxNQUEzQixFQUFtQztBQUNoRyxvQ0FBSUQsZUFBSixFQUFxQjtBQUNqQmpDLCtDQUFXMkIsS0FBWCxDQUFpQk8sTUFBakI7QUFDQUMsd0NBQUlDLFNBQUosQ0FBYyxlQUFkLEVBQStCLGdCQUEvQixFQUFpREYsTUFBakQ7QUFDSDtBQUNKLDZCQUxEO0FBTUgseUJBUk0sTUFRQSxJQUFJcEYsS0FBSyxDQUFMLElBQVUsQ0FBZCxFQUFpQjtBQUNwQjhDLDRCQUFBLG9EQUFBQSxDQUFnQnlDLFlBQWhCLENBQTZCdkYsS0FBSyxDQUFMLENBQTdCLEVBQXNDLFlBQVk7QUFDOUN2Qyx1Q0FBT29HLE9BQVAsQ0FBZUMsV0FBZixDQUEyQixFQUFDLFVBQVcscUJBQVosRUFBbUMsUUFBUyxLQUE1QyxFQUFtRCxNQUFPOUQsS0FBSyxDQUFMLENBQTFELEVBQTNCO0FBQ0gsNkJBRkQsRUFFRyxVQUFVb0YsTUFBVixFQUFrQjtBQUNqQmxDLDJDQUFXMkIsS0FBWCxDQUFpQk8sTUFBakI7QUFDQUMsb0NBQUlDLFNBQUosQ0FBYyxlQUFkLEVBQStCLGdCQUEvQixFQUFpREYsTUFBakQ7QUFDSCw2QkFMRDtBQU1IOztBQUVEOztBQUVKLHlCQUFLLENBQUw7QUFDSSw0QkFBSXBGLEtBQUssQ0FBTCxJQUFVLEdBQWQsRUFBbUI7QUFDZjtBQUNBOEMsNEJBQUEsb0RBQUFBLENBQWdCMEMsb0JBQWhCLENBQXFDeEYsS0FBSyxDQUFMLENBQXJDLEVBQThDLE9BQTlDLEVBQXVEeUIsRUFBRUMsSUFBekQsRUFBK0QsVUFBVXlELGVBQVYsRUFBMkJDLE1BQTNCLEVBQW1DO0FBQzlGLG9DQUFJRCxlQUFKLEVBQXFCO0FBQ2pCakMsK0NBQVcyQixLQUFYLENBQWlCTyxNQUFqQjtBQUNBQyx3Q0FBSUMsU0FBSixDQUFjLGVBQWQsRUFBK0IsZ0JBQS9CLEVBQWlERixNQUFqRDtBQUNIO0FBQ0osNkJBTEQ7QUFNSCx5QkFSRCxNQVFPLElBQUlwRixLQUFLLENBQUwsSUFBVSxDQUFkLEVBQWlCO0FBQ3BCO0FBQ0E4Qyw0QkFBQSxvREFBQUEsQ0FBZ0IwQyxvQkFBaEIsQ0FBcUN4RixLQUFLLENBQUwsQ0FBckMsRUFBOEMsV0FBOUMsRUFBMkR5QixFQUFFQyxJQUE3RCxFQUFtRSxVQUFVeUQsZUFBVixFQUEyQkMsTUFBM0IsRUFBbUM7QUFDbEcsb0NBQUlELGVBQUosRUFBcUI7QUFDakJqQywrQ0FBVzJCLEtBQVgsQ0FBaUJPLE1BQWpCO0FBQ0FDLHdDQUFJQyxTQUFKLENBQWMsZUFBZCxFQUErQixnQkFBL0IsRUFBaURGLE1BQWpEO0FBQ0g7QUFDSiw2QkFMRDtBQU1ILHlCQVJNLE1BUUEsSUFBSXBGLEtBQUssQ0FBTCxJQUFVLENBQWQsRUFBaUI7QUFDcEI4Qyw0QkFBQSxvREFBQUEsQ0FBZ0IyQyxVQUFoQixDQUEyQnpGLEtBQUssQ0FBTCxDQUEzQixFQUFvQyxZQUFZO0FBQzVDdkMsdUNBQU9vRyxPQUFQLENBQWVDLFdBQWYsQ0FBMkIsRUFBQyxVQUFXLHFCQUFaLEVBQW1DLFFBQVMsSUFBNUMsRUFBa0QsTUFBTzlELEtBQUssQ0FBTCxDQUF6RCxFQUEzQjtBQUNILDZCQUZELEVBRUcsVUFBVW9GLE1BQVYsRUFBa0I7QUFDakJsQywyQ0FBVzJCLEtBQVgsQ0FBaUJPLE1BQWpCO0FBQ0FDLG9DQUFJQyxTQUFKLENBQWMsZUFBZCxFQUErQixnQkFBL0IsRUFBaURGLE1BQWpEO0FBQ0gsNkJBTEQ7QUFNSDs7QUFFRDs7QUFFSix5QkFBSyxDQUFMO0FBQ0ksNEJBQUlqRixNQUFPSCxLQUFLLENBQUwsRUFBUTBGLElBQVIsS0FBaUJuQyxTQUFsQixHQUErQnZELEtBQUssQ0FBTCxFQUFRMEYsSUFBdkMsR0FBOEMxRixLQUFLLENBQUwsQ0FBeEQ7QUFBQSw0QkFDSTJGLFdBQVkzRixLQUFLLENBQUwsSUFBVSxDQUFYLEdBQWdCLE1BQWhCLEdBQXlCLE9BRHhDO0FBQUEsNEJBRUk0RixlQUZKOztBQUlBeEMsb0NBQVlZLGFBQVosRUFBMkIyQixRQUEzQixFQUFxQyxDQUFyQyxLQUEyQyxDQUEzQzs7QUFFQUMsMENBQWtCLFVBQVNDLFFBQVQsRUFBbUI7QUFDakMsZ0NBQUlDLGNBQWMsRUFBbEI7QUFDQSxnQ0FBSUMsVUFBVSxFQUFkOztBQUVBLGlDQUFLLElBQUlDLEtBQVQsSUFBa0JoRyxLQUFLLENBQUwsQ0FBbEIsRUFBMkI7QUFDdkIsb0NBQUlpRyxVQUFVRCxNQUFNRSxLQUFOLENBQVksaUJBQVosQ0FBZDtBQUNBLG9DQUFJLENBQUNELE9BQUwsRUFDSTs7QUFFSixvQ0FBSUUsYUFBYW5HLEtBQUssQ0FBTCxFQUFRLFdBQVdpRyxRQUFRLENBQVIsQ0FBWCxHQUF3QixPQUFoQyxDQUFqQjtBQUNBSCw0Q0FBWU0sSUFBWixDQUFpQixDQUFDRCxVQUFELEVBQWFFLE1BQWIsQ0FBb0JyRyxLQUFLLENBQUwsRUFBUWdHLEtBQVIsRUFBZXBLLEtBQWYsQ0FBcUIsR0FBckIsQ0FBcEIsQ0FBakI7QUFDSDs7QUFFRCxnQ0FBSW9FLEtBQUssQ0FBTCxFQUFRc0csR0FBUixLQUFnQi9DLFNBQXBCLEVBQStCO0FBQzNCdUMsNENBQVlNLElBQVosQ0FBaUIsQ0FBQyxVQUFELEVBQWFwRyxLQUFLLENBQUwsRUFBUXNHLEdBQXJCLENBQWpCO0FBQ0g7O0FBRURQLG9DQUFRUSxHQUFSLEdBQWN2RyxLQUFLLENBQUwsQ0FBZDtBQUNBK0Ysb0NBQVE1RixHQUFSLEdBQWMwRixTQUFTMUYsR0FBdkI7QUFDQTRGLG9DQUFRUyxJQUFSLEdBQWV4RyxLQUFLLENBQUwsQ0FBZjtBQUNBK0Ysb0NBQVFqRixLQUFSLEdBQWdCZCxLQUFLLENBQUwsQ0FBaEI7QUFDQStGLG9DQUFRVSxJQUFSLEdBQWV6RyxLQUFLLENBQUwsQ0FBZjtBQUNBK0Ysb0NBQVFXLFVBQVIsR0FBc0IxRyxLQUFLLENBQUwsSUFBVSxDQUFYLEdBQWdCLENBQWhCLEdBQW9CLENBQXpDO0FBQ0ErRixvQ0FBUUQsV0FBUixHQUFzQkEsV0FBdEI7QUFDQUMsb0NBQVFZLE9BQVIsR0FBbUIzRyxLQUFLLENBQUwsRUFBUTBGLElBQVIsS0FBaUJuQyxTQUFsQixHQUErQnZELEtBQUssQ0FBTCxJQUFVLFVBQXpDLEdBQXNELENBQXhFO0FBQ0ErRixvQ0FBUWEsSUFBUixHQUFlLENBQUNqQixRQUFELENBQWY7QUFDQUksb0NBQVFjLEtBQVIsR0FBZ0I3RyxLQUFLLENBQUwsRUFBUTZHLEtBQVIsR0FBZ0IsQ0FBaEIsR0FBb0IsQ0FBcEM7O0FBRUEsZ0NBQUlmLFlBQVluRCxNQUFoQixFQUF3QjtBQUNwQm9ELHdDQUFRYSxJQUFSLENBQWFSLElBQWIsQ0FBa0IsYUFBbEI7QUFDSDs7QUFFRHRELDRCQUFBLG9EQUFBQSxDQUFnQmdFLGNBQWhCLENBQStCOUMsYUFBL0IsRUFBOEMsQ0FBQytCLE9BQUQsQ0FBOUMsRUFBeUQsWUFBWTtBQUNqRTtBQUNBdEksdUNBQU9vRyxPQUFQLENBQWVDLFdBQWYsQ0FBMkI7QUFDdkJpRCw0Q0FBUSxpQkFEZTtBQUV2Qi9HLDBDQUFNK0YsT0FGaUI7QUFHdkJpQiw4Q0FBVW5CO0FBSGEsaUNBQTNCOztBQU1BLG9DQUFJRixhQUFhLE9BQWpCLEVBQTBCO0FBQ3RCLHdDQUFJc0IsU0FBU3BCLFNBQVNxQixLQUFULElBQWtCekosT0FBT29HLE9BQVAsQ0FBZXNELE1BQWYsQ0FBc0IscUJBQXRCLENBQS9CO0FBQ0FDLHFEQUFpQkgsTUFBakIsRUFBeUJwQixTQUFTMUYsR0FBbEM7QUFDSDs7QUFFRCx5Q0FBU2lILGdCQUFULENBQTBCQyxTQUExQixFQUFxQ2xILEdBQXJDLEVBQTBDO0FBQ3RDLHdDQUFJMEIsZ0JBQWdCeUYsaUJBQWhCLEtBQXNDLENBQTFDLENBQTJDLHdDQUEzQyxFQUNJOztBQUVKdkgsMkRBQXVCO0FBQ25CSSw2Q0FBS0EsR0FEYztBQUVuQlcsK0NBQU8rRSxTQUFTMEIsVUFBVCxHQUFzQixHQUF0QixHQUE0QjFCLFNBQVMyQixTQUZ6QjtBQUduQnZMLGlEQUFTOEosUUFBUVUsSUFBUixDQUFhZ0IsT0FBYixDQUFxQixRQUFyQixFQUErQixJQUEvQixDQUhVO0FBSW5CcEgsOENBQU1nSCxTQUphO0FBS25CbEcsK0NBQU8sU0FMWTtBQU1uQkcsaURBQVVPLGdCQUFnQnlGLGlCQUFoQixLQUFzQyxFQUF2QyxHQUE2Qy9ELFNBQTdDLEdBQXlEMUIsZ0JBQWdCeUYsaUJBQWhCLEdBQW9DLENBTm5GO0FBT25CckcsaURBQVMsWUFBWTtBQUNqQmlDLHVEQUFXQyxNQUFYLENBQWtCLHdDQUF3QzRDLFFBQVFRLEdBQWxFO0FBQ0F2RSxzRUFBMEIsSUFBMUI7QUFDSDtBQVZrQixxQ0FBdkI7O0FBYUFrQiwrQ0FBV0MsTUFBWCxDQUFrQixxQ0FBcUM0QyxRQUFRUSxHQUEvRDtBQUNIO0FBQ0osNkJBaENEO0FBaUNILHlCQWpFRDs7QUFtRUF6RCx3QkFBQSxvREFBQUEsQ0FBZ0I0RSxjQUFoQixDQUErQjFELGFBQS9CLEVBQThDN0QsR0FBOUMsRUFBbUR5RixlQUFuRCxFQUFvRSxVQUFVOUosR0FBVixFQUFlO0FBQy9FO0FBQ0EsZ0NBQUlrSSxrQkFBa0JELGdCQUFnQkMsYUFBdEMsRUFBcUQ7QUFDakQyRCwrQ0FBZTNELGFBQWYsRUFBOEI0RCxTQUFTekgsR0FBVCxFQUFjLEVBQWQsQ0FBOUIsRUFBaUR5RixlQUFqRDtBQUNIO0FBQ0oseUJBTEQ7O0FBT0E7O0FBRUoseUJBQUssQ0FBTDtBQUFTO0FBQ0wsNEJBQUkvRCxnQkFBZ0JnRyxVQUFoQixLQUErQixDQUFuQyxFQUFzQztBQUNsQ3BLLG1DQUFPb0csT0FBUCxDQUFlQyxXQUFmLENBQTJCLEVBQUMsVUFBVyxxQkFBWixFQUFtQyxPQUFRLENBQUM5RCxLQUFLLENBQUwsQ0FBNUMsRUFBcUQsVUFBVyxJQUFoRSxFQUEzQjtBQUNIOztBQUVEOztBQUVKLHlCQUFLLENBQUw7QUFBUztBQUNMLDRCQUFJNkIsZ0JBQWdCZ0csVUFBaEIsS0FBK0IsQ0FBbkMsRUFBc0M7QUFDbENwSyxtQ0FBT29HLE9BQVAsQ0FBZUMsV0FBZixDQUEyQixFQUFDLFVBQVcscUJBQVosRUFBbUMsT0FBUSxDQUFDOUQsS0FBSyxDQUFMLENBQTVDLEVBQXFELFVBQVcsS0FBaEUsRUFBM0I7QUFDSDs7QUFFRDs7QUFFSix5QkFBSyxFQUFMLENBdkpKLENBdUpjO0FBQ1YseUJBQUssRUFBTDtBQUFVO0FBQ047O0FBRUo7QUFDSWtELG1DQUFXOEIsSUFBWCxDQUFnQixDQUFDaEYsS0FBSyxDQUFMLENBQUQsRUFBVUEsSUFBVixDQUFoQjtBQTVKUjtBQThKSCxhQS9KRDs7QUFpS0EsZ0JBQUkrRCxnQkFBZ0JDLGFBQWhCLEtBQWtDQSxhQUF0QyxFQUFxRDtBQUNqRCxxQkFBSzhELGFBQUwsQ0FBbUI5RCxhQUFuQixFQUFrQytELEVBQWxDLEdBQXVDdEQsSUFBSXNELEVBQTNDO0FBQ0EscUJBQUtDLGFBQUwsQ0FBbUJoRSxhQUFuQjtBQUNIO0FBQ0osU0FwTXlCOztBQXNNMUJpRSxrQkFBVSxVQUFTakUsYUFBVCxFQUF3QmtFLFNBQXhCLEVBQW1DQyxTQUFuQyxFQUE4QztBQUNwRCxtQkFBTyxLQUFLOUQsZUFBTCxDQUFxQkwsYUFBckIsQ0FBUDtBQUNBLGdCQUFJa0UsY0FBY2hFLFdBQVdrRSxLQUE3QixFQUNJOztBQUVKLGlCQUFLbkYsSUFBTCxDQUFVZSxhQUFWOztBQUVBLGdCQUFJRCxnQkFBZ0JDLGFBQWhCLEtBQWtDQSxhQUF0QyxFQUFxRDtBQUNqRHFFLHlCQUFTckUsYUFBVCxFQUF3QixPQUF4QjtBQUNBcUUseUJBQVNyRSxhQUFULEVBQXdCLE1BQXhCO0FBQ0g7QUFDSixTQWpOeUI7O0FBbU4xQk8seUJBQWlCLFVBQVNQLGFBQVQsRUFBd0I7QUFDckMsZ0JBQUlVLE9BQU8sSUFBWDs7QUFFQVIsdUJBQVdvRSxTQUFYLENBQXFCLDRCQUFyQixFQUFtRCxVQUFVdEksSUFBVixFQUFnQjtBQUMvRCxvQkFBSStELGdCQUFnQkMsYUFBaEIsS0FBa0NBLGFBQXRDLEVBQ0k7O0FBRUpVLHFCQUFLb0QsYUFBTCxDQUFtQjlELGFBQW5CLElBQW9DaEUsS0FBS3VJLFFBQXpDO0FBQ0E3RCxxQkFBS3NELGFBQUwsQ0FBbUJoRSxhQUFuQjtBQUNILGFBTkQsRUFNRyxVQUFVd0UsT0FBVixFQUFtQjtBQUNsQix1QkFBTzlELEtBQUtMLGVBQUwsQ0FBcUJMLGFBQXJCLENBQVA7O0FBRUEsb0JBQUl3RSxZQUFZdEUsV0FBV3VFLGFBQTNCLEVBQTBDO0FBQ3RDaEwsMkJBQU9vRyxPQUFQLENBQWVDLFdBQWYsQ0FBMkIsRUFBQ2lELFFBQVEsY0FBVCxFQUEzQjtBQUNIOztBQUVELHdCQUFReUIsT0FBUjtBQUNJLHlCQUFLdEUsV0FBV2tFLEtBQWhCO0FBQ0EseUJBQUtsRSxXQUFXdUUsYUFBaEI7QUFDSTtBQUhSOztBQU1BckcsdUJBQU9iLFVBQVAsQ0FBa0JtRCxLQUFLekIsSUFBTCxDQUFVeUYsSUFBVixDQUFlaEUsSUFBZixDQUFsQixFQUF3QyxJQUF4QyxFQUE4Q1YsYUFBOUM7QUFDSCxhQXBCRDtBQXFCSCxTQTNPeUI7O0FBNk8xQmdFLHVCQUFlLFVBQVNoRSxhQUFULEVBQXdCO0FBQ25DLGdCQUFJMkUsU0FBUyxLQUFLYixhQUFMLENBQW1COUQsYUFBbkIsRUFBa0M0RSxNQUFsQyxDQUF5Q25CLE9BQXpDLENBQWlELGNBQWpELEVBQWlFLFFBQWpFLENBQWI7O0FBRUEsaUJBQUtwRCxlQUFMLENBQXFCTCxhQUFyQixJQUFzQ0UsV0FBVzJFLFdBQVgsQ0FBdUIsYUFBYUYsTUFBcEMsRUFBNEM7QUFDOUUsdUJBQVEsU0FEc0U7QUFFOUUsdUJBQVEsS0FBS2IsYUFBTCxDQUFtQjlELGFBQW5CLEVBQWtDM0csR0FGb0M7QUFHOUUsc0JBQU8sS0FBS3lLLGFBQUwsQ0FBbUI5RCxhQUFuQixFQUFrQytELEVBSHFDO0FBSTlFLHdCQUFTLEVBSnFFO0FBSzlFLHdCQUFTLENBTHFFO0FBTTlFLDJCQUFZO0FBTmtFLGFBQTVDLEVBT25DLEtBQUt2RCxPQUFMLENBQWFrRSxJQUFiLENBQWtCLElBQWxCLEVBQXdCMUUsYUFBeEIsQ0FQbUMsRUFPSyxLQUFLaUUsUUFBTCxDQUFjUyxJQUFkLENBQW1CLElBQW5CLEVBQXlCMUUsYUFBekIsQ0FQTCxDQUF0QztBQVFILFNBeFB5Qjs7QUEwUDFCOEQsdUJBQWUsRUExUFc7QUEyUDFCekQseUJBQWlCLEVBM1BTO0FBNFAxQnlFLGVBQU87QUE1UG1CLEtBQTlCOztBQStQQTs7Ozs7OztBQU9BLGFBQVNuQixjQUFULENBQXdCM0QsYUFBeEIsRUFBdUM3RCxHQUF2QyxFQUE0QzRJLFFBQTVDLEVBQXNEO0FBQ2xELFlBQUlDLGtCQUFrQmpGLGdCQUFnQmtGLElBQWhCLENBQXFCakYsYUFBckIsRUFBb0NrRixLQUExRDs7QUFFQTdGLHVCQUFlVyxhQUFmLElBQWdDWCxlQUFlVyxhQUFmLEtBQWlDLEVBQWpFO0FBQ0ErRSxtQkFBV0EsWUFBWXRILEVBQUVDLElBQXpCOztBQUVBO0FBQ0EsWUFBSTJCLGVBQWVXLGFBQWYsRUFBOEI3RCxHQUE5QixDQUFKLEVBQXdDO0FBQ3BDO0FBQ0g7O0FBRUQrRCxtQkFBV29FLFNBQVgsQ0FBcUIsV0FBckIsRUFBa0M7QUFDOUJhLGtCQUFNakwsT0FBT2lDLEdBQVAsQ0FEd0I7QUFFOUJpSixvQkFBUSxzREFGc0I7QUFHOUJDLDBCQUFjTDtBQUhnQixTQUFsQyxFQUlHLFVBQVVoSixJQUFWLEVBQWdCO0FBQ2Y7QUFDQXNKLDRCQUFnQnRGLGFBQWhCLEVBQStCaEUsS0FBS3VJLFFBQXBDLEVBQThDMUssSUFBOUMsQ0FBbUQsVUFBVTBMLEtBQVYsRUFBaUI7QUFDaEUsb0JBQUkxRCxXQUFXMEQsTUFBTSxDQUFOLENBQWY7O0FBRUE7QUFDQSx1QkFBT2xHLGVBQWVXLGFBQWYsRUFBOEI2QixTQUFTMUYsR0FBdkMsQ0FBUDs7QUFFQTRJLHlCQUFTbEQsUUFBVDtBQUNILGFBUEQ7QUFRSCxTQWRELEVBY0csVUFBVTJDLE9BQVYsRUFBbUJnQixPQUFuQixFQUE0QjtBQUMzQixvQkFBUWhCLE9BQVI7QUFDSSxxQkFBS3RFLFdBQVdrRSxLQUFoQjtBQUNBLHFCQUFLbEUsV0FBV3VFLGFBQWhCO0FBQ0k7QUFIUjs7QUFNQXJHLG1CQUFPYixVQUFQLENBQWtCb0csY0FBbEIsRUFBa0MsSUFBRSxJQUFwQyxFQUEwQzNELGFBQTFDLEVBQXlEN0QsR0FBekQsRUFBOEQ0SSxRQUE5RDtBQUNILFNBdEJEO0FBdUJIOztBQUVEOzs7O0FBSUEsUUFBSVUsY0FBYyxVQUFVekYsYUFBVixFQUF5QjtBQUN2QyxZQUFJeUYsWUFBWUMsT0FBaEIsRUFDSTs7QUFFSjtBQUNBRCxvQkFBWUMsT0FBWixHQUFzQixJQUF0Qjs7QUFFQSxZQUFJQyxtQkFBbUJqSyxlQUFlMUMsR0FBZixDQUFtQixtQkFBbkIsRUFBd0MsRUFBQ2lCLGFBQWEyTCxNQUFkLEVBQXNCekwsUUFBUSxJQUE5QixFQUFvQ0MsUUFBUSxJQUE1QyxFQUF4QyxDQUF2QjtBQUNBLFlBQUl5TCxzQkFBc0JDLElBQUlDLHNCQUFKLEdBQTZCLElBQXZEO0FBQ0EsWUFBSUMsa0JBQUo7O0FBRUE7QUFDQSxZQUFJaEcsa0JBQWtCRCxnQkFBZ0JDLGFBQXRDLEVBQXFEO0FBQ2pEeUYsd0JBQVlDLE9BQVosR0FBc0IsS0FBdEI7QUFDQTtBQUNIOztBQUVEO0FBQ0EsWUFBSUMsaUJBQWlCM0YsYUFBakIsQ0FBSixFQUFxQztBQUNqQ2dHLGlDQUFxQnJKLEtBQUtzSixHQUFMLENBQVVKLHNCQUFzQmxKLEtBQUt1SixHQUFMLENBQVNDLEtBQUtDLEdBQUwsS0FBYVQsaUJBQWlCM0YsYUFBakIsQ0FBdEIsQ0FBaEMsRUFBeUYsQ0FBekYsQ0FBckI7QUFDQSxnQkFBSWdHLHFCQUFxQixDQUF6QixFQUE0QjtBQUN4QjVILHVCQUFPYixVQUFQLENBQWtCa0ksV0FBbEIsRUFBK0JPLGtCQUEvQixFQUFtRGhHLGFBQW5EOztBQUVBeUYsNEJBQVlDLE9BQVosR0FBc0IsS0FBdEI7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQS9CLHVCQUFlM0QsYUFBZixFQUE4QkEsYUFBOUIsRUFBNkMsVUFBVXFHLGVBQVYsRUFBMkI7QUFDcEUsZ0JBQUlDLFVBQVUsSUFBSUgsSUFBSixFQUFkO0FBQUEsZ0JBQ0lJLFNBQVNELFFBQVFFLE9BQVIsRUFEYjtBQUFBLGdCQUVJQyxVQUFVSCxRQUFRSSxXQUFSLEVBRmQ7QUFBQSxnQkFHSUMsV0FBV0wsUUFBUU0sUUFBUixLQUFxQixDQUhwQztBQUFBLGdCQUlJQyxLQUpKO0FBQUEsZ0JBSVdDLENBSlg7QUFBQSxnQkFJY0MsWUFKZDtBQUFBLGdCQUk0QkMsR0FKNUI7O0FBTUEsZ0JBQUlYLGdCQUFnQlksS0FBaEIsS0FBMEIxSCxTQUExQixJQUF1QzhHLGdCQUFnQlksS0FBaEIsQ0FBc0J0SSxNQUF0QixLQUFpQyxDQUE1RSxFQUNJOztBQUVKO0FBQ0FrSSxvQkFBUVIsZ0JBQWdCWSxLQUFoQixDQUFzQnJQLEtBQXRCLENBQTRCLEdBQTVCLENBQVI7QUFDQSxpQkFBS2tQLElBQUksQ0FBVCxFQUFZQSxJQUFJRCxNQUFNbEksTUFBdEIsRUFBOEJtSSxHQUE5QixFQUNJRCxNQUFNQyxDQUFOLElBQVdsRCxTQUFTaUQsTUFBTUMsQ0FBTixDQUFULEVBQW1CLEVBQW5CLENBQVg7O0FBRUosZ0JBQUlELE1BQU0sQ0FBTixNQUFhTixNQUFiLElBQXVCTSxNQUFNLENBQU4sTUFBYUYsUUFBeEMsRUFDSTs7QUFFSjVLLG1DQUF1QjtBQUNuQmUsdUJBQU9nSixJQUFJb0IsSUFEUTtBQUVuQmpQLHlCQUFTd0IsT0FBTzBOLElBQVAsQ0FBWUMsVUFBWixDQUF1QixlQUF2QixFQUF3QzNELE9BQXhDLENBQWdELFdBQWhELEVBQTZEcUMsSUFBSW9CLElBQWpFLENBRlU7QUFHbkI3SyxzQkFBTTVDLE9BQU9vRyxPQUFQLENBQWVzRCxNQUFmLENBQXNCLGVBQXRCLENBSGE7QUFJbkJoRyx1QkFBTyxTQUpZO0FBS25CRix5QkFBUyxZQUFZO0FBQ2pCb0Usd0JBQUlDLFNBQUosQ0FBYyxhQUFkLEVBQTZCLHVCQUE3QjtBQUNBdEQsOENBQTBCLElBQTFCO0FBQ0g7QUFSa0IsYUFBdkI7O0FBV0FxRCxnQkFBSUMsU0FBSixDQUFjLFVBQWQsRUFBMEIsc0JBQTFCO0FBQ0gsU0E5QkQ7O0FBZ0NBcEIsbUJBQVdvRSxTQUFYLENBQXFCLGFBQXJCLEVBQW9DLEVBQUNjLFFBQVEsc0RBQVQsRUFBcEMsRUFBc0csVUFBVXBKLElBQVYsRUFBZ0I7QUFDbEgsZ0JBQUlzSyxVQUFVLElBQUlILElBQUosRUFBZDtBQUFBLGdCQUNJSSxTQUFTRCxRQUFRRSxPQUFSLEVBRGI7QUFBQSxnQkFFSUMsVUFBVUgsUUFBUUksV0FBUixFQUZkO0FBQUEsZ0JBR0lDLFdBQVdMLFFBQVFNLFFBQVIsS0FBcUIsQ0FIcEM7O0FBS0F4SCx3QkFBWVksYUFBWixFQUEyQlIsUUFBM0IsQ0FBb0MsQ0FBcEMsS0FBMEN4RCxLQUFLdUksUUFBTCxDQUFjNUYsTUFBeEQ7O0FBRUE7QUFDQTJHLDRCQUFnQnRGLGFBQWhCLEVBQStCaEUsS0FBS3VJLFFBQXBDLEVBQThDMUssSUFBOUMsQ0FBbUQsVUFBVTBMLEtBQVYsRUFBaUI7QUFDaEVBLHNCQUFNeEgsT0FBTixDQUFjLFVBQVVzSixPQUFWLEVBQW1CO0FBQzdCLHdCQUFJUixLQUFKLEVBQVdDLENBQVg7O0FBRUE7QUFDQSwyQkFBT3pILGVBQWVXLGFBQWYsRUFBOEJxSCxRQUFRbEwsR0FBdEMsQ0FBUDs7QUFFQWlELGdDQUFZWSxhQUFaLEVBQTJCUixRQUEzQixDQUFvQyxDQUFwQyxLQUEwQyxDQUExQztBQUNBL0YsMkJBQU9vRyxPQUFQLENBQWVDLFdBQWYsQ0FBMkI7QUFDdkJpRCxnQ0FBUSxjQURlO0FBRXZCN0gsZ0NBQVE4RSxhQUZlO0FBR3ZCeEgsOEJBQU0sVUFIaUI7QUFJdkI4TywrQkFBT2xJLFlBQVlZLGFBQVosRUFBMkJSLFFBQTNCLENBQW9DLENBQXBDLENBSmdCO0FBS3ZCK0gsaUNBQVNuSSxZQUFZWSxhQUFaLEVBQTJCUixRQUEzQixDQUFvQyxDQUFwQztBQUxjLHFCQUEzQjs7QUFRQSx3QkFBSTNCLGdCQUFnQjJKLHlCQUFoQixLQUE4QyxDQUFsRCxFQUNJOztBQUVKO0FBQ0Esd0JBQUlILFFBQVFKLEtBQVIsS0FBa0IxSCxTQUFsQixJQUErQjhILFFBQVFKLEtBQVIsQ0FBY3RJLE1BQWQsS0FBeUIsQ0FBNUQsRUFDSTs7QUFFSjtBQUNBa0ksNEJBQVFRLFFBQVFKLEtBQVIsQ0FBY3JQLEtBQWQsQ0FBb0IsR0FBcEIsQ0FBUjtBQUNBLHlCQUFLa1AsSUFBSSxDQUFULEVBQVlBLElBQUlELE1BQU1sSSxNQUF0QixFQUE4Qm1JLEdBQTlCLEVBQ0lELE1BQU1DLENBQU4sSUFBV2xELFNBQVNpRCxNQUFNQyxDQUFOLENBQVQsRUFBbUIsRUFBbkIsQ0FBWDs7QUFFSix3QkFBSUQsTUFBTSxDQUFOLE1BQWFOLE1BQWIsSUFBdUJNLE1BQU0sQ0FBTixNQUFhRixRQUF4QyxFQUNJOztBQUVKO0FBQ0Esd0JBQUljLGVBQWVoTyxPQUFPME4sSUFBUCxDQUFZQyxVQUFaLENBQXVCLFVBQXZCLEVBQW1DeFAsS0FBbkMsQ0FBeUMsR0FBekMsQ0FBbkI7QUFBQSx3QkFDSThQLFlBQVlqTyxPQUFPME4sSUFBUCxDQUFZQyxVQUFaLENBQXVCLE9BQXZCLEVBQWdDeFAsS0FBaEMsQ0FBc0MsR0FBdEMsQ0FEaEI7QUFBQSx3QkFFSStQLGdCQUFnQkYsYUFBYSxDQUFiLEVBQWdCdkYsS0FBaEIsQ0FBc0IsbUJBQXRCLENBRnBCO0FBQUEsd0JBR0k4RSxHQUhKO0FBQUEsd0JBR1NZLEtBSFQ7QUFBQSx3QkFHZ0JiLFlBSGhCOztBQUtBTSw0QkFBUVEsR0FBUixHQUFjUixRQUFRUSxHQUFSLElBQWUsQ0FBN0I7QUFDQSw0QkFBUVIsUUFBUVEsR0FBaEI7QUFDSSw2QkFBSyxDQUFMO0FBQVM7QUFDTGIsa0NBQU1TLGFBQWEsQ0FBYixFQUFnQmhFLE9BQWhCLENBQXdCa0UsY0FBYyxDQUFkLENBQXhCLEVBQTBDQSxjQUFjLENBQWQsQ0FBMUMsSUFBOEQsR0FBcEU7QUFDQTs7QUFFSiw2QkFBSyxDQUFMO0FBQVM7QUFDTFgsa0NBQU1TLGFBQWEsQ0FBYixFQUFnQmhFLE9BQWhCLENBQXdCa0UsY0FBYyxDQUFkLENBQXhCLEVBQTBDQSxjQUFjLENBQWQsQ0FBMUMsSUFBOEQsR0FBcEU7QUFDQTs7QUFFSjtBQUFVO0FBQ05YLGtDQUFNUyxhQUFhLENBQWIsRUFBZ0JoRSxPQUFoQixDQUF3QmtFLGNBQWMsQ0FBZCxDQUF4QixFQUEwQ0EsY0FBYyxDQUFkLElBQW1CLElBQW5CLEdBQTBCQSxjQUFjLENBQWQsQ0FBMUIsR0FBNkMsR0FBdkYsSUFBOEYsR0FBcEc7QUFWUjs7QUFhQSx3QkFBSWQsTUFBTWxJLE1BQU4sS0FBaUIsQ0FBckIsRUFBd0I7QUFDcEJpSixnQ0FBUW5CLFVBQVVJLE1BQU0sQ0FBTixDQUFsQjtBQUNBRywrQkFBTyxPQUFPUyxhQUFhLENBQWIsRUFBZ0JoRSxPQUFoQixDQUF3QixTQUF4QixFQUFtQ21FLFFBQVEsR0FBUixHQUFjRSxNQUFNQyxNQUFOLENBQWFDLE1BQWIsQ0FBb0JKLEtBQXBCLEVBQTJCRixTQUEzQixDQUFqRCxDQUFQLEdBQWlHLEdBQXhHO0FBQ0g7O0FBRUQzTCwyQ0FBdUI7QUFDbkJJLDZCQUFLa0wsUUFBUWxMLEdBRE07QUFFbkJXLCtCQUFPdUssUUFBUTlELFVBQVIsR0FBcUIsR0FBckIsR0FBMkI4RCxRQUFRN0QsU0FGdkI7QUFHbkJ2TCxpQ0FBUytPLEdBSFU7QUFJbkIzSyw4QkFBTWdMLFFBQVFuRSxLQUFSLElBQWlCekosT0FBT29HLE9BQVAsQ0FBZXNELE1BQWYsQ0FBc0IscUJBQXRCLENBSko7QUFLbkJoRywrQkFBTyxTQUxZO0FBTW5CRixpQ0FBUyxZQUFZO0FBQ2pCZSxzREFBMEIsSUFBMUI7QUFDSDtBQVJrQixxQkFBdkI7QUFVSCxpQkFqRUQ7O0FBbUVBLG9CQUFJaUssY0FBZXZNLGVBQWUxQyxHQUFmLENBQW1CLGdCQUFnQmdILGFBQW5DLE1BQXNELElBQXpFO0FBQ0Esb0JBQUlrSSxhQUFjeE0sZUFBZTFDLEdBQWYsQ0FBbUIsaUJBQWlCZ0gsYUFBcEMsTUFBdUQsSUFBekU7O0FBRUEyRixpQ0FBaUIzRixhQUFqQixJQUFrQ21HLEtBQUtDLEdBQUwsRUFBbEM7QUFDQTFLLCtCQUFldEMsR0FBZixDQUFtQixtQkFBbkIsRUFBd0N1TSxnQkFBeEM7O0FBRUE7QUFDQXZILHVCQUFPYixVQUFQLENBQWtCa0ksV0FBbEIsRUFBK0JJLG1CQUEvQixFQUFvRDdGLGFBQXBEOztBQUVBO0FBQ0Esb0JBQUlELGdCQUFnQkMsYUFBaEIsS0FBa0NBLGFBQXRDLEVBQXFEO0FBQ2pELHdCQUFJaUksZUFBZUMsVUFBbkIsRUFBK0I7QUFDM0I7QUFDQTVJLGlEQUF5QlUsYUFBekI7O0FBRUExRCxnQ0FBUXVDLEdBQVIsQ0FBWSxDQUNSLG9EQUFBQyxDQUFnQnFKLGlCQUFoQixDQUFrQ25JLGFBQWxDLENBRFEsRUFFUixvREFBQWxCLENBQWdCc0osa0JBQWhCLENBQW1DcEksYUFBbkMsQ0FGUSxDQUFaLEVBR0duRyxJQUhILENBR1EsWUFBWTtBQUNoQkosbUNBQU9vRyxPQUFQLENBQWVDLFdBQWYsQ0FBMkI7QUFDdkJpRCx3Q0FBUSxJQURlO0FBRXZCc0YsdUNBQU8sTUFGZ0I7QUFHdkJySSwrQ0FBZUQsZ0JBQWdCQyxhQUhSO0FBSXZCc0ksZ0RBQWdCdkksZ0JBQWdCd0gsT0FBaEIsR0FBMEJ4SCxnQkFBZ0J3SCxPQUFoQixDQUF3QmdCLEdBQWxELEdBQXdEO0FBSmpELDZCQUEzQjtBQU1ILHlCQVZEO0FBV0g7QUFDSjs7QUFFRDlDLDRCQUFZQyxPQUFaLEdBQXNCLEtBQXRCO0FBQ0gsYUFsR0Q7QUFtR0gsU0E1R0QsRUE0R0csVUFBVWxCLE9BQVYsRUFBbUJnQixPQUFuQixFQUE0QjtBQUMzQkMsd0JBQVlDLE9BQVosR0FBc0IsS0FBdEI7O0FBRUEsb0JBQVFsQixPQUFSO0FBQ0kscUJBQUt0RSxXQUFXa0UsS0FBaEI7QUFDQSxxQkFBS2xFLFdBQVd1RSxhQUFoQjtBQUNJO0FBSFI7O0FBTUFyRyxtQkFBT2IsVUFBUCxDQUFrQmtJLFdBQWxCLEVBQStCLElBQUUsSUFBakMsRUFBdUN6RixhQUF2QztBQUNILFNBdEhEO0FBdUhILEtBcExEOztBQXNMQTs7Ozs7Ozs7QUFRQSxhQUFTc0YsZUFBVCxDQUF5QnRGLGFBQXpCLEVBQXdDdUYsS0FBeEMsRUFBK0M7QUFDM0MsZUFBTyxJQUFJakosT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUJpTSxNQUFuQixFQUEyQjtBQUMxQyxnQkFBSUMsZ0JBQWdCLEVBQXBCO0FBQ0FwSiwyQkFBZVcsYUFBZixJQUFnQ1gsZUFBZVcsYUFBZixLQUFpQyxFQUFqRTs7QUFFQXVGLGtCQUFNeEgsT0FBTixDQUFjLFVBQVU4RCxRQUFWLEVBQW9CO0FBQzlCO0FBQ0F4QywrQkFBZVcsYUFBZixFQUE4QjZCLFNBQVMxRixHQUF2QyxJQUE4QyxJQUE5Qzs7QUFFQTtBQUNBLG9CQUFJNkQsa0JBQWtCNkIsU0FBUzFGLEdBQS9CLEVBQW9DO0FBQ2hDNEQsb0NBQWdCMkksTUFBaEIsQ0FBdUIxSSxhQUF2QixFQUFzQzZCLFNBQVMwQixVQUFULEdBQXNCLEdBQXRCLEdBQTRCMUIsU0FBUzJCLFNBQTNFO0FBQ0g7O0FBRURpRiw4QkFBY3JHLElBQWQsQ0FBbUIsQ0FBQ1AsU0FBUzFGLEdBQVYsRUFBZTBGLFNBQVMwQixVQUF4QixFQUFvQzFCLFNBQVMyQixTQUE3QyxFQUF3RDNCLFFBQXhELENBQW5CO0FBQ0gsYUFWRDs7QUFZQSxnQkFBSSxDQUFDNEcsY0FBYzlKLE1BQW5CLEVBQTJCO0FBQ3ZCcEMsd0JBQVEsRUFBUjtBQUNBO0FBQ0g7O0FBRUR1QyxZQUFBLG9EQUFBQSxDQUFnQjZKLGVBQWhCLENBQWdDM0ksYUFBaEMsRUFBK0N5SSxhQUEvQyxFQUE4RDVPLElBQTlELENBQW1FMEMsT0FBbkUsRUFBNEUsVUFBVXpFLEdBQVYsRUFBZTtBQUN2RixvQkFBSThRLGFBQWE5USxJQUFJK1EsSUFBSixHQUFXLElBQVgsR0FBa0IvUSxJQUFJRyxPQUF2Qzs7QUFFQWlILDJCQUFXMkIsS0FBWCxDQUFpQitILFVBQWpCO0FBQ0F2SCxvQkFBSUMsU0FBSixDQUFjLGVBQWQsRUFBK0IsZ0JBQS9CLEVBQWlELGdDQUFnQ3NILFVBQWpGOztBQUVBSix1QkFBT0ksVUFBUDtBQUNILGFBUEQ7QUFRSCxTQTdCTSxDQUFQO0FBOEJIOztBQUVEOzs7Ozs7O0FBT0EsUUFBSXZFLFdBQVcsVUFBU3JFLGFBQVQsRUFBd0IyQixRQUF4QixFQUFrQ21ILGVBQWxDLEVBQW1EO0FBQzlELFlBQUlDLFNBQVMzSixZQUFZWSxhQUFaLEVBQTJCMkIsUUFBM0IsRUFBcUMsQ0FBckMsQ0FBYjtBQUNBLFlBQUlxSCxxQkFBcUJqSixnQkFBZ0JrRixJQUFoQixDQUFxQmpGLGFBQXJCLENBQXpCO0FBQUEsWUFDSWlKLGFBQWN0SCxhQUFhLE9BQWQsR0FBeUIsT0FBekIsR0FBbUMsUUFEcEQ7QUFBQSxZQUVJdUgsVUFBVSxVQUFVRCxVQUFWLEdBQXVCLEdBQXZCLEdBQTZCakosYUFGM0M7QUFBQSxZQUdJbUosWUFBYXpOLGVBQWUxQyxHQUFmLENBQW1Ca1EsT0FBbkIsTUFBZ0MsSUFIakQ7O0FBS0EsWUFBSUUsWUFBWUwsU0FDVnpNLFFBQVFDLE9BQVIsQ0FBZ0J1TSxlQUFoQixDQURVLEdBRVYsb0RBQUFoSyxDQUFnQnVLLHFCQUFoQixDQUFzQzFILFFBQXRDLENBRk47O0FBSUEsWUFBSTJILGNBQWMsSUFBSWhOLE9BQUosQ0FBWSxVQUFVQyxPQUFWLEVBQW1CaU0sTUFBbkIsRUFBMkI7QUFDckQsZ0JBQUllLFVBQVU7QUFDVmxFLDhCQUFjMkQsbUJBQW1COUQsS0FEdkI7QUFFVnNFLHVCQUFPLEdBRkc7QUFHVkMsZ0NBQWdCLENBSE47QUFJVkMscUJBQU0vSCxhQUFhLE1BQWQsR0FBd0IsQ0FBeEIsR0FBNEIsQ0FKdkI7QUFLVm9ILHdCQUFRQTtBQUxFLGFBQWQ7O0FBUUE3SSx1QkFBV29FLFNBQVgsQ0FBcUIsY0FBckIsRUFBcUNpRixPQUFyQyxFQUE4Q2hOLE9BQTlDLEVBQXVELFVBQVVpSSxPQUFWLEVBQW1CZ0IsT0FBbkIsRUFBNEI7QUFDL0VnRCx1QkFBTztBQUNIbUIsMEJBQU1uRixPQURIO0FBRUh4SSwwQkFBTXdKO0FBRkgsaUJBQVA7QUFJSCxhQUxEO0FBTUgsU0FmaUIsQ0FBbEI7O0FBaUJBbEosZ0JBQVF1QyxHQUFSLENBQVksQ0FDUnlLLFdBRFEsRUFFUkYsU0FGUSxDQUFaLEVBR0d2UCxJQUhILENBR1EsVUFBVTRHLEdBQVYsRUFBZTtBQUNuQixnQkFBSXpFLE9BQU95RSxJQUFJLENBQUosQ0FBWDtBQUNBLGdCQUFJcUksa0JBQWtCckksSUFBSSxDQUFKLENBQXRCO0FBQ0EsZ0JBQUltSixrQkFBa0IsS0FBdEIsQ0FIbUIsQ0FHVTs7QUFFN0I7QUFDQSxnQkFBSUMsV0FBVyxFQUFmO0FBQUEsZ0JBQ0lDLFlBREo7O0FBR0FBLDJCQUFlLFlBQVc7QUFDdEIsb0JBQUk3QixXQUFKLEVBQWlCQyxVQUFqQixFQUE2QjZCLGFBQTdCLEVBQ0lDLGdCQURKOztBQUdBdE8sK0JBQWV0QyxHQUFmLENBQW1COFAsT0FBbkIsRUFBNEIsQ0FBNUI7O0FBRUFqQiw4QkFBZXZNLGVBQWUxQyxHQUFmLENBQW1CLGdCQUFnQmdILGFBQW5DLE1BQXNELElBQXJFO0FBQ0FrSSw2QkFBY3hNLGVBQWUxQyxHQUFmLENBQW1CLGlCQUFpQmdILGFBQXBDLE1BQXVELElBQXJFO0FBQ0ErSixnQ0FBaUJyTyxlQUFlMUMsR0FBZixDQUFtQixtQkFBbkIsRUFBd0MsRUFBQ2lCLGFBQWEyTCxNQUFkLEVBQXNCekwsUUFBUSxJQUE5QixFQUFvQ0MsUUFBUSxJQUE1QyxFQUF4QyxFQUEyRjRGLGFBQTNGLE1BQThHVCxTQUEvSDs7QUFFQSxvQkFBSVEsZ0JBQWdCQyxhQUFoQixLQUFrQ0EsYUFBdEMsRUFBcUQ7QUFDakQ7QUFDQSx3QkFBSWlJLGVBQWVDLFVBQWYsSUFBNkI2QixhQUFqQyxFQUFnRDtBQUM1QztBQUNBekssaURBQXlCVSxhQUF6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQWdLLDJDQUFvQnRPLGVBQWUxQyxHQUFmLENBQW1CLG9CQUFuQixFQUF5QyxFQUFDaUIsYUFBYTJMLE1BQWQsRUFBc0J6TCxRQUFRLElBQTlCLEVBQW9DQyxRQUFRLElBQTVDLEVBQXpDLEVBQTRGMkYsZ0JBQWdCQyxhQUE1RyxNQUErSFQsU0FBbko7QUFDQSw0QkFBSXlLLGdCQUFKLEVBQXNCO0FBQ2xCMU4sb0NBQVF1QyxHQUFSLENBQVksQ0FDUixvREFBQUMsQ0FBZ0JxSixpQkFBaEIsQ0FBa0NuSSxhQUFsQyxDQURRLEVBRVIsb0RBQUFsQixDQUFnQnNKLGtCQUFoQixDQUFtQ3BJLGFBQW5DLENBRlEsQ0FBWixFQUdHbkcsSUFISCxDQUdRLFlBQVk7QUFDaEJKLHVDQUFPb0csT0FBUCxDQUFlQyxXQUFmLENBQTJCO0FBQ3ZCaUQsNENBQVEsSUFEZTtBQUV2QnNGLDJDQUFPLE1BRmdCO0FBR3ZCckksbURBQWVELGdCQUFnQkMsYUFIUjtBQUl2QnNJLG9EQUFnQnZJLGdCQUFnQndILE9BQWhCLEdBQTBCeEgsZ0JBQWdCd0gsT0FBaEIsQ0FBd0JnQixHQUFsRCxHQUF3RDtBQUpqRCxpQ0FBM0I7QUFNSCw2QkFWRDtBQVdIO0FBQ0o7QUFDSjtBQUNKLGFBbkNEOztBQXFDQTtBQUNBLGdCQUFJdk0sS0FBS3VJLFFBQUwsS0FBa0IsQ0FBbEIsSUFBd0J2SSxLQUFLdUksUUFBTCxZQUF5QjBGLEtBQXpCLElBQWtDak8sS0FBS3VJLFFBQUwsQ0FBYzVGLE1BQWQsS0FBeUIsQ0FBbkYsSUFBeUY3QyxhQUE3RixFQUE0RztBQUN4R2dPO0FBQ0E7QUFDSDs7QUFFRDFLLHdCQUFZWSxhQUFaLEVBQTJCMkIsUUFBM0IsRUFBcUMsQ0FBckMsSUFBMEMzRixLQUFLdUksUUFBTCxDQUFjLENBQWQsQ0FBMUM7O0FBRUEsZ0JBQUlsRixlQUFlVyxhQUFmLE1BQWtDVCxTQUF0QyxFQUFpRDtBQUM3Q0YsK0JBQWVXLGFBQWYsSUFBZ0MsRUFBaEM7QUFDSDs7QUFFRDtBQUNBdkMsY0FBRU0sT0FBRixDQUFVL0IsS0FBS3VJLFFBQWYsRUFBeUIsVUFBVXhDLE9BQVYsRUFBbUJtSSxLQUFuQixFQUEwQjtBQUMvQyxvQkFBSUMsTUFBSjs7QUFFQTtBQUNBLG9CQUFJLENBQUNELEtBQUwsRUFDSTs7QUFFSixvQkFBSW5JLFFBQVFRLEdBQVIsS0FBZ0J1RyxlQUFwQixFQUFxQztBQUNqQ2Msc0NBQWtCLElBQWxCO0FBQ0EsMkJBQU8sS0FBUDtBQUNIOztBQUVEO0FBQ0E7QUFDQTdILHdCQUFRRCxXQUFSLEdBQXNCQyxRQUFRRCxXQUFSLElBQXVCLEVBQTdDOztBQUVBO0FBQ0Esb0JBQUlDLFFBQVFPLEdBQVIsSUFBZVAsUUFBUU8sR0FBUixDQUFZOUosSUFBWixLQUFxQixPQUF4QyxFQUFpRDtBQUM3QzJSLDZCQUFTcEksUUFBUU8sR0FBUixDQUFZOEgsV0FBWixDQUF3QnhTLEtBQXhCLENBQThCLEdBQTlCLENBQVQ7O0FBRUFtSyw0QkFBUUQsV0FBUixDQUFvQk0sSUFBcEIsQ0FBeUI7QUFDckI1Siw4QkFBTSxVQURlO0FBRXJCNlIsa0NBQVU7QUFDTkMsaUNBQUtILE9BQU8sQ0FBUCxDQURDO0FBRU5JLGlDQUFLSixPQUFPLENBQVA7QUFGQztBQUZXLHFCQUF6QjtBQU9IOztBQUVEcEksd0JBQVFZLE9BQVIsR0FBa0JaLFFBQVFZLE9BQVIsSUFBbUIsQ0FBckM7QUFDQVosd0JBQVFhLElBQVIsR0FBZSxDQUFDakIsUUFBRCxDQUFmOztBQUVBLG9CQUFJSSxRQUFRRCxXQUFSLENBQW9CbkQsTUFBeEIsRUFDSW9ELFFBQVFhLElBQVIsQ0FBYVIsSUFBYixDQUFrQixhQUFsQjs7QUFFSjtBQUNBLG9CQUFJLENBQUMvQyxlQUFlVyxhQUFmLEVBQThCK0IsUUFBUTVGLEdBQXRDLENBQUwsRUFBaUQ7QUFDN0MyQyxvQkFBQSxvREFBQUEsQ0FBZ0I0RSxjQUFoQixDQUErQjFELGFBQS9CLEVBQThDK0IsUUFBUTVGLEdBQXRELEVBQTJELElBQTNELEVBQWlFLFVBQVVyRSxHQUFWLEVBQWU7QUFDNUU2TCx1Q0FBZTNELGFBQWYsRUFBOEIrQixRQUFRNUYsR0FBdEM7QUFDSCxxQkFGRDtBQUdIOztBQUVEME4seUJBQVN6SCxJQUFULENBQWNMLE9BQWQ7QUFDQSxvQkFBSUEsUUFBUVcsVUFBUixLQUF1QixDQUF2QixJQUE0QmhILGVBQWUxQyxHQUFmLENBQW1Ca1EsT0FBbkIsTUFBZ0MsSUFBaEUsRUFBc0U7QUFDbEU7QUFDQTtBQUNIO0FBQ0osYUEvQ0Q7O0FBaURBcEssWUFBQSxvREFBQUEsQ0FBZ0JnRSxjQUFoQixDQUErQjlDLGFBQS9CLEVBQThDNkosUUFBOUMsRUFBd0QsWUFBWTtBQUNoRXpLLDRCQUFZWSxhQUFaLEVBQTJCMkIsUUFBM0IsRUFBcUMsQ0FBckMsS0FBMkNrSSxTQUFTbEwsTUFBcEQ7O0FBRUFsRix1QkFBT29HLE9BQVAsQ0FBZUMsV0FBZixDQUEyQjtBQUN2Qiw4QkFBVyxjQURZO0FBRXZCLDhCQUFXRSxhQUZZO0FBR3ZCLDRCQUFTMkIsUUFIYztBQUl2Qiw2QkFBVXZDLFlBQVlZLGFBQVosRUFBMkIyQixRQUEzQixFQUFxQyxDQUFyQyxDQUphO0FBS3ZCLCtCQUFZdkMsWUFBWVksYUFBWixFQUEyQjJCLFFBQTNCLEVBQXFDLENBQXJDO0FBTFcsaUJBQTNCOztBQVFBLG9CQUFJaUksbUJBQW1CeEssWUFBWVksYUFBWixFQUEyQjJCLFFBQTNCLEVBQXFDLENBQXJDLElBQTBDM0YsS0FBS3VJLFFBQUwsQ0FBYyxDQUFkLENBQWpFLEVBQW1GO0FBQy9FdUY7QUFDQTtBQUNIOztBQUVEekYseUJBQVNyRSxhQUFULEVBQXdCMkIsUUFBeEIsRUFBa0NtSCxlQUFsQztBQUNILGFBakJELEVBaUJHckwsRUFBRUMsSUFqQkw7QUFrQkgsU0FqSUQsRUFpSUcsVUFBVTVGLEdBQVYsRUFBZTtBQUNkLGdCQUFJQSxJQUFJK1EsSUFBSixZQUFvQjJCLFFBQXhCLEVBQWtDO0FBQzlCLG9CQUFJcEosU0FBU3RKLElBQUkrUSxJQUFKLEdBQVcsSUFBWCxHQUFrQi9RLElBQUlHLE9BQW5DO0FBQ0Esc0JBQU0sSUFBSUQsS0FBSixDQUFVb0osTUFBVixDQUFOO0FBQ0g7O0FBRUQsb0JBQVF0SixJQUFJNlIsSUFBWjtBQUNJLHFCQUFLekosV0FBV3VFLGFBQWhCO0FBQ0k7QUFDQTs7QUFFSjtBQUNJeEwsNEJBQVFDLEdBQVIsQ0FBWSxRQUFaLEVBQXNCcEIsR0FBdEI7QUFDQXNHLDJCQUFPYixVQUFQLENBQWtCOEcsUUFBbEIsRUFBNEIsSUFBNUIsRUFBa0NyRSxhQUFsQyxFQUFpRDJCLFFBQWpELEVBQTJEbUgsZUFBM0Q7QUFDQTtBQVJSO0FBVUgsU0FqSkQ7QUFrSkgsS0E5S0Q7O0FBZ0xBOzs7Ozs7QUFNQSxRQUFJN0ksbUJBQW1CLFVBQVM4RSxRQUFULEVBQW1CO0FBQ3RDLFlBQUkvRSxnQkFBZ0JELGdCQUFnQkMsYUFBcEM7O0FBRUE7QUFDQUUsbUJBQVdDLFFBQVg7O0FBRUE7QUFDQXJCLFFBQUEsb0RBQUFBLENBQWdCMkwsUUFBaEIsQ0FBeUJ6SyxhQUF6QixFQUF3QyxZQUFZO0FBQ2hELGdCQUFJRCxnQkFBZ0JDLGFBQWhCLEtBQWtDQSxhQUF0QyxFQUNJOztBQUVKO0FBQ0FWLHFDQUF5QlMsZ0JBQWdCQyxhQUF6Qzs7QUFFQSxnQkFBSTBLLFVBQVVDLE1BQWQsRUFBc0I7QUFDbEJsRiw0QkFBWTFGLGdCQUFnQkMsYUFBNUI7QUFDQUksd0NBQXdCbkIsSUFBeEIsQ0FBNkJjLGdCQUFnQkMsYUFBN0M7O0FBRUFxRSx5QkFBU3RFLGdCQUFnQkMsYUFBekIsRUFBd0MsT0FBeEM7QUFDQXFFLHlCQUFTdEUsZ0JBQWdCQyxhQUF6QixFQUF3QyxNQUF4QztBQUNIOztBQUVELGdCQUFJLE9BQU8rRSxRQUFQLEtBQW9CLFVBQXhCLEVBQW9DO0FBQ2hDQTtBQUNIO0FBQ0osU0FsQkQsRUFrQkcsVUFBVTNELE1BQVYsRUFBa0I7QUFDakJsQyx1QkFBVzJCLEtBQVgsQ0FBaUJPLE1BQWpCO0FBQ0FDLGdCQUFJQyxTQUFKLENBQWMsaUJBQWQsRUFBaUMsb0JBQWpDLEVBQXVERixNQUF2RDtBQUNILFNBckJEOztBQXVCQTtBQUNBO0FBQ0FsQixtQkFBV29FLFNBQVgsQ0FBcUIsb0JBQXJCLEVBQTJDN0csRUFBRUMsSUFBN0M7QUFDSCxLQWpDRDs7QUFtQ0FqRSxXQUFPb0csT0FBUCxDQUFlK0ssU0FBZixDQUF5QkMsV0FBekIsQ0FBcUMsVUFBVUMsT0FBVixFQUFtQkMsTUFBbkIsRUFBMkJDLFlBQTNCLEVBQXlDO0FBQzFFLFlBQUlDLG9CQUFvQixLQUF4Qjs7QUFFQSxnQkFBUUgsUUFBUS9ILE1BQWhCO0FBQ0ksaUJBQUssaUJBQUw7QUFDSWhELGdDQUFnQm1MLE9BQWhCLENBQXdCSixRQUFRM08sR0FBaEMsRUFBcUMyTyxRQUFRNUYsS0FBN0MsRUFBb0QsS0FBcEQ7QUFDQW5GLGdDQUFnQkMsYUFBaEIsR0FBZ0M4SyxRQUFRM08sR0FBeEM7O0FBRUEsb0JBQUk2TixtQkFBbUJ0TyxlQUFlMUMsR0FBZixDQUFtQixvQkFBbkIsRUFBeUMsRUFBQ2lCLGFBQWEyTCxNQUFkLEVBQXNCekwsUUFBUSxJQUE5QixFQUFvQ0MsUUFBUSxJQUE1QyxFQUF6QyxDQUF2QjtBQUNBNFAsaUNBQWlCakssZ0JBQWdCQyxhQUFqQyxJQUFrRCxDQUFsRDtBQUNBdEUsK0JBQWV0QyxHQUFmLENBQW1CLG9CQUFuQixFQUF5QzRRLGdCQUF6Qzs7QUFFQS9KLGlDQUFpQixZQUFZO0FBQ3pCeEcsMkJBQU9vRyxPQUFQLENBQWVDLFdBQWYsQ0FBMkI7QUFDdkJpRCxnQ0FBUSxJQURlO0FBRXZCc0YsK0JBQU8sU0FGZ0I7QUFHdkJySSx1Q0FBZUQsZ0JBQWdCQyxhQUhSO0FBSXZCc0ksd0NBQWdCdkksZ0JBQWdCd0gsT0FBaEIsR0FBMEJ4SCxnQkFBZ0J3SCxPQUFoQixDQUF3QmdCLEdBQWxELEdBQXdEO0FBSmpELHFCQUEzQjtBQU1ILGlCQVBEOztBQVNBOztBQUVKLGlCQUFLLG1CQUFMO0FBQ0ksb0JBQUk0QyxpQkFBa0JwTCxnQkFBZ0JrRixJQUFoQixDQUFxQjZGLFFBQVEzTyxHQUE3QixNQUFzQ29ELFNBQTVEO0FBQ0Esb0JBQUksQ0FBQzRMLGNBQUwsRUFBcUI7QUFDakJwTCxvQ0FBZ0JtTCxPQUFoQixDQUF3QkosUUFBUTNPLEdBQWhDLEVBQXFDMk8sUUFBUTVGLEtBQTdDOztBQUVBO0FBQ0F6TCwyQkFBT29HLE9BQVAsQ0FBZUMsV0FBZixDQUEyQjtBQUN2QmlELGdDQUFRLGlDQURlO0FBRXZCNUcsNkJBQUsyTyxRQUFRM08sR0FGVTtBQUd2Qm9NLDZCQUFLeEksZ0JBQWdCa0YsSUFBaEIsQ0FBcUI2RixRQUFRM08sR0FBN0IsRUFBa0NvTTtBQUhoQixxQkFBM0I7O0FBTUE7QUFDSDs7QUFFRGxILG9CQUFJQyxTQUFKLENBQWMsYUFBZCxFQUE2QixrQkFBN0I7O0FBRUF2QixnQ0FBZ0JtTCxPQUFoQixDQUF3QkosUUFBUTNPLEdBQWhDLEVBQXFDMk8sUUFBUTVGLEtBQTdDLEVBQW9ELEtBQXBEO0FBQ0FuRixnQ0FBZ0JDLGFBQWhCLEdBQWdDOEssUUFBUTNPLEdBQXhDOztBQUVBLG9CQUFJNk4sbUJBQW1CdE8sZUFBZTFDLEdBQWYsQ0FBbUIsb0JBQW5CLEVBQXlDLEVBQUNpQixhQUFhMkwsTUFBZCxFQUFzQnpMLFFBQVEsSUFBOUIsRUFBb0NDLFFBQVEsSUFBNUMsRUFBekMsQ0FBdkI7QUFDQTRQLGlDQUFpQmpLLGdCQUFnQkMsYUFBakMsSUFBa0QsQ0FBbEQ7QUFDQXRFLCtCQUFldEMsR0FBZixDQUFtQixvQkFBbkIsRUFBeUM0USxnQkFBekM7O0FBRUEvSixpQ0FBaUIsWUFBWTtBQUN6QnhHLDJCQUFPb0csT0FBUCxDQUFlQyxXQUFmLENBQTJCO0FBQ3ZCaUQsZ0NBQVEsSUFEZTtBQUV2QnNGLCtCQUFPO0FBRmdCLHFCQUEzQjtBQUlILGlCQUxEOztBQU9BOztBQUVKLGlCQUFLLHFCQUFMO0FBQ0ksb0JBQUkrQyx5QkFBMEJOLFFBQVFPLFNBQVIsS0FBc0JQLFFBQVEzTyxHQUE1RDtBQUNBLG9CQUFJZ1AsaUJBQWlCLElBQXJCOztBQUVBLHFCQUFLLElBQUlHLFVBQVQsSUFBdUJ2TCxnQkFBZ0JrRixJQUF2QyxFQUE2QztBQUN6Q3FHLGlDQUFhQyxPQUFPRCxVQUFQLENBQWI7O0FBRUEsd0JBQUlBLGVBQWVSLFFBQVEzTyxHQUEzQixFQUFnQztBQUM1QmdQLHlDQUFpQixLQUFqQjtBQUNBO0FBQ0g7QUFDSjs7QUFFRCxvQkFBSUEsY0FBSixFQUFvQjtBQUNoQjtBQUNBMVIsMkJBQU9vRyxPQUFQLENBQWVDLFdBQWYsQ0FBMkI7QUFDdkJpRCxnQ0FBUSwyQkFEZTtBQUV2QjVHLDZCQUFLMk8sUUFBUTNPLEdBRlU7QUFHdkIrSSwrQkFBTzRGLFFBQVE1RjtBQUhRLHFCQUEzQjs7QUFNQTtBQUNIOztBQUVEbkYsZ0NBQWdCbUwsT0FBaEIsQ0FBd0JKLFFBQVEzTyxHQUFoQyxFQUFxQzJPLFFBQVE1RixLQUE3Qzs7QUFFQSxvQkFBSWtHLHNCQUFKLEVBQTRCO0FBQ3hCL0osd0JBQUlDLFNBQUosQ0FBYyxhQUFkLEVBQTZCLHVCQUE3Qjs7QUFFQTdILDJCQUFPb0csT0FBUCxDQUFlQyxXQUFmLENBQTJCO0FBQ3ZCaUQsZ0NBQVE7QUFEZSxxQkFBM0I7QUFHSCxpQkFORCxNQU1PO0FBQ0h0SiwyQkFBT29HLE9BQVAsQ0FBZUMsV0FBZixDQUEyQjtBQUN2QmlELGdDQUFRLDBCQURlO0FBRXZCNUcsNkJBQUsyTyxRQUFRM08sR0FGVTtBQUd2Qm9NLDZCQUFLeEksZ0JBQWdCa0YsSUFBaEIsQ0FBcUI2RixRQUFRM08sR0FBN0IsRUFBa0NvTTtBQUhoQixxQkFBM0I7QUFLSDs7QUFFRDs7QUFFSixpQkFBSyxpQkFBTDtBQUNJMEMsb0NBQW9CLElBQXBCOztBQUVBLG9CQUFJTyxXQUFXLEVBQWY7QUFDQSxvQkFBSUMsV0FBVyxFQUFmOztBQUVBLG9CQUFJQyxlQUFlLFVBQVVDLE9BQVYsRUFBbUJ4UCxHQUFuQixFQUF3QjtBQUN2QywyQkFBTyxJQUFJRyxPQUFKLENBQVksVUFBVUMsT0FBVixFQUFtQmlNLE1BQW5CLEVBQTJCO0FBQzFDMUosd0JBQUEsb0RBQUFBLENBQWdCNEUsY0FBaEIsQ0FBK0IzRCxnQkFBZ0JDLGFBQS9DLEVBQThEN0QsR0FBOUQsRUFBbUUsVUFBVXlQLFdBQVYsRUFBdUI7QUFDdEZELG9DQUFRMUksTUFBUixHQUFpQjJJLFlBQVkxSSxLQUE3QjtBQUNBM0c7QUFDSCx5QkFIRCxFQUdHLFVBQVV6RSxHQUFWLEVBQWU7QUFDZCxnQ0FBSUEsR0FBSixFQUFTO0FBQ0xvSCwyQ0FBVzJCLEtBQVgsQ0FBaUIvSSxNQUFNLEVBQXZCO0FBQ0g7O0FBRUR5RTtBQUNILHlCQVREO0FBVUgscUJBWE0sQ0FBUDtBQVlILGlCQWJEOztBQWVBa0Isa0JBQUVvTyxLQUFGLENBQVE5TCxnQkFBZ0JrRixJQUF4QixFQUE4QixVQUFVM0wsS0FBVixFQUFpQkQsR0FBakIsRUFBc0I7QUFDaERtUyw2QkFBU25TLEdBQVQsSUFBZ0JDLEtBQWhCO0FBQ0FtUyw2QkFBU3JKLElBQVQsQ0FBY3NKLGFBQWFwUyxLQUFiLEVBQW9CRCxHQUFwQixDQUFkO0FBQ0gsaUJBSEQ7O0FBS0FpRCx3QkFBUXVDLEdBQVIsQ0FBWTRNLFFBQVosRUFBc0I1UixJQUF0QixDQUEyQixZQUFZO0FBQ25DbVIsaUNBQWFRLFFBQWI7QUFDSCxpQkFGRDs7QUFJQTs7QUFFSixpQkFBSyxjQUFMO0FBQ0kvTixrQkFBRW9PLEtBQUYsQ0FBUWYsUUFBUWdCLFFBQWhCLEVBQTBCLFVBQVV4UyxLQUFWLEVBQWlCRCxHQUFqQixFQUFzQjtBQUM1Q3dFLG9DQUFnQnhFLEdBQWhCLElBQXVCQyxLQUF2QjtBQUNILGlCQUZEOztBQUlBO0FBQ0FHLHVCQUFPb0csT0FBUCxDQUFlQyxXQUFmLENBQTJCO0FBQ3ZCaUQsNEJBQVEsaUJBRGU7QUFFdkIrSSw4QkFBVW5PO0FBRmEsaUJBQTNCOztBQUtBOztBQUVKLGlCQUFLLHFCQUFMO0FBQ0ksb0JBQUlvTyx3QkFBd0IsNEJBQTVCO0FBQ0F0Uyx1QkFBT3VTLE1BQVAsQ0FBY2hULEdBQWQsQ0FBa0IrUyxxQkFBbEIsRUFBeUMsVUFBVUUsU0FBVixFQUFxQjtBQUMxRDtBQUNBLHdCQUFJQSxTQUFKLEVBQWU7QUFDWDtBQUNIOztBQUVEO0FBQ0F4UywyQkFBT3VTLE1BQVAsQ0FBYzVSLE1BQWQsQ0FBcUIyUixxQkFBckIsRUFBNEM7QUFDeENHLHdDQUFnQixLQUFLO0FBRG1CLHFCQUE1Qzs7QUFJQTtBQUNBblEsMkNBQXVCO0FBQ25CVyw0QkFBSSxxQkFEZTtBQUVuQkksK0JBQU9yRCxPQUFPME4sSUFBUCxDQUFZQyxVQUFaLENBQXVCLCtCQUF2QixDQUZZO0FBR25CblAsaUNBQVN3QixPQUFPME4sSUFBUCxDQUFZQyxVQUFaLENBQXVCLGlDQUF2QixDQUhVO0FBSW5CL0ssOEJBQU01QyxPQUFPb0csT0FBUCxDQUFlc0QsTUFBZixDQUFzQixnQkFBdEIsQ0FKYTtBQUtuQmhHLCtCQUFPO0FBTFkscUJBQXZCOztBQVFBa0Usd0JBQUlDLFNBQUosQ0FBYyxVQUFkLEVBQTBCLGdDQUExQjtBQUNILGlCQXJCRDs7QUF1QkE7O0FBRUosaUJBQUssUUFBTDtBQUNJMkosb0NBQW9CLElBQXBCO0FBQ0FELDZCQUFhLElBQWI7O0FBRUEsb0JBQUltQixNQUFKO0FBQ0Esb0JBQUlDLG9CQUFvQjFRLGVBQWUxQyxHQUFmLENBQW1CLG9CQUFuQixFQUF5QyxFQUFDaUIsYUFBYWdRLEtBQWQsRUFBcUI5UCxRQUFRLElBQTdCLEVBQW1DQyxRQUFRLElBQTNDLEVBQXpDLENBQXhCO0FBQ0Esb0JBQUk2TixXQUFKLEVBQWlCQyxVQUFqQixFQUE2QjZCLGFBQTdCO0FBQ0Esb0JBQUlDLGdCQUFKOztBQUVBLG9CQUFJakssZ0JBQWdCQyxhQUFwQixFQUFtQztBQUMvQmlJLGtDQUFldk0sZUFBZTFDLEdBQWYsQ0FBbUIsZ0JBQWdCK0csZ0JBQWdCQyxhQUFuRCxNQUFzRSxJQUFyRjtBQUNBa0ksaUNBQWN4TSxlQUFlMUMsR0FBZixDQUFtQixpQkFBaUIrRyxnQkFBZ0JDLGFBQXBELE1BQXVFLElBQXJGO0FBQ0ErSixvQ0FBaUJyTyxlQUFlMUMsR0FBZixDQUFtQixtQkFBbkIsRUFBd0MsRUFBQ2lCLGFBQWEyTCxNQUFkLEVBQXNCekwsUUFBUSxJQUE5QixFQUFvQ0MsUUFBUSxJQUE1QyxFQUF4QyxFQUEyRjJGLGdCQUFnQkMsYUFBM0csTUFBOEhULFNBQS9JOztBQUVBLHdCQUFJMEksZUFBZUMsVUFBZixJQUE2QjZCLGFBQWpDLEVBQWdEO0FBQzVDb0MsaUNBQVMsTUFBVDtBQUNILHFCQUZELE1BRU87QUFDSEEsaUNBQVMsU0FBVDtBQUNIO0FBQ0osaUJBVkQsTUFVTztBQUNIQSw2QkFBUyxPQUFUO0FBQ0g7O0FBRUQsd0JBQVFBLE1BQVI7QUFDSSx5QkFBSyxNQUFMO0FBQ0k5Syw0QkFBSWdMLFdBQUosQ0FBZ0IsT0FBaEI7QUFDQWhMLDRCQUFJQyxTQUFKLENBQWMsU0FBZCxFQUF5QixPQUF6QixFQUFrQ3ZCLGdCQUFnQkMsYUFBbEQ7O0FBRUF2RywrQkFBT0MsT0FBUCxDQUFlQyxLQUFmLENBQXFCUCxHQUFyQixDQUF5QjtBQUNyQiwwQ0FBYyxJQURPO0FBRXJCLDJDQUFlO0FBRk0seUJBQXpCOztBQUtBOztBQUVKLHlCQUFLLFNBQUw7QUFDSWlJLDRCQUFJZ0wsV0FBSixDQUFnQixTQUFoQjtBQUNBaEwsNEJBQUlDLFNBQUosQ0FBYyxTQUFkLEVBQXlCLFNBQXpCLEVBQW9DdkIsZ0JBQWdCQyxhQUFwRDtBQUNBOztBQUVKLHlCQUFLLE9BQUw7QUFDSXFCLDRCQUFJZ0wsV0FBSixDQUFnQixRQUFoQjtBQUNBaEwsNEJBQUlDLFNBQUosQ0FBYyxTQUFkLEVBQXlCLFFBQXpCO0FBQ0E7QUFwQlI7O0FBdUJBO0FBQ0E3SCx1QkFBT29HLE9BQVAsQ0FBZUMsV0FBZixDQUEyQjtBQUN2QmlELDRCQUFRLElBRGU7QUFFdkJzRiwyQkFBTzhELE1BRmdCO0FBR3ZCbk0sbUNBQWVELGdCQUFnQkMsYUFIUjtBQUl2QnNJLG9DQUFnQnZJLGdCQUFnQndILE9BQWhCLEdBQTBCeEgsZ0JBQWdCd0gsT0FBaEIsQ0FBd0JnQixHQUFsRCxHQUF3RDtBQUpqRCxpQkFBM0I7O0FBT0E7O0FBRUosaUJBQUssbUJBQUw7QUFDSSxvQkFBSXJMLHFCQUFxQjROLFFBQVF2SSxHQUE3QixDQUFKLEVBQXVDO0FBQ25DOUksMkJBQU93QyxhQUFQLENBQXFCdUIsS0FBckIsQ0FBMkJzTixRQUFRdkksR0FBbkMsRUFBd0M5RSxFQUFFQyxJQUExQztBQUNBLDJCQUFPUixxQkFBcUI0TixRQUFRdkksR0FBN0IsQ0FBUDtBQUNIOztBQUVEOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQUssa0JBQUw7QUFDSSxvQkFBSStKLGNBQWMsS0FBbEI7QUFBQSxvQkFDSUMsU0FESjtBQUFBLG9CQUVJQyxtQkFGSjs7QUFJQXZCLG9DQUFvQixJQUFwQjtBQUNBdUIsc0NBQXNCLFVBQVNDLFlBQVQsRUFBdUI7QUFDekMsd0JBQUlBLGFBQWE5TixNQUFiLEtBQXdCLENBQTVCLEVBQStCO0FBQzNCO0FBQ0g7O0FBRUQsd0JBQUkrTixjQUFjRCxhQUFhRSxHQUFiLENBQWlCLFVBQVNmLFdBQVQsRUFBc0I7QUFDckQsK0JBQU9BLFlBQVl6UCxHQUFuQjtBQUNILHFCQUZpQixDQUFsQjs7QUFJQStELCtCQUFXb0UsU0FBWCxDQUFxQixXQUFyQixFQUFrQyxFQUFDLFFBQVNvSSxZQUFZRSxJQUFaLENBQWlCLEdBQWpCLENBQVYsRUFBaUMsVUFBVyxRQUE1QyxFQUFsQyxFQUF5RixVQUFTNVEsSUFBVCxFQUFlO0FBQ3BHQSw2QkFBS3VJLFFBQUwsQ0FBY3hHLE9BQWQsQ0FBc0IsVUFBUzhPLEtBQVQsRUFBZ0I7QUFDbEMsZ0NBQUlDLFdBQVlELE1BQU1FLE1BQU4sS0FBaUIsQ0FBakIsSUFBc0JGLE1BQU1HLGFBQU4sS0FBd0IsQ0FBOUQ7QUFDQXZULG1DQUFPb0csT0FBUCxDQUFlQyxXQUFmLENBQTJCLEVBQUMsVUFBVyxxQkFBWixFQUFtQyxPQUFRK00sTUFBTTFRLEdBQWpELEVBQXNELFVBQVcyUSxRQUFqRSxFQUEzQjtBQUNILHlCQUhEO0FBSUgscUJBTEQ7QUFNSCxpQkFmRDs7QUFpQkFQLDRCQUFZbk8sT0FBT2IsVUFBUCxDQUFrQixZQUFXO0FBQ3JDLHdCQUFJMFAsc0JBQXVCdlIsZUFBZTFDLEdBQWYsQ0FBbUIsVUFBbkIsTUFBbUMsSUFBOUQ7QUFDQSx3QkFBSWlVLHdCQUF3QixLQUE1QixFQUFtQztBQUMvQjtBQUNIOztBQUVEWCxrQ0FBYyxJQUFkO0FBQ0F6TyxvQ0FBZ0JxUCxZQUFoQixHQUErQixDQUEvQjs7QUFFQXBPLG9CQUFBLG9EQUFBQSxDQUFnQnFPLGNBQWhCLENBQStCLE9BQS9CLEVBQXdDckMsUUFBUXNDLFVBQWhELEVBQTRELFVBQVM1TixRQUFULEVBQW1CO0FBQzNFd0wscUNBQWF4TCxRQUFiOztBQUVBLDRCQUFJM0IsZ0JBQWdCZ0csVUFBaEIsS0FBK0IsQ0FBbkMsRUFBc0M7QUFDbEMySSxnREFBb0JoTixTQUFTLENBQVQsQ0FBcEI7QUFDSDtBQUNKLHFCQU5ELEVBTUcsVUFBUzRCLE1BQVQsRUFBaUI7QUFDaEI0SixxQ0FBYSxDQUFDLEVBQUQsRUFBSyxDQUFMLENBQWI7QUFDQTlMLG1DQUFXMkIsS0FBWCxDQUFpQk8sTUFBakI7QUFDSCxxQkFURDtBQVVILGlCQW5CVyxFQW1CVCxJQW5CUyxDQUFaOztBQXFCQXRDLGdCQUFBLG9EQUFBQSxDQUFnQnFPLGNBQWhCLENBQStCckMsUUFBUXRTLElBQXZDLEVBQTZDc1MsUUFBUXNDLFVBQXJELEVBQWlFLFVBQVM1TixRQUFULEVBQW1CO0FBQ2hGLHdCQUFJOE0sV0FBSixFQUFpQjtBQUNiO0FBQ0g7O0FBRUR0QixpQ0FBYXhMLFFBQWI7QUFDQXBCLDJCQUFPaVAsWUFBUCxDQUFvQmQsU0FBcEI7O0FBRUEsd0JBQUkxTyxnQkFBZ0JnRyxVQUFoQixLQUErQixDQUFuQyxFQUFzQztBQUNsQzJJLDRDQUFvQmhOLFNBQVMsQ0FBVCxDQUFwQjtBQUNIO0FBQ0osaUJBWEQsRUFXRyxVQUFTNEIsTUFBVCxFQUFpQjtBQUNoQix3QkFBSWtMLFdBQUosRUFBaUI7QUFDYjtBQUNIOztBQUVEdEIsaUNBQWEsQ0FBQyxFQUFELEVBQUssQ0FBTCxDQUFiO0FBQ0E5TCwrQkFBVzJCLEtBQVgsQ0FBaUJPLE1BQWpCOztBQUVBaEQsMkJBQU9pUCxZQUFQLENBQW9CZCxTQUFwQjtBQUNILGlCQXBCRDs7QUFzQkE7O0FBRUosaUJBQUssb0JBQUw7QUFDSXRCLG9DQUFvQixJQUFwQjtBQUNBbk0sZ0JBQUEsb0RBQUFBLENBQWdCd08sZ0JBQWhCLENBQWlDeEMsUUFBUXNDLFVBQXpDLEVBQXFEcEMsWUFBckQsRUFBbUUsVUFBVTVKLE1BQVYsRUFBa0I7QUFDakY0SixpQ0FBYSxDQUFDLEVBQUQsRUFBSyxDQUFMLENBQWI7QUFDQTlMLCtCQUFXMkIsS0FBWCxDQUFpQk8sTUFBakI7QUFDSCxpQkFIRDs7QUFLQTs7QUFFSixpQkFBSyxpQkFBTDtBQUNJNkosb0NBQW9CLElBQXBCOztBQUVBbk0sZ0JBQUEsb0RBQUFBLENBQWdCeU8sZUFBaEIsQ0FBZ0N6QyxRQUFRcE8sRUFBeEMsRUFBNEM7QUFDeENnRiwwQkFBT29KLFFBQVFwSixJQUFSLEtBQWlCbkMsU0FBbEIsR0FBK0J1TCxRQUFRcEosSUFBdkMsR0FBOEMsQ0FEWjtBQUV4QzhMLGdDQUFZQyxRQUFRM0MsUUFBUTRDLEtBQWhCO0FBRjRCLGlCQUE1QyxFQUdHMUMsWUFISCxFQUdpQixVQUFVNUosTUFBVixFQUFrQjtBQUMvQjRKLGlDQUFhLENBQUMsRUFBRCxFQUFLLENBQUwsQ0FBYjtBQUNBOUwsK0JBQVcyQixLQUFYLENBQWlCTyxNQUFqQjtBQUNILGlCQU5EOztBQVFBOztBQUVKLGlCQUFLLGdCQUFMO0FBQ0k2SixvQ0FBb0IsSUFBcEI7QUFDQW5NLGdCQUFBLG9EQUFBQSxDQUFnQjZPLGNBQWhCLENBQStCcEMsT0FBT1QsUUFBUXZJLEdBQWYsQ0FBL0IsRUFBb0R5SSxZQUFwRCxFQUFrRSxVQUFVN0osZUFBVixFQUEyQkMsTUFBM0IsRUFBbUM7QUFDakc0SixpQ0FBYXpMLFNBQWI7O0FBRUEsd0JBQUk0QixlQUFKLEVBQXFCO0FBQ2pCakMsbUNBQVcyQixLQUFYLENBQWlCTyxNQUFqQjtBQUNBQyw0QkFBSUMsU0FBSixDQUFjLGVBQWQsRUFBK0IsZ0JBQS9CLEVBQWlERixNQUFqRDtBQUNIO0FBQ0osaUJBUEQ7O0FBU0E7O0FBRUosaUJBQUssbUNBQUw7QUFDSTZKLG9DQUFvQixJQUFwQjtBQUNBbk0sZ0JBQUEsb0RBQUFBLENBQWdCOE8saUNBQWhCLENBQWtEOUMsUUFBUTNPLEdBQTFELEVBQStENk8sWUFBL0QsRUFBNkUsVUFBVTVKLE1BQVYsRUFBa0I7QUFDM0Y0SixpQ0FBYSxFQUFiO0FBQ0E5TCwrQkFBVzJCLEtBQVgsQ0FBaUJPLE1BQWpCO0FBQ0gsaUJBSEQ7O0FBS0E7O0FBRUosaUJBQUssZ0JBQUw7QUFDSTZKLG9DQUFvQixJQUFwQjtBQUNBbk0sZ0JBQUEsb0RBQUFBLENBQWdCNEUsY0FBaEIsQ0FBK0IzRCxnQkFBZ0JDLGFBQS9DLEVBQThEOEssUUFBUTNPLEdBQXRFLEVBQTJFNk8sWUFBM0UsRUFBeUYsVUFBVWxULEdBQVYsRUFBZTtBQUNwR2tULGlDQUFhLElBQWI7QUFDSCxpQkFGRDs7QUFJQSxvQkFBSW5OLGdCQUFnQmdHLFVBQWhCLEtBQStCLENBQS9CLElBQW9DaUgsUUFBUStDLG1CQUFoRCxFQUFxRTtBQUNqRTNOLCtCQUFXb0UsU0FBWCxDQUFxQixXQUFyQixFQUFrQyxFQUFDLFFBQVN3RyxRQUFRM08sR0FBbEIsRUFBdUIsVUFBVyxRQUFsQyxFQUFsQyxFQUErRSxVQUFTSCxJQUFULEVBQWU7QUFDMUZBLDZCQUFLdUksUUFBTCxDQUFjeEcsT0FBZCxDQUFzQixVQUFTOE8sS0FBVCxFQUFnQjtBQUNsQyxnQ0FBSUMsV0FBWUQsTUFBTUUsTUFBTixLQUFpQixDQUFqQixJQUFzQkYsTUFBTUcsYUFBTixLQUF3QixDQUE5RDtBQUNBdlQsbUNBQU9vRyxPQUFQLENBQWVDLFdBQWYsQ0FBMkIsRUFBQyxVQUFXLHFCQUFaLEVBQW1DLE9BQVErTSxNQUFNMVEsR0FBakQsRUFBc0QsVUFBVzJRLFFBQWpFLEVBQTNCO0FBQ0gseUJBSEQ7QUFJSCxxQkFMRDtBQU1IOztBQUVEOztBQUVKO0FBQ0EsaUJBQUssVUFBTDtBQUNJekwsb0JBQUlDLFNBQUosQ0FBYyxlQUFkLEVBQStCd0osUUFBUWpLLEtBQXZDLEVBQThDaUssUUFBUTdTLE9BQXREO0FBQ0E7O0FBRUosaUJBQUssYUFBTDtBQUNJLG9CQUFJNlYsWUFBWSxFQUFoQjtBQUNBN0Msb0NBQW9CLElBQXBCOztBQUVBLG9CQUFJSCxRQUFRckksSUFBUixLQUFpQmxELFNBQXJCLEVBQWdDO0FBQzVCdU8sOEJBQVU3VixPQUFWLEdBQW9CNlMsUUFBUXJJLElBQTVCO0FBQ0g7O0FBRUQsb0JBQUlxSSxRQUFRaUQsT0FBUixLQUFvQnhPLFNBQXhCLEVBQW1DO0FBQy9CdU8sOEJBQVVoUixLQUFWLEdBQWtCZ08sUUFBUWlELE9BQTFCO0FBQ0g7O0FBRUQsb0JBQUlqRCxRQUFRa0QsR0FBUixLQUFnQnpPLFNBQXBCLEVBQStCO0FBQzNCdU8sOEJBQVVHLFdBQVYsR0FBd0JuRCxRQUFRa0QsR0FBaEM7QUFDSDs7QUFFRCxvQkFBSWxELFFBQVF6UixHQUFSLEtBQWdCa0csU0FBcEIsRUFBK0I7QUFDM0J1Tyw4QkFBVUksV0FBVixHQUF3QnBELFFBQVF6UixHQUFoQztBQUNIOztBQUVELG9CQUFJeVIsUUFBUWhKLFdBQVIsQ0FBb0JuRCxNQUF4QixFQUFnQztBQUM1Qm1QLDhCQUFVSyxVQUFWLEdBQXVCckQsUUFBUWhKLFdBQVIsQ0FBb0I4SyxJQUFwQixDQUF5QixHQUF6QixDQUF2QjtBQUNIOztBQUVELG9CQUFJLFVBQVV3QixJQUFWLENBQWV0RCxRQUFRdUQsRUFBdkIsQ0FBSixFQUFnQztBQUM1QlAsOEJBQVVuTCxPQUFWLEdBQW9CbUksUUFBUXVELEVBQTVCO0FBQ0gsaUJBRkQsTUFFTztBQUNIUCw4QkFBVTNSLEdBQVYsR0FBZ0IyTyxRQUFRdUQsRUFBUixDQUFXelcsS0FBWCxDQUFpQixHQUFqQixFQUFzQixDQUF0QixDQUFoQjtBQUNIOztBQUVELG9CQUFJa1QsUUFBUVgsTUFBUixLQUFtQjVLLFNBQXZCLEVBQWtDO0FBQzlCdU8sOEJBQVV4RCxHQUFWLEdBQWdCUSxRQUFRWCxNQUFSLENBQWVtRSxRQUEvQjtBQUNBUiw4QkFBVVMsSUFBVixHQUFpQnpELFFBQVFYLE1BQVIsQ0FBZXFFLFNBQWhDO0FBQ0g7O0FBRUR0TywyQkFBV29FLFNBQVgsQ0FBcUIsZUFBckIsRUFBc0N3SixTQUF0QyxFQUFpRCxVQUFTOVIsSUFBVCxFQUFlO0FBQzVEcUYsd0JBQUlDLFNBQUosQ0FBYyxhQUFkLEVBQTZCLGNBQTdCLEVBQTZDdkIsZ0JBQWdCQyxhQUE3RDtBQUNBNUMsaUNBQWFDLElBQWIsQ0FBa0IsTUFBbEI7O0FBRUEyTixpQ0FBYSxDQUFDLENBQUQsRUFBSWhQLElBQUosQ0FBYjtBQUNILGlCQUxELEVBS0csVUFBU3dJLE9BQVQsRUFBa0JnQixPQUFsQixFQUEyQjtBQUMxQm5FLHdCQUFJQyxTQUFKLENBQWMsZUFBZCxFQUErQix3QkFBL0IsRUFBeURrRCxPQUF6RDtBQUNBcEgsaUNBQWFDLElBQWIsQ0FBa0IsT0FBbEI7O0FBRUEsNEJBQVFtSCxPQUFSO0FBQ0ksNkJBQUt0RSxXQUFXdU8sT0FBaEI7QUFDSXpELHlDQUFhLENBQUMsQ0FBRCxFQUFJeEYsT0FBSixDQUFiO0FBQ0E7O0FBRUo7QUFDSSxnQ0FBSWhCLFlBQVl0RSxXQUFXd08sY0FBdkIsSUFBeUNsSixRQUFRbUUsSUFBUixLQUFpQixDQUE5RCxFQUFpRTtBQUM3RHFCLDZDQUFhLENBQUMsQ0FBRCxDQUFiO0FBQ0E7QUFDSDs7QUFFREEseUNBQWEsQ0FBQyxDQUFELENBQWI7QUFDQTtBQVpSO0FBY0gsaUJBdkJEOztBQXlCQTs7QUFFSixpQkFBSyx5QkFBTDtBQUNJLG9CQUFJMkQsY0FBYyxZQUFXO0FBQ3pCek8sK0JBQVdvRSxTQUFYLENBQXFCLGdDQUFyQixFQUF1RDBHLFlBQXZELEVBQXFFLFVBQVN4RyxPQUFULEVBQWtCZ0IsT0FBbEIsRUFBMkI7QUFDNUYsZ0NBQVFoQixPQUFSO0FBQ0ksaUNBQUt0RSxXQUFXME8sV0FBaEI7QUFDQSxpQ0FBSzFPLFdBQVcyTyxRQUFoQjtBQUNBLGlDQUFLM08sV0FBVzRPLE9BQWhCO0FBQ0EsaUNBQUs1TyxXQUFXd08sY0FBaEI7QUFDSXRRLHVDQUFPYixVQUFQLENBQWtCb1IsV0FBbEIsRUFBK0IsSUFBRSxJQUFqQztBQUNBOztBQUVKO0FBQ0kzRCw2Q0FBYSxJQUFiO0FBVFI7QUFXSCxxQkFaRDtBQWFILGlCQWREOztBQWdCQTJEO0FBQ0ExRCxvQ0FBb0IsSUFBcEI7QUFDQTs7QUFFSixpQkFBSyxxQkFBTDtBQUNJLG9CQUFJMEQsY0FBYyxZQUFXO0FBQ3pCek8sK0JBQVdvRSxTQUFYLENBQXFCLHNCQUFyQixFQUE2QzBHLFlBQTdDLEVBQTJELFVBQVN4RyxPQUFULEVBQWtCZ0IsT0FBbEIsRUFBMkI7QUFDbEYsZ0NBQVFoQixPQUFSO0FBQ0ksaUNBQUt0RSxXQUFXME8sV0FBaEI7QUFDQSxpQ0FBSzFPLFdBQVcyTyxRQUFoQjtBQUNBLGlDQUFLM08sV0FBVzRPLE9BQWhCO0FBQ0EsaUNBQUs1TyxXQUFXd08sY0FBaEI7QUFDSXRRLHVDQUFPYixVQUFQLENBQWtCb1IsV0FBbEIsRUFBK0IsSUFBRSxJQUFqQztBQUNBOztBQUVKO0FBQ0kzRCw2Q0FBYSxJQUFiO0FBVFI7QUFXSCxxQkFaRDtBQWFILGlCQWREOztBQWdCQTJEO0FBQ0ExRCxvQ0FBb0IsSUFBcEI7QUFDQTs7QUFFSixpQkFBSyxtQkFBTDtBQUNJLG9CQUFJMEQsY0FBYyxVQUFTSSxXQUFULEVBQXNCO0FBQ3BDN08sK0JBQVdvRSxTQUFYLENBQXFCLDBCQUFyQixFQUFpRDtBQUM3QyxrQ0FBV3lLLFlBQVluSyxNQURzQjtBQUU3QyxpQ0FBVW1LLFlBQVk3TCxLQUZ1QjtBQUc3QyxnQ0FBUzZMLFlBQVlDO0FBSHdCLHFCQUFqRCxFQUlHaEUsWUFKSCxFQUlpQixVQUFTeEcsT0FBVCxFQUFrQmdCLE9BQWxCLEVBQTJCO0FBQ3hDLGdDQUFRaEIsT0FBUjtBQUNJLGlDQUFLdEUsV0FBVzBPLFdBQWhCO0FBQ0EsaUNBQUsxTyxXQUFXMk8sUUFBaEI7QUFDQSxpQ0FBSzNPLFdBQVc0TyxPQUFoQjtBQUNBLGlDQUFLNU8sV0FBV3dPLGNBQWhCO0FBQ0l0USx1Q0FBT2IsVUFBUCxDQUFrQm9SLFdBQWxCLEVBQStCLElBQUUsSUFBakMsRUFBdUNJLFdBQXZDO0FBQ0E7O0FBRUo7QUFDSS9ELDZDQUFhLElBQWI7QUFUUjtBQVdILHFCQWhCRDtBQWlCSCxpQkFsQkQ7O0FBb0JBMkQsNEJBQVk3RCxPQUFaO0FBQ0FHLG9DQUFvQixJQUFwQjtBQUNBOztBQUVKLGlCQUFLLGlCQUFMO0FBQ0ksb0JBQUkwRCxjQUFjLFVBQVNJLFdBQVQsRUFBc0I7QUFDcEM3TywrQkFBV29FLFNBQVgsQ0FBcUIsV0FBckIsRUFBa0M7QUFDOUIsZ0NBQVN5SyxZQUFZNVc7QUFEUyxxQkFBbEMsRUFFRzZTLFlBRkgsRUFFaUIsVUFBU3hHLE9BQVQsRUFBa0JnQixPQUFsQixFQUEyQjtBQUN4QyxnQ0FBUWhCLE9BQVI7QUFDSSxpQ0FBS3RFLFdBQVcwTyxXQUFoQjtBQUNBLGlDQUFLMU8sV0FBVzJPLFFBQWhCO0FBQ0EsaUNBQUszTyxXQUFXNE8sT0FBaEI7QUFDQSxpQ0FBSzVPLFdBQVd3TyxjQUFoQjtBQUNJdFEsdUNBQU9iLFVBQVAsQ0FBa0JvUixXQUFsQixFQUErQixJQUFFLElBQWpDLEVBQXVDSSxXQUF2QztBQUNBOztBQUVKO0FBQ0kvRCw2Q0FBYSxJQUFiO0FBVFI7QUFXSCxxQkFkRDtBQWVILGlCQWhCRDs7QUFrQkEyRCw0QkFBWTdELE9BQVo7QUFDQUcsb0NBQW9CLElBQXBCO0FBQ0E7O0FBRUosaUJBQUssU0FBTDtBQUNJNUosb0JBQUlDLFNBQUosQ0FBYyxhQUFkLEVBQTZCLGlCQUE3QjtBQUNBMkosb0NBQW9CLElBQXBCOztBQUVBLG9CQUFJZ0Usa0JBQWtCLFlBQVc7QUFDN0IvTywrQkFBV29FLFNBQVgsQ0FBcUIsY0FBckIsRUFBcUM7QUFDakMsb0NBQWEsQ0FBQyxRQURtQjtBQUVqQyxtQ0FBWSxHQUZxQjtBQUdqQyxrQ0FBVztBQUhzQixxQkFBckMsRUFJRyxVQUFTdEksSUFBVCxFQUFlO0FBQ2RnUCxxQ0FBYSxDQUFiO0FBQ0gscUJBTkQsRUFNRyxVQUFTeEcsT0FBVCxFQUFrQmdCLE9BQWxCLEVBQTJCO0FBQzFCLGdDQUFRaEIsT0FBUjtBQUNJLGlDQUFLdEUsV0FBVzBPLFdBQWhCO0FBQ0EsaUNBQUsxTyxXQUFXMk8sUUFBaEI7QUFDQSxpQ0FBSzNPLFdBQVc0TyxPQUFoQjtBQUNJMVEsdUNBQU9iLFVBQVAsQ0FBa0IwUixlQUFsQixFQUFtQyxJQUFFLElBQXJDO0FBQ0E7O0FBRUosaUNBQUsvTyxXQUFXd08sY0FBaEI7QUFDSSxvQ0FBSWxKLFFBQVFtRSxJQUFSLEtBQWlCLEdBQWpCLElBQXdCbkUsUUFBUW1FLElBQVIsS0FBaUIsR0FBN0MsRUFBa0Q7QUFDOUNxQixpREFBYSxDQUFiO0FBQ0E7QUFDSDs7QUFFRDVNLHVDQUFPYixVQUFQLENBQWtCMFIsZUFBbEIsRUFBbUMsSUFBRSxJQUFyQztBQUNBOztBQUVKO0FBQ0lqRSw2Q0FBYSxDQUFiO0FBakJSO0FBbUJILHFCQTFCRDtBQTJCSCxpQkE1QkQ7O0FBOEJBLG9CQUFJa0UsdUJBQXVCLFlBQVc7QUFDbENoUCwrQkFBV29FLFNBQVgsQ0FBcUIsYUFBckIsRUFBb0M7QUFDaEMsK0JBQVE7QUFEd0IscUJBQXBDLEVBRUcsSUFGSCxFQUVTLFVBQVNFLE9BQVQsRUFBa0JnQixPQUFsQixFQUEyQjtBQUNoQyxnQ0FBUWhCLE9BQVI7QUFDSSxpQ0FBS3RFLFdBQVcwTyxXQUFoQjtBQUNBLGlDQUFLMU8sV0FBVzJPLFFBQWhCO0FBQ0EsaUNBQUszTyxXQUFXNE8sT0FBaEI7QUFDQSxpQ0FBSzVPLFdBQVd3TyxjQUFoQjtBQUNJdFEsdUNBQU9iLFVBQVAsQ0FBa0IyUixvQkFBbEIsRUFBd0MsSUFBRSxJQUExQztBQUNBO0FBTlI7QUFRSCxxQkFYRDtBQVlILGlCQWJEOztBQWVBRDtBQUNBQztBQUNBOztBQUVKLGlCQUFLLFlBQUw7QUFDSTtBQUNBO0FBQ0Esb0JBQUlQLFdBQUo7O0FBRUExRCxvQ0FBb0IsSUFBcEI7O0FBRUEsb0JBQUlILFFBQVF2SSxHQUFSLEtBQWdCaEQsU0FBcEIsRUFBK0I7QUFDM0JvUCxrQ0FBYyxVQUFTSSxXQUFULEVBQXNCO0FBQ2hDQSxvQ0FBWUksT0FBWixHQUFzQnZMLFNBQVNtTCxZQUFZSSxPQUFyQixFQUE4QixFQUE5QixDQUF0QjtBQUNBSixvQ0FBWXJTLEVBQVosR0FBaUJrSCxTQUFTbUwsWUFBWXJTLEVBQXJCLEVBQXlCLEVBQXpCLENBQWpCOztBQUVBd0QsbUNBQVdvRSxTQUFYLENBQXFCLGtCQUFyQixFQUF5QyxFQUFDLE9BQVF5SyxZQUFZeE0sR0FBckIsRUFBekMsRUFBb0UsVUFBU3ZHLElBQVQsRUFBZTtBQUMvRSxnQ0FBS0EsS0FBS3VJLFFBQUwsWUFBeUIwRixLQUExQixLQUFxQyxLQUFyQyxJQUE4Q2pPLEtBQUt1SSxRQUFMLENBQWM1RixNQUFkLEtBQXlCLENBQXZFLElBQTRFM0MsS0FBS3VJLFFBQUwsQ0FBYyxDQUFkLEVBQWlCekMsV0FBakIsS0FBaUN2QyxTQUFqSCxFQUE0SDtBQUN4SDhCLG9DQUFJQyxTQUFKLENBQWMsZUFBZCxFQUErQix5QkFBL0IsRUFBMER5TixXQUExRDs7QUFFQS9ELDZDQUFhLElBQWI7QUFDQTtBQUNIOztBQUVELGdDQUFJbEUsQ0FBSjs7QUFFQSxpQ0FBS0EsSUFBSSxDQUFULEVBQVlBLElBQUk5SyxLQUFLdUksUUFBTCxDQUFjLENBQWQsRUFBaUJ6QyxXQUFqQixDQUE2Qm5ELE1BQTdDLEVBQXFEbUksR0FBckQsRUFBMEQ7QUFDdEQsb0NBQUk5SyxLQUFLdUksUUFBTCxDQUFjLENBQWQsRUFBaUJ6QyxXQUFqQixDQUE2QmdGLENBQTdCLEVBQWdDdE8sSUFBaEMsS0FBeUMsS0FBekMsSUFBa0R3RCxLQUFLdUksUUFBTCxDQUFjLENBQWQsRUFBaUJ6QyxXQUFqQixDQUE2QmdGLENBQTdCLEVBQWdDc0ksR0FBaEMsQ0FBb0NDLFFBQXBDLEtBQWlETixZQUFZSSxPQUEvRyxJQUEwSG5ULEtBQUt1SSxRQUFMLENBQWMsQ0FBZCxFQUFpQnpDLFdBQWpCLENBQTZCZ0YsQ0FBN0IsRUFBZ0NzSSxHQUFoQyxDQUFvQ0UsR0FBcEMsS0FBNENQLFlBQVlyUyxFQUF0TCxFQUEwTDtBQUN0THNPLGlEQUFhaFAsS0FBS3VJLFFBQUwsQ0FBYyxDQUFkLEVBQWlCekMsV0FBakIsQ0FBNkJnRixDQUE3QixFQUFnQ3NJLEdBQTdDO0FBQ0E7QUFDSDtBQUNKOztBQUVEL04sZ0NBQUlDLFNBQUosQ0FBYyxlQUFkLEVBQStCLHlCQUEvQixFQUEwRHlOLFdBQTFEO0FBQ0gseUJBbEJELEVBa0JHLFVBQVN2SyxPQUFULEVBQWtCZ0IsT0FBbEIsRUFBMkI7QUFDMUIsb0NBQVFoQixPQUFSO0FBQ0kscUNBQUt0RSxXQUFXME8sV0FBaEI7QUFDQSxxQ0FBSzFPLFdBQVcyTyxRQUFoQjtBQUNBLHFDQUFLM08sV0FBVzRPLE9BQWhCO0FBQ0EscUNBQUs1TyxXQUFXd08sY0FBaEI7QUFDSXRRLDJDQUFPYixVQUFQLENBQWtCb1IsV0FBbEIsRUFBK0IsSUFBRSxJQUFqQyxFQUF1Q0ksV0FBdkM7QUFDQTs7QUFFSjtBQUNJL0QsaURBQWEsSUFBYjtBQVRSO0FBV0gseUJBOUJEO0FBK0JILHFCQW5DRDtBQW9DSCxpQkFyQ0QsTUFxQ087QUFDSDJELGtDQUFjLFVBQVNJLFdBQVQsRUFBc0I7QUFDaEM3TyxtQ0FBV29FLFNBQVgsQ0FBcUIsY0FBckIsRUFBcUMsRUFBQyxRQUFTeUssWUFBWUksT0FBWixHQUFzQixHQUF0QixHQUE0QkosWUFBWXJTLEVBQWxELEVBQXJDLEVBQTRGLFVBQVNWLElBQVQsRUFBZTtBQUN2RyxnQ0FBSXVULFNBQVV2VCxLQUFLdUksUUFBTCxDQUFjNUYsTUFBZixHQUF5QjNDLEtBQUt1SSxRQUFMLENBQWMsQ0FBZCxDQUF6QixHQUE0QyxJQUF6RDtBQUNBLGdDQUFJZ0wsV0FBVyxJQUFmLEVBQXFCO0FBQ2pCbE8sb0NBQUlDLFNBQUosQ0FBYyxlQUFkLEVBQStCLHlCQUEvQixFQUEwRHlOLFdBQTFEO0FBQ0g7O0FBRUQvRCx5Q0FBYXVFLE1BQWI7QUFDSCx5QkFQRCxFQU9HLFVBQVMvSyxPQUFULEVBQWtCZ0IsT0FBbEIsRUFBMkI7QUFDMUIsb0NBQVFoQixPQUFSO0FBQ0kscUNBQUt0RSxXQUFXME8sV0FBaEI7QUFDQSxxQ0FBSzFPLFdBQVcyTyxRQUFoQjtBQUNBLHFDQUFLM08sV0FBVzRPLE9BQWhCO0FBQ0EscUNBQUs1TyxXQUFXd08sY0FBaEI7QUFDSXRRLDJDQUFPYixVQUFQLENBQWtCb1IsV0FBbEIsRUFBK0IsSUFBRSxJQUFqQyxFQUF1Q0ksV0FBdkM7QUFDQTs7QUFFSjtBQUNJL0QsaURBQWEsSUFBYjtBQVRSO0FBV0gseUJBbkJEO0FBb0JILHFCQXJCRDtBQXNCSDs7QUFFRDJELDRCQUFZN0QsT0FBWjtBQUNBOztBQUVKLGlCQUFLLGlCQUFMO0FBQ0lHLG9DQUFvQixJQUFwQjs7QUFFQSxvQkFBSTBELGNBQWMsVUFBU2EsS0FBVCxFQUFnQjtBQUM5QnRQLCtCQUFXb0UsU0FBWCxDQUFxQixrQkFBckIsRUFBeUMsRUFBQyxPQUFRa0wsS0FBVCxFQUF6QyxFQUEwRCxVQUFTeFQsSUFBVCxFQUFlO0FBQ3JFLDRCQUFLQSxLQUFLdUksUUFBTCxZQUF5QjBGLEtBQTFCLEtBQXFDLEtBQXJDLElBQThDak8sS0FBS3VJLFFBQUwsQ0FBYzVGLE1BQWQsS0FBeUIsQ0FBdkUsSUFBNEUzQyxLQUFLdUksUUFBTCxDQUFjLENBQWQsRUFBaUJqQyxHQUFqQixLQUF5Qi9DLFNBQXpHLEVBQW9IO0FBQ2hIOEIsZ0NBQUlDLFNBQUosQ0FBYyxlQUFkLEVBQStCLHlCQUEvQixFQUEwRHdKLE9BQTFEOztBQUVBRSx5Q0FBYSxJQUFiO0FBQ0E7QUFDSDs7QUFFRCw0QkFBSWIsU0FBU25PLEtBQUt1SSxRQUFMLENBQWMsQ0FBZCxFQUFpQmpDLEdBQWpCLENBQXFCOEgsV0FBckIsQ0FBaUN4UyxLQUFqQyxDQUF1QyxHQUF2QyxDQUFiO0FBQ0FvVCxxQ0FBYWIsTUFBYjtBQUNILHFCQVZELEVBVUcsVUFBUzNGLE9BQVQsRUFBa0JnQixPQUFsQixFQUEyQjtBQUMxQixnQ0FBUWhCLE9BQVI7QUFDSSxpQ0FBS3RFLFdBQVcwTyxXQUFoQjtBQUNBLGlDQUFLMU8sV0FBVzJPLFFBQWhCO0FBQ0EsaUNBQUszTyxXQUFXNE8sT0FBaEI7QUFDQSxpQ0FBSzVPLFdBQVd3TyxjQUFoQjtBQUNJdFEsdUNBQU9iLFVBQVAsQ0FBa0JvUixXQUFsQixFQUErQixJQUFFLElBQWpDLEVBQXVDYSxLQUF2QztBQUNBOztBQUVKO0FBQ0l4RSw2Q0FBYSxJQUFiO0FBVFI7QUFXSCxxQkF0QkQ7QUF1QkgsaUJBeEJEOztBQTBCQTJELDRCQUFZN0QsUUFBUXZJLEdBQXBCO0FBQ0E7O0FBRUosaUJBQUssY0FBTDtBQUNJLG9CQUFJb00sY0FBYyxVQUFTSSxXQUFULEVBQXNCO0FBQ3BDN08sK0JBQVdvRSxTQUFYLENBQXFCLGVBQXJCLEVBQXNDLEVBQUMsVUFBV3lLLFlBQVlJLE9BQVosR0FBc0IsR0FBdEIsR0FBNEJKLFlBQVlyUyxFQUFwRCxFQUF0QyxFQUErRixVQUFTVixJQUFULEVBQWU7QUFDMUcsNEJBQUl1VCxTQUFVdlQsS0FBS3VJLFFBQUwsQ0FBYzVGLE1BQWYsR0FBeUIzQyxLQUFLdUksUUFBTCxDQUFjLENBQWQsQ0FBekIsR0FBNEMsSUFBekQ7QUFDQSw0QkFBSWdMLFdBQVcsSUFBZixFQUFxQjtBQUNqQmxPLGdDQUFJQyxTQUFKLENBQWMsZUFBZCxFQUErQix5QkFBL0IsRUFBMER5TixXQUExRDtBQUNIOztBQUVEL0QscUNBQWF1RSxNQUFiO0FBQ0gscUJBUEQsRUFPRyxVQUFTL0ssT0FBVCxFQUFrQmdCLE9BQWxCLEVBQTJCO0FBQzFCLGdDQUFRaEIsT0FBUjtBQUNJLGlDQUFLdEUsV0FBVzBPLFdBQWhCO0FBQ0EsaUNBQUsxTyxXQUFXMk8sUUFBaEI7QUFDQSxpQ0FBSzNPLFdBQVc0TyxPQUFoQjtBQUNBLGlDQUFLNU8sV0FBV3dPLGNBQWhCO0FBQ0l0USx1Q0FBT2IsVUFBUCxDQUFrQm9SLFdBQWxCLEVBQStCLElBQUUsSUFBakMsRUFBdUNJLFdBQXZDO0FBQ0E7O0FBRUo7QUFDSS9ELDZDQUFhLElBQWI7QUFUUjtBQVdILHFCQW5CRDtBQW9CSCxpQkFyQkQ7O0FBdUJBMkQsNEJBQVk3RCxPQUFaO0FBQ0FHLG9DQUFvQixJQUFwQjtBQUNBOztBQUVKLGlCQUFLLGNBQUw7QUFDSSxvQkFBSTBELGNBQWMsVUFBU0ksV0FBVCxFQUFzQjtBQUNwQzdPLCtCQUFXb0UsU0FBWCxDQUFxQixXQUFyQixFQUFrQyxFQUFDLFVBQVd5SyxZQUFZSSxPQUFaLEdBQXNCLEdBQXRCLEdBQTRCSixZQUFZclMsRUFBcEQsRUFBbEMsRUFBMkYsVUFBU1YsSUFBVCxFQUFlO0FBQ3RHLDRCQUFJdVQsU0FBVXZULEtBQUt1SSxRQUFMLFlBQXlCMEYsS0FBekIsSUFBa0NqTyxLQUFLdUksUUFBTCxDQUFjNUYsTUFBZCxLQUF5QixDQUE1RCxHQUFpRTNDLEtBQUt1SSxRQUFMLENBQWMsQ0FBZCxDQUFqRSxHQUFvRixJQUFqRztBQUNBLDRCQUFJZ0wsV0FBVyxJQUFmLEVBQXFCO0FBQ2pCbE8sZ0NBQUlDLFNBQUosQ0FBYyxlQUFkLEVBQStCLHlCQUEvQixFQUEwRHlOLFdBQTFEO0FBQ0g7O0FBRUQvRCxxQ0FBYXVFLE1BQWI7QUFDSCxxQkFQRCxFQU9HLFVBQVMvSyxPQUFULEVBQWtCZ0IsT0FBbEIsRUFBMkI7QUFDMUIsZ0NBQVFoQixPQUFSO0FBQ0ksaUNBQUt0RSxXQUFXME8sV0FBaEI7QUFDQSxpQ0FBSzFPLFdBQVcyTyxRQUFoQjtBQUNBLGlDQUFLM08sV0FBVzRPLE9BQWhCO0FBQ0EsaUNBQUs1TyxXQUFXd08sY0FBaEI7QUFDSXRRLHVDQUFPYixVQUFQLENBQWtCb1IsV0FBbEIsRUFBK0IsSUFBRSxJQUFqQyxFQUF1Q0ksV0FBdkM7QUFDQTs7QUFFSjtBQUNJL0QsNkNBQWEsSUFBYjtBQVRSO0FBV0gscUJBbkJEO0FBb0JILGlCQXJCRDs7QUF1QkEyRCw0QkFBWTdELE9BQVo7QUFDQUcsb0NBQW9CLElBQXBCO0FBQ0E7O0FBRUosaUJBQUssY0FBTDtBQUNJLG9CQUFJMEQsV0FBSjs7QUFFQSxvQkFBSTdELFFBQVF2SSxHQUFSLEtBQWdCaEQsU0FBcEIsRUFBK0I7QUFDM0JvUCxrQ0FBYyxVQUFTSSxXQUFULEVBQXNCO0FBQ2hDQSxvQ0FBWUksT0FBWixHQUFzQnZMLFNBQVNtTCxZQUFZSSxPQUFyQixFQUE4QixFQUE5QixDQUF0QjtBQUNBSixvQ0FBWXJTLEVBQVosR0FBaUJrSCxTQUFTbUwsWUFBWXJTLEVBQXJCLEVBQXlCLEVBQXpCLENBQWpCOztBQUVBd0QsbUNBQVdvRSxTQUFYLENBQXFCLGtCQUFyQixFQUF5QyxFQUFDLE9BQVF5SyxZQUFZeE0sR0FBckIsRUFBekMsRUFBb0UsVUFBU3ZHLElBQVQsRUFBZTtBQUMvRSxnQ0FBS0EsS0FBS3VJLFFBQUwsWUFBeUIwRixLQUExQixLQUFxQyxLQUFyQyxJQUE4Q2pPLEtBQUt1SSxRQUFMLENBQWM1RixNQUFkLEtBQXlCLENBQXZFLElBQTRFM0MsS0FBS3VJLFFBQUwsQ0FBYyxDQUFkLEVBQWlCekMsV0FBakIsS0FBaUN2QyxTQUFqSCxFQUE0SDtBQUN4SDhCLG9DQUFJQyxTQUFKLENBQWMsZUFBZCxFQUErQix5QkFBL0IsRUFBMER5TixXQUExRDs7QUFFQS9ELDZDQUFhLElBQWI7QUFDQTtBQUNIOztBQUVELGdDQUFJbEUsQ0FBSjs7QUFFQSxpQ0FBS0EsSUFBSSxDQUFULEVBQVlBLElBQUk5SyxLQUFLdUksUUFBTCxDQUFjLENBQWQsRUFBaUJ6QyxXQUFqQixDQUE2Qm5ELE1BQTdDLEVBQXFEbUksR0FBckQsRUFBMEQ7QUFDdEQsb0NBQUk5SyxLQUFLdUksUUFBTCxDQUFjLENBQWQsRUFBaUJ6QyxXQUFqQixDQUE2QmdGLENBQTdCLEVBQWdDdE8sSUFBaEMsS0FBeUMsT0FBekMsSUFBb0R3RCxLQUFLdUksUUFBTCxDQUFjLENBQWQsRUFBaUJ6QyxXQUFqQixDQUE2QmdGLENBQTdCLEVBQWdDNUQsS0FBaEMsQ0FBc0NtTSxRQUF0QyxLQUFtRE4sWUFBWUksT0FBbkgsSUFBOEhuVCxLQUFLdUksUUFBTCxDQUFjLENBQWQsRUFBaUJ6QyxXQUFqQixDQUE2QmdGLENBQTdCLEVBQWdDNUQsS0FBaEMsQ0FBc0N1TSxHQUF0QyxLQUE4Q1YsWUFBWXJTLEVBQTVMLEVBQWdNO0FBQzVMc08saURBQWFoUCxLQUFLdUksUUFBTCxDQUFjLENBQWQsRUFBaUJ6QyxXQUFqQixDQUE2QmdGLENBQTdCLEVBQWdDNUQsS0FBN0M7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ3QixnQ0FBSUMsU0FBSixDQUFjLGVBQWQsRUFBK0IseUJBQS9CLEVBQTBEeU4sV0FBMUQ7QUFDSCx5QkFsQkQsRUFrQkcsVUFBU3ZLLE9BQVQsRUFBa0JnQixPQUFsQixFQUEyQjtBQUMxQixvQ0FBUWhCLE9BQVI7QUFDSSxxQ0FBS3RFLFdBQVcwTyxXQUFoQjtBQUNBLHFDQUFLMU8sV0FBVzJPLFFBQWhCO0FBQ0EscUNBQUszTyxXQUFXNE8sT0FBaEI7QUFDQSxxQ0FBSzVPLFdBQVd3TyxjQUFoQjtBQUNJdFEsMkNBQU9iLFVBQVAsQ0FBa0JvUixXQUFsQixFQUErQixJQUFFLElBQWpDLEVBQXVDSSxXQUF2QztBQUNBOztBQUVKO0FBQ0kvRCxpREFBYSxJQUFiO0FBVFI7QUFXSCx5QkE5QkQ7QUErQkgscUJBbkNEO0FBb0NILGlCQXJDRCxNQXFDTztBQUNIMkQsa0NBQWMsVUFBU0ksV0FBVCxFQUFzQjtBQUNoQzdPLG1DQUFXb0UsU0FBWCxDQUFxQixnQkFBckIsRUFBdUMsRUFBQyxVQUFXeUssWUFBWUksT0FBWixHQUFzQixHQUF0QixHQUE0QkosWUFBWXJTLEVBQXBELEVBQXZDLEVBQWdHLFVBQVNWLElBQVQsRUFBZTtBQUMzRyxnQ0FBSXVULFNBQVV2VCxLQUFLdUksUUFBTCxDQUFjNUYsTUFBZixHQUF5QjNDLEtBQUt1SSxRQUFMLENBQWMsQ0FBZCxDQUF6QixHQUE0QyxJQUF6RDtBQUNBLGdDQUFJZ0wsV0FBVyxJQUFmLEVBQXFCO0FBQ2pCbE8sb0NBQUlDLFNBQUosQ0FBYyxlQUFkLEVBQStCLHlCQUEvQixFQUEwRHlOLFdBQTFEO0FBQ0g7O0FBRUQvRCx5Q0FBYXVFLE1BQWI7QUFDSCx5QkFQRCxFQU9HLFVBQVMvSyxPQUFULEVBQWtCZ0IsT0FBbEIsRUFBMkI7QUFDMUIsb0NBQVFoQixPQUFSO0FBQ0kscUNBQUt0RSxXQUFXME8sV0FBaEI7QUFDQSxxQ0FBSzFPLFdBQVcyTyxRQUFoQjtBQUNBLHFDQUFLM08sV0FBVzRPLE9BQWhCO0FBQ0EscUNBQUs1TyxXQUFXd08sY0FBaEI7QUFDSXRRLDJDQUFPYixVQUFQLENBQWtCb1IsV0FBbEIsRUFBK0IsSUFBRSxJQUFqQyxFQUF1Q0ksV0FBdkM7QUFDQTs7QUFFSjtBQUNJL0QsaURBQWEsSUFBYjtBQVRSO0FBV0gseUJBbkJEO0FBb0JILHFCQXJCRDtBQXNCSDs7QUFFRDJELDRCQUFZN0QsT0FBWjtBQUNBRyxvQ0FBb0IsSUFBcEI7QUFDQTs7QUFFSixpQkFBSyxnQkFBTDtBQUNJbk0sZ0JBQUEsb0RBQUFBLENBQWdCb0Msa0JBQWhCLENBQW1DNEosUUFBUXZJLEdBQTNDLEVBQWdEdUksUUFBUTRFLEdBQXhELEVBQTZELFlBQVc7QUFDcEUxRSxpQ0FBYSxJQUFiO0FBQ0gsaUJBRkQsRUFFRyxVQUFVN0osZUFBVixFQUEyQkMsTUFBM0IsRUFBbUM7QUFDbEMsd0JBQUlELGVBQUosRUFBcUI7QUFDakJqQyxtQ0FBVzJCLEtBQVgsQ0FBaUJPLE1BQWpCO0FBQ0FDLDRCQUFJQyxTQUFKLENBQWMsZUFBZCxFQUErQixnQkFBL0IsRUFBaURGLE1BQWpEO0FBQ0g7O0FBRUQ0SixpQ0FBYSxLQUFiO0FBQ0gsaUJBVEQ7O0FBV0FDLG9DQUFvQixJQUFwQjtBQUNBOztBQUVKLGlCQUFLLGtCQUFMO0FBQ0lyTTtBQUNBOztBQUVKLGlCQUFLLGtCQUFMO0FBQ0lFLGdCQUFBLG9EQUFBQSxDQUFnQjBDLG9CQUFoQixDQUFxQ3NKLFFBQVF2SSxHQUE3QyxFQUFrRHVJLFFBQVE0RSxHQUExRCxFQUErRCxZQUFXO0FBQ3RFMUUsaUNBQWEsSUFBYjtBQUNILGlCQUZELEVBRUcsVUFBUzdKLGVBQVQsRUFBMEJDLE1BQTFCLEVBQWtDO0FBQ2pDLHdCQUFJRCxlQUFKLEVBQXFCO0FBQ2pCakMsbUNBQVcyQixLQUFYLENBQWlCTyxNQUFqQjtBQUNBQyw0QkFBSUMsU0FBSixDQUFjLGVBQWQsRUFBK0IsZ0JBQS9CLEVBQWlERixNQUFqRDtBQUNIOztBQUVENEosaUNBQWEsS0FBYjtBQUNILGlCQVREOztBQVdBQyxvQ0FBb0IsSUFBcEI7QUFDQTs7QUFFSixpQkFBSyxxQkFBTDtBQUNJLG9CQUFJMEUseUJBQXlCLFVBQVNILEtBQVQsRUFBZ0I7QUFDekN0UCwrQkFBV29FLFNBQVgsQ0FBcUIsaUJBQXJCLEVBQXdDLEVBQUMsT0FBUWtMLEtBQVQsRUFBeEMsRUFBeUQsVUFBU3hULElBQVQsRUFBZTtBQUNwRWdQLHFDQUFhLElBQWI7QUFDSCxxQkFGRCxFQUVHLFVBQVN4RyxPQUFULEVBQWtCZ0IsT0FBbEIsRUFBMkI7QUFDMUIsZ0NBQVFoQixPQUFSO0FBQ0ksaUNBQUt0RSxXQUFXME8sV0FBaEI7QUFDQSxpQ0FBSzFPLFdBQVcyTyxRQUFoQjtBQUNBLGlDQUFLM08sV0FBVzRPLE9BQWhCO0FBQ0EsaUNBQUs1TyxXQUFXd08sY0FBaEI7QUFDSXRRLHVDQUFPYixVQUFQLENBQWtCb1Msc0JBQWxCLEVBQTBDLEtBQUcsSUFBN0MsRUFBbURILEtBQW5EO0FBQ0E7QUFOUjs7QUFTQXRRLG1DQUFXMkIsS0FBWCxDQUFpQiw2Q0FBNkMyRCxPQUE3QyxHQUF1RCxHQUF4RTtBQUNBd0cscUNBQWEsS0FBYjtBQUNILHFCQWREO0FBZUgsaUJBaEJEOztBQWtCQTJFLHVDQUF1QjdFLFFBQVF2SSxHQUEvQjtBQUNBMEksb0NBQW9CLElBQXBCO0FBQ0E7O0FBRUosaUJBQUssc0JBQUw7QUFDSTVKLG9CQUFJQyxTQUFKLENBQWMsVUFBZCxFQUEwQixzQkFBMUI7O0FBRUEsb0JBQUlzTyw0QkFBNEIsVUFBU0osS0FBVCxFQUFnQjtBQUM1Q3RQLCtCQUFXb0UsU0FBWCxDQUFxQixrQkFBckIsRUFBeUMsRUFBQyxPQUFRa0wsS0FBVCxFQUF6QyxFQUEwRCxVQUFTeFQsSUFBVCxFQUFlO0FBQ3JFZ1AscUNBQWEsSUFBYjtBQUNILHFCQUZELEVBRUcsVUFBU3hHLE9BQVQsRUFBa0JnQixPQUFsQixFQUEyQjtBQUMxQixnQ0FBUWhCLE9BQVI7QUFDSSxpQ0FBS3RFLFdBQVcwTyxXQUFoQjtBQUNBLGlDQUFLMU8sV0FBVzJPLFFBQWhCO0FBQ0EsaUNBQUszTyxXQUFXNE8sT0FBaEI7QUFDSTFRLHVDQUFPYixVQUFQLENBQWtCcVMseUJBQWxCLEVBQTZDLEtBQUcsSUFBaEQsRUFBc0RKLEtBQXREO0FBQ0E7QUFMUjs7QUFRQXRRLG1DQUFXMkIsS0FBWCxDQUFpQiw4Q0FBOEMyRCxPQUE5QyxHQUF3RCxHQUF6RTtBQUNBd0cscUNBQWEsS0FBYjtBQUNILHFCQWJEO0FBY0gsaUJBZkQ7O0FBaUJBNEUsMENBQTBCOUUsUUFBUXZJLEdBQWxDO0FBQ0EwSSxvQ0FBb0IsSUFBcEI7QUFDQTs7QUFFSixpQkFBSyxzQkFBTDtBQUNJLG9CQUFJNEUsTUFBSjtBQUFBLG9CQUNJRixzQkFESjtBQUFBLG9CQUVJRyxjQUFlaEYsUUFBUWlGLFNBQVQsR0FBc0IsQ0FBdEIsR0FBMEIsQ0FGNUM7QUFBQSxvQkFHSUMsY0FBYyxDQUhsQjs7QUFLQS9FLG9DQUFvQixJQUFwQjs7QUFFQTRFLHlCQUFTLFlBQVc7QUFDaEJHLG1DQUFlLENBQWY7QUFDQSx3QkFBSUEsZ0JBQWdCRixXQUFwQixFQUFpQztBQUM3QjtBQUNIOztBQUVEOUUsaUNBQWEsSUFBYjtBQUNILGlCQVBEOztBQVNBMkUseUNBQXlCLFVBQVNILEtBQVQsRUFBZ0I7QUFDckN0UCwrQkFBV29FLFNBQVgsQ0FBcUIsaUJBQXJCLEVBQXdDLEVBQUMsT0FBUWtMLEtBQVQsRUFBeEMsRUFBeUQsVUFBU3hULElBQVQsRUFBZTtBQUNwRTZUO0FBQ0gscUJBRkQsRUFFRyxVQUFTckwsT0FBVCxFQUFrQmdCLE9BQWxCLEVBQTJCO0FBQzFCLGdDQUFRaEIsT0FBUjtBQUNJLGlDQUFLdEUsV0FBVzBPLFdBQWhCO0FBQ0EsaUNBQUsxTyxXQUFXMk8sUUFBaEI7QUFDQSxpQ0FBSzNPLFdBQVc0TyxPQUFoQjtBQUNJMVEsdUNBQU9iLFVBQVAsQ0FBa0JvUyxzQkFBbEIsRUFBMEMsS0FBRyxJQUE3QyxFQUFtREgsS0FBbkQ7QUFDQTtBQUxSOztBQVFBdFEsbUNBQVcyQixLQUFYLENBQWlCLDZDQUE2QzJELE9BQTdDLEdBQXVELEdBQXhFO0FBQ0FxTDtBQUNILHFCQWJEO0FBY0gsaUJBZkQ7O0FBaUJBLG9CQUFJL0UsUUFBUWlGLFNBQVosRUFBdUI7QUFDbkI7QUFDQUosMkNBQXVCN0UsUUFBUXZJLEdBQS9CO0FBQ0g7O0FBRUQ7QUFDQXpELGdCQUFBLG9EQUFBQSxDQUFnQm1SLGFBQWhCLENBQThCbkYsUUFBUXZJLEdBQXRDLEVBQTJDc04sTUFBM0M7QUFDQTs7QUFFSixpQkFBSyxjQUFMO0FBQ0l4TyxvQkFBSUMsU0FBSixDQUFjLGFBQWQsRUFBNkIsZUFBN0IsRUFBOEM7QUFDMUMsOEJBQVdsSixRQUFROFgsUUFBUixDQUFpQnpXLE1BRGM7QUFFMUMsMkJBQVFxTSxJQUFJcUssT0FGOEI7QUFHMUMsMkJBQVFwUSxnQkFBZ0JDO0FBSGtCLGlCQUE5Qzs7QUFNQTs7QUFFSixpQkFBSyxjQUFMO0FBQ0lxQixvQkFBSUMsU0FBSixDQUFjLFVBQWQsRUFBMEIsV0FBMUIsRUFBdUN3SixRQUFRcE8sRUFBL0M7QUFDQTs7QUFFSixpQkFBSyxpQkFBTDtBQUNJMkUsb0JBQUlDLFNBQUosQ0FBYyxhQUFkLEVBQTZCLG1CQUE3QixFQUFrRCxDQUFDd0osUUFBUXBPLEVBQVQsRUFBYW9PLFFBQVFzRixHQUFyQixDQUFsRDtBQUNBOztBQUVKLGlCQUFLLGtCQUFMO0FBQ0kvTyxvQkFBSUMsU0FBSixDQUFjLGFBQWQsRUFBNkIsZUFBN0IsRUFBOEMsQ0FBQ3dKLFFBQVFwTyxFQUFULEVBQWFvTyxRQUFRdUUsUUFBckIsRUFBK0J2RSxRQUFRdUYsR0FBdkMsQ0FBOUM7QUFDQTs7QUFFSixpQkFBSyxXQUFMO0FBQ0loUCxvQkFBSUMsU0FBSixDQUFjLFVBQWQsRUFBMEIsU0FBMUIsRUFBcUN3SixRQUFRd0YsSUFBN0M7QUFDQTs7QUFFSixpQkFBSyxpQkFBTDtBQUNJalAsb0JBQUlDLFNBQUosQ0FBYyxVQUFkLEVBQTBCLG1CQUExQixFQUErQ3dKLFFBQVF0UyxJQUF2RDtBQUNBOztBQUVKLGlCQUFLLGtCQUFMO0FBQ0l5UyxvQ0FBb0IsSUFBcEI7QUFDQW5NLGdCQUFBLG9EQUFBQSxDQUFnQnlSLFlBQWhCLENBQTZCdkYsWUFBN0IsRUFBMkMsVUFBVTVKLE1BQVYsRUFBa0I7QUFDekRsQywrQkFBVzJCLEtBQVgsQ0FBaUJPLE1BQWpCO0FBQ0FDLHdCQUFJQyxTQUFKLENBQWMsZUFBZCxFQUErQixnQkFBL0IsRUFBaURGLE1BQWpEOztBQUVBNEosaUNBQWEsRUFBYjtBQUNILGlCQUxEOztBQU9BOztBQUVKLGlCQUFLLHNCQUFMO0FBQ0lDLG9DQUFvQixJQUFwQjtBQUNBbk0sZ0JBQUEsb0RBQUFBLENBQWdCMFIsaUJBQWhCLENBQWtDMUYsUUFBUTRFLEdBQTFDLEVBQStDNUUsUUFBUXNDLFVBQVIsSUFBc0IsQ0FBckUsRUFBd0VwQyxZQUF4RSxFQUFzRixVQUFTNUosTUFBVCxFQUFpQjtBQUNuR2xDLCtCQUFXMkIsS0FBWCxDQUFpQk8sTUFBakI7QUFDQUMsd0JBQUlDLFNBQUosQ0FBYyxlQUFkLEVBQStCLGdCQUEvQixFQUFpREYsTUFBakQ7O0FBRUE0SixpQ0FBYSxDQUFDLEVBQUQsRUFBSyxDQUFMLENBQWI7QUFDSCxpQkFMRDs7QUFPQTs7QUFFSixpQkFBSyxlQUFMO0FBQ0lsTSxnQkFBQSxvREFBQUEsQ0FBZ0IyUixhQUFoQixDQUE4QjNGLFFBQVF4UixLQUF0QyxFQUE2Q3dSLFFBQVFzQyxVQUFyRCxFQUFpRSxVQUFVNU4sUUFBVixFQUFvQjhILEtBQXBCLEVBQTJCO0FBQ3hGMEQsaUNBQWEsQ0FBQ3hMLFFBQUQsRUFBVzhILEtBQVgsRUFBa0J3RCxRQUFReFIsS0FBMUIsQ0FBYjs7QUFFQSx3QkFBSXVFLGdCQUFnQmdHLFVBQWhCLEtBQStCLENBQS9CLElBQW9DckUsU0FBU2IsTUFBakQsRUFBeUQ7QUFDckQsNEJBQUl3RyxPQUFPM0YsU0FBU21OLEdBQVQsQ0FBYSxVQUFTZixXQUFULEVBQXNCO0FBQzFDLG1DQUFPQSxZQUFZelAsR0FBbkI7QUFDSCx5QkFGVSxDQUFYOztBQUlBK0QsbUNBQVdvRSxTQUFYLENBQXFCLFdBQXJCLEVBQWtDLEVBQUMsUUFBU2EsS0FBS3lILElBQUwsQ0FBVSxHQUFWLENBQVYsRUFBMEIsVUFBVyxRQUFyQyxFQUFsQyxFQUFrRixVQUFTNVEsSUFBVCxFQUFlO0FBQzdGQSxpQ0FBS3VJLFFBQUwsQ0FBY3hHLE9BQWQsQ0FBc0IsVUFBUzhPLEtBQVQsRUFBZ0I7QUFDbEMsb0NBQUlDLFdBQVlELE1BQU1FLE1BQU4sS0FBaUIsQ0FBakIsSUFBc0JGLE1BQU1HLGFBQU4sS0FBd0IsQ0FBOUQ7QUFDQXZULHVDQUFPb0csT0FBUCxDQUFlQyxXQUFmLENBQTJCLEVBQUMsVUFBVyxxQkFBWixFQUFtQyxPQUFRK00sTUFBTTFRLEdBQWpELEVBQXNELFVBQVcyUSxRQUFqRSxFQUEzQjtBQUNILDZCQUhEO0FBSUgseUJBTEQ7QUFNSDtBQUNKLGlCQWZELEVBZUcsVUFBVTFMLE1BQVYsRUFBa0I7QUFDakJsQywrQkFBVzJCLEtBQVgsQ0FBaUJPLE1BQWpCO0FBQ0FDLHdCQUFJQyxTQUFKLENBQWMsZUFBZCxFQUErQixnQkFBL0IsRUFBaURGLE1BQWpEOztBQUVBNEosaUNBQWEsQ0FBQyxFQUFELEVBQUssQ0FBTCxFQUFRRixRQUFReFIsS0FBaEIsQ0FBYjtBQUNILGlCQXBCRDs7QUFzQkEyUixvQ0FBb0IsSUFBcEI7QUFDQTs7QUFFSixpQkFBSyxZQUFMO0FBQ0lBLG9DQUFvQixJQUFwQjs7QUFFQW5NLGdCQUFBLG9EQUFBQSxDQUFnQjRSLFVBQWhCLENBQTJCNUYsUUFBUS9RLE1BQW5DLEVBQTJDK1EsUUFBUXhSLEtBQW5ELEVBQTBEd1IsUUFBUXNDLFVBQWxFLEVBQThFLFVBQVV1RCxjQUFWLEVBQTBCckosS0FBMUIsRUFBaUM7QUFDM0cwRCxpQ0FBYSxDQUFDMkYsY0FBRCxFQUFpQnJKLEtBQWpCLEVBQXdCd0QsUUFBUXhSLEtBQWhDLENBQWI7QUFDSCxpQkFGRCxFQUVHLFVBQVM4SCxNQUFULEVBQWlCO0FBQ2hCbEMsK0JBQVcyQixLQUFYLENBQWlCTyxNQUFqQjtBQUNBQyx3QkFBSUMsU0FBSixDQUFjLGVBQWQsRUFBK0IsZ0JBQS9CLEVBQWlERixNQUFqRDs7QUFFQTRKLGlDQUFhLENBQUMsRUFBRCxFQUFLLENBQUwsRUFBUUYsUUFBUXhSLEtBQWhCLENBQWI7QUFDSCxpQkFQRDs7QUFTQTs7QUFFSixpQkFBSyxVQUFMO0FBQ0l3QyxnQ0FBZ0IsSUFBaEI7QUFDQXVGLG9CQUFJQyxTQUFKLENBQWMsYUFBZCxFQUE2QixXQUE3QjtBQUNBOztBQUVKLGlCQUFLLG1CQUFMO0FBQ0ksb0JBQUlpTyxTQUFTblEsWUFBWVcsZ0JBQWdCQyxhQUE1QixDQUFiO0FBQ0FpTCxvQ0FBb0IsSUFBcEI7O0FBRUFuTSxnQkFBQSxvREFBQUEsQ0FBZ0I0RSxjQUFoQixDQUErQjNELGdCQUFnQkMsYUFBL0MsRUFBOERELGdCQUFnQkMsYUFBOUUsRUFBNkYsVUFBVTZCLFFBQVYsRUFBb0I7QUFDN0dtSixpQ0FBYTtBQUNUaFAsOEJBQU11VCxNQURHO0FBRVR0TSxnQ0FBUXBCLFNBQVNxQjtBQUZSLHFCQUFiO0FBSUgsaUJBTEQsRUFLRyxZQUFZO0FBQ1g4SCxpQ0FBYTtBQUNUaFAsOEJBQU11VDtBQURHLHFCQUFiO0FBR0gsaUJBVEQ7O0FBV0E7O0FBRUosaUJBQUssaUJBQUw7QUFDSXJQLDJCQUFXQyxRQUFYO0FBQ0FKLGdDQUFnQkMsYUFBaEIsR0FBZ0M4SyxRQUFRM08sR0FBeEM7O0FBRUEsb0JBQUlpUSxvQkFBb0IxUSxlQUFlMUMsR0FBZixDQUFtQixvQkFBbkIsRUFBeUMsRUFBQ2lCLGFBQWFnUSxLQUFkLEVBQXFCOVAsUUFBUSxJQUE3QixFQUFtQ0MsUUFBUSxJQUEzQyxFQUF6QyxDQUF4QjtBQUNBLG9CQUFJNFAsbUJBQW9CdE8sZUFBZTFDLEdBQWYsQ0FBbUIsb0JBQW5CLEVBQXlDLEVBQUNpQixhQUFhMkwsTUFBZCxFQUFzQnpMLFFBQVEsSUFBOUIsRUFBb0NDLFFBQVEsSUFBNUMsRUFBekMsRUFBNEYyRixnQkFBZ0JDLGFBQTVHLE1BQStIVCxTQUF2SjtBQUNBLG9CQUFJcVIsWUFBWSxJQUFoQjs7QUFFQSxvQkFBSUEsU0FBSixFQUFlO0FBQ1gzUSxxQ0FBaUJqQyx5QkFBakI7QUFDSCxpQkFGRCxNQUVPO0FBQ0hBO0FBQ0g7O0FBRUQ7O0FBRUosaUJBQUssZUFBTDtBQUNJa0MsMkJBQVdDLFFBQVg7QUFDQUosZ0NBQWdCOFEsSUFBaEIsQ0FBcUIvRixRQUFRM08sR0FBN0I7QUFDQTJDLGdCQUFBLG9EQUFBQSxDQUFnQnRELFFBQWhCLENBQXlCc1AsUUFBUTNPLEdBQWpDOztBQUVBLG9CQUFJMlUsa0JBQWtCcFYsZUFBZTFDLEdBQWYsQ0FBbUIsbUJBQW5CLEVBQXdDLEVBQUNpQixhQUFhMkwsTUFBZCxFQUFzQnpMLFFBQVEsSUFBOUIsRUFBb0NDLFFBQVEsSUFBNUMsRUFBeEMsQ0FBdEI7QUFDQSx1QkFBTzBXLGdCQUFnQmhHLFFBQVEzTyxHQUF4QixDQUFQO0FBQ0FULCtCQUFldEMsR0FBZixDQUFtQixtQkFBbkIsRUFBd0MwWCxlQUF4Qzs7QUFFQSxvQkFBSTlHLG1CQUFtQnRPLGVBQWUxQyxHQUFmLENBQW1CLG9CQUFuQixFQUF5QyxFQUFDaUIsYUFBYTJMLE1BQWQsRUFBc0J6TCxRQUFRLElBQTlCLEVBQW9DQyxRQUFRLElBQTVDLEVBQXpDLENBQXZCO0FBQ0EsdUJBQU80UCxpQkFBaUJjLFFBQVEzTyxHQUF6QixDQUFQO0FBQ0FULCtCQUFldEMsR0FBZixDQUFtQixvQkFBbkIsRUFBeUM0USxnQkFBekM7O0FBRUF0TywrQkFBZXBCLE1BQWYsQ0FBc0IsZ0JBQWdCd1EsUUFBUTNPLEdBQTlDO0FBQ0FULCtCQUFlcEIsTUFBZixDQUFzQixpQkFBaUJ3USxRQUFRM08sR0FBL0M7O0FBRUEsb0JBQUkyTyxRQUFRaUcsSUFBUixLQUFpQixLQUFyQixFQUE0QjtBQUN4QmhSLG9DQUFnQkMsYUFBaEIsR0FBZ0M4SyxRQUFRaUcsSUFBeEM7QUFDQTlRO0FBQ0g7O0FBRUQ7QUFDQWpDOztBQUVBOztBQUVKLGlCQUFLLFlBQUw7QUFDSSxvQkFBSWdULHlCQUF5QixVQUFVeEIsS0FBVixFQUFpQjtBQUMxQ3RQLCtCQUFXb0UsU0FBWCxDQUFxQixxQkFBckIsRUFBNEMsRUFBQyxRQUFTa0wsS0FBVixFQUE1QyxFQUE4RCxJQUE5RCxFQUFvRSxVQUFVaEwsT0FBVixFQUFtQmdCLE9BQW5CLEVBQTRCO0FBQzVGLGdDQUFRaEIsT0FBUjtBQUNJLGlDQUFLdEUsV0FBVzBPLFdBQWhCO0FBQ0EsaUNBQUsxTyxXQUFXMk8sUUFBaEI7QUFDQSxpQ0FBSzNPLFdBQVc0TyxPQUFoQjtBQUNJMVEsdUNBQU9iLFVBQVAsQ0FBa0J5VCxzQkFBbEIsRUFBMEMsS0FBRyxJQUE3QyxFQUFtRHhCLEtBQW5EO0FBQ0E7QUFMUjs7QUFRQXRRLG1DQUFXMkIsS0FBWCxDQUFpQixvREFBb0QyRCxPQUFwRCxHQUE4RCxHQUEvRTtBQUNILHFCQVZEO0FBV0gsaUJBWkQ7O0FBY0F3TSx1Q0FBdUJsRyxRQUFRdkksR0FBL0I7QUFDQXpELGdCQUFBLG9EQUFBQSxDQUFnQjJDLFVBQWhCLENBQTJCcUosUUFBUXZJLEdBQW5DLEVBQXdDLElBQXhDLEVBQThDLFVBQVVuQixNQUFWLEVBQWtCO0FBQzVEbEMsK0JBQVcyQixLQUFYLENBQWlCTyxNQUFqQjtBQUNBQyx3QkFBSUMsU0FBSixDQUFjLGVBQWQsRUFBK0IsZ0JBQS9CLEVBQWlERixNQUFqRDtBQUNILGlCQUhEOztBQUtBOztBQUVKLGlCQUFLLGFBQUw7QUFDSUMsb0JBQUlDLFNBQUosQ0FBYyxhQUFkLEVBQTZCLEtBQTdCLEVBQW9Dd0osUUFBUW1HLEdBQTVDO0FBQ0E7QUFubENSOztBQXNsQ0EsWUFBSWhHLGlCQUFKLEVBQXVCO0FBQ25CLG1CQUFPLElBQVA7QUFDSDtBQUNKLEtBNWxDRDs7QUE4bENBO0FBQ0EsUUFBSWxMLGdCQUFnQkMsYUFBcEIsRUFBbUM7QUFDL0JDO0FBQ0g7QUFDSixDQTUzREQsRTs7Ozs7Ozs7Ozs7OztBQ3hWQTtBQUFBOzs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTWlSLHFCQUFxQixDQUFDbFYsSUFBRCxFQUFPbVYsTUFBUCxLQUFrQjtBQUN6QyxRQUFJQyxRQUFKOztBQUVBLFFBQUk7QUFDQUEsbUJBQVd0USxLQUFLdVEsS0FBTCxDQUFXclYsSUFBWCxDQUFYO0FBQ0EzQixRQUFBLDhDQUFBQSxDQUFPK1csb0JBQW9CRCxNQUEzQjtBQUNILEtBSEQsQ0FHRSxPQUFPRyxFQUFQLEVBQVc7QUFDVEYsbUJBQVcsSUFBSUQsTUFBSixFQUFYO0FBQ0g7O0FBRUQsV0FBT0MsUUFBUDtBQUNILENBWEQ7O0FBYUEsTUFBTUcscUJBQXNCQyxPQUFELElBQWE7QUFDcEMsV0FBT0EsUUFBUS9OLE9BQVIsQ0FBZ0IsZ0JBQWhCLEVBQWtDLEdBQWxDLEVBQXVDZ08sV0FBdkMsR0FBcUQ3WixLQUFyRCxDQUEyRCxHQUEzRCxFQUFnRThaLE1BQWhFLENBQXVFQyxRQUFRQSxLQUFLaFQsTUFBTCxJQUFlLENBQTlGLENBQVA7QUFDSCxDQUZEOztBQUlBLDRDQUFlO0FBQ1g7OztBQUdBaVQsd0JBQW9CLFNBQVNDLGtDQUFULENBQTRDMU0sSUFBNUMsRUFBa0RKLFFBQWxELEVBQTREO0FBQzVFOUwsZ0JBQVFDLEdBQVIsQ0FBWSxvQ0FBWjtBQUNBRCxnQkFBUUMsR0FBUixDQUFZLE1BQVosRUFBb0JpTSxJQUFwQjs7QUFFQSxZQUFJMk0sT0FBTyxJQUFYO0FBQ0EsWUFBSUMsa0JBQWtCM1QsT0FBTzRULFlBQVAsQ0FBb0IsV0FBcEIsRUFBaUMsT0FBakMsRUFBMEMsSUFBMUMsRUFBZ0QsQ0FBaEQsQ0FBdEI7O0FBRUEsaUJBQVNDLHFCQUFULENBQStCQyxLQUEvQixFQUFzQy9WLEdBQXRDLEVBQTJDO0FBQ3ZDbEQsb0JBQVFDLEdBQVIsQ0FBWSx5QkFBWixFQUF1Q2daLEtBQXZDLEVBQThDL1YsR0FBOUM7O0FBRUEsbUJBQU8sSUFBSUcsT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUJpTSxNQUFuQixFQUEyQjtBQUMxQ3VKLGdDQUFnQkksZUFBaEIsQ0FBZ0MsVUFBVUMsRUFBVixFQUFjO0FBQzFDQSx1QkFBR0MsVUFBSCxDQUFjLDBCQUEwQkgsS0FBMUIsR0FBa0MsR0FBbEMsR0FBd0MvVixHQUF4QyxHQUE4QyxpQkFBNUQsRUFBK0UsRUFBL0UsRUFBbUYsVUFBVWlXLEVBQVYsRUFBY0UsU0FBZCxFQUF5QjtBQUN4Ryw0QkFBSUMsZUFBZUQsVUFBVUUsSUFBVixDQUFlN1QsTUFBbEM7QUFDQSw0QkFBSTRRLFNBQVMsRUFBYjs7QUFFQXRXLGdDQUFRQyxHQUFSLENBQVksd0JBQVosRUFBc0NxWixZQUF0QyxFQUFvREwsS0FBcEQ7O0FBRUEsNkJBQUssSUFBSXBMLElBQUksQ0FBYixFQUFnQkEsSUFBSXlMLFlBQXBCLEVBQWtDekwsR0FBbEMsRUFBdUM7QUFDbkN5SSxtQ0FBT25OLElBQVAsQ0FBWWtRLFVBQVVFLElBQVYsQ0FBZUMsSUFBZixDQUFvQjNMLENBQXBCLENBQVo7QUFDSDs7QUFFRHZLLGdDQUFRZ1QsTUFBUjtBQUNILHFCQVhELEVBV0csVUFBVTZDLEVBQVYsRUFBY3RhLEdBQWQsRUFBbUI7QUFDbEJ1Siw0QkFBSUMsU0FBSixDQUFjLFVBQWQsRUFBMEIsa0JBQTFCLEVBQThDeEosSUFBSUcsT0FBbEQ7O0FBRUE7QUFDQSw0QkFBSUgsSUFBSUcsT0FBSixDQUFZeWEsT0FBWixDQUFvQixlQUFwQixNQUF5QyxDQUFDLENBQTlDLEVBQWlEO0FBQzdDblcsb0NBQVEsRUFBUjtBQUNBO0FBQ0g7O0FBRURpTSwrQkFBTzFRLElBQUlHLE9BQVg7QUFDSCxxQkFyQkQ7QUFzQkgsaUJBdkJEO0FBd0JILGFBekJNLENBQVA7QUEwQkg7O0FBRUQsaUJBQVMwYSxlQUFULENBQXlCeFcsR0FBekIsRUFBOEI7QUFDMUIsZ0JBQUkyVixPQUFPLElBQVg7QUFDQSxnQkFBSTlSLGdCQUFnQnVMLE9BQU9wUCxHQUFQLENBQXBCOztBQUVBLG1CQUFPLElBQUlHLE9BQUosQ0FBWSxVQUFVQyxPQUFWLEVBQW1CaU0sTUFBbkIsRUFBMkI7QUFDMUNzSixxQkFBS3JILFFBQUwsQ0FBY3RPLEdBQWQsRUFBbUIsWUFBWTtBQUMzQmxELDRCQUFRQyxHQUFSLENBQVksa0JBQVo7O0FBRUFvRCw0QkFBUXVDLEdBQVIsQ0FBWSxDQUNSb1Qsc0JBQXNCLFVBQXRCLEVBQWtDOVYsR0FBbEMsQ0FEUSxFQUVSOFYsc0JBQXNCLElBQXRCLEVBQTRCOVYsR0FBNUIsQ0FGUSxDQUFaLEVBR0d0QyxJQUhILENBR1EsVUFBVTRHLEdBQVYsRUFBZTtBQUNuQiw0QkFBSW1TLGtCQUFrQm5TLElBQUksQ0FBSixDQUF0QjtBQUNBLDRCQUFJb1Msa0JBQWtCcFMsSUFBSSxDQUFKLENBQXRCOztBQUVBLDRCQUFJakIsV0FBVyxFQUFmO0FBQ0EsNEJBQUlxSyxXQUFXLEVBQWY7QUFDQSw0QkFBSWlKLFFBQVEsRUFBWjs7QUFFQUYsd0NBQWdCN1UsT0FBaEIsQ0FBd0IsVUFBVWdWLE1BQVYsRUFBa0I7QUFDdEMsZ0NBQUlDLFlBQVk5QixtQkFBbUI2QixPQUFPRSxVQUExQixFQUFzQ3JOLE1BQXRDLENBQWhCO0FBQ0EsZ0NBQUl6SixNQUFNb1AsT0FBT3dILE9BQU81VyxHQUFkLENBQVY7O0FBRUFxRCxxQ0FBU3VULE9BQU81VyxHQUFoQixJQUF1QjtBQUNuQkEscUNBQUtBLEdBRGM7QUFFbkJvSCw0Q0FBWXdQLE9BQU94UCxVQUZBO0FBR25CQywyQ0FBV3VQLE9BQU92UCxTQUhDO0FBSW5CMFAsdUNBQU9ILE9BQU9HLEtBSks7QUFLbkJDLGlEQUFpQixDQUxFO0FBTW5CQyw4Q0FBYyxDQU5LO0FBT25CQywwQ0FBVSxDQUNOTixPQUFPeFAsVUFBUCxDQUFrQmtPLFdBQWxCLEVBRE0sRUFFTnNCLE9BQU92UCxTQUFQLENBQWlCaU8sV0FBakIsRUFGTSxFQUdOdFYsR0FITTtBQVBTLDZCQUF2Qjs7QUFjQSxnQ0FBSTZXLFVBQVVyTyxNQUFkLEVBQXNCO0FBQ2xCbkYseUNBQVN1VCxPQUFPNVcsR0FBaEIsRUFBcUJrWCxRQUFyQixDQUE4QmpSLElBQTlCLENBQW1DNFEsVUFBVXJPLE1BQVYsQ0FBaUI4TSxXQUFqQixFQUFuQztBQUNIOztBQUVELDZCQUFDLE9BQUQsRUFBVSxPQUFWLEVBQW1CLFFBQW5CLEVBQTZCLFlBQTdCLEVBQTJDLGNBQTNDLEVBQTJEMVQsT0FBM0QsQ0FBbUUsVUFBVWlFLEtBQVYsRUFBaUI7QUFDaEYsb0NBQUlnUixVQUFVaFIsS0FBVixDQUFKLEVBQXNCO0FBQ2xCeEMsNkNBQVN1VCxPQUFPNVcsR0FBaEIsRUFBcUI2RixLQUFyQixJQUE4QmdSLFVBQVVoUixLQUFWLENBQTlCO0FBQ0g7QUFDSiw2QkFKRDs7QUFNQSxnQ0FBSWdSLFVBQVVuTCxHQUFkLEVBQW1CO0FBQ2ZySSx5Q0FBU3VULE9BQU81VyxHQUFoQixFQUFxQjBMLEdBQXJCLEdBQTJCMEQsT0FBT3lILFVBQVVuTCxHQUFqQixLQUF5QixDQUFwRDtBQUNIO0FBQ0oseUJBL0JEOztBQWlDQWdMLHdDQUFnQjlVLE9BQWhCLENBQXdCLFVBQVVnVixNQUFWLEVBQWtCO0FBQ3RDLGdDQUFJTyxjQUFjN0YsUUFBUXNGLE9BQU9RLE1BQWYsQ0FBbEI7QUFDQSxnQ0FBSUMsU0FBU0YsY0FBY3BaLE9BQU82WSxPQUFPUSxNQUFkLENBQWQsR0FBc0MsT0FBT1IsT0FBTzVXLEdBQWpFO0FBQ0EsZ0NBQUlqQixTQUFTcVEsT0FBT3dILE9BQU81VyxHQUFkLENBQWI7QUFDQSxnQ0FBSXNYLHNCQUFzQlgsTUFBTVUsTUFBTixJQUFnQlYsTUFBTVUsTUFBTixFQUFjTCxlQUE5QixHQUFnRCxDQUExRTs7QUFFQUwsa0NBQU1VLE1BQU4sSUFBZ0JWLE1BQU1VLE1BQU4sS0FBaUIsRUFBakM7QUFDQVYsa0NBQU1VLE1BQU4sRUFBYzlXLEVBQWQsR0FBbUI4VyxNQUFuQjtBQUNBVixrQ0FBTVUsTUFBTixFQUFjMVcsS0FBZCxHQUFzQmlXLE9BQU9qVyxLQUE3QjtBQUNBZ1csa0NBQU1VLE1BQU4sRUFBY0wsZUFBZCxHQUFnQ3hXLEtBQUtzSixHQUFMLENBQVM4TSxPQUFPdlEsSUFBaEIsRUFBc0JpUixtQkFBdEIsQ0FBaEM7O0FBRUEsZ0NBQUkzUixjQUFjb1AsbUJBQW1CNkIsT0FBT2pSLFdBQTFCLEVBQXVDbUksS0FBdkMsQ0FBbEI7QUFDQSxnQ0FBSXJILE9BQU8sRUFBWDs7QUFFQWtELGdDQUFJNE4sU0FBSixDQUFjM1YsT0FBZCxDQUFzQixVQUFVMlIsR0FBVixFQUFlNUksQ0FBZixFQUFrQjtBQUNwQyxvQ0FBSWlNLE9BQU9uUSxJQUFQLEdBQWNqRyxLQUFLZ1gsR0FBTCxDQUFTLENBQVQsRUFBWTdNLENBQVosQ0FBbEIsRUFBa0M7QUFDOUJsRSx5Q0FBS1IsSUFBTCxDQUFVc04sR0FBVjtBQUNIO0FBQ0osNkJBSkQ7O0FBTUEsZ0NBQUlzRCxZQUFZOUIsbUJBQW1CNkIsT0FBT0UsVUFBMUIsRUFBc0NyTixNQUF0QyxDQUFoQjtBQUNBLGdDQUFJZ08sV0FBV25HLFFBQVF1RixVQUFVblEsS0FBbEIsQ0FBZjs7QUFFQWdILHFDQUFTa0osT0FBT3hRLEdBQWhCLElBQXVCO0FBQ25CQSxxQ0FBS2dKLE9BQU93SCxPQUFPeFEsR0FBZCxDQURjO0FBRW5CcEcscUNBQUtqQixNQUZjO0FBR25CNEIsdUNBQU9pVyxPQUFPalcsS0FISztBQUluQjJGLHNDQUFNc1EsT0FBT3RRLElBSk07QUFLbkJELHNDQUFNdVEsT0FBT3ZRLElBTE07QUFNbkJxUixzQ0FBTXBHLFFBQVFzRixPQUFPZSxNQUFmLENBTmE7QUFPbkJoUyw2Q0FBYUEsV0FQTTtBQVFuQmMsc0NBQU1BLElBUmE7QUFTbkJtUiwyQ0FBV0gsUUFUUTtBQVVuQkksc0NBQU1SLE1BVmE7QUFXbkJILDBDQUFVOUIsbUJBQW1Cd0IsT0FBT3RRLElBQTFCO0FBWFMsNkJBQXZCOztBQWNBLGdDQUFJLENBQUNqRCxTQUFTdEUsTUFBVCxDQUFMLEVBQXVCO0FBQ25CakMsd0NBQVEySCxJQUFSLENBQWEsNkJBQWIsRUFBNEMxRixNQUE1QztBQUNBO0FBQ0g7O0FBRURzRSxxQ0FBU3RFLE1BQVQsRUFBaUJrWSxZQUFqQixJQUFpQyxDQUFqQztBQUNBNVQscUNBQVN0RSxNQUFULEVBQWlCaVksZUFBakIsR0FBbUN4VyxLQUFLc0osR0FBTCxDQUFTekcsU0FBU3RFLE1BQVQsRUFBaUJpWSxlQUExQixFQUEyQ0osT0FBT3ZRLElBQWxELENBQW5DO0FBQ0gseUJBNUNEOztBQThDQXZKLGdDQUFRQyxHQUFSLENBQVksa0NBQVosRUFBZ0RpRCxHQUFoRDs7QUFFQTtBQUNBMlYsNkJBQUttQyxLQUFMLENBQVc5WCxHQUFYLEVBQWdCK1gsTUFBaEIsQ0FBdUI7QUFDbkIscUNBQVN6VyxFQUFFMFcsTUFBRixDQUFTckIsS0FBVCxDQURVO0FBRW5CLHdDQUFZclYsRUFBRTBXLE1BQUYsQ0FBUzNVLFFBQVQsQ0FGTztBQUduQix3Q0FBWS9CLEVBQUUwVyxNQUFGLENBQVN0SyxRQUFUO0FBSE8seUJBQXZCLEVBSUcsVUFBVS9SLEdBQVYsRUFBZXNjLFlBQWYsRUFBNkI7QUFDNUIsZ0NBQUl0YyxHQUFKLEVBQVM7QUFDTCxvQ0FBSXNKLFNBQVN0SixJQUFJK1EsSUFBSixHQUFXLElBQVgsR0FBa0IvUSxJQUFJRyxPQUFuQzs7QUFFQSxvQ0FBSTtBQUNBNloseUNBQUttQyxLQUFMLENBQVc5WCxHQUFYLEVBQWdCcUMsS0FBaEI7QUFDSCxpQ0FGRCxDQUVFLE9BQU84UyxFQUFQLEVBQVcsQ0FBRTs7QUFFZmpRLG9DQUFJQyxTQUFKLENBQWMsVUFBZCxFQUEwQixpQkFBMUIsRUFBNkNGLE1BQTdDO0FBQ0FvSCx1Q0FBT3BILE1BQVA7O0FBRUE7QUFDSDs7QUFFRG5JLG9DQUFRQyxHQUFSLENBQVksMkJBQVo7O0FBRUE0WSxpQ0FBS21DLEtBQUwsQ0FBVzlYLEdBQVgsRUFBZ0JxQyxLQUFoQjtBQUNBakM7QUFDSCx5QkF0QkQ7QUF1QkgscUJBcEhELEVBb0hHLFVBQVU2RSxNQUFWLEVBQWtCO0FBQ2pCQyw0QkFBSUMsU0FBSixDQUFjLFVBQWQsRUFBMEIsd0JBQTFCLEVBQW9ERixNQUFwRDtBQUNBb0gsK0JBQU9wSCxNQUFQO0FBQ0gscUJBdkhEO0FBd0hILGlCQTNIRCxFQTJIRyxVQUFVQSxNQUFWLEVBQWtCO0FBQ2pCQyx3QkFBSUMsU0FBSixDQUFjLFVBQWQsRUFBMEIsZUFBMUIsRUFBMkNGLE1BQTNDO0FBQ0FvSCwyQkFBT3BILE1BQVA7QUFDSCxpQkE5SEQ7QUErSEgsYUFoSU0sQ0FBUDtBQWlJSDs7QUFFRCxZQUFJcUssV0FBV3RHLEtBQUt3SCxHQUFMLENBQVMsVUFBVXhRLEdBQVYsRUFBZTtBQUNuQ2xELG9CQUFRQyxHQUFSLENBQVksZUFBWixFQUE2QmlELEdBQTdCO0FBQ0EsbUJBQU93VyxnQkFBZ0IwQixJQUFoQixDQUFxQnZDLElBQXJCLEVBQTJCM1YsR0FBM0IsQ0FBUDtBQUNILFNBSGMsQ0FBZjs7QUFLQUcsZ0JBQVF1QyxHQUFSLENBQVk0TSxRQUFaLEVBQXNCNVIsSUFBdEIsQ0FBMkIsWUFBWTtBQUNuQ2tMO0FBQ0gsU0FGRCxFQUVHQSxRQUZIO0FBR0gsS0F6TFU7O0FBMkxYOzs7O0FBSUFoRztBQUFBLHFDQUFVLGFBQTBDO0FBQ2hELGlCQUFLdVYsS0FBTCxHQUFhLE1BQU0sNkVBQUF4YixFQUFuQjtBQUNILFNBRkQ7O0FBQUEsaUJBQXlCeWIsd0JBQXpCO0FBQUE7QUFBQTs7QUFBQSxlQUF5QkEsd0JBQXpCO0FBQUEsUUEvTFc7O0FBbU1YOzs7Ozs7QUFNQTlKO0FBQUEsc0NBQVUsV0FBd0N2UCxNQUF4QyxFQUFnRHNaLFNBQWhELEVBQTJEQyxNQUEzRCxFQUFtRTtBQUN6RSxpQkFBS0MsT0FBTCxHQUFleFosTUFBZjs7QUFFQSxnQkFBSTtBQUNBLHFCQUFLK1ksS0FBTCxDQUFXL1ksTUFBWCxJQUFxQixNQUFNLDZFQUFBRCxDQUFTQyxNQUFULENBQTNCO0FBQ0EscUJBQUt3WixPQUFMLEdBQWV4WixNQUFmO0FBQ0gsYUFIRCxDQUdFLE9BQU9wRCxHQUFQLEVBQVk7QUFDVjJjLHVCQUFPM2MsSUFBSStRLElBQUosR0FBVyxJQUFYLEdBQWtCL1EsSUFBSUcsT0FBN0I7QUFDQTtBQUNIOztBQUVEdWM7QUFDSCxTQVpEOztBQUFBLGlCQUF5Qkcsd0JBQXpCO0FBQUE7QUFBQTs7QUFBQSxlQUF5QkEsd0JBQXpCO0FBQUEsUUF6TVc7O0FBdU5YOzs7QUFHQW5aO0FBQUEsc0NBQVUsV0FBd0NOLE1BQXhDLEVBQWdEO0FBQ3RELGlCQUFLK1ksS0FBTCxDQUFXL1ksTUFBWCxFQUFtQnNELEtBQW5CO0FBQ0EsbUJBQU8sNkVBQUFoRCxDQUFTTixNQUFULENBQVA7QUFDSCxTQUhEOztBQUFBLGlCQUF5QjBaLHdCQUF6QjtBQUFBO0FBQUE7O0FBQUEsZUFBeUJBLHdCQUF6QjtBQUFBLFFBMU5XOztBQStOWDs7Ozs7Ozs7O0FBU0F6SCxvQkFBZ0IsU0FBUzBILDhCQUFULENBQXdDQyxVQUF4QyxFQUFvREMsU0FBcEQsRUFBK0RQLFNBQS9ELEVBQTBFQyxNQUExRSxFQUFrRjtBQUM5RixZQUFJdlosU0FBUyxLQUFLd1osT0FBbEI7QUFDQSxZQUFJN2IsT0FBTyxLQUFLb2IsS0FBTCxDQUFXL1ksTUFBWCxDQUFYOztBQUVBLGlCQUFTOFosYUFBVCxHQUF5QjtBQUNyQixtQkFBTyxJQUFJMVksT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUJpTSxNQUFuQixFQUEyQjtBQUMxQzNQLHFCQUFLMlEsS0FBTCxDQUFXLFVBQVgsRUFBdUIsVUFBVTFSLEdBQVYsRUFBZXdQLEtBQWYsRUFBc0I7QUFDekMsd0JBQUl4UCxHQUFKLEVBQVM7QUFDTDBRLCtCQUFPMVEsR0FBUDtBQUNILHFCQUZELE1BRU87QUFDSHlFLGdDQUFRK0ssS0FBUjtBQUNIO0FBQ0osaUJBTkQ7QUFPSCxhQVJNLENBQVA7QUFTSDs7QUFFRCxpQkFBUzJOLFdBQVQsR0FBdUI7QUFDbkIsZ0JBQUlDLFNBQUo7QUFDQSxnQkFBSUMsU0FBSjs7QUFFQSxvQkFBUUwsVUFBUjtBQUNJLHFCQUFLLE9BQUw7QUFDSUksZ0NBQVksTUFBWjtBQUNBQyxnQ0FBWSwwQ0FBWjtBQUNBOztBQUVKLHFCQUFLLFVBQUw7QUFDSUQsZ0NBQVksY0FBWjtBQUNBQyxnQ0FBWSwyQ0FBWjtBQUNBOztBQUVKLHFCQUFLLGFBQUw7QUFDSUQsZ0NBQVksY0FBWjtBQUNBQyxnQ0FBWSwyQ0FBWjtBQUNBO0FBZFI7O0FBaUJBLG1CQUFPLElBQUk3WSxPQUFKLENBQVksVUFBVUMsT0FBVixFQUFtQmlNLE1BQW5CLEVBQTJCO0FBQzFDM1AscUJBQUtHLEdBQUwsQ0FBUyxVQUFULEVBQXFCO0FBQ2pCa1IsMkJBQU9nTCxTQURVO0FBRWpCRSwyQkFBTyxFQUZVO0FBR2pCck0sNEJBQVFnTSxTQUhTO0FBSWpCSSwrQkFBV0E7QUFKTSxpQkFBckIsRUFLRyxVQUFVcmQsR0FBVixFQUFla0UsSUFBZixFQUFxQjtBQUNwQix3QkFBSWxFLEdBQUosRUFBUztBQUNMMFEsK0JBQU8xUSxHQUFQO0FBQ0gscUJBRkQsTUFFTztBQUNIeUUsZ0NBQVFQLEtBQUsyUSxHQUFMLENBQVMsVUFBVTVLLE9BQVYsRUFBbUI7QUFDaEMsbUNBQU9BLFFBQVF6SSxLQUFmO0FBQ0gseUJBRk8sQ0FBUjtBQUdIO0FBQ0osaUJBYkQ7QUFjSCxhQWZNLENBQVA7QUFnQkg7O0FBRURnRCxnQkFBUXVDLEdBQVIsQ0FBWSxDQUNSb1csYUFEUSxFQUVSRCxlQUZRLENBQVosRUFHR25iLElBSEgsQ0FHUTJhLFNBSFIsRUFHbUIsVUFBVTFjLEdBQVYsRUFBZTtBQUM5QjJjLG1CQUFPM2MsSUFBSStRLElBQUosR0FBVyxJQUFYLEdBQWtCL1EsSUFBSUcsT0FBN0I7QUFDSCxTQUxEO0FBTUgsS0FyU1U7O0FBdVNYOzs7OztBQUtBeUwsb0JBQWdCLFNBQVMyUiw4QkFBVCxDQUF3Q3JWLGFBQXhDLEVBQXVEN0QsR0FBdkQsRUFBNERxWSxTQUE1RCxFQUF1RUMsTUFBdkUsRUFBK0U7QUFDM0YsWUFBSXZaLFNBQVM4RSxhQUFiO0FBQ0EsWUFBSXNWLGVBQWUvSixPQUFPcFAsR0FBUCxDQUFuQjs7QUFFQXFZLG9CQUFZQSxhQUFhL1csRUFBRUMsSUFBM0I7QUFDQStXLGlCQUFTQSxVQUFVaFgsRUFBRUMsSUFBckI7O0FBRUEsYUFBS3VXLEtBQUwsQ0FBVy9ZLE1BQVgsRUFBbUJsQyxHQUFuQixDQUF1QixVQUF2QixFQUFtQztBQUMvQnVjLG1CQUFPQyxZQUFZQyxJQUFaLENBQWlCSCxZQUFqQjtBQUR3QixTQUFuQyxFQUVHLFVBQVV4ZCxHQUFWLEVBQWVpQixPQUFmLEVBQXdCO0FBQ3ZCLGdCQUFJakIsR0FBSixFQUFTO0FBQ0wyYyx1QkFBTzNjLElBQUkrUSxJQUFKLEdBQVcsSUFBWCxHQUFrQi9RLElBQUlHLE9BQTdCO0FBQ0E7QUFDSDs7QUFFRCxnQkFBSSxDQUFDYyxRQUFRNEYsTUFBYixFQUFxQjtBQUNqQjhWLHVCQUFPLElBQVA7QUFDQTtBQUNIOztBQUVERCxzQkFBVXpiLFFBQVEsQ0FBUixFQUFXTyxLQUFyQjtBQUNILFNBZEQ7QUFlSCxLQWxVVTs7QUFvVVg7Ozs7Ozs7O0FBUUFnVSxzQkFBa0IsU0FBU29JLGdDQUFULENBQTBDWCxTQUExQyxFQUFxRFAsU0FBckQsRUFBZ0VDLE1BQWhFLEVBQXdFO0FBQ3RGLFlBQUl2WixTQUFTLEtBQUt3WixPQUFsQjtBQUNBLFlBQUk3YixPQUFPLEtBQUtvYixLQUFMLENBQVcvWSxNQUFYLENBQVg7O0FBRUEsaUJBQVN5YSxZQUFULENBQXNCWixTQUF0QixFQUFpQztBQUM3QixtQkFBTyxJQUFJelksT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUJpTSxNQUFuQixFQUEyQjtBQUMxQzNQLHFCQUFLRyxHQUFMLENBQVMsT0FBVCxFQUFrQjtBQUNka1IsMkJBQU8sY0FETztBQUVkbkIsNEJBQVFnTSxTQUZNO0FBR2RJLCtCQUFXLDJDQUhHO0FBSWRDLDJCQUFPO0FBSk8saUJBQWxCLEVBS0csVUFBVXRkLEdBQVYsRUFBZWlCLE9BQWYsRUFBd0I7QUFDdkIsd0JBQUlqQixHQUFKLEVBQVM7QUFDTDBRLCtCQUFPMVEsR0FBUDtBQUNILHFCQUZELE1BRU87QUFDSHlFLGdDQUFReEQsT0FBUjtBQUNIO0FBQ0osaUJBWEQ7QUFZSCxhQWJNLENBQVA7QUFjSDs7QUFFRCxpQkFBUzZjLGFBQVQsR0FBeUI7QUFDckIsbUJBQU8sSUFBSXRaLE9BQUosQ0FBWSxVQUFVQyxPQUFWLEVBQW1CaU0sTUFBbkIsRUFBMkI7QUFDMUMzUCxxQkFBSzJRLEtBQUwsQ0FBVyxPQUFYLEVBQW9CLFVBQVUxUixHQUFWLEVBQWV3UCxLQUFmLEVBQXNCO0FBQ3RDLHdCQUFJeFAsR0FBSixFQUFTO0FBQ0wwUSwrQkFBTzFRLEdBQVA7QUFDSCxxQkFGRCxNQUVPO0FBQ0h5RSxnQ0FBUStLLEtBQVI7QUFDSDtBQUNKLGlCQU5EO0FBT0gsYUFSTSxDQUFQO0FBU0g7O0FBRUQsaUJBQVM1RCxjQUFULENBQXdCaEgsRUFBeEIsRUFBNEI7QUFDeEIsbUJBQU8sSUFBSUosT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUJpTSxNQUFuQixFQUEyQjtBQUMxQzNQLHFCQUFLRyxHQUFMLENBQVMsVUFBVCxFQUFxQjtBQUNqQnVjLDJCQUFPQyxZQUFZQyxJQUFaLENBQWlCL1ksRUFBakI7QUFEVSxpQkFBckIsRUFFRyxVQUFVNUUsR0FBVixFQUFlaUIsT0FBZixFQUF3QjtBQUN2Qix3QkFBSWpCLEdBQUosRUFBUztBQUNMMFEsK0JBQU8xUSxJQUFJK1EsSUFBSixHQUFXLElBQVgsR0FBa0IvUSxJQUFJRyxPQUE3QjtBQUNILHFCQUZELE1BRU8sSUFBSSxDQUFDYyxRQUFRNEYsTUFBYixFQUFxQjtBQUN4QjFGLGdDQUFRMkgsSUFBUixDQUFhLHNCQUFzQmxFLEVBQW5DO0FBQ0FILGdDQUFRLElBQVI7QUFDSCxxQkFITSxNQUdBO0FBQ0hBLGdDQUFRO0FBQ0pHLGdDQUFJQSxFQURBO0FBRUo2Ryx3Q0FBWXhLLFFBQVEsQ0FBUixFQUFXTyxLQUFYLENBQWlCaUssVUFGekI7QUFHSkMsdUNBQVd6SyxRQUFRLENBQVIsRUFBV08sS0FBWCxDQUFpQmtLO0FBSHhCLHlCQUFSO0FBS0g7QUFDSixpQkFmRDtBQWdCSCxhQWpCTSxDQUFQO0FBa0JIOztBQUVELGlCQUFTcVMsbUJBQVQsQ0FBNkI5QyxNQUE3QixFQUFxQztBQUNqQyxtQkFBTyxJQUFJelcsT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUJpTSxNQUFuQixFQUEyQjtBQUMxQzNQLHFCQUFLRyxHQUFMLENBQVMsVUFBVCxFQUFxQjtBQUNqQmtSLDJCQUFPLG1CQURVO0FBRWpCaUwsK0JBQVcsaURBRk07QUFHakJJLDJCQUFPQyxZQUFZTSxLQUFaLENBQWtCLENBQUMvQyxPQUFPclcsRUFBUixDQUFsQixFQUErQixDQUFDcVcsT0FBT3JXLEVBQVIsRUFBWXlKLEtBQUtDLEdBQUwsRUFBWixDQUEvQjtBQUhVLGlCQUFyQixFQUlHLFVBQVV0TyxHQUFWLEVBQWVrRSxJQUFmLEVBQXFCO0FBQ3BCLHdCQUFJbEUsR0FBSixFQUFTO0FBQ0wwUSwrQkFBTzFRLEdBQVA7QUFDSCxxQkFGRCxNQUVPO0FBQ0gsNEJBQUkyVCxXQUFXLEVBQWY7QUFDQSw0QkFBSXNLLDJCQUEyQixLQUEvQjs7QUFFQS9aLDZCQUFLK0IsT0FBTCxDQUFhLFVBQVVpWSxPQUFWLEVBQW1CO0FBQzVCLGdDQUFJQSxRQUFRMWMsS0FBUixDQUFjNkMsR0FBZCxJQUFxQmpCLE1BQXpCLEVBQWlDO0FBQzdCNmEsMkRBQTJCLElBQTNCO0FBQ0E7QUFDSDs7QUFFRHRLLHFDQUFTckosSUFBVCxDQUFjc0IsZUFBZXNTLFFBQVExYyxLQUFSLENBQWM2QyxHQUE3QixDQUFkO0FBQ0gseUJBUEQ7O0FBU0FHLGdDQUFRdUMsR0FBUixDQUFZNE0sUUFBWixFQUFzQjVSLElBQXRCLENBQTJCLFVBQVU0RyxHQUFWLEVBQWU7QUFDdENzUyxtQ0FBT2tELFlBQVAsR0FBc0J4WSxFQUFFeVksT0FBRixDQUFVelYsR0FBVixDQUF0Qjs7QUFFQSxnQ0FBSXNWLHdCQUFKLEVBQThCO0FBQzFCaEQsdUNBQU9rRCxZQUFQLENBQW9CN1QsSUFBcEIsQ0FBeUIsRUFBQ2pHLEtBQUtqQixNQUFOLEVBQXpCO0FBQ0g7O0FBRURxQjtBQUNILHlCQVJELEVBUUcsVUFBVXpFLEdBQVYsRUFBZTtBQUNkaWIsbUNBQU9rRCxZQUFQLEdBQXNCLEVBQXRCO0FBQ0ExWjtBQUNILHlCQVhEO0FBWUg7QUFDSixpQkFqQ0Q7QUFrQ0gsYUFuQ00sQ0FBUDtBQW9DSDs7QUFFRCxpQkFBUzRaLGtCQUFULENBQTRCcEQsTUFBNUIsRUFBb0M7QUFDaEMsbUJBQU8sSUFBSXpXLE9BQUosQ0FBWSxVQUFVQyxPQUFWLEVBQW1CaU0sTUFBbkIsRUFBMkI7QUFDMUMzUCxxQkFBS0csR0FBTCxDQUFTLFVBQVQsRUFBcUI7QUFDakJrUiwyQkFBTyxlQURVO0FBRWpCcUwsMkJBQU9DLFlBQVlDLElBQVosQ0FBaUIxQyxPQUFPclcsRUFBeEIsQ0FGVTtBQUdqQnlZLCtCQUFXLDJDQUhNO0FBSWpCQywyQkFBTztBQUpVLGlCQUFyQixFQUtHLFVBQVV0ZCxHQUFWLEVBQWVpQixPQUFmLEVBQXdCO0FBQ3ZCLHdCQUFJakIsR0FBSixFQUFTO0FBQ0wwUSwrQkFBTzFRLEdBQVA7QUFDSCxxQkFGRCxNQUVPO0FBQ0hpYiwrQkFBT3RRLElBQVAsR0FBYzFKLFFBQVEsQ0FBUixFQUFXTyxLQUFYLENBQWlCbUosSUFBL0I7QUFDQXNRLCtCQUFPNVcsR0FBUCxHQUFhcEQsUUFBUSxDQUFSLEVBQVdPLEtBQVgsQ0FBaUI2QyxHQUE5Qjs7QUFFQUk7QUFDSDtBQUNKLGlCQWREO0FBZUgsYUFoQk0sQ0FBUDtBQWlCSDs7QUFFRCxpQkFBUzZaLG9CQUFULENBQThCckQsTUFBOUIsRUFBc0M7QUFDbEMsbUJBQU8sSUFBSXpXLE9BQUosQ0FBWSxVQUFVQyxPQUFWLEVBQW1CaU0sTUFBbkIsRUFBMkI7QUFDMUMzUCxxQkFBSzJRLEtBQUwsQ0FBVyxVQUFYLEVBQXVCO0FBQ25CVSwyQkFBTyxlQURZO0FBRW5CcUwsMkJBQU9DLFlBQVlDLElBQVosQ0FBaUIxQyxPQUFPclcsRUFBeEI7QUFGWSxpQkFBdkIsRUFHRyxVQUFVNUUsR0FBVixFQUFld1AsS0FBZixFQUFzQjtBQUNyQix3QkFBSXhQLEdBQUosRUFBUztBQUNMMFEsK0JBQU8xUSxHQUFQO0FBQ0gscUJBRkQsTUFFTztBQUNIaWIsK0JBQU96TCxLQUFQLEdBQWVBLEtBQWY7QUFDQS9LO0FBQ0g7QUFDSixpQkFWRDtBQVdILGFBWk0sQ0FBUDtBQWFIOztBQUVERCxnQkFBUXVDLEdBQVIsQ0FBWSxDQUNSOFcsYUFBYVosU0FBYixDQURRLEVBRVJhLGVBRlEsQ0FBWixFQUdHL2IsSUFISCxDQUdRLENBQUMsQ0FBQ2laLEtBQUQsRUFBUXhMLEtBQVIsQ0FBRCxLQUFvQjtBQUN4QixnQkFBSStPLG1CQUFtQixFQUF2QjtBQUNBLGdCQUFJOUcsU0FBUzlPLElBQUlxUyxLQUFKLENBQVVuRyxHQUFWLENBQWMsVUFBVW9HLE1BQVYsRUFBa0I7QUFDekMsb0JBQUl1RCxXQUFXO0FBQ1g1Wix3QkFBSXFXLE9BQU96WixLQUFQLENBQWFvRCxFQUROO0FBRVhJLDJCQUFPaVcsT0FBT3paLEtBQVAsQ0FBYXdELEtBRlQ7QUFHWDBGLDBCQUFNdVEsT0FBT3paLEtBQVAsQ0FBYTZaO0FBSFIsaUJBQWY7O0FBTUFrRCxpQ0FBaUJqVSxJQUFqQixDQUFzQnlULG9CQUFvQlMsUUFBcEIsQ0FBdEI7QUFDQUQsaUNBQWlCalUsSUFBakIsQ0FBc0IrVCxtQkFBbUJHLFFBQW5CLENBQXRCO0FBQ0FELGlDQUFpQmpVLElBQWpCLENBQXNCZ1UscUJBQXFCRSxRQUFyQixDQUF0Qjs7QUFFQSx1QkFBT0EsUUFBUDtBQUNILGFBWlksQ0FBYjs7QUFjQWhhLG9CQUFRdUMsR0FBUixDQUFZd1gsZ0JBQVosRUFBOEJ4YyxJQUE5QixDQUFtQyxZQUFZO0FBQzNDMmEsMEJBQVUsQ0FDTmpGLE1BRE0sRUFFTjlPLElBQUk2RyxLQUZFLENBQVY7QUFJSCxhQUxELEVBS0csVUFBVXhQLEdBQVYsRUFBZTtBQUNkMmMsdUJBQU8zYyxJQUFJK1EsSUFBSixHQUFXLElBQVgsR0FBa0IvUSxJQUFJRyxPQUE3QjtBQUNILGFBUEQ7QUFRSCxTQTNCRCxFQTJCRyxVQUFVSCxHQUFWLEVBQWU7QUFDZDJjLG1CQUFPM2MsSUFBSStRLElBQUosR0FBVyxJQUFYLEdBQWtCL1EsSUFBSUcsT0FBN0I7QUFDSCxTQTdCRDtBQThCSCxLQTNlVTs7QUE2ZVg7Ozs7O0FBS0EyVix1Q0FBbUMsU0FBUzJJLGlEQUFULENBQTJEcGEsR0FBM0QsRUFBZ0VxWSxTQUFoRSxFQUEyRUMsTUFBM0UsRUFBbUY7QUFDbEgsWUFBSXZaLFNBQVMsS0FBS3daLE9BQWxCO0FBQ0EsWUFBSTdiLE9BQU8sS0FBS29iLEtBQUwsQ0FBVy9ZLE1BQVgsQ0FBWDs7QUFFQWlCLGNBQU1vUCxPQUFPcFAsR0FBUCxDQUFOOztBQUVBLGlCQUFTdUgsY0FBVCxDQUF3QmhILEVBQXhCLEVBQTRCO0FBQ3hCLG1CQUFPLElBQUlKLE9BQUosQ0FBWSxVQUFVQyxPQUFWLEVBQW1CaU0sTUFBbkIsRUFBMkI7QUFDMUMzUCxxQkFBS0csR0FBTCxDQUFTLFVBQVQsRUFBcUI7QUFDakJ1YywyQkFBT0MsWUFBWUMsSUFBWixDQUFpQi9ZLEVBQWpCO0FBRFUsaUJBQXJCLEVBRUcsVUFBVTVFLEdBQVYsRUFBZWlCLE9BQWYsRUFBd0I7QUFDdkIsd0JBQUlqQixHQUFKLEVBQVM7QUFDTDBRLCtCQUFPMVEsR0FBUDtBQUNILHFCQUZELE1BRU8sSUFBSSxDQUFDaUIsUUFBUTRGLE1BQWIsRUFBcUI7QUFDeEJwQyxnQ0FBUSxJQUFSO0FBQ0gscUJBRk0sTUFFQTtBQUNIQSxnQ0FBUTtBQUNKSixpQ0FBS3BELFFBQVEsQ0FBUixFQUFXTSxHQURaO0FBRUprSyx3Q0FBWXhLLFFBQVEsQ0FBUixFQUFXTyxLQUFYLENBQWlCaUssVUFGekI7QUFHSkMsdUNBQVd6SyxRQUFRLENBQVIsRUFBV08sS0FBWCxDQUFpQmtLO0FBSHhCLHlCQUFSO0FBS0g7QUFDSixpQkFkRDtBQWVILGFBaEJNLENBQVA7QUFpQkg7O0FBRUQsaUJBQVNxUyxtQkFBVCxDQUE2QjlDLE1BQTdCLEVBQXFDO0FBQ2pDLG1CQUFPLElBQUl6VyxPQUFKLENBQVksVUFBVUMsT0FBVixFQUFtQmlNLE1BQW5CLEVBQTJCO0FBQzFDLG9CQUFJZ0wsU0FBU1QsT0FBT3JXLEVBQXBCO0FBQ0Esb0JBQUkyUixLQUFLbUYsT0FBT2dELE1BQVAsQ0FBYyxDQUFkLEVBQWlCaEQsT0FBTzdVLE1BQVAsR0FBZ0IsQ0FBakMsSUFBc0N6RSxPQUFPdWMsWUFBUCxDQUFvQmpELE9BQU9rRCxVQUFQLENBQWtCbEQsT0FBTzdVLE1BQVAsR0FBZ0IsQ0FBbEMsSUFBdUMsQ0FBM0QsQ0FBL0M7QUFDQSxvQkFBSTRXLFFBQVFDLFlBQVlNLEtBQVosQ0FBa0IsQ0FBQ3RDLE1BQUQsQ0FBbEIsRUFBNEIsQ0FBQ25GLEVBQUQsQ0FBNUIsRUFBa0MsSUFBbEMsRUFBd0MsSUFBeEMsQ0FBWjs7QUFFQXhWLHFCQUFLRyxHQUFMLENBQVMsVUFBVCxFQUFxQjtBQUNqQmtSLDJCQUFPLG1CQURVO0FBRWpCcUwsMkJBQU9BLEtBRlU7QUFHakJKLCtCQUFXLGlEQUFBd0I7QUFITSxpQkFBckIsRUFJRyxVQUFVN2UsR0FBVixFQUFlaUIsT0FBZixFQUF3QjtBQUN2Qix3QkFBSWpCLEdBQUosRUFBUztBQUNMMFEsK0JBQU8xUSxHQUFQO0FBQ0gscUJBRkQsTUFFTztBQUNILDRCQUFJMlQsV0FBVyxFQUFmO0FBQ0ExUyxnQ0FBUWdGLE9BQVIsQ0FBZ0IsVUFBVWdWLE1BQVYsRUFBa0I7QUFDOUJ0SCxxQ0FBU3JKLElBQVQsQ0FBY3NCLGVBQWVxUCxPQUFPelosS0FBUCxDQUFhNkMsR0FBNUIsQ0FBZDtBQUNILHlCQUZEOztBQUlBRyxnQ0FBUXVDLEdBQVIsQ0FBWTRNLFFBQVosRUFBc0I1UixJQUF0QixDQUEyQixVQUFVNEcsR0FBVixFQUFlO0FBQ3RDc1MsbUNBQU9rRCxZQUFQLEdBQXNCeFksRUFBRXlZLE9BQUYsQ0FBVXpWLEdBQVYsQ0FBdEI7QUFDQWxFO0FBQ0gseUJBSEQsRUFHR2lNLE1BSEg7QUFJSDtBQUNKLGlCQWxCRDtBQW1CSCxhQXhCTSxDQUFQO0FBeUJIOztBQUVELGlCQUFTMk4sa0JBQVQsQ0FBNEJwRCxNQUE1QixFQUFvQztBQUNoQyxtQkFBTyxJQUFJelcsT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUJpTSxNQUFuQixFQUEyQjtBQUMxQzNQLHFCQUFLRyxHQUFMLENBQVMsVUFBVCxFQUFxQjtBQUNqQmtSLDJCQUFPLGVBRFU7QUFFakJxTCwyQkFBT0MsWUFBWUMsSUFBWixDQUFpQjFDLE9BQU9yVyxFQUF4QixDQUZVO0FBR2pCeVksK0JBQVcsMkNBQUF5QjtBQUhNLGlCQUFyQixFQUlHLFVBQVU5ZSxHQUFWLEVBQWVpQixPQUFmLEVBQXdCO0FBQ3ZCLHdCQUFJakIsR0FBSixFQUFTO0FBQ0wwUSwrQkFBTzFRLEdBQVA7QUFDSCxxQkFGRCxNQUVPO0FBQ0gsNEJBQUlnRixRQUFRL0QsUUFBUTRGLE1BQVIsR0FBaUI1RixRQUFRLENBQVIsRUFBV08sS0FBWCxDQUFpQndELEtBQWxDLEdBQTBDLEVBQXREO0FBQ0EsNEJBQUkyRixPQUFPMUosUUFBUTRGLE1BQVIsR0FBaUI1RixRQUFRLENBQVIsRUFBV08sS0FBWCxDQUFpQm1KLElBQWxDLEdBQXlDLEVBQXBEO0FBQ0EsNEJBQUlELE9BQU96SixRQUFRNEYsTUFBUixHQUFpQjVGLFFBQVEsQ0FBUixFQUFXTyxLQUFYLENBQWlCa0osSUFBbEMsR0FBeUMsQ0FBcEQ7QUFDQSw0QkFBSXJHLE1BQU1wRCxRQUFRNEYsTUFBUixHQUFpQjVGLFFBQVEsQ0FBUixFQUFXTyxLQUFYLENBQWlCNkMsR0FBbEMsR0FBd0NqQixNQUFsRDs7QUFFQTBLLCtCQUFPaVIsTUFBUCxDQUFjOUQsTUFBZCxFQUFzQjtBQUNsQmpXLG1DQUFPQSxLQURXO0FBRWxCMkYsa0NBQU1BLElBRlk7QUFHbEJELGtDQUFNQSxJQUhZO0FBSWxCckcsaUNBQUtBO0FBSmEseUJBQXRCOztBQU9BSTtBQUNIO0FBQ0osaUJBdEJEO0FBdUJILGFBeEJNLENBQVA7QUF5Qkg7O0FBRUQsaUJBQVN1YSxpQkFBVCxDQUEyQi9ELE1BQTNCLEVBQW1DO0FBQy9CLG1CQUFPLElBQUl6VyxPQUFKLENBQVksVUFBVUMsT0FBVixFQUFtQmlNLE1BQW5CLEVBQTJCO0FBQzFDM1AscUJBQUsyUSxLQUFMLENBQVcsVUFBWCxFQUF1QjtBQUNuQlUsMkJBQU8sZUFEWTtBQUVuQnFMLDJCQUFPQyxZQUFZQyxJQUFaLENBQWlCMUMsT0FBT3JXLEVBQXhCO0FBRlksaUJBQXZCLEVBR0csVUFBVTVFLEdBQVYsRUFBZXdQLEtBQWYsRUFBc0I7QUFDckIsd0JBQUl4UCxHQUFKLEVBQVM7QUFDTDBRLCtCQUFPMVEsR0FBUDtBQUNILHFCQUZELE1BRU87QUFDSGliLCtCQUFPekwsS0FBUCxHQUFlQSxLQUFmO0FBQ0EvSztBQUNIO0FBQ0osaUJBVkQ7QUFXSCxhQVpNLENBQVA7QUFhSDs7QUFFRDFELGFBQUtHLEdBQUwsQ0FBUyxVQUFULEVBQXFCO0FBQ2pCa1IsbUJBQU8sWUFEVTtBQUVqQnFMLG1CQUFPQyxZQUFZTSxLQUFaLENBQWtCLENBQUMzWixHQUFELENBQWxCLEVBQXlCLENBQUNBLE1BQU0sQ0FBUCxDQUF6QixFQUFvQyxJQUFwQyxFQUEwQyxJQUExQyxDQUZVO0FBR2pCZ1osdUJBQVcsaURBQUF3QjtBQUhNLFNBQXJCLEVBSUcsVUFBVTdlLEdBQVYsRUFBZWlCLE9BQWYsRUFBd0I7QUFDdkIsZ0JBQUlqQixHQUFKLEVBQVM7QUFDTDJjLHVCQUFPM2MsSUFBSStRLElBQUosR0FBVyxJQUFYLEdBQWtCL1EsSUFBSUcsT0FBN0I7QUFDQTtBQUNIOztBQUVELGdCQUFJc1gsU0FBUyxFQUFiO0FBQ0EsZ0JBQUk5RCxXQUFXLEVBQWY7O0FBRUExUyxvQkFBUWdGLE9BQVIsQ0FBZ0IsVUFBVWdWLE1BQVYsRUFBa0I7QUFDOUIsb0JBQUlnRSxhQUFhO0FBQ2JyYSx3QkFBSXFXLE9BQU8xWixHQUFQLENBQVcsQ0FBWDtBQURTLGlCQUFqQjs7QUFJQWtXLHVCQUFPbk4sSUFBUCxDQUFZMlUsVUFBWjs7QUFFQXRMLHlCQUFTckosSUFBVCxDQUFjK1QsbUJBQW1CWSxVQUFuQixDQUFkO0FBQ0F0TCx5QkFBU3JKLElBQVQsQ0FBY3lULG9CQUFvQmtCLFVBQXBCLENBQWQ7QUFDQXRMLHlCQUFTckosSUFBVCxDQUFjMFUsa0JBQWtCQyxVQUFsQixDQUFkO0FBQ0gsYUFWRDs7QUFZQXphLG9CQUFRdUMsR0FBUixDQUFZNE0sUUFBWixFQUFzQjVSLElBQXRCLENBQTJCLFlBQVk7QUFDbkM7QUFDQTBWLHVCQUFPeUgsSUFBUCxDQUFZLFVBQVVDLENBQVYsRUFBYUMsQ0FBYixFQUFnQjtBQUN4QiwyQkFBT0EsRUFBRTFVLElBQUYsR0FBU3lVLEVBQUV6VSxJQUFsQjtBQUNILGlCQUZEOztBQUlBZ1MsMEJBQVVqRixNQUFWO0FBQ0gsYUFQRCxFQU9HLFVBQVV6WCxHQUFWLEVBQWU7QUFDZDJjLHVCQUFPM2MsSUFBSStRLElBQUosR0FBVyxJQUFYLEdBQWtCL1EsSUFBSUcsT0FBN0I7QUFDSCxhQVREO0FBVUgsU0FuQ0Q7QUFvQ0gsS0F4bkJVOztBQTBuQlg7Ozs7Ozs7Ozs7Ozs7QUFhQXNWLHFCQUFpQixTQUFTNEosK0JBQVQsQ0FBeUNDLFFBQXpDLEVBQW1EQyxJQUFuRCxFQUF5RDdDLFNBQXpELEVBQW9FQyxNQUFwRSxFQUE0RTtBQUN6RixZQUFJdlosU0FBUyxLQUFLd1osT0FBbEI7QUFDQSxZQUFJN2IsT0FBTyxLQUFLb2IsS0FBTCxDQUFXL1ksTUFBWCxDQUFYOztBQUVBbWMsYUFBSzNWLElBQUwsR0FBWTJWLEtBQUszVixJQUFMLElBQWEsQ0FBekI7QUFDQTJWLGFBQUs3SixVQUFMLEdBQWtCNkosS0FBSzdKLFVBQUwsSUFBbUIsS0FBckM7O0FBRUEsaUJBQVM5SixjQUFULENBQXdCaEgsRUFBeEIsRUFBNEI7QUFDeEJBLGlCQUFLNk8sT0FBTzdPLEVBQVAsQ0FBTDs7QUFFQSxtQkFBTyxJQUFJSixPQUFKLENBQVksVUFBVUMsT0FBVixFQUFtQmlNLE1BQW5CLEVBQTJCO0FBQzFDM1AscUJBQUtHLEdBQUwsQ0FBUyxVQUFULEVBQXFCO0FBQ2pCdWMsMkJBQU9DLFlBQVlDLElBQVosQ0FBaUIvWSxFQUFqQjtBQURVLGlCQUFyQixFQUVHLFVBQVU1RSxHQUFWLEVBQWVpQixPQUFmLEVBQXdCO0FBQ3ZCLHdCQUFJakIsR0FBSixFQUFTO0FBQ0wwUSwrQkFBTzFRLEdBQVA7QUFDSCxxQkFGRCxNQUVPLElBQUksQ0FBQ2lCLFFBQVE0RixNQUFiLEVBQXFCO0FBQ3hCcEMsZ0NBQVEsSUFBUjtBQUNILHFCQUZNLE1BRUE7QUFDSEEsZ0NBQVE7QUFDSkosaUNBQUtwRCxRQUFRLENBQVIsRUFBV00sR0FEWjtBQUVKNkosbUNBQU9uSyxRQUFRLENBQVIsRUFBV08sS0FBWCxDQUFpQjRKLEtBRnBCO0FBR0pLLHdDQUFZeEssUUFBUSxDQUFSLEVBQVdPLEtBQVgsQ0FBaUJpSyxVQUh6QjtBQUlKQyx1Q0FBV3pLLFFBQVEsQ0FBUixFQUFXTyxLQUFYLENBQWlCa0s7QUFKeEIseUJBQVI7QUFNSDtBQUNKLGlCQWZEO0FBZ0JILGFBakJNLENBQVA7QUFrQkg7O0FBRUQsaUJBQVNzVCxpQkFBVCxHQUE2QjtBQUN6QixtQkFBTyxJQUFJeGEsT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUJpTSxNQUFuQixFQUEyQjtBQUMxQzNQLHFCQUFLMlEsS0FBTCxDQUFXLFVBQVgsRUFBdUI7QUFDbkJVLDJCQUFPLGVBRFk7QUFFbkJxTCwyQkFBT0MsWUFBWUMsSUFBWixDQUFpQjJCLFFBQWpCO0FBRlksaUJBQXZCLEVBR0csVUFBVXRmLEdBQVYsRUFBZXdQLEtBQWYsRUFBc0I7QUFDckIsd0JBQUl4UCxHQUFKLEVBQVM7QUFDTDBRLCtCQUFPMVEsR0FBUDtBQUNILHFCQUZELE1BRU87QUFDSHlFLGdDQUFRK0ssS0FBUjtBQUNIO0FBQ0osaUJBVEQ7QUFVSCxhQVhNLENBQVA7QUFZSDs7QUFFRCxpQkFBU2dRLGVBQVQsR0FBMkI7QUFDdkIsbUJBQU8sSUFBSWhiLE9BQUosQ0FBWSxVQUFVQyxPQUFWLEVBQW1CaU0sTUFBbkIsRUFBMkI7QUFDMUMsb0JBQUkrTyxVQUFVO0FBQ1ZyTiwyQkFBTyxlQURHO0FBRVZxTCwyQkFBT0MsWUFBWUMsSUFBWixDQUFpQjJCLFFBQWpCLENBRkc7QUFHVmpDLCtCQUFXLDJDQUhEO0FBSVZwTSw0QkFBUXNPLEtBQUszVjtBQUpILGlCQUFkOztBQU9BLG9CQUFJLENBQUMyVixLQUFLN0osVUFBVixFQUFzQjtBQUNsQitKLDRCQUFRbkMsS0FBUixHQUFnQixFQUFoQjtBQUNIOztBQUVEdmMscUJBQUtHLEdBQUwsQ0FBUyxVQUFULEVBQXFCdWUsT0FBckIsRUFBOEIsVUFBVXpmLEdBQVYsRUFBZWlCLE9BQWYsRUFBd0I7QUFDbEQsd0JBQUlqQixHQUFKLEVBQVM7QUFDTDBRLCtCQUFPMVEsR0FBUDtBQUNILHFCQUZELE1BRU87QUFDSHlFLGdDQUFReEQsT0FBUjtBQUNIO0FBQ0osaUJBTkQ7QUFPSCxhQW5CTSxDQUFQO0FBb0JIOztBQUVEdUQsZ0JBQVF1QyxHQUFSLENBQVksQ0FDUnlZLGlCQURRLEVBRVJSLG1CQUZRLENBQVosRUFHR2pkLElBSEgsQ0FHUSxVQUFVNEcsR0FBVixFQUFlO0FBQ25CLGdCQUFJb0osV0FBV3BKLElBQUksQ0FBSixFQUFPK1csT0FBUCxFQUFmO0FBQ0EsZ0JBQUlsUSxRQUFRN0csSUFBSSxDQUFKLENBQVo7QUFDQSxnQkFBSWdMLFdBQVcsRUFBZjtBQUNBLGdCQUFJOEQsU0FBUyxFQUFiOztBQUVBO0FBQ0E5RCxxQkFBU3ZRLE1BQVQsSUFBbUJ3SSxlQUFleEksTUFBZixDQUFuQjs7QUFFQTJPLHFCQUFTOUwsT0FBVCxDQUFpQixVQUFVZ1YsTUFBVixFQUFrQjtBQUMvQnhELHVCQUFPbk4sSUFBUCxDQUFZO0FBQ1JHLHlCQUFLd1EsT0FBT3paLEtBQVAsQ0FBYWlKLEdBRFY7QUFFUnpGLDJCQUFPaVcsT0FBT3paLEtBQVAsQ0FBYXdELEtBRlo7QUFHUjJGLDBCQUFNc1EsT0FBT3paLEtBQVAsQ0FBYW1KLElBSFg7QUFJUkQsMEJBQU11USxPQUFPelosS0FBUCxDQUFha0osSUFKWDtBQUtSc1IsNEJBQVF2SSxPQUFPd0gsT0FBT3paLEtBQVAsQ0FBYXVhLElBQXBCLENBTEE7QUFNUjFYLHlCQUFLNFcsT0FBT3paLEtBQVAsQ0FBYTZDLEdBTlY7QUFPUnlHLDBCQUFNbVEsT0FBT3paLEtBQVAsQ0FBYXNKLElBUFg7QUFRUm1SLCtCQUFXaEIsT0FBT3paLEtBQVAsQ0FBYXlhLFNBUmhCO0FBU1JqUyxpQ0FBYWlSLE9BQU96WixLQUFQLENBQWF3STtBQVRsQixpQkFBWjs7QUFZQSxvQkFBSSxDQUFDMkosU0FBU3NILE9BQU96WixLQUFQLENBQWE2QyxHQUF0QixDQUFELElBQStCNFcsT0FBT3paLEtBQVAsQ0FBYTZDLEdBQWIsSUFBb0JqQixNQUF2RCxFQUErRDtBQUMzRHVRLDZCQUFTc0gsT0FBT3paLEtBQVAsQ0FBYTZDLEdBQXRCLElBQTZCdUgsZUFBZXFQLE9BQU96WixLQUFQLENBQWE2QyxHQUE1QixDQUE3QjtBQUNIO0FBQ0osYUFoQkQ7O0FBa0JBc2Isd0JBQVk1WSxHQUFaLENBQWdCNE0sUUFBaEIsRUFBMEI1UixJQUExQixDQUErQixVQUFVNEcsR0FBVixFQUFlO0FBQzFDLG9CQUFJaVgsbUJBQW1CalgsSUFBSXZGLE1BQUosSUFBY3VGLElBQUl2RixNQUFKLEVBQVlnSSxLQUExQixHQUFrQyxJQUF6RDtBQUNBcU0sdUJBQU94UixPQUFQLENBQWUsVUFBVTlGLE9BQVYsRUFBbUI7QUFDOUIsd0JBQUksQ0FBQ3dJLElBQUl4SSxRQUFRa0UsR0FBWixDQUFMLEVBQXVCO0FBQ25CO0FBQ0g7O0FBRURsRSw0QkFBUXNMLFVBQVIsR0FBcUI5QyxJQUFJeEksUUFBUWtFLEdBQVosRUFBaUJvSCxVQUF0QztBQUNBdEwsNEJBQVF1TCxTQUFSLEdBQW9CL0MsSUFBSXhJLFFBQVFrRSxHQUFaLEVBQWlCcUgsU0FBckM7QUFDQXZMLDRCQUFRaUwsS0FBUixHQUFpQmpMLFFBQVEySyxJQUFSLENBQWE4UCxPQUFiLENBQXFCLE1BQXJCLE1BQWlDLENBQUMsQ0FBbkMsR0FBd0NqUyxJQUFJeEksUUFBUWtFLEdBQVosRUFBaUIrRyxLQUF6RCxHQUFpRXdVLGdCQUFqRjtBQUNILGlCQVJEOztBQVVBbEQsMEJBQVUsQ0FDTmpGLE1BRE0sRUFFTmpJLEtBRk0sQ0FBVjtBQUlILGFBaEJELEVBZ0JHLFVBQVV4UCxHQUFWLEVBQWU7QUFDZDJjLHVCQUFPM2MsSUFBSStRLElBQUosR0FBVyxJQUFYLEdBQWtCL1EsSUFBSUcsT0FBN0I7QUFDSCxhQWxCRDtBQW1CSCxTQWpERCxFQWlERyxVQUFVSCxHQUFWLEVBQWU7QUFDZDJjLG1CQUFPM2MsSUFBSStRLElBQUosR0FBVyxJQUFYLEdBQWtCL1EsSUFBSUcsT0FBN0I7QUFDSCxTQW5ERDtBQW9ESCxLQS92QlU7O0FBaXdCWDs7Ozs7QUFLQTBWLG9CQUFnQixTQUFTZ0ssOEJBQVQsQ0FBd0NwVixHQUF4QyxFQUE2Q2lTLFNBQTdDLEVBQXdEQyxNQUF4RCxFQUFnRTtBQUM1RSxZQUFJdlosU0FBUyxLQUFLd1osT0FBbEI7QUFDQSxZQUFJN2IsT0FBTyxLQUFLb2IsS0FBTCxDQUFXL1ksTUFBWCxDQUFYOztBQUVBLGlCQUFTMGMsZUFBVCxDQUF5QnpiLEdBQXpCLEVBQThCO0FBQzFCLG1CQUFPLElBQUlHLE9BQUosQ0FBWSxVQUFVQyxPQUFWLEVBQW1CaU0sTUFBbkIsRUFBMkI7QUFDMUMzUCxxQkFBS0csR0FBTCxDQUFTLFVBQVQsRUFBcUI7QUFDakJ1YywyQkFBT0MsWUFBWUMsSUFBWixDQUFpQnRaLEdBQWpCO0FBRFUsaUJBQXJCLEVBRUcsVUFBVXJFLEdBQVYsRUFBZWlCLE9BQWYsRUFBd0I7QUFDdkIsd0JBQUlqQixHQUFKLEVBQVM7QUFDTDBRLCtCQUFPMVEsR0FBUDtBQUNILHFCQUZELE1BRU8sSUFBSSxDQUFDaUIsUUFBUTRGLE1BQWIsRUFBcUI7QUFDeEJwQyxnQ0FBUSxJQUFSO0FBQ0gscUJBRk0sTUFFQTtBQUNIQSxnQ0FBUXhELFFBQVEsQ0FBUixFQUFXTyxLQUFYLENBQWlCNEosS0FBekI7QUFDSDtBQUNKLGlCQVZEO0FBV0gsYUFaTSxDQUFQO0FBYUg7O0FBRURySyxhQUFLRyxHQUFMLENBQVMsVUFBVCxFQUFxQjtBQUNqQnVjLG1CQUFPQyxZQUFZQyxJQUFaLENBQWlCbFQsR0FBakI7QUFEVSxTQUFyQixFQUVHLFVBQVV6SyxHQUFWLEVBQWVpQixPQUFmLEVBQXdCO0FBQ3ZCLGdCQUFJakIsR0FBSixFQUFTO0FBQ0wyYyx1QkFBTyxJQUFQLEVBQWEzYyxJQUFJK1EsSUFBSixHQUFXLElBQVgsR0FBa0IvUSxJQUFJRyxPQUFuQztBQUNBO0FBQ0g7O0FBRUQsZ0JBQUksQ0FBQ2MsUUFBUTRGLE1BQWIsRUFBcUI7QUFDakI4Vix1QkFBTyxLQUFQLEVBQWMseUJBQXlCbFMsR0FBdkM7QUFDQTtBQUNIOztBQUVELGdCQUFJeUUsTUFBTWpPLFFBQVEsQ0FBUixFQUFXTyxLQUFyQjtBQUNBc2UsNEJBQWdCNVEsSUFBSTdLLEdBQXBCLEVBQXlCdEMsSUFBekIsQ0FBOEIsVUFBVXFKLEtBQVYsRUFBaUI7QUFDM0M4RCxvQkFBSS9ELE1BQUosR0FBYUMsS0FBYjtBQUNBc1IsMEJBQVV4TixHQUFWO0FBQ0gsYUFIRCxFQUdHLFVBQVVsUCxHQUFWLEVBQWU7QUFDZDJjLHVCQUFPLElBQVAsRUFBYTNjLElBQUkrUSxJQUFKLEdBQVcsSUFBWCxHQUFrQi9RLElBQUlHLE9BQW5DO0FBQ0gsYUFMRDtBQU1ILFNBcEJEO0FBcUJILEtBL3lCVTs7QUFpekJYOzs7Ozs7O0FBT0EwUSxxQkFBaUIsU0FBU2tQLCtCQUFULENBQXlDM2MsTUFBekMsRUFBaURjLElBQWpELEVBQXVEO0FBQ3BFLFlBQUluRCxPQUFPLEtBQUtvYixLQUFMLENBQVcvWSxNQUFYLENBQVg7O0FBRUEsZUFBTyxJQUFJb0IsT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUJpTSxNQUFuQixFQUEyQjtBQUMxQyxnQkFBSXNQLGFBQWEsRUFBakI7QUFDQSxnQkFBSTNTLE9BQU9uSixLQUFLMlEsR0FBTCxDQUFTLFVBQVU5SyxRQUFWLEVBQW9CO0FBQ3BDLHVCQUFPMEosT0FBTzFKLFNBQVMsQ0FBVCxDQUFQLENBQVA7QUFDSCxhQUZVLENBQVg7O0FBSUEsZ0JBQUlzRCxLQUFLeEcsTUFBTCxHQUFjLENBQWxCLEVBQXFCO0FBQ2pCbVosMkJBQVc1TixLQUFYLEdBQW1CLGNBQW5CO0FBQ0E0TiwyQkFBV3ZDLEtBQVgsR0FBbUJDLFlBQVl1QyxVQUFaLENBQXVCLENBQXZCLENBQW5CO0FBQ0gsYUFIRCxNQUdPO0FBQ0hELDJCQUFXdkMsS0FBWCxHQUFtQkMsWUFBWUMsSUFBWixDQUFpQnRRLEtBQUssQ0FBTCxDQUFqQixDQUFuQjtBQUNIOztBQUVEdE0saUJBQUtHLEdBQUwsQ0FBUyxVQUFULEVBQXFCOGUsVUFBckIsRUFBaUMsVUFBVWhnQixHQUFWLEVBQWVpQixPQUFmLEVBQXdCO0FBQ3JELG9CQUFJakIsR0FBSixFQUFTO0FBQ0wwUSwyQkFBTzFRLEdBQVA7QUFDSCxpQkFGRCxNQUVPO0FBQ0gsd0JBQUlrZ0Isa0JBQWtCLEVBQXRCO0FBQ0FqZiw0QkFBUWdGLE9BQVIsQ0FBZ0IsVUFBVWdWLE1BQVYsRUFBa0I7QUFDOUIsNEJBQUk1TixLQUFLdU4sT0FBTCxDQUFhSyxPQUFPelosS0FBUCxDQUFhNkMsR0FBMUIsTUFBbUMsQ0FBQyxDQUF4QyxFQUEyQztBQUN2QzZiLDRDQUFnQmpGLE9BQU96WixLQUFQLENBQWE2QyxHQUE3QixJQUFvQzRXLE9BQU96WixLQUEzQztBQUNIO0FBQ0oscUJBSkQ7O0FBTUEsd0JBQUkyZSxpQkFBaUJqYyxLQUFLMlEsR0FBTCxDQUFTLFVBQVU5SyxRQUFWLEVBQW9CO0FBQzlDLDRCQUFJbVIsWUFBWW5SLFNBQVMsQ0FBVCxDQUFoQjtBQUNBLDRCQUFJMUYsTUFBTW9QLE9BQU8xSixTQUFTLENBQVQsQ0FBUCxDQUFWOztBQUVBLDRCQUFJbVUsVUFBVTtBQUNWN1osaUNBQUtBLEdBREs7QUFFVm9ILHdDQUFZMUIsU0FBUyxDQUFULENBRkY7QUFHVjJCLHVDQUFXM0IsU0FBUyxDQUFULENBSEQ7QUFJVnFSLG1DQUFPLEVBSkc7QUFLVkcsc0NBQVUsQ0FDTnhSLFNBQVMsQ0FBVCxFQUFZNFAsV0FBWixFQURNLEVBRU41UCxTQUFTLENBQVQsRUFBWTRQLFdBQVosRUFGTSxFQUdOdFYsR0FITTtBQUxBLHlCQUFkOztBQVlBLDRCQUFJNlcsVUFBVXJPLE1BQWQsRUFBc0I7QUFDbEJxUixvQ0FBUTNDLFFBQVIsQ0FBaUJqUixJQUFqQixDQUFzQjRRLFVBQVVyTyxNQUFWLENBQWlCOE0sV0FBakIsRUFBdEI7QUFDSDs7QUFFRCx5QkFBQyxPQUFELEVBQVUsT0FBVixFQUFtQixRQUFuQixFQUE2QixZQUE3QixFQUEyQyxjQUEzQyxFQUEyRDFULE9BQTNELENBQW1FLFVBQVVpRSxLQUFWLEVBQWlCO0FBQ2hGLGdDQUFJZ1IsVUFBVWhSLEtBQVYsQ0FBSixFQUFzQjtBQUNsQmdVLHdDQUFRaFUsS0FBUixJQUFpQmdSLFVBQVVoUixLQUFWLENBQWpCO0FBQ0g7QUFDSix5QkFKRDs7QUFNQSw0QkFBSWdSLFVBQVVuTCxHQUFkLEVBQW1CO0FBQ2ZtTyxvQ0FBUW5PLEdBQVIsR0FBYzBELE9BQU95SCxVQUFVbkwsR0FBakIsS0FBeUIsQ0FBdkM7QUFDSDs7QUFFRG1PLGdDQUFRN0MsZUFBUixHQUEwQjZFLGdCQUFnQjdiLEdBQWhCLElBQXVCNmIsZ0JBQWdCN2IsR0FBaEIsRUFBcUJnWCxlQUE1QyxHQUE4RCxDQUF4RjtBQUNBNkMsZ0NBQVE1QyxZQUFSLEdBQXVCNEUsZ0JBQWdCN2IsR0FBaEIsSUFBdUI2YixnQkFBZ0I3YixHQUFoQixFQUFxQmlYLFlBQTVDLEdBQTJELENBQWxGOztBQUVBLCtCQUFPNEMsT0FBUDtBQUNILHFCQWxDb0IsQ0FBckI7O0FBb0NBbmQseUJBQUtpQixNQUFMLENBQVk7QUFDUjBGLGtDQUFVeVk7QUFERixxQkFBWixFQUVHLFVBQVVuZ0IsR0FBVixFQUFlO0FBQ2QsNEJBQUlBLEdBQUosRUFBUztBQUNMMFEsbUNBQU8xUSxHQUFQO0FBQ0gseUJBRkQsTUFFTztBQUNIeUUsb0NBQVEwYixjQUFSO0FBQ0g7QUFDSixxQkFSRDtBQVNIO0FBQ0osYUF6REQ7QUEwREgsU0F2RU0sQ0FBUDtBQXdFSCxLQW40QlU7O0FBcTRCWDs7Ozs7Ozs7O0FBU0FuVixvQkFBZ0IsU0FBU29WLDhCQUFULENBQXdDbFksYUFBeEMsRUFBdUQ2SixRQUF2RCxFQUFpRTJLLFNBQWpFLEVBQTRFQyxNQUE1RSxFQUFvRjtBQUNoRyxZQUFJM0IsUUFBUSxFQUFaO0FBQ0EsWUFBSXFGLG1CQUFtQixFQUF2Qjs7QUFFQXRPLGlCQUFTOUwsT0FBVCxDQUFpQixVQUFVOUYsT0FBVixFQUFtQjtBQUNoQyxnQkFBSXViLFNBQVN2YixRQUFRMEssT0FBUixHQUFrQnpJLE9BQU9qQyxRQUFRMEssT0FBZixDQUFsQixHQUE0QyxPQUFPMUssUUFBUWtFLEdBQXhFOztBQUVBO0FBQ0EsZ0JBQUksQ0FBQzJXLE1BQU1VLE1BQU4sQ0FBTCxFQUFvQjtBQUNoQlYsc0JBQU1VLE1BQU4sSUFBZ0I7QUFDWjlXLHdCQUFJOFcsTUFEUTtBQUVaMVcsMkJBQU83RSxRQUFRNkUsS0FGSDtBQUdacVcscUNBQWlCbGIsUUFBUXVLO0FBSGIsaUJBQWhCO0FBS0g7O0FBRUQsZ0JBQUlULFVBQVU7QUFDVlEscUJBQUtnSixPQUFPdFQsUUFBUXNLLEdBQWYsQ0FESztBQUVWcEcscUJBQUtvUCxPQUFPdFQsUUFBUWtFLEdBQWYsQ0FGSztBQUdWVyx1QkFBTzdFLFFBQVE2RSxLQUhMO0FBSVYyRixzQkFBTXhLLFFBQVF3SyxJQUpKO0FBS1ZELHNCQUFNdkssUUFBUXVLLElBTEo7QUFNVnFSLHNCQUFNcEcsUUFBUXhWLFFBQVF5SyxVQUFoQixDQU5JO0FBT1ZzUixzQkFBTVIsTUFQSTtBQVFWMVIsNkJBQWFtSSxNQUFNbU8sT0FBTixDQUFjbmdCLFFBQVE2SixXQUF0QixJQUFxQzdKLFFBQVE2SixXQUE3QyxHQUEyRCxFQVI5RDtBQVNWYyxzQkFBTTNLLFFBQVEySyxJQVRKO0FBVVZtUiwyQkFBV3RHLFFBQVF4VixRQUFRNEssS0FBaEIsQ0FWRDtBQVdWd1EsMEJBQVU5QixtQkFBbUJ0WixRQUFRd0ssSUFBM0I7QUFYQSxhQUFkOztBQWNBLGdCQUFJeEssUUFBUW9nQixTQUFaLEVBQXVCO0FBQ25CdFcsd0JBQVFhLElBQVIsQ0FBYVIsSUFBYixDQUFrQixXQUFsQjtBQUNIOztBQUVELGdCQUFJbkssUUFBUXFnQixPQUFaLEVBQXFCO0FBQ2pCdlcsd0JBQVFhLElBQVIsQ0FBYVIsSUFBYixDQUFrQixPQUFsQjtBQUNIOztBQUVEK1YsNkJBQWlCL1YsSUFBakIsQ0FBc0JMLE9BQXRCO0FBQ0gsU0FuQ0Q7O0FBcUNBLGFBQUtrUyxLQUFMLENBQVdqVSxhQUFYLEVBQTBCbEcsTUFBMUIsQ0FBaUM7QUFDN0JnWixtQkFBT3JWLEVBQUUwVyxNQUFGLENBQVNyQixLQUFULENBRHNCO0FBRTdCakosc0JBQVVzTztBQUZtQixTQUFqQyxFQUdHLFVBQVVyZ0IsR0FBVixFQUFlO0FBQ2QsZ0JBQUlBLEdBQUosRUFBUztBQUNMMmMsdUJBQU8zYyxJQUFJK1EsSUFBSixHQUFXLElBQVgsR0FBa0IvUSxJQUFJRyxPQUE3QjtBQUNBO0FBQ0g7O0FBRUR1YztBQUNILFNBVkQ7QUFXSCxLQWw4QlU7O0FBbzhCWDs7OztBQUlBbkwsMkJBQXVCLFNBQVNrUCxxQ0FBVCxDQUErQzVXLFFBQS9DLEVBQXlEO0FBQzVFLFlBQUl6RyxTQUFTLEtBQUt3WixPQUFsQjtBQUNBLFlBQUk3YixPQUFPLEtBQUtvYixLQUFMLENBQVcvWSxNQUFYLENBQVg7O0FBRUEsZUFBTyxJQUFJb0IsT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUJpTSxNQUFuQixFQUEyQjtBQUMxQzNQLGlCQUFLRyxHQUFMLENBQVMsVUFBVCxFQUFxQjtBQUNqQmtSLHVCQUFPLEtBRFU7QUFFakJxTCx1QkFBT0MsWUFBWUMsSUFBWixDQUFpQjlULFFBQWpCLENBRlU7QUFHakJ3VCwyQkFBVywyQ0FITTtBQUlqQkMsdUJBQU87QUFKVSxhQUFyQixFQUtHLFVBQVV0ZCxHQUFWLEVBQWVpQixPQUFmLEVBQXdCO0FBQ3ZCLG9CQUFJakIsR0FBSixFQUFTO0FBQ0wwUSwyQkFBTzFRLEdBQVA7QUFDSCxpQkFGRCxNQUVPO0FBQ0gsd0JBQUl5WCxTQUFTeFcsUUFBUTRGLE1BQVIsR0FBaUI1RixRQUFRLENBQVIsRUFBV08sS0FBWCxDQUFpQmlKLEdBQWxDLEdBQXdDLENBQXJEO0FBQ0FoRyw0QkFBUWdULE1BQVI7QUFDSDtBQUNKLGFBWkQ7QUFhSCxTQWRNLENBQVA7QUFlSCxLQTM5QlU7O0FBNjlCWDs7OztBQUlBbkgsd0JBQW9CLFNBQVNvUSxrQ0FBVCxDQUE0Q3RkLE1BQTVDLEVBQW9EO0FBQ3BFQSxpQkFBU0EsVUFBVSxLQUFLd1osT0FBeEI7QUFDQSxZQUFJN2IsT0FBTyxLQUFLb2IsS0FBTCxDQUFXL1ksTUFBWCxDQUFYOztBQUVBLGlCQUFTdWQsZUFBVCxDQUF5Qi9iLEVBQXpCLEVBQTZCO0FBQ3pCLG1CQUFPLElBQUlKLE9BQUosQ0FBWSxVQUFVQyxPQUFWLEVBQW1CaU0sTUFBbkIsRUFBMkI7QUFDMUMzUCxxQkFBS0csR0FBTCxDQUFTLFVBQVQsRUFBcUI7QUFDakJrUiwyQkFBTyxlQURVO0FBRWpCcUwsMkJBQU9DLFlBQVlDLElBQVosQ0FBaUIvWSxFQUFqQixDQUZVO0FBR2pCeVksK0JBQVcsMkNBSE07QUFJakJDLDJCQUFPO0FBSlUsaUJBQXJCLEVBS0csVUFBVXRkLEdBQVYsRUFBZWlCLE9BQWYsRUFBd0I7QUFDdkIsd0JBQUlqQixHQUFKLEVBQVM7QUFDTDBRLCtCQUFPMVEsR0FBUDtBQUNILHFCQUZELE1BRU87QUFDSHlFLGdDQUFRO0FBQ0pHLGdDQUFJQSxFQURBO0FBRUpJLG1DQUFPL0QsUUFBUSxDQUFSLEVBQVdPLEtBQVgsQ0FBaUJ3RCxLQUZwQjtBQUdKcVcsNkNBQWlCcGEsUUFBUSxDQUFSLEVBQVdPLEtBQVgsQ0FBaUJrSjtBQUg5Qix5QkFBUjtBQUtIO0FBQ0osaUJBZkQ7QUFnQkgsYUFqQk0sQ0FBUDtBQWtCSDs7QUFFRDtBQUNBO0FBQ0EsZUFBTyxJQUFJbEcsT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUJpTSxNQUFuQixFQUEyQjtBQUMxQztBQUNBM1AsaUJBQUtHLEdBQUwsQ0FBUyxVQUFULEVBQXFCO0FBQ2pCa1IsdUJBQU8sZUFEVTtBQUVqQmlMLDJCQUFXdUQ7QUFGTSxhQUFyQixFQUdHLFVBQVU1Z0IsR0FBVixFQUFlaUIsT0FBZixFQUF3QjtBQUN2QixvQkFBSWpCLEdBQUosRUFBUztBQUNMMFEsMkJBQU8xUSxJQUFJK1EsSUFBSixHQUFXLElBQVgsR0FBa0IvUSxJQUFJRyxPQUE3QjtBQUNBO0FBQ0g7O0FBRUQsb0JBQUl3VCxXQUFXMVMsUUFBUTRULEdBQVIsQ0FBWSxVQUFVb0csTUFBVixFQUFrQjtBQUN6QywyQkFBTzBGLGdCQUFnQjFGLE9BQU8xWixHQUF2QixDQUFQO0FBQ0gsaUJBRmMsQ0FBZjs7QUFJQWlELHdCQUFRdUMsR0FBUixDQUFZNE0sUUFBWixFQUFzQjVSLElBQXRCLENBQTJCLFVBQVU4ZSxVQUFWLEVBQXNCO0FBQzdDOWYseUJBQUtpQixNQUFMLENBQVk7QUFDUmdaLCtCQUFPNkY7QUFEQyxxQkFBWixFQUVHLFVBQVU3Z0IsR0FBVixFQUFlO0FBQ2QsNEJBQUlBLEdBQUosRUFBUztBQUNMMFEsbUNBQU8xUSxJQUFJK1EsSUFBSixHQUFXLElBQVgsR0FBa0IvUSxJQUFJRyxPQUE3QjtBQUNBO0FBQ0g7O0FBRURzRTtBQUNILHFCQVREO0FBVUgsaUJBWEQsRUFXRyxVQUFVekUsR0FBVixFQUFlO0FBQ2QwUSwyQkFBTzFRLElBQUkrUSxJQUFKLEdBQVcsSUFBWCxHQUFrQi9RLElBQUlHLE9BQTdCO0FBQ0gsaUJBYkQ7QUFjSCxhQTNCRDtBQTRCSCxTQTlCTSxDQUFQO0FBK0JILEtBM2hDVTs7QUE2aENYa1EsdUJBQW1CLFNBQVN5USxpQ0FBVCxDQUEyQzFkLE1BQTNDLEVBQW1EO0FBQ2xFQSxpQkFBU0EsVUFBVSxLQUFLd1osT0FBeEI7QUFDQSxZQUFJN2IsT0FBTyxLQUFLb2IsS0FBTCxDQUFXL1ksTUFBWCxDQUFYOztBQUVBLGlCQUFTMmQsa0JBQVQsQ0FBNEI3QyxPQUE1QixFQUFxQztBQUNqQyxtQkFBTyxJQUFJMVosT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUJpTSxNQUFuQixFQUEyQjtBQUMxQzNQLHFCQUFLRyxHQUFMLENBQVMsVUFBVCxFQUFxQjtBQUNqQmtSLDJCQUFPLGVBRFU7QUFFakJxTCwyQkFBT0MsWUFBWUMsSUFBWixDQUFpQk8sUUFBUTdaLEdBQXpCLENBRlU7QUFHakJnWiwrQkFBVywyQ0FITTtBQUlqQkMsMkJBQU87QUFKVSxpQkFBckIsRUFLRyxVQUFVdGQsR0FBVixFQUFlaUIsT0FBZixFQUF3QjtBQUN2Qix3QkFBSWpCLEdBQUosRUFBUztBQUNMMFEsK0JBQU8xUSxHQUFQO0FBQ0gscUJBRkQsTUFFTztBQUNIa2UsZ0NBQVE3QyxlQUFSLEdBQTBCcGEsUUFBUTRGLE1BQVIsR0FBaUI1RixRQUFRLENBQVIsRUFBV08sS0FBWCxDQUFpQmtKLElBQWxDLEdBQXlDLENBQW5FO0FBQ0FqRztBQUNIO0FBQ0osaUJBWkQ7QUFhSCxhQWRNLENBQVA7QUFlSDs7QUFFRCxpQkFBU3VjLGlCQUFULENBQTJCOUMsT0FBM0IsRUFBb0M7QUFDaEMsbUJBQU8sSUFBSTFaLE9BQUosQ0FBWSxVQUFVQyxPQUFWLEVBQW1CaU0sTUFBbkIsRUFBMkI7QUFDMUMzUCxxQkFBSzJRLEtBQUwsQ0FBVyxVQUFYLEVBQXVCO0FBQ25CVSwyQkFBTyxlQURZO0FBRW5CcUwsMkJBQU9DLFlBQVlDLElBQVosQ0FBaUJPLFFBQVE3WixHQUF6QjtBQUZZLGlCQUF2QixFQUdHLFVBQVVyRSxHQUFWLEVBQWV3UCxLQUFmLEVBQXNCO0FBQ3JCLHdCQUFJeFAsR0FBSixFQUFTO0FBQ0wwUSwrQkFBTzFRLEdBQVA7QUFDSCxxQkFGRCxNQUVPO0FBQ0hrZSxnQ0FBUTVDLFlBQVIsR0FBdUI5TCxLQUF2QjtBQUNBL0s7QUFDSDtBQUNKLGlCQVZEO0FBV0gsYUFaTSxDQUFQO0FBYUg7O0FBRUQsZUFBTyxJQUFJRCxPQUFKLENBQVksVUFBVUMsT0FBVixFQUFtQmlNLE1BQW5CLEVBQTJCO0FBQzFDM1AsaUJBQUtHLEdBQUwsQ0FBUyxVQUFULEVBQXFCLFVBQVVsQixHQUFWLEVBQWVpQixPQUFmLEVBQXdCO0FBQ3pDLG9CQUFJakIsR0FBSixFQUFTO0FBQ0wwUSwyQkFBTzFRLElBQUkrUSxJQUFKLEdBQVcsSUFBWCxHQUFrQi9RLElBQUlHLE9BQTdCO0FBQ0E7QUFDSDs7QUFFRCxvQkFBSXVILFdBQVcsRUFBZjtBQUNBLG9CQUFJaU0sV0FBVyxFQUFmOztBQUVBMVMsd0JBQVFnRixPQUFSLENBQWdCLFVBQVVnVixNQUFWLEVBQWtCO0FBQzlCLHdCQUFJaUQsVUFBVWpELE9BQU96WixLQUFyQjs7QUFFQW1TLDZCQUFTckosSUFBVCxDQUFjeVcsbUJBQW1CN0MsT0FBbkIsQ0FBZDtBQUNBdkssNkJBQVNySixJQUFULENBQWMwVyxrQkFBa0I5QyxPQUFsQixDQUFkOztBQUVBeFcsNkJBQVM0QyxJQUFULENBQWM0VCxPQUFkO0FBQ0gsaUJBUEQ7O0FBU0ExWix3QkFBUXVDLEdBQVIsQ0FBWTRNLFFBQVosRUFBc0I1UixJQUF0QixDQUEyQixZQUFZO0FBQ25DaEIseUJBQUtpQixNQUFMLENBQVk7QUFDUjBGLGtDQUFVQTtBQURGLHFCQUFaLEVBRUcsVUFBVTFILEdBQVYsRUFBZTtBQUNkLDRCQUFJQSxHQUFKLEVBQVM7QUFDTDBRLG1DQUFPMVEsSUFBSStRLElBQUosR0FBVyxJQUFYLEdBQWtCL1EsSUFBSUcsT0FBN0I7QUFDQTtBQUNIOztBQUVEc0U7QUFDSCxxQkFURDtBQVVILGlCQVhELEVBV0csVUFBVXpFLEdBQVYsRUFBZTtBQUNkMFEsMkJBQU8xUSxJQUFJK1EsSUFBSixHQUFXLElBQVgsR0FBa0IvUSxJQUFJRyxPQUE3QjtBQUNILGlCQWJEO0FBY0gsYUFoQ0Q7QUFpQ0gsU0FsQ00sQ0FBUDtBQW1DSCxLQXRtQ1U7O0FBd21DWDs7Ozs7QUFLQXdKLGdCQUFZLFNBQVNzWCwwQkFBVCxDQUFvQ3ZKLEtBQXBDLEVBQTJDZ0YsU0FBM0MsRUFBc0RDLE1BQXRELEVBQThEO0FBQ3RFLFlBQUl2WixTQUFTLEtBQUt3WixPQUFsQjtBQUNBLFlBQUk3YixPQUFPLEtBQUtvYixLQUFMLENBQVcvWSxNQUFYLENBQVg7O0FBRUFyQyxhQUFLRyxHQUFMLENBQVMsVUFBVCxFQUFxQjtBQUNqQnVjLG1CQUFPQyxZQUFZQyxJQUFaLENBQWlCbEssT0FBT2lFLEtBQVAsQ0FBakI7QUFEVSxTQUFyQixFQUVHLFVBQVUxWCxHQUFWLEVBQWVpQixPQUFmLEVBQXdCO0FBQ3ZCLGdCQUFJakIsR0FBSixFQUFTO0FBQ0wyYyx1QkFBTzNjLElBQUkrUSxJQUFKLEdBQVcsSUFBWCxHQUFrQi9RLElBQUlHLE9BQTdCO0FBQ0E7QUFDSDs7QUFFRCxnQkFBSSxDQUFDYyxRQUFRNEYsTUFBYixFQUFxQjtBQUNqQjZWLDZCQUFhQSxXQUFiO0FBQ0E7QUFDSDs7QUFFRCxnQkFBSXZjLFVBQVVjLFFBQVEsQ0FBUixFQUFXTyxLQUF6QjtBQUNBckIsb0JBQVE0YixJQUFSLEdBQWUsSUFBZjs7QUFFQWhiLGlCQUFLaUIsTUFBTCxDQUFZLFVBQVosRUFBd0I3QixPQUF4QixFQUFpQyxVQUFVSCxHQUFWLEVBQWU7QUFDNUMsb0JBQUlBLEdBQUosRUFBUztBQUNMMmMsMkJBQU8zYyxJQUFJK1EsSUFBSixHQUFXLElBQVgsR0FBa0IvUSxJQUFJRyxPQUE3QjtBQUNBO0FBQ0g7O0FBRUR1Yyw2QkFBYUEsV0FBYjtBQUNILGFBUEQ7QUFRSCxTQXhCRDtBQXlCSCxLQTFvQ1U7O0FBNG9DWDs7Ozs7QUFLQWpULGtCQUFjLFNBQVN5WCw0QkFBVCxDQUFzQ3hKLEtBQXRDLEVBQTZDZ0YsU0FBN0MsRUFBd0RDLE1BQXhELEVBQWdFO0FBQzFFLFlBQUl2WixTQUFTLEtBQUt3WixPQUFsQjtBQUNBLFlBQUk3YixPQUFPLEtBQUtvYixLQUFMLENBQVcvWSxNQUFYLENBQVg7O0FBRUFyQyxhQUFLRyxHQUFMLENBQVMsVUFBVCxFQUFxQjtBQUNqQnVjLG1CQUFPQyxZQUFZQyxJQUFaLENBQWlCbEssT0FBT2lFLEtBQVAsQ0FBakI7QUFEVSxTQUFyQixFQUVHLFVBQVUxWCxHQUFWLEVBQWVpQixPQUFmLEVBQXdCO0FBQ3ZCLGdCQUFJakIsR0FBSixFQUFTO0FBQ0wyYyx1QkFBTzNjLElBQUkrUSxJQUFKLEdBQVcsSUFBWCxHQUFrQi9RLElBQUlHLE9BQTdCO0FBQ0E7QUFDSDs7QUFFRCxnQkFBSSxDQUFDYyxRQUFRNEYsTUFBYixFQUFxQjtBQUNqQjZWLDZCQUFhQSxXQUFiO0FBQ0E7QUFDSDs7QUFFRCxnQkFBSXZjLFVBQVVjLFFBQVEsQ0FBUixFQUFXTyxLQUF6QjtBQUNBckIsb0JBQVE0YixJQUFSLEdBQWUsS0FBZjs7QUFFQWhiLGlCQUFLaUIsTUFBTCxDQUFZLFVBQVosRUFBd0I3QixPQUF4QixFQUFpQyxVQUFVSCxHQUFWLEVBQWU7QUFDNUMsb0JBQUlBLEdBQUosRUFBUztBQUNMMmMsMkJBQU8zYyxJQUFJK1EsSUFBSixHQUFXLElBQVgsR0FBa0IvUSxJQUFJRyxPQUE3QjtBQUNBO0FBQ0g7O0FBRUR1Yyw2QkFBYUEsV0FBYjtBQUNILGFBUEQ7QUFRSCxTQXhCRDtBQXlCSCxLQTlxQ1U7O0FBZ3JDWDs7Ozs7OztBQU9BdFQsd0JBQW9CLFNBQVMrWCxrQ0FBVCxDQUE0Q3pKLEtBQTVDLEVBQW1ERSxHQUFuRCxFQUF3RDhFLFNBQXhELEVBQW1FQyxNQUFuRSxFQUEyRTtBQUMzRixZQUFJdlosU0FBUyxLQUFLd1osT0FBbEI7QUFDQSxZQUFJN2IsT0FBTyxLQUFLb2IsS0FBTCxDQUFXL1ksTUFBWCxDQUFYOztBQUVBckMsYUFBS0csR0FBTCxDQUFTLFVBQVQsRUFBcUI7QUFDakJ1YyxtQkFBT0MsWUFBWUMsSUFBWixDQUFpQmxLLE9BQU9pRSxLQUFQLENBQWpCO0FBRFUsU0FBckIsRUFFRyxVQUFVMVgsR0FBVixFQUFlaUIsT0FBZixFQUF3QjtBQUN2QixnQkFBSWpCLEdBQUosRUFBUztBQUNMMmMsdUJBQU8sSUFBUCxFQUFhM2MsSUFBSStRLElBQUosR0FBVyxJQUFYLEdBQWtCL1EsSUFBSUcsT0FBbkM7QUFDQTtBQUNIOztBQUVELGdCQUFJLENBQUNjLFFBQVE0RixNQUFiLEVBQXFCO0FBQ2pCOFYsdUJBQU8sS0FBUCxFQUFjLDJEQUEyRGpGLEtBQTNELEdBQW1FLFNBQW5FLEdBQStFRSxHQUEvRSxHQUFxRixHQUFuRztBQUNBO0FBQ0g7O0FBRUQsZ0JBQUl6WCxVQUFVYyxRQUFRLENBQVIsRUFBV08sS0FBekI7QUFDQSxnQkFBSXJCLFFBQVEySyxJQUFSLENBQWE4UCxPQUFiLENBQXFCaEQsR0FBckIsTUFBOEIsQ0FBQyxDQUFuQyxFQUFzQztBQUNsQytFLHVCQUFPLEtBQVAsRUFBYywyREFBMkRqRixLQUEzRCxHQUFtRSxTQUFuRSxHQUErRUUsR0FBL0UsR0FBcUYsR0FBbkc7QUFDQTtBQUNIOztBQUVEelgsb0JBQVEySyxJQUFSLENBQWFSLElBQWIsQ0FBa0JzTixHQUFsQjtBQUNBN1csaUJBQUtpQixNQUFMLENBQVksVUFBWixFQUF3QjdCLE9BQXhCLEVBQWlDLFVBQVVILEdBQVYsRUFBZTtBQUM1QyxvQkFBSUEsR0FBSixFQUFTO0FBQ0wyYywyQkFBTyxJQUFQLEVBQWEzYyxJQUFJK1EsSUFBSixHQUFXLElBQVgsR0FBa0IvUSxJQUFJRyxPQUFuQztBQUNBO0FBQ0g7O0FBRUR1YztBQUNILGFBUEQ7QUFRSCxTQTVCRDtBQTZCSCxLQXh0Q1U7O0FBMHRDWDs7Ozs7OztBQU9BaFQsMEJBQXNCLFNBQVMwWCxvQ0FBVCxDQUE4QzFKLEtBQTlDLEVBQXFERSxHQUFyRCxFQUEwRDhFLFNBQTFELEVBQXFFQyxNQUFyRSxFQUE2RTtBQUMvRixZQUFJdlosU0FBUyxLQUFLd1osT0FBbEI7QUFDQSxZQUFJN2IsT0FBTyxLQUFLb2IsS0FBTCxDQUFXL1ksTUFBWCxDQUFYOztBQUVBckMsYUFBS0csR0FBTCxDQUFTLFVBQVQsRUFBcUI7QUFDakJ1YyxtQkFBT0MsWUFBWUMsSUFBWixDQUFpQmxLLE9BQU9pRSxLQUFQLENBQWpCO0FBRFUsU0FBckIsRUFFRyxVQUFVMVgsR0FBVixFQUFlaUIsT0FBZixFQUF3QjtBQUN2QixnQkFBSWpCLEdBQUosRUFBUztBQUNMMmMsdUJBQU8sSUFBUCxFQUFhM2MsSUFBSStRLElBQUosR0FBVyxJQUFYLEdBQWtCL1EsSUFBSUcsT0FBbkM7QUFDQTtBQUNIOztBQUVELGdCQUFJLENBQUNjLFFBQVE0RixNQUFiLEVBQXFCO0FBQ2pCOFYsdUJBQU8sS0FBUCxFQUFjLDJEQUEyRGpGLEtBQTNELEdBQW1FLFNBQW5FLEdBQStFRSxHQUEvRSxHQUFxRixHQUFuRztBQUNBO0FBQ0g7O0FBRUQsZ0JBQUl6WCxVQUFVYyxRQUFRLENBQVIsRUFBV08sS0FBekI7QUFDQSxnQkFBSTZmLFdBQVdsaEIsUUFBUTJLLElBQVIsQ0FBYThQLE9BQWIsQ0FBcUJoRCxHQUFyQixDQUFmOztBQUVBLGdCQUFJeUosYUFBYSxDQUFDLENBQWxCLEVBQXFCO0FBQ2pCMUUsdUJBQU8sS0FBUCxFQUFjLDJEQUEyRGpGLEtBQTNELEdBQW1FLFNBQW5FLEdBQStFRSxHQUEvRSxHQUFxRixHQUFuRztBQUNBO0FBQ0g7O0FBRUR6WCxvQkFBUTJLLElBQVIsQ0FBYXdXLE1BQWIsQ0FBb0JELFFBQXBCLEVBQThCLENBQTlCO0FBQ0F0Z0IsaUJBQUtpQixNQUFMLENBQVksVUFBWixFQUF3QjdCLE9BQXhCLEVBQWlDLFVBQVVILEdBQVYsRUFBZTtBQUM1QyxvQkFBSUEsR0FBSixFQUFTO0FBQ0wyYywyQkFBTyxJQUFQLEVBQWEzYyxJQUFJK1EsSUFBSixHQUFXLElBQVgsR0FBa0IvUSxJQUFJRyxPQUFuQztBQUNBO0FBQ0g7O0FBRUR1YztBQUNILGFBUEQ7QUFRSCxTQTlCRDtBQStCSCxLQXB3Q1U7O0FBc3dDWDs7Ozs7QUFLQXZFLG1CQUFlLFNBQVNvSiw2QkFBVCxDQUF1QzdKLEtBQXZDLEVBQThDOEosRUFBOUMsRUFBa0Q7QUFDN0QsWUFBSXBlLFNBQVMsS0FBS3daLE9BQWxCOztBQUVBO0FBQ0EsYUFBS1QsS0FBTCxDQUFXL1ksTUFBWCxFQUFtQlgsTUFBbkIsQ0FBMEIsVUFBMUIsRUFBc0NnUixPQUFPaUUsS0FBUCxDQUF0QyxFQUFxRDhKLEVBQXJEO0FBQ0gsS0FoeENVOztBQWt4Q1g7Ozs7O0FBS0EvSSxrQkFBYyxTQUFTZ0osNEJBQVQsQ0FBc0MvRSxTQUF0QyxFQUFpREMsTUFBakQsRUFBeUQ7QUFDbkUsWUFBSXZaLFNBQVMsS0FBS3daLE9BQWxCO0FBQ0EsWUFBSTdiLE9BQU8sS0FBS29iLEtBQUwsQ0FBVy9ZLE1BQVgsQ0FBWDs7QUFFQSxpQkFBU3NlLG1CQUFULENBQTZCOUosR0FBN0IsRUFBa0M7QUFDOUIsbUJBQU8sSUFBSXBULE9BQUosQ0FBWSxVQUFVQyxPQUFWLEVBQW1CaU0sTUFBbkIsRUFBMkI7QUFDMUMzUCxxQkFBSzJRLEtBQUwsQ0FBVyxVQUFYLEVBQXVCO0FBQ25CVSwyQkFBTyxLQURZO0FBRW5CcUwsMkJBQU9DLFlBQVlDLElBQVosQ0FBaUIvRixHQUFqQjtBQUZZLGlCQUF2QixFQUdHLFVBQVU1WCxHQUFWLEVBQWV3UCxLQUFmLEVBQXNCO0FBQ3JCLHdCQUFJeFAsR0FBSixFQUFTO0FBQ0wwUSwrQkFBTzFRLEdBQVA7QUFDSCxxQkFGRCxNQUVPO0FBQ0h5RSxnQ0FBUStLLEtBQVI7QUFDSDtBQUNKLGlCQVREO0FBVUgsYUFYTSxDQUFQO0FBWUg7O0FBRUR6TyxhQUFLRyxHQUFMLENBQVMsVUFBVCxFQUFxQjtBQUNqQmtSLG1CQUFPLEtBRFU7QUFFakJpTCx1QkFBVyxpREFBQXdCO0FBRk0sU0FBckIsRUFHRyxVQUFVN2UsR0FBVixFQUFlaUIsT0FBZixFQUF3QjtBQUN2QixnQkFBSWpCLEdBQUosRUFBUztBQUNMMmMsdUJBQU8zYyxJQUFJK1EsSUFBSixHQUFXLElBQVgsR0FBa0IvUSxJQUFJRyxPQUE3QjtBQUNBO0FBQ0g7O0FBRUQsZ0JBQUl3VCxXQUFXLEVBQWY7QUFDQTFTLG9CQUFRZ0YsT0FBUixDQUFnQixVQUFVZ1YsTUFBVixFQUFrQjtBQUM5QnRILHlCQUFTc0gsT0FBTzFaLEdBQWhCLElBQXVCbWdCLG9CQUFvQnpHLE9BQU8xWixHQUEzQixDQUF2QjtBQUNILGFBRkQ7O0FBSUFvZSx3QkFBWTVZLEdBQVosQ0FBZ0I0TSxRQUFoQixFQUEwQjVSLElBQTFCLENBQStCMmEsU0FBL0IsRUFBMEMsVUFBVTFjLEdBQVYsRUFBZTtBQUNyRDJjLHVCQUFPM2MsSUFBSStRLElBQUosR0FBVyxJQUFYLEdBQWtCL1EsSUFBSUcsT0FBN0I7QUFDSCxhQUZEO0FBR0gsU0FqQkQ7QUFrQkgsS0E1ekNVOztBQTh6Q1g7Ozs7QUFJQXdoQixxQ0FBaUMsU0FBU0MsK0NBQVQsR0FBMkQ7QUFDeEYsWUFBSXhlLFNBQVMsS0FBS3daLE9BQWxCO0FBQ0EsWUFBSTdiLE9BQU8sS0FBS29iLEtBQUwsQ0FBVy9ZLE1BQVgsQ0FBWDs7QUFFQSxlQUFPLElBQUlvQixPQUFKLENBQVksVUFBVUMsT0FBVixFQUFtQmlNLE1BQW5CLEVBQTJCO0FBQzFDM1AsaUJBQUtHLEdBQUwsQ0FBUyxVQUFULEVBQXFCO0FBQ2pCa1IsdUJBQU8sS0FEVTtBQUVqQnFMLHVCQUFPQyxZQUFZQyxJQUFaLENBQWlCLGFBQWpCO0FBRlUsYUFBckIsRUFHRyxVQUFVM2QsR0FBVixFQUFlaUIsT0FBZixFQUF3QjtBQUN2QixvQkFBSWpCLEdBQUosRUFBUztBQUNMMFEsMkJBQU8xUSxJQUFJK1EsSUFBSixHQUFXLElBQVgsR0FBa0IvUSxJQUFJRyxPQUE3QjtBQUNILGlCQUZELE1BRU87QUFDSCx3QkFBSXNYLFNBQVMsRUFBYjs7QUFFQXhXLDRCQUFRZ0YsT0FBUixDQUFnQixVQUFVZ1YsTUFBVixFQUFrQjtBQUM5Qiw0QkFBSUEsT0FBT3paLEtBQVAsQ0FBYXdJLFdBQWIsQ0FBeUJuRCxNQUE3QixFQUFxQztBQUNqQztBQUNIOztBQUVENFEsK0JBQU9uTixJQUFQLENBQVkyUSxPQUFPelosS0FBUCxDQUFhaUosR0FBekI7QUFDSCxxQkFORDs7QUFRQWhHLDRCQUFRZ1QsTUFBUjtBQUNIO0FBQ0osYUFuQkQ7QUFvQkgsU0FyQk0sQ0FBUDtBQXNCSCxLQTUxQ1U7O0FBODFDWDs7Ozs7Ozs7QUFRQWlCLHVCQUFtQixTQUFTbUosaUNBQVQsQ0FBMkNqSyxHQUEzQyxFQUFnRHFGLFNBQWhELEVBQTJEUCxTQUEzRCxFQUFzRUMsTUFBdEUsRUFBOEU7QUFDN0YsWUFBSXZaLFNBQVMsS0FBS3daLE9BQWxCO0FBQ0EsWUFBSTdiLE9BQU8sS0FBS29iLEtBQUwsQ0FBVy9ZLE1BQVgsQ0FBWDs7QUFFQSxpQkFBUzBlLGdCQUFULEdBQTRCO0FBQ3hCLG1CQUFPLElBQUl0ZCxPQUFKLENBQVksVUFBVUMsT0FBVixFQUFtQmlNLE1BQW5CLEVBQTJCO0FBQzFDM1AscUJBQUsyUSxLQUFMLENBQVcsVUFBWCxFQUF1QjtBQUNuQlUsMkJBQU8sS0FEWTtBQUVuQnFMLDJCQUFPQyxZQUFZQyxJQUFaLENBQWlCL0YsR0FBakI7QUFGWSxpQkFBdkIsRUFHRyxVQUFVNVgsR0FBVixFQUFld1AsS0FBZixFQUFzQjtBQUNyQix3QkFBSXhQLEdBQUosRUFBUztBQUNMMFEsK0JBQU8xUSxHQUFQO0FBQ0gscUJBRkQsTUFFTztBQUNIeUUsZ0NBQVErSyxLQUFSO0FBQ0g7QUFDSixpQkFURDtBQVVILGFBWE0sQ0FBUDtBQVlIOztBQUVELGlCQUFTdVMsY0FBVCxDQUF3QjVoQixPQUF4QixFQUFpQztBQUM3QixtQkFBTyxJQUFJcUUsT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUJpTSxNQUFuQixFQUEyQjtBQUMxQzNQLHFCQUFLRyxHQUFMLENBQVMsVUFBVCxFQUFxQjtBQUNqQnVjLDJCQUFPQyxZQUFZQyxJQUFaLENBQWlCeGQsUUFBUWtFLEdBQXpCO0FBRFUsaUJBQXJCLEVBRUcsVUFBVXJFLEdBQVYsRUFBZWlCLE9BQWYsRUFBd0I7QUFDdkIsd0JBQUlqQixHQUFKLEVBQVM7QUFDTDBRLCtCQUFPMVEsR0FBUDtBQUNILHFCQUZELE1BRU87QUFDSDtBQUNBRyxnQ0FBUXNMLFVBQVIsR0FBcUJ4SyxRQUFRNEYsTUFBUixHQUFpQjVGLFFBQVEsQ0FBUixFQUFXTyxLQUFYLENBQWlCaUssVUFBbEMsR0FBK0MsS0FBcEU7QUFDQXRMLGdDQUFRdUwsU0FBUixHQUFvQnpLLFFBQVE0RixNQUFSLEdBQWlCNUYsUUFBUSxDQUFSLEVBQVdPLEtBQVgsQ0FBaUJrSyxTQUFsQyxHQUE4QyxPQUFsRTtBQUNBdkwsZ0NBQVFnTCxNQUFSLEdBQWlCbEssUUFBUTRGLE1BQVIsR0FBaUI1RixRQUFRLENBQVIsRUFBV08sS0FBWCxDQUFpQjRKLEtBQWxDLEdBQTBDLElBQTNEOztBQUVBM0c7QUFDSDtBQUNKLGlCQWJEO0FBY0gsYUFmTSxDQUFQO0FBZ0JIOztBQUVELGlCQUFTdWQsY0FBVCxHQUEwQjtBQUN0QixtQkFBTyxJQUFJeGQsT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUJpTSxNQUFuQixFQUEyQjtBQUMxQzNQLHFCQUFLRyxHQUFMLENBQVMsVUFBVCxFQUFxQjtBQUNqQmtSLDJCQUFPLEtBRFU7QUFFakJxTCwyQkFBT0MsWUFBWUMsSUFBWixDQUFpQi9GLEdBQWpCLENBRlU7QUFHakJ5RiwrQkFBVywyQ0FITTtBQUlqQnBNLDRCQUFRZ00sU0FKUztBQUtqQkssMkJBQU87QUFMVSxpQkFBckIsRUFNRyxVQUFVdGQsR0FBVixFQUFlaUIsT0FBZixFQUF3QjtBQUN2Qix3QkFBSWpCLEdBQUosRUFBUztBQUNMMFEsK0JBQU8xUSxHQUFQO0FBQ0gscUJBRkQsTUFFTztBQUNILDRCQUFJMlQsV0FBVyxFQUFmO0FBQ0EsNEJBQUk4RCxTQUFTLEVBQWI7O0FBRUF4VyxnQ0FBUWdGLE9BQVIsQ0FBZ0IsVUFBVWdWLE1BQVYsRUFBa0I7QUFDOUIsZ0NBQUk5YSxVQUFVO0FBQ1Z5RSxvQ0FBSXFXLE9BQU96WixLQUFQLENBQWEwYSxJQURQO0FBRVZsWCx1Q0FBT2lXLE9BQU96WixLQUFQLENBQWF3RCxLQUZWO0FBR1YyRixzQ0FBTXNRLE9BQU96WixLQUFQLENBQWFtSixJQUhUO0FBSVZELHNDQUFNdVEsT0FBT3paLEtBQVAsQ0FBYWtKLElBSlQ7QUFLVnJHLHFDQUFLNFcsT0FBT3paLEtBQVAsQ0FBYTZDLEdBTFI7QUFNVm9HLHFDQUFLd1EsT0FBT3paLEtBQVAsQ0FBYWlKLEdBTlI7QUFPVkssc0NBQU1tUSxPQUFPelosS0FBUCxDQUFhc0osSUFQVDtBQVFWa1Isd0NBQVF2SSxPQUFPd0gsT0FBT3paLEtBQVAsQ0FBYXVhLElBQXBCO0FBUkUsNkJBQWQ7O0FBV0F0RSxtQ0FBT25OLElBQVAsQ0FBWW5LLE9BQVo7QUFDQXdULHFDQUFTckosSUFBVCxDQUFjeVgsZUFBZTVoQixPQUFmLENBQWQ7QUFDSCx5QkFkRDs7QUFnQkFxRSxnQ0FBUXVDLEdBQVIsQ0FBWTRNLFFBQVosRUFBc0I1UixJQUF0QixDQUEyQixZQUFZO0FBQ25DMEMsb0NBQVFnVCxNQUFSO0FBQ0gseUJBRkQsRUFFRy9HLE1BRkg7QUFHSDtBQUNKLGlCQWpDRDtBQWtDSCxhQW5DTSxDQUFQO0FBb0NIOztBQUVEbE0sZ0JBQVF1QyxHQUFSLENBQVksQ0FDUmliLGdCQURRLEVBRVJGLGtCQUZRLENBQVosRUFHRy9mLElBSEgsQ0FHUTJhLFNBSFIsRUFHbUIsVUFBVTFjLEdBQVYsRUFBZTtBQUM5QjJjLG1CQUFPM2MsSUFBSStRLElBQUosR0FBVyxJQUFYLEdBQWtCL1EsSUFBSUcsT0FBN0I7QUFDSCxTQUxEO0FBTUgsS0F6N0NVOztBQTI3Q1g7Ozs7Ozs7Ozs7O0FBV0F3WSxtQkFBZSxTQUFTc0osNkJBQVQsQ0FBdUNDLENBQXZDLEVBQTBDakYsU0FBMUMsRUFBcURQLFNBQXJELEVBQWdFQyxNQUFoRSxFQUF3RTtBQUNuRnVGLFlBQUlBLEVBQUV2SSxXQUFGLEVBQUo7O0FBRUEsWUFBSXZXLFNBQVMsS0FBS3daLE9BQWxCO0FBQ0EsWUFBSTdiLE9BQU8sS0FBS29iLEtBQUwsQ0FBVy9ZLE1BQVgsQ0FBWDtBQUNBLFlBQUltVCxLQUFLMkwsRUFBRXhELE1BQUYsQ0FBUyxDQUFULEVBQVl3RCxFQUFFcmIsTUFBRixHQUFXLENBQXZCLElBQTRCekUsT0FBT3VjLFlBQVAsQ0FBb0J1RCxFQUFFdEQsVUFBRixDQUFhc0QsRUFBRXJiLE1BQUYsR0FBVyxDQUF4QixJQUE2QixDQUFqRCxDQUFyQztBQUNBLFlBQUk0VyxRQUFRQyxZQUFZTSxLQUFaLENBQWtCa0UsQ0FBbEIsRUFBcUIzTCxFQUFyQixFQUF5QixLQUF6QixFQUFnQyxJQUFoQyxDQUFaOztBQUVBLGlCQUFTMkcsYUFBVCxHQUF5QjtBQUNyQixtQkFBTyxJQUFJMVksT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUJpTSxNQUFuQixFQUEyQjtBQUMxQzNQLHFCQUFLMlEsS0FBTCxDQUFXLFVBQVgsRUFBdUI7QUFDbkJVLDJCQUFPLFVBRFk7QUFFbkJxTCwyQkFBT0E7QUFGWSxpQkFBdkIsRUFHRyxVQUFVemQsR0FBVixFQUFld1AsS0FBZixFQUFzQjtBQUNyQix3QkFBSXhQLEdBQUosRUFBUztBQUNMMFEsK0JBQU8xUSxHQUFQO0FBQ0gscUJBRkQsTUFFTztBQUNIeUUsZ0NBQVErSyxLQUFSO0FBQ0g7QUFDSixpQkFURDtBQVVILGFBWE0sQ0FBUDtBQVlIOztBQUVELGlCQUFTMlMsY0FBVCxHQUEwQjtBQUN0QixtQkFBTyxJQUFJM2QsT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUJpTSxNQUFuQixFQUEyQjtBQUMxQzNQLHFCQUFLRyxHQUFMLENBQVMsVUFBVCxFQUFxQjtBQUNqQmtSLDJCQUFPLFVBRFU7QUFFakJxTCwyQkFBT0EsS0FGVTtBQUdqQnhNLDRCQUFRZ00sU0FIUztBQUlqQm1GLDBCQUFNO0FBSlcsaUJBQXJCLEVBS0csVUFBVXBpQixHQUFWLEVBQWVpQixPQUFmLEVBQXdCO0FBQ3ZCLHdCQUFJakIsR0FBSixFQUFTO0FBQ0wwUSwrQkFBTzFRLEdBQVA7QUFDSCxxQkFGRCxNQUVPO0FBQ0h5RSxnQ0FBUXhELFFBQVE0VCxHQUFSLENBQVksVUFBVW9HLE1BQVYsRUFBa0I7QUFDbEMsbUNBQU9BLE9BQU96WixLQUFkO0FBQ0gseUJBRk8sQ0FBUjtBQUdIO0FBQ0osaUJBYkQ7QUFjSCxhQWZNLENBQVA7QUFnQkg7O0FBRURnRCxnQkFBUXVDLEdBQVIsQ0FBWSxDQUNSb2IsZ0JBRFEsRUFFUmpGLGVBRlEsQ0FBWixFQUdHbmIsSUFISCxDQUdRLFVBQVU0RyxHQUFWLEVBQWU7QUFDbkIrVCxzQkFBVTJGLEtBQVYsQ0FBZ0IsSUFBaEIsRUFBc0IxWixHQUF0QjtBQUNILFNBTEQsRUFLRyxVQUFVM0ksR0FBVixFQUFlO0FBQ2QyYyxtQkFBTzNjLElBQUkrUSxJQUFKLEdBQVcsSUFBWCxHQUFrQi9RLElBQUlHLE9BQTdCO0FBQ0gsU0FQRDtBQVFILEtBeC9DVTs7QUEwL0NYOzs7Ozs7Ozs7OztBQVdBeVksZ0JBQVksU0FBUzBKLDBCQUFULENBQW9DcmdCLE1BQXBDLEVBQTRDaWdCLENBQTVDLEVBQStDakYsU0FBL0MsRUFBMERQLFNBQTFELEVBQXFFQyxNQUFyRSxFQUE2RTtBQUNyRnVGLFlBQUlBLEVBQUV2SSxXQUFGLEVBQUo7O0FBRUEsWUFBSXZXLFNBQVMsS0FBS3daLE9BQWxCO0FBQ0EsWUFBSTdiLE9BQU8sS0FBS29iLEtBQUwsQ0FBVy9ZLE1BQVgsQ0FBWDtBQUNBLFlBQUltVCxLQUFLMkwsRUFBRXhELE1BQUYsQ0FBUyxDQUFULEVBQVl3RCxFQUFFcmIsTUFBRixHQUFXLENBQXZCLElBQTRCekUsT0FBT3VjLFlBQVAsQ0FBb0J1RCxFQUFFdEQsVUFBRixDQUFhc0QsRUFBRXJiLE1BQUYsR0FBVyxDQUF4QixJQUE2QixDQUFqRCxDQUFyQztBQUNBLFlBQUk0VyxRQUFRQyxZQUFZTSxLQUFaLENBQWtCa0UsQ0FBbEIsRUFBcUIzTCxFQUFyQixFQUF5QixLQUF6QixFQUFnQyxJQUFoQyxDQUFaOztBQUVBLGlCQUFTZ00sYUFBVCxHQUF5QjtBQUNyQixtQkFBTyxJQUFJL2QsT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUJpTSxNQUFuQixFQUEyQjtBQUMxQzNQLHFCQUFLMlEsS0FBTCxDQUFXLFVBQVgsRUFBdUI7QUFDbkJVLDJCQUFPLFVBRFk7QUFFbkJxTCwyQkFBT0E7QUFGWSxpQkFBdkIsRUFHRyxVQUFVemQsR0FBVixFQUFld1AsS0FBZixFQUFzQjtBQUNyQix3QkFBSXhQLEdBQUosRUFBUztBQUNMMFEsK0JBQU8xUSxHQUFQO0FBQ0gscUJBRkQsTUFFTztBQUNIeUUsZ0NBQVErSyxLQUFSO0FBQ0g7QUFDSixpQkFURDtBQVVILGFBWE0sQ0FBUDtBQVlIOztBQUVELGlCQUFTZ0MsV0FBVCxHQUF1QjtBQUNuQixtQkFBTyxJQUFJaE4sT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUJpTSxNQUFuQixFQUEyQjtBQUMxQzNQLHFCQUFLRyxHQUFMLENBQVMsVUFBVCxFQUFxQjtBQUNqQmtSLDJCQUFPLFVBRFU7QUFFakJxTCwyQkFBT0EsS0FGVTtBQUdqQnhNLDRCQUFRZ00sU0FIUztBQUlqQkssMkJBQU8sRUFKVTtBQUtqQkQsK0JBQVcsMkNBQUF5QjtBQUxNLGlCQUFyQixFQU1HLFVBQVU5ZSxHQUFWLEVBQWVpQixPQUFmLEVBQXdCO0FBQ3ZCLHdCQUFJakIsR0FBSixFQUFTO0FBQ0wwUSwrQkFBTzFRLEdBQVA7QUFDSCxxQkFGRCxNQUVPO0FBQ0h5RSxnQ0FBUXhELE9BQVI7QUFDSDtBQUNKLGlCQVpEO0FBYUgsYUFkTSxDQUFQO0FBZUg7O0FBRUQsaUJBQVMySyxjQUFULENBQXdCcVAsTUFBeEIsRUFBZ0M7QUFDNUIsbUJBQU8sSUFBSXpXLE9BQUosQ0FBWSxVQUFVQyxPQUFWLEVBQW1CaU0sTUFBbkIsRUFBMkI7QUFDMUMzUCxxQkFBS0csR0FBTCxDQUFTLFVBQVQsRUFBcUI7QUFDakJ1YywyQkFBT0MsWUFBWUMsSUFBWixDQUFpQjFDLE9BQU81VyxHQUF4QjtBQURVLGlCQUFyQixFQUVHLFVBQVVyRSxHQUFWLEVBQWVpQixPQUFmLEVBQXdCO0FBQ3ZCLHdCQUFJakIsR0FBSixFQUFTO0FBQ0wwUSwrQkFBTzFRLEdBQVA7QUFDSCxxQkFGRCxNQUVPLElBQUksQ0FBQ2lCLFFBQVE0RixNQUFiLEVBQXFCO0FBQ3hCcEM7QUFDSCxxQkFGTSxNQUVBO0FBQ0h3VywrQkFBT3hQLFVBQVAsR0FBb0J4SyxRQUFRLENBQVIsRUFBV08sS0FBWCxDQUFpQmlLLFVBQXJDO0FBQ0F3UCwrQkFBT3ZQLFNBQVAsR0FBbUJ6SyxRQUFRLENBQVIsRUFBV08sS0FBWCxDQUFpQmtLLFNBQXBDO0FBQ0F1UCwrQkFBTzlQLE1BQVAsR0FBZ0JsSyxRQUFRLENBQVIsRUFBV08sS0FBWCxDQUFpQjRKLEtBQWpDOztBQUVBM0c7QUFDSDtBQUNKLGlCQWREO0FBZUgsYUFoQk0sQ0FBUDtBQWlCSDs7QUFFRDs7Ozs7QUFLQUQsZ0JBQVF1QyxHQUFSLENBQVksQ0FDUndiLGVBRFEsRUFFUi9RLGFBRlEsQ0FBWixFQUdHelAsSUFISCxDQUdRLENBQUMsQ0FBQ3lOLEtBQUQsRUFBUXVDLFFBQVIsQ0FBRCxLQUF1QjtBQUMzQixnQkFBSXZDLFFBQVE3RyxJQUFJNkcsS0FBaEI7QUFDQSxnQkFBSW1FLFdBQVcsRUFBZjtBQUNBLGdCQUFJOEQsU0FBUyxFQUFiOztBQUVBOU8sZ0JBQUlvSixRQUFKLENBQWE5TCxPQUFiLENBQXFCLFVBQVVnVixNQUFWLEVBQWtCO0FBQ25DLG9CQUFJOWEsVUFBVTtBQUNWeUUsd0JBQUlxVyxPQUFPelosS0FBUCxDQUFhMGEsSUFEUDtBQUVWelIseUJBQUt3USxPQUFPelosS0FBUCxDQUFhaUosR0FGUjtBQUdWcEcseUJBQUs0VyxPQUFPelosS0FBUCxDQUFhNkMsR0FIUjtBQUlWVywyQkFBT2lXLE9BQU96WixLQUFQLENBQWF3RCxLQUpWO0FBS1YyRiwwQkFBTXNRLE9BQU96WixLQUFQLENBQWFtSixJQUxUO0FBTVZxUiw0QkFBUXZJLE9BQU93SCxPQUFPelosS0FBUCxDQUFhdWEsSUFBcEIsQ0FORTtBQU9WclIsMEJBQU11USxPQUFPelosS0FBUCxDQUFha0osSUFQVDtBQVFWSSwwQkFBTW1RLE9BQU96WixLQUFQLENBQWFzSjtBQVJULGlCQUFkOztBQVdBLG9CQUFJM0ssUUFBUWtFLEdBQVIsSUFBZWpCLE1BQW5CLEVBQTJCO0FBQ3ZCdVEsNkJBQVNySixJQUFULENBQWNzQixlQUFlekwsT0FBZixDQUFkO0FBQ0g7O0FBRURzWCx1QkFBT25OLElBQVAsQ0FBWW5LLE9BQVo7QUFDSCxhQWpCRDs7QUFtQkFxRSxvQkFBUXVDLEdBQVIsQ0FBWTRNLFFBQVosRUFBc0I1UixJQUF0QixDQUEyQixZQUFZO0FBQ25DMmEsMEJBQVVqRixNQUFWLEVBQWtCakksS0FBbEI7QUFDSCxhQUZELEVBRUcsVUFBVXhQLEdBQVYsRUFBZTtBQUNkMmMsdUJBQU8zYyxJQUFJK1EsSUFBSixHQUFXLElBQVgsR0FBa0IvUSxJQUFJRyxPQUE3QjtBQUNILGFBSkQ7QUFLSCxTQWhDRCxFQWdDRyxVQUFVSCxHQUFWLEVBQWU7QUFDZDJjLG1CQUFPM2MsSUFBSStRLElBQUosR0FBVyxJQUFYLEdBQWtCL1EsSUFBSUcsT0FBN0I7QUFDSCxTQWxDRDtBQW1DSCxLQTFtRFU7O0FBNG1EWDs7Ozs7O0FBTUFpQixTQUFLLFNBQVNvaEIsbUJBQVQsQ0FBNkJ0ZSxJQUE3QixFQUFtQ3VlLEtBQW5DLEVBQTBDO0FBQzNDLGFBQUtqRyxLQUFMLENBQVdKLE1BQVgsQ0FBa0IsS0FBbEIsRUFBeUI7QUFDckJsWSxrQkFBTUEsSUFEZTtBQUVyQitILGdCQUFJb0MsS0FBS0MsR0FBTCxFQUZpQjtBQUdyQm1VLG1CQUFPQTtBQUhjLFNBQXpCLEVBSUc5YyxFQUFFQyxJQUpMO0FBS0gsS0F4bkRVOztBQTBuRFg7Ozs7OztBQU1BOGMsb0JBQWdCLFNBQVNDLDhCQUFULENBQXdDakcsU0FBeEMsRUFBbURDLE1BQW5ELEVBQTJEO0FBQ3ZFLGFBQUtILEtBQUwsQ0FBV3RiLEdBQVgsQ0FBZSxLQUFmLEVBQXNCLFVBQVVsQixHQUFWLEVBQWVpQixPQUFmLEVBQXdCO0FBQzFDLGdCQUFJakIsR0FBSixFQUFTO0FBQ0wyYyx1QkFBTzNjLElBQUkrUSxJQUFKLEdBQVcsSUFBWCxHQUFrQi9RLElBQUlHLE9BQTdCO0FBQ0E7QUFDSDs7QUFFRCxnQkFBSXlpQixXQUFXLENBQWY7QUFDQSxnQkFBSUMsYUFBYTVoQixRQUFRNFQsR0FBUixDQUFZLFVBQVVvRyxNQUFWLEVBQWtCak0sQ0FBbEIsRUFBcUI7QUFDOUMsb0JBQUkyTCxPQUFPTSxPQUFPelosS0FBbEI7QUFDQSxvQkFBSWtKLE9BQU8sSUFBSTJELElBQUosQ0FBU3NNLEtBQUsxTyxFQUFkLENBQVg7O0FBRUEsb0JBQUk2VyxXQUFXbkksS0FBSzFPLEVBQUwsR0FBVTJXLFFBQXpCO0FBQ0FBLDJCQUFXakksS0FBSzFPLEVBQWhCOztBQUVBLHVCQUFRK0MsSUFBSSxDQUFMLEdBQ0QsTUFBTXRFLElBQU4sR0FBYSxJQUFiLEdBQW9Cb1ksUUFBcEIsR0FBK0IsTUFBL0IsR0FBd0NuSSxLQUFLelcsSUFENUMsR0FFRCxNQUFNd0csSUFBTixHQUFhLElBQWIsR0FBb0JpUSxLQUFLelcsSUFGL0I7QUFHSCxhQVZnQixDQUFqQjs7QUFZQXdZLHNCQUFVbUcsVUFBVjtBQUNILFNBcEJEO0FBcUJILEtBdHBEVTs7QUF3cERYRSxhQUFTLElBeHBERTtBQXlwRFhuRyxhQUFTLElBenBERTs7QUEycERYVCxXQUFPLEVBM3BESTtBQTRwRFhLLFdBQU87QUE1cERJLENBQWYsQzs7Ozs7OzhDQ3hCQTs7Ozs7OztHQVFBLENBQUUsV0FBVyxDQUVYLHdFQUNBLEdBQUkvVSxVQUFKLENBRUEsMkNBQ0EsR0FBSTRRLFNBQVUsUUFBZCxDQUVBLDREQUNBLEdBQUkySyxrQkFBbUIsR0FBdkIsQ0FFQSwrREFDQSxHQUFJQyxpQkFBa0IscUJBQXRCLENBRUEsb0RBQ0EsR0FBSUMsZ0JBQWlCLDJCQUFyQixDQUVBLGlEQUNBLEdBQUlDLGFBQWMsd0JBQWxCLENBRUEsc0RBQ0EsR0FBSUMsV0FBWSxDQUFoQixDQUNJQyxjQUFnQixDQURwQixDQUVJQyxpQkFBbUIsQ0FGdkIsQ0FHSUMsV0FBYSxDQUhqQixDQUlJQyxpQkFBbUIsRUFKdkIsQ0FLSUMsYUFBZSxFQUxuQixDQU1JQyxtQkFBcUIsRUFOekIsQ0FPSUMsU0FBVyxHQVBmLENBUUlDLFdBQWEsR0FSakIsQ0FTSUMsVUFBWSxHQVRoQixDQVdBLHNEQUNBLEdBQUlDLHdCQUF5QixDQUE3QixDQUNJQyxxQkFBdUIsQ0FEM0IsQ0FHQSxnREFDQSxHQUFJQyxzQkFBdUIsRUFBM0IsQ0FDSUMsdUJBQXlCLEtBRDdCLENBR0EscUZBQ0EsR0FBSUMsV0FBWSxHQUFoQixDQUNJQyxTQUFXLEVBRGYsQ0FHQSxtREFDQSxHQUFJQyxrQkFBbUIsQ0FBdkIsQ0FDSUMsY0FBZ0IsQ0FEcEIsQ0FFSUMsZ0JBQWtCLENBRnRCLENBSUEseURBQ0EsR0FBSUMsVUFBVyxFQUFJLENBQW5CLENBQ0lDLGlCQUFtQixnQkFEdkIsQ0FFSUMsWUFBYyx1QkFGbEIsQ0FHSUMsSUFBTSxFQUFJLENBSGQsQ0FLQSx1RUFDQSxHQUFJQyxrQkFBbUIsVUFBdkIsQ0FDSUMsZ0JBQWtCRCxpQkFBbUIsQ0FEekMsQ0FFSUUsc0JBQXdCRixtQkFBcUIsQ0FGakQsQ0FJQSwyREFDQSxHQUFJRyxXQUFZLENBQ2QsQ0FBQyxLQUFELENBQVFuQixRQUFSLENBRGMsQ0FFZCxDQUFDLE1BQUQsQ0FBU1AsU0FBVCxDQUZjLENBR2QsQ0FBQyxTQUFELENBQVlDLGFBQVosQ0FIYyxDQUlkLENBQUMsT0FBRCxDQUFVRSxVQUFWLENBSmMsQ0FLZCxDQUFDLFlBQUQsQ0FBZUMsZ0JBQWYsQ0FMYyxDQU1kLENBQUMsTUFBRCxDQUFTSyxTQUFULENBTmMsQ0FPZCxDQUFDLFNBQUQsQ0FBWUosWUFBWixDQVBjLENBUWQsQ0FBQyxjQUFELENBQWlCQyxrQkFBakIsQ0FSYyxDQVNkLENBQUMsT0FBRCxDQUFVRSxVQUFWLENBVGMsQ0FBaEIsQ0FZQSwyQ0FDQSxHQUFJbUIsU0FBVSxvQkFBZCxDQUNJQyxTQUFXLGdCQURmLENBRUlDLFFBQVUsa0JBRmQsQ0FHSUMsUUFBVSxlQUhkLENBSUlDLFNBQVcsZ0JBSmYsQ0FLSUMsUUFBVSxtQkFMZCxDQU1JQyxPQUFTLDRCQU5iLENBT0lDLE9BQVMsY0FQYixDQVFJQyxVQUFZLGlCQVJoQixDQVNJQyxVQUFZLGlCQVRoQixDQVVJQyxXQUFhLGtCQVZqQixDQVdJQyxVQUFZLGlCQVhoQixDQVlJQyxPQUFTLGNBWmIsQ0FhSUMsVUFBWSxpQkFiaEIsQ0FjSUMsVUFBWSxpQkFkaEIsQ0FlSUMsV0FBYSxrQkFmakIsQ0FnQklDLFdBQWEsa0JBaEJqQixDQWtCQSxHQUFJQyxnQkFBaUIsc0JBQXJCLENBQ0lDLFlBQWMsbUJBRGxCLENBRUlDLFdBQWEsdUJBRmpCLENBR0lDLFdBQWEsdUJBSGpCLENBSUlDLFFBQVUsb0JBSmQsQ0FLSUMsU0FBVyxxQkFMZixDQU1JQyxTQUFXLHFCQU5mLENBT0lDLFNBQVcscUJBUGYsQ0FRSUMsZ0JBQWtCLDRCQVJ0QixDQVNJQyxVQUFZLHNCQVRoQixDQVVJQyxVQUFZLHNCQVZoQixDQVlBLHVFQUNBLEdBQUlDLHNCQUF1QixnQkFBM0IsQ0FDSUMsb0JBQXNCLG9CQUQxQixDQUVJQyxzQkFBd0IsK0JBRjVCLENBSUEsdURBQ0EsR0FBSUMsZUFBZ0IsK0JBQXBCLENBQ0lDLGdCQUFrQixXQUR0QixDQUVJQyxpQkFBbUJDLE9BQU9ILGNBQWNJLE1BQXJCLENBRnZCLENBR0lDLG1CQUFxQkYsT0FBT0YsZ0JBQWdCRyxNQUF2QixDQUh6QixDQUtBLHlDQUNBLEdBQUlFLFVBQVcsa0JBQWYsQ0FDSUMsV0FBYSxpQkFEakIsQ0FFSUMsY0FBZ0Isa0JBRnBCLENBSUEsMERBQ0EsR0FBSUMsY0FBZSxrREFBbkIsQ0FDSUMsY0FBZ0IsT0FEcEIsQ0FFSUMsYUFBZSxLQUZuQixDQUdJQyxXQUFhLGtHQUhqQixDQUtBOzs7S0FJQSxHQUFJQyxjQUFlLHFCQUFuQixDQUNJQyxnQkFBa0JYLE9BQU9VLGFBQWFULE1BQXBCLENBRHRCLENBR0EscURBQ0EsR0FBSVcsUUFBUyxZQUFiLENBQ0lDLFlBQWMsTUFEbEIsQ0FFSUMsVUFBWSxNQUZoQixDQUlBLDBDQUNBLEdBQUlDLGVBQWdCLDJDQUFwQixDQUNJQyxjQUFnQixtQ0FEcEIsQ0FFSUMsZUFBaUIsT0FGckIsQ0FJQSwrREFDQSxHQUFJQyxhQUFjLDJDQUFsQixDQUVBLG1EQUNBLEdBQUlDLGNBQWUsVUFBbkIsQ0FFQTs7O0tBSUEsR0FBSUMsY0FBZSxpQ0FBbkIsQ0FFQSxxRUFDQSxHQUFJQyxTQUFVLE1BQWQsQ0FFQSxnREFDQSxHQUFJQyxnQkFBaUIsTUFBckIsQ0FFQSwyREFDQSxHQUFJQyxZQUFhLG9CQUFqQixDQUVBLDJDQUNBLEdBQUlDLFlBQWEsWUFBakIsQ0FFQSxpREFDQSxHQUFJQyxjQUFlLDZCQUFuQixDQUVBLDBDQUNBLEdBQUlDLFdBQVksYUFBaEIsQ0FFQSw4Q0FDQSxHQUFJQyxVQUFXLGtCQUFmLENBRUEsOEVBQ0EsR0FBSUMsU0FBVSw2Q0FBZCxDQUVBLDZEQUNBLEdBQUlDLFdBQVksTUFBaEIsQ0FFQSxzRUFDQSxHQUFJQyxtQkFBb0Isd0JBQXhCLENBRUEsaURBQ0EsR0FBSUMsZUFBZ0IsaUJBQXBCLENBQ0lDLGtCQUFvQixnQ0FEeEIsQ0FFSUMsb0JBQXNCLGlCQUYxQixDQUdJQyxlQUFpQixpQkFIckIsQ0FJSUMsYUFBZSwyQkFKbkIsQ0FLSUMsY0FBZ0Isc0JBTHBCLENBTUlDLGVBQWlCLDhDQU5yQixDQU9JQyxtQkFBcUIsaUJBUHpCLENBUUlDLGFBQWUsOEpBUm5CLENBU0lDLGFBQWUsMkJBVG5CLENBVUlDLFdBQWEsZ0JBVmpCLENBV0lDLGFBQWVOLGNBQWdCQyxjQUFoQixDQUFpQ0Msa0JBQWpDLENBQXNEQyxZQVh6RSxDQWFBLDhDQUNBLEdBQUlJLFFBQVMsV0FBYixDQUNJQyxTQUFXLElBQU1iLGFBQU4sQ0FBc0IsR0FEckMsQ0FFSWMsUUFBVSxJQUFNSCxZQUFOLENBQXFCLEdBRm5DLENBR0lJLFFBQVUsSUFBTWQsaUJBQU4sQ0FBMEJDLG1CQUExQixDQUFnRCxHQUg5RCxDQUlJYyxTQUFXLE1BSmYsQ0FLSUMsVUFBWSxJQUFNZCxjQUFOLENBQXVCLEdBTHZDLENBTUllLFFBQVUsSUFBTWQsWUFBTixDQUFxQixHQU5uQyxDQU9JZSxPQUFTLEtBQU9uQixhQUFQLENBQXVCVyxZQUF2QixDQUFzQ0ssUUFBdEMsQ0FBaURiLGNBQWpELENBQWtFQyxZQUFsRSxDQUFpRkssWUFBakYsQ0FBZ0csR0FQN0csQ0FRSVcsT0FBUywwQkFSYixDQVNJQyxXQUFhLE1BQVFOLE9BQVIsQ0FBa0IsR0FBbEIsQ0FBd0JLLE1BQXhCLENBQWlDLEdBVGxELENBVUlFLFlBQWMsS0FBT3RCLGFBQVAsQ0FBdUIsR0FWekMsQ0FXSXVCLFdBQWEsaUNBWGpCLENBWUlDLFdBQWEsb0NBWmpCLENBYUlDLFFBQVUsSUFBTWhCLFlBQU4sQ0FBcUIsR0FibkMsQ0FjSWlCLE1BQVEsU0FkWixDQWdCQSx1Q0FDQSxHQUFJQyxhQUFjLE1BQVFULE9BQVIsQ0FBa0IsR0FBbEIsQ0FBd0JDLE1BQXhCLENBQWlDLEdBQW5ELENBQ0lTLFlBQWMsTUFBUUgsT0FBUixDQUFrQixHQUFsQixDQUF3Qk4sTUFBeEIsQ0FBaUMsR0FEbkQsQ0FFSVUsZ0JBQWtCLE1BQVFqQixNQUFSLENBQWlCLHdCQUZ2QyxDQUdJa0IsZ0JBQWtCLE1BQVFsQixNQUFSLENBQWlCLHdCQUh2QyxDQUlJbUIsU0FBV1YsV0FBYSxHQUo1QixDQUtJVyxTQUFXLElBQU10QixVQUFOLENBQW1CLElBTGxDLENBTUl1QixVQUFZLE1BQVFQLEtBQVIsQ0FBZ0IsS0FBaEIsQ0FBd0IsQ0FBQ0osV0FBRCxDQUFjQyxVQUFkLENBQTBCQyxVQUExQixFQUFzQzFWLElBQXRDLENBQTJDLEdBQTNDLENBQXhCLENBQTBFLEdBQTFFLENBQWdGa1csUUFBaEYsQ0FBMkZELFFBQTNGLENBQXNHLElBTnRILENBT0lHLE1BQVFGLFNBQVdELFFBQVgsQ0FBc0JFLFNBUGxDLENBUUlFLFFBQVUsTUFBUSxDQUFDbEIsU0FBRCxDQUFZTSxVQUFaLENBQXdCQyxVQUF4QixFQUFvQzFWLElBQXBDLENBQXlDLEdBQXpDLENBQVIsQ0FBd0QsR0FBeEQsQ0FBOERvVyxLQVI1RSxDQVNJRSxTQUFXLE1BQVEsQ0FBQ2QsWUFBY1AsT0FBZCxDQUF3QixHQUF6QixDQUE4QkEsT0FBOUIsQ0FBdUNRLFVBQXZDLENBQW1EQyxVQUFuRCxDQUErRFgsUUFBL0QsRUFBeUUvVSxJQUF6RSxDQUE4RSxHQUE5RSxDQUFSLENBQTZGLEdBVDVHLENBV0EsaUNBQ0EsR0FBSXVXLFFBQVNwRSxPQUFPMkMsTUFBUCxDQUFlLEdBQWYsQ0FBYixDQUVBOzs7S0FJQSxHQUFJMEIsYUFBY3JFLE9BQU84QyxPQUFQLENBQWdCLEdBQWhCLENBQWxCLENBRUEseUZBQ0EsR0FBSXdCLFdBQVl0RSxPQUFPbUQsT0FBUyxLQUFULENBQWlCQSxNQUFqQixDQUEwQixJQUExQixDQUFpQ2dCLFFBQWpDLENBQTRDRixLQUFuRCxDQUEwRCxHQUExRCxDQUFoQixDQUVBLCtDQUNBLEdBQUlNLGVBQWdCdkUsT0FBTyxDQUN6QndELFFBQVUsR0FBVixDQUFnQlAsT0FBaEIsQ0FBMEIsR0FBMUIsQ0FBZ0NXLGVBQWhDLENBQWtELEtBQWxELENBQTBELENBQUNmLE9BQUQsQ0FBVVcsT0FBVixDQUFtQixHQUFuQixFQUF3QjNWLElBQXhCLENBQTZCLEdBQTdCLENBQTFELENBQThGLEdBRHJFLENBRXpCOFYsWUFBYyxHQUFkLENBQW9CRSxlQUFwQixDQUFzQyxLQUF0QyxDQUE4QyxDQUFDaEIsT0FBRCxDQUFVVyxRQUFVRSxXQUFwQixDQUFpQyxHQUFqQyxFQUFzQzdWLElBQXRDLENBQTJDLEdBQTNDLENBQTlDLENBQWdHLEdBRnZFLENBR3pCMlYsUUFBVSxHQUFWLENBQWdCRSxXQUFoQixDQUE4QixHQUE5QixDQUFvQ0UsZUFIWCxDQUl6QkosUUFBVSxHQUFWLENBQWdCSyxlQUpTLENBS3pCZCxRQUx5QixDQU16Qm1CLE9BTnlCLEVBT3pCclcsSUFQeUIsQ0FPcEIsR0FQb0IsQ0FBUCxDQU9QLEdBUE8sQ0FBcEIsQ0FTQSxzSkFDQSxHQUFJMlcsY0FBZXhFLE9BQU8sSUFBTXlELEtBQU4sQ0FBYzFCLGFBQWQsQ0FBK0JDLGlCQUEvQixDQUFtREMsbUJBQW5ELENBQXlFUSxVQUF6RSxDQUFzRixHQUE3RixDQUFuQixDQUVBLDRFQUNBLEdBQUlnQyxrQkFBbUIscUVBQXZCLENBRUEsMERBQ0EsR0FBSUMsY0FBZSxDQUNqQixPQURpQixDQUNSLFFBRFEsQ0FDRSxVQURGLENBQ2MsTUFEZCxDQUNzQixPQUR0QixDQUMrQixjQUQvQixDQUMrQyxjQUQvQyxDQUVqQixVQUZpQixDQUVMLFdBRkssQ0FFUSxZQUZSLENBRXNCLFlBRnRCLENBRW9DLEtBRnBDLENBRTJDLE1BRjNDLENBRW1ELFFBRm5ELENBR2pCLFNBSGlCLENBR04sUUFITSxDQUdJLEtBSEosQ0FHVyxRQUhYLENBR3FCLFFBSHJCLENBRytCLFdBSC9CLENBRzRDLFlBSDVDLENBSWpCLG1CQUppQixDQUlJLGFBSkosQ0FJbUIsYUFKbkIsQ0FJa0MsU0FKbEMsQ0FLakIsR0FMaUIsQ0FLWixjQUxZLENBS0ksVUFMSixDQUtnQixVQUxoQixDQUs0QixZQUw1QixDQUFuQixDQVFBLDJEQUNBLEdBQUlDLGlCQUFrQixDQUFDLENBQXZCLENBRUEsNkRBQ0EsR0FBSUMsZ0JBQWlCLEVBQXJCLENBQ0FBLGVBQWUzRixVQUFmLEVBQTZCMkYsZUFBZTFGLFVBQWYsRUFDN0IwRixlQUFlekYsT0FBZixFQUEwQnlGLGVBQWV4RixRQUFmLEVBQzFCd0YsZUFBZXZGLFFBQWYsRUFBMkJ1RixlQUFldEYsUUFBZixFQUMzQnNGLGVBQWVyRixlQUFmLEVBQWtDcUYsZUFBZXBGLFNBQWYsRUFDbENvRixlQUFlbkYsU0FBZixFQUE0QixJQUo1QixDQUtBbUYsZUFBZTlHLE9BQWYsRUFBMEI4RyxlQUFlN0csUUFBZixFQUMxQjZHLGVBQWU3RixjQUFmLEVBQWlDNkYsZUFBZTVHLE9BQWYsRUFDakM0RyxlQUFlNUYsV0FBZixFQUE4QjRGLGVBQWUzRyxPQUFmLEVBQzlCMkcsZUFBZTFHLFFBQWYsRUFBMkIwRyxlQUFlekcsT0FBZixFQUMzQnlHLGVBQWV2RyxNQUFmLEVBQXlCdUcsZUFBZXRHLFNBQWYsRUFDekJzRyxlQUFlckcsU0FBZixFQUE0QnFHLGVBQWVuRyxTQUFmLEVBQzVCbUcsZUFBZWxHLE1BQWYsRUFBeUJrRyxlQUFlakcsU0FBZixFQUN6QmlHLGVBQWUvRixVQUFmLEVBQTZCLEtBUDdCLENBU0Esb0VBQ0EsR0FBSWdHLGVBQWdCLEVBQXBCLENBQ0FBLGNBQWMvRyxPQUFkLEVBQXlCK0csY0FBYzlHLFFBQWQsRUFDekI4RyxjQUFjOUYsY0FBZCxFQUFnQzhGLGNBQWM3RixXQUFkLEVBQ2hDNkYsY0FBYzdHLE9BQWQsRUFBeUI2RyxjQUFjNUcsT0FBZCxFQUN6QjRHLGNBQWM1RixVQUFkLEVBQTRCNEYsY0FBYzNGLFVBQWQsRUFDNUIyRixjQUFjMUYsT0FBZCxFQUF5QjBGLGNBQWN6RixRQUFkLEVBQ3pCeUYsY0FBY3hGLFFBQWQsRUFBMEJ3RixjQUFjeEcsTUFBZCxFQUMxQndHLGNBQWN2RyxTQUFkLEVBQTJCdUcsY0FBY3RHLFNBQWQsRUFDM0JzRyxjQUFjcEcsU0FBZCxFQUEyQm9HLGNBQWNuRyxNQUFkLEVBQzNCbUcsY0FBY2xHLFNBQWQsRUFBMkJrRyxjQUFjakcsU0FBZCxFQUMzQmlHLGNBQWN2RixRQUFkLEVBQTBCdUYsY0FBY3RGLGVBQWQsRUFDMUJzRixjQUFjckYsU0FBZCxFQUEyQnFGLGNBQWNwRixTQUFkLEVBQTJCLElBVnRELENBV0FvRixjQUFjM0csUUFBZCxFQUEwQjJHLGNBQWMxRyxPQUFkLEVBQzFCMEcsY0FBY2hHLFVBQWQsRUFBNEIsS0FENUIsQ0FHQSxnRUFDQSxHQUFJaUcsaUJBQWtCLENBQ3BCO0FBQ0EsT0FBUSxHQUZZLENBRU4sT0FBUSxHQUZGLENBRU8sT0FBUSxHQUZmLENBRW9CLE9BQVEsR0FGNUIsQ0FFaUMsT0FBUSxHQUZ6QyxDQUU4QyxPQUFRLEdBRnRELENBR3BCLE9BQVEsR0FIWSxDQUdOLE9BQVEsR0FIRixDQUdPLE9BQVEsR0FIZixDQUdvQixPQUFRLEdBSDVCLENBR2lDLE9BQVEsR0FIekMsQ0FHOEMsT0FBUSxHQUh0RCxDQUlwQixPQUFRLEdBSlksQ0FJTixPQUFRLEdBSkYsQ0FLcEIsT0FBUSxHQUxZLENBS04sT0FBUSxHQUxGLENBTXBCLE9BQVEsR0FOWSxDQU1OLE9BQVEsR0FORixDQU1PLE9BQVEsR0FOZixDQU1vQixPQUFRLEdBTjVCLENBT3BCLE9BQVEsR0FQWSxDQU9OLE9BQVEsR0FQRixDQU9PLE9BQVEsR0FQZixDQU9vQixPQUFRLEdBUDVCLENBUXBCLE9BQVEsR0FSWSxDQVFOLE9BQVEsR0FSRixDQVFPLE9BQVEsR0FSZixDQVFvQixPQUFRLEdBUjVCLENBU3BCLE9BQVEsR0FUWSxDQVNOLE9BQVEsR0FURixDQVNPLE9BQVEsR0FUZixDQVNvQixPQUFRLEdBVDVCLENBVXBCLE9BQVEsR0FWWSxDQVVOLE9BQVEsR0FWRixDQVdwQixPQUFRLEdBWFksQ0FXTixPQUFRLEdBWEYsQ0FXTyxPQUFRLEdBWGYsQ0FXb0IsT0FBUSxHQVg1QixDQVdpQyxPQUFRLEdBWHpDLENBVzhDLE9BQVEsR0FYdEQsQ0FZcEIsT0FBUSxHQVpZLENBWU4sT0FBUSxHQVpGLENBWU8sT0FBUSxHQVpmLENBWW9CLE9BQVEsR0FaNUIsQ0FZaUMsT0FBUSxHQVp6QyxDQVk4QyxPQUFRLEdBWnRELENBYXBCLE9BQVEsR0FiWSxDQWFOLE9BQVEsR0FiRixDQWFPLE9BQVEsR0FiZixDQWFvQixPQUFRLEdBYjVCLENBY3BCLE9BQVEsR0FkWSxDQWNOLE9BQVEsR0FkRixDQWNPLE9BQVEsR0FkZixDQWNvQixPQUFRLEdBZDVCLENBZXBCLE9BQVEsR0FmWSxDQWVOLE9BQVEsR0FmRixDQWVPLE9BQVEsR0FmZixDQWdCcEIsT0FBUSxJQWhCWSxDQWdCTixPQUFRLElBaEJGLENBaUJwQixPQUFRLElBakJZLENBaUJOLE9BQVEsSUFqQkYsQ0FrQnBCLE9BQVEsSUFsQlksQ0FtQnBCO0FBQ0EsU0FBVSxHQXBCVSxDQW9CSixTQUFVLEdBcEJOLENBb0JXLFNBQVUsR0FwQnJCLENBcUJwQixTQUFVLEdBckJVLENBcUJKLFNBQVUsR0FyQk4sQ0FxQlcsU0FBVSxHQXJCckIsQ0FzQnBCLFNBQVUsR0F0QlUsQ0FzQkosU0FBVSxHQXRCTixDQXNCVyxTQUFVLEdBdEJyQixDQXNCMEIsU0FBVSxHQXRCcEMsQ0F1QnBCLFNBQVUsR0F2QlUsQ0F1QkosU0FBVSxHQXZCTixDQXVCVyxTQUFVLEdBdkJyQixDQXVCMEIsU0FBVSxHQXZCcEMsQ0F3QnBCLFNBQVUsR0F4QlUsQ0F3QkosU0FBVSxHQXhCTixDQXdCVyxTQUFVLEdBeEJyQixDQXdCMEIsU0FBVSxHQXhCcEMsQ0F5QnBCLFNBQVUsR0F6QlUsQ0F5QkosU0FBVSxHQXpCTixDQXlCVyxTQUFVLEdBekJyQixDQXlCMEIsU0FBVSxHQXpCcEMsQ0F5QnlDLFNBQVUsR0F6Qm5ELENBMEJwQixTQUFVLEdBMUJVLENBMEJKLFNBQVUsR0ExQk4sQ0EwQlcsU0FBVSxHQTFCckIsQ0EwQjBCLFNBQVUsR0ExQnBDLENBMEJ5QyxTQUFVLEdBMUJuRCxDQTJCcEIsU0FBVSxHQTNCVSxDQTJCSixTQUFVLEdBM0JOLENBMkJXLFNBQVUsR0EzQnJCLENBMkIwQixTQUFVLEdBM0JwQyxDQTRCcEIsU0FBVSxHQTVCVSxDQTRCSixTQUFVLEdBNUJOLENBNEJXLFNBQVUsR0E1QnJCLENBNEIwQixTQUFVLEdBNUJwQyxDQTZCcEIsU0FBVSxHQTdCVSxDQTZCSixTQUFVLEdBN0JOLENBNkJXLFNBQVUsR0E3QnJCLENBNkIwQixTQUFVLEdBN0JwQyxDQThCcEIsU0FBVSxHQTlCVSxDQThCSixTQUFVLEdBOUJOLENBOEJXLFNBQVUsR0E5QnJCLENBOEIwQixTQUFVLEdBOUJwQyxDQThCeUMsU0FBVSxHQTlCbkQsQ0ErQnBCLFNBQVUsR0EvQlUsQ0ErQkosU0FBVSxHQS9CTixDQStCVyxTQUFVLEdBL0JyQixDQStCMEIsU0FBVSxHQS9CcEMsQ0ErQnlDLFNBQVUsR0EvQm5ELENBZ0NwQixTQUFVLEdBaENVLENBZ0NKLFNBQVUsR0FoQ04sQ0FpQ3BCLFNBQVUsR0FqQ1UsQ0FpQ0osU0FBVSxHQWpDTixDQWlDVyxTQUFVLEdBakNyQixDQWtDcEIsU0FBVSxHQWxDVSxDQWtDSixTQUFVLEdBbENOLENBa0NXLFNBQVUsR0FsQ3JCLENBa0MwQixTQUFVLEdBbENwQyxDQWtDeUMsU0FBVSxHQWxDbkQsQ0FtQ3BCLFNBQVUsR0FuQ1UsQ0FtQ0osU0FBVSxHQW5DTixDQW1DVyxTQUFVLEdBbkNyQixDQW1DMEIsU0FBVSxHQW5DcEMsQ0FtQ3lDLFNBQVUsR0FuQ25ELENBb0NwQixTQUFVLEdBcENVLENBb0NKLFNBQVUsR0FwQ04sQ0FvQ1csU0FBVSxHQXBDckIsQ0FvQzBCLFNBQVUsR0FwQ3BDLENBcUNwQixTQUFVLEdBckNVLENBcUNKLFNBQVUsR0FyQ04sQ0FxQ1csU0FBVSxHQXJDckIsQ0FxQzBCLFNBQVUsR0FyQ3BDLENBc0NwQixTQUFVLEdBdENVLENBc0NKLFNBQVUsR0F0Q04sQ0FzQ1csU0FBVSxHQXRDckIsQ0F1Q3BCLFNBQVUsR0F2Q1UsQ0F1Q0osU0FBVSxHQXZDTixDQXVDVyxTQUFVLEdBdkNyQixDQXdDcEIsU0FBVSxHQXhDVSxDQXdDSixTQUFVLEdBeENOLENBd0NXLFNBQVUsR0F4Q3JCLENBeUNwQixTQUFVLEdBekNVLENBeUNKLFNBQVUsR0F6Q04sQ0F5Q1csU0FBVSxHQXpDckIsQ0EwQ3BCLFNBQVUsR0ExQ1UsQ0EwQ0osU0FBVSxHQTFDTixDQTBDVyxTQUFVLEdBMUNyQixDQTBDMEIsU0FBVSxHQTFDcEMsQ0EyQ3BCLFNBQVUsR0EzQ1UsQ0EyQ0osU0FBVSxHQTNDTixDQTJDVyxTQUFVLEdBM0NyQixDQTJDMEIsU0FBVSxHQTNDcEMsQ0E0Q3BCLFNBQVUsR0E1Q1UsQ0E0Q0osU0FBVSxHQTVDTixDQTRDVyxTQUFVLEdBNUNyQixDQTZDcEIsU0FBVSxHQTdDVSxDQTZDSixTQUFVLEdBN0NOLENBNkNXLFNBQVUsR0E3Q3JCLENBOENwQixTQUFVLEdBOUNVLENBOENKLFNBQVUsR0E5Q04sQ0E4Q1csU0FBVSxHQTlDckIsQ0E4QzBCLFNBQVUsR0E5Q3BDLENBOEN5QyxTQUFVLEdBOUNuRCxDQThDd0QsU0FBVSxHQTlDbEUsQ0ErQ3BCLFNBQVUsR0EvQ1UsQ0ErQ0osU0FBVSxHQS9DTixDQStDVyxTQUFVLEdBL0NyQixDQStDMEIsU0FBVSxHQS9DcEMsQ0ErQ3lDLFNBQVUsR0EvQ25ELENBK0N3RCxTQUFVLEdBL0NsRSxDQWdEcEIsU0FBVSxHQWhEVSxDQWdESixTQUFVLEdBaEROLENBaURwQixTQUFVLEdBakRVLENBaURKLFNBQVUsR0FqRE4sQ0FpRFcsU0FBVSxHQWpEckIsQ0FrRHBCLFNBQVUsR0FsRFUsQ0FrREosU0FBVSxHQWxETixDQWtEVyxTQUFVLEdBbERyQixDQW1EcEIsU0FBVSxHQW5EVSxDQW1ESixTQUFVLEdBbkROLENBbURXLFNBQVUsR0FuRHJCLENBb0RwQixTQUFVLElBcERVLENBb0RKLFNBQVUsSUFwRE4sQ0FxRHBCLFNBQVUsSUFyRFUsQ0FxREosU0FBVSxJQXJETixDQXNEcEIsU0FBVSxJQXREVSxDQXNESixTQUFVLElBdEROLENBQXRCLENBeURBLCtDQUNBLEdBQUlDLGFBQWMsQ0FDaEIsSUFBSyxPQURXLENBRWhCLElBQUssTUFGVyxDQUdoQixJQUFLLE1BSFcsQ0FJaEIsSUFBSyxRQUpXLENBS2hCLElBQUssT0FMVyxDQU1oQixJQUFLLE9BTlcsQ0FBbEIsQ0FTQSwrQ0FDQSxHQUFJQyxlQUFnQixDQUNsQixRQUFTLEdBRFMsQ0FFbEIsT0FBUSxHQUZVLENBR2xCLE9BQVEsR0FIVSxDQUlsQixTQUFVLEdBSlEsQ0FLbEIsUUFBUyxHQUxTLENBTWxCLFFBQVMsR0FOUyxDQUFwQixDQVNBLDJFQUNBLEdBQUlDLGVBQWdCLENBQ2xCLEtBQU0sSUFEWSxDQUVsQixJQUFLLEdBRmEsQ0FHbEIsS0FBTSxHQUhZLENBSWxCLEtBQU0sR0FKWSxDQUtsQixTQUFVLE9BTFEsQ0FNbEIsU0FBVSxPQU5RLENBQXBCLENBU0EsaUVBQ0EsR0FBSUMsZ0JBQWlCQyxVQUFyQixDQUNJQyxhQUFldmdCLFFBRG5CLENBR0Esa0RBQ0EsR0FBSXdnQixZQUFhLE1BQU94b0IsT0FBUCxFQUFpQixRQUFqQixFQUE2QkEsTUFBN0IsRUFBdUNBLE9BQU9nSyxNQUFQLEdBQWtCQSxNQUF6RCxFQUFtRWhLLE1BQXBGLENBRUEsbUNBQ0EsR0FBSXlvQixVQUFXLE1BQU8zakIsS0FBUCxFQUFlLFFBQWYsRUFBMkJBLElBQTNCLEVBQW1DQSxLQUFLa0YsTUFBTCxHQUFnQkEsTUFBbkQsRUFBNkRsRixJQUE1RSxDQUVBLGdEQUNBLEdBQUk0akIsTUFBT0YsWUFBY0MsUUFBZCxFQUEwQkUsU0FBUyxhQUFULEdBQXJDLENBRUEsc0NBQ0EsR0FBSUMsYUFBYyxNQUFPQyxRQUFQLEVBQWtCLFFBQWxCLEVBQThCQSxPQUE5QixFQUF5QyxDQUFDQSxRQUFRQyxRQUFsRCxFQUE4REQsT0FBaEYsQ0FFQSxxQ0FDQSxHQUFJRSxZQUFhSCxhQUFlLE1BQU9JLE9BQVAsRUFBaUIsUUFBaEMsRUFBNENBLE1BQTVDLEVBQXNELENBQUNBLE9BQU9GLFFBQTlELEVBQTBFRSxNQUEzRixDQUVBLDhEQUNBLEdBQUlDLGVBQWdCRixZQUFjQSxXQUFXRixPQUFYLEdBQXVCRCxXQUF6RCxDQUVBLG1EQUNBLEdBQUlNLGFBQWNELGVBQWlCVCxXQUFXaHNCLE9BQTlDLENBRUEsNkNBQ0EsR0FBSTJzQixVQUFZLFVBQVcsQ0FDekIsR0FBSSxDQUNGLE1BQU9ELGNBQWVBLFlBQVlFLE9BQVosQ0FBb0IsTUFBcEIsQ0FBdEIsQ0FDRCxDQUFDLE1BQU9wbEIsQ0FBUCxDQUFVLENBQUUsQ0FDZixDQUplLEVBQWhCLENBTUEsZ0NBQ0EsR0FBSXFsQixtQkFBb0JGLFVBQVlBLFNBQVNHLGFBQTdDLENBQ0lDLFdBQWFKLFVBQVlBLFNBQVNLLE1BRHRDLENBRUlDLFVBQVlOLFVBQVlBLFNBQVNPLEtBRnJDLENBR0lDLGFBQWVSLFVBQVlBLFNBQVNTLFFBSHhDLENBSUlDLFVBQVlWLFVBQVlBLFNBQVNXLEtBSnJDLENBS0lDLGlCQUFtQlosVUFBWUEsU0FBU2EsWUFMNUMsQ0FPQSw4RUFFQTs7Ozs7OztLQVFBLFFBQVNDLFlBQVQsQ0FBcUJsWixHQUFyQixDQUEwQm1aLElBQTFCLENBQWdDLENBQzlCO0FBQ0FuWixJQUFJdlQsR0FBSixDQUFRMHNCLEtBQUssQ0FBTCxDQUFSLENBQWlCQSxLQUFLLENBQUwsQ0FBakIsRUFDQSxNQUFPblosSUFBUCxDQUNELENBRUQ7Ozs7Ozs7S0FRQSxRQUFTb1osWUFBVCxDQUFxQjNzQixHQUFyQixDQUEwQkUsS0FBMUIsQ0FBaUMsQ0FDL0I7QUFDQUYsSUFBSTRzQixHQUFKLENBQVExc0IsS0FBUixFQUNBLE1BQU9GLElBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7S0FVQSxRQUFTK2dCLE1BQVQsQ0FBZThMLElBQWYsQ0FBcUJDLE9BQXJCLENBQThCQyxJQUE5QixDQUFvQyxDQUNsQyxPQUFRQSxLQUFLeG5CLE1BQWIsRUFDRSxJQUFLLEVBQUwsQ0FBUSxNQUFPc25CLE1BQUs1UixJQUFMLENBQVU2UixPQUFWLENBQVAsQ0FDUixJQUFLLEVBQUwsQ0FBUSxNQUFPRCxNQUFLNVIsSUFBTCxDQUFVNlIsT0FBVixDQUFtQkMsS0FBSyxDQUFMLENBQW5CLENBQVAsQ0FDUixJQUFLLEVBQUwsQ0FBUSxNQUFPRixNQUFLNVIsSUFBTCxDQUFVNlIsT0FBVixDQUFtQkMsS0FBSyxDQUFMLENBQW5CLENBQTRCQSxLQUFLLENBQUwsQ0FBNUIsQ0FBUCxDQUNSLElBQUssRUFBTCxDQUFRLE1BQU9GLE1BQUs1UixJQUFMLENBQVU2UixPQUFWLENBQW1CQyxLQUFLLENBQUwsQ0FBbkIsQ0FBNEJBLEtBQUssQ0FBTCxDQUE1QixDQUFxQ0EsS0FBSyxDQUFMLENBQXJDLENBQVAsQ0FKVixDQU1BLE1BQU9GLE1BQUs5TCxLQUFMLENBQVcrTCxPQUFYLENBQW9CQyxJQUFwQixDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7O0tBVUEsUUFBU0MsZ0JBQVQsQ0FBeUJDLEtBQXpCLENBQWdDQyxNQUFoQyxDQUF3Q0MsUUFBeEMsQ0FBa0RDLFdBQWxELENBQStELENBQzdELEdBQUl0YyxPQUFRLENBQUMsQ0FBYixDQUNJdkwsT0FBUzBuQixNQUFRQSxNQUFNMW5CLE1BQWQsQ0FBdUIsQ0FEcEMsQ0FHQSxNQUFPLEVBQUV1TCxLQUFGLENBQVV2TCxNQUFqQixDQUF5QixDQUN2QixHQUFJckYsT0FBUStzQixNQUFNbmMsS0FBTixDQUFaLENBQ0FvYyxPQUFPRSxXQUFQLENBQW9CbHRCLEtBQXBCLENBQTJCaXRCLFNBQVNqdEIsS0FBVCxDQUEzQixDQUE0QytzQixLQUE1QyxFQUNELENBQ0QsTUFBT0csWUFBUCxDQUNELENBRUQ7Ozs7Ozs7O0tBU0EsUUFBU0MsVUFBVCxDQUFtQkosS0FBbkIsQ0FBMEJFLFFBQTFCLENBQW9DLENBQ2xDLEdBQUlyYyxPQUFRLENBQUMsQ0FBYixDQUNJdkwsT0FBUzBuQixNQUFRQSxNQUFNMW5CLE1BQWQsQ0FBdUIsQ0FEcEMsQ0FHQSxNQUFPLEVBQUV1TCxLQUFGLENBQVV2TCxNQUFqQixDQUF5QixDQUN2QixHQUFJNG5CLFNBQVNGLE1BQU1uYyxLQUFOLENBQVQsQ0FBdUJBLEtBQXZCLENBQThCbWMsS0FBOUIsSUFBeUMsS0FBN0MsQ0FBb0QsQ0FDbEQsTUFDRCxDQUNGLENBQ0QsTUFBT0EsTUFBUCxDQUNELENBRUQ7Ozs7Ozs7O0tBU0EsUUFBU0ssZUFBVCxDQUF3QkwsS0FBeEIsQ0FBK0JFLFFBQS9CLENBQXlDLENBQ3ZDLEdBQUk1bkIsUUFBUzBuQixNQUFRQSxNQUFNMW5CLE1BQWQsQ0FBdUIsQ0FBcEMsQ0FFQSxNQUFPQSxRQUFQLENBQWlCLENBQ2YsR0FBSTRuQixTQUFTRixNQUFNMW5CLE1BQU4sQ0FBVCxDQUF3QkEsTUFBeEIsQ0FBZ0MwbkIsS0FBaEMsSUFBMkMsS0FBL0MsQ0FBc0QsQ0FDcEQsTUFDRCxDQUNGLENBQ0QsTUFBT0EsTUFBUCxDQUNELENBRUQ7Ozs7Ozs7OztLQVVBLFFBQVNNLFdBQVQsQ0FBb0JOLEtBQXBCLENBQTJCTyxTQUEzQixDQUFzQyxDQUNwQyxHQUFJMWMsT0FBUSxDQUFDLENBQWIsQ0FDSXZMLE9BQVMwbkIsTUFBUUEsTUFBTTFuQixNQUFkLENBQXVCLENBRHBDLENBR0EsTUFBTyxFQUFFdUwsS0FBRixDQUFVdkwsTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSSxDQUFDaW9CLFVBQVVQLE1BQU1uYyxLQUFOLENBQVYsQ0FBd0JBLEtBQXhCLENBQStCbWMsS0FBL0IsQ0FBTCxDQUE0QyxDQUMxQyxNQUFPLE1BQVAsQ0FDRCxDQUNGLENBQ0QsTUFBTyxLQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7S0FTQSxRQUFTUSxZQUFULENBQXFCUixLQUFyQixDQUE0Qk8sU0FBNUIsQ0FBdUMsQ0FDckMsR0FBSTFjLE9BQVEsQ0FBQyxDQUFiLENBQ0l2TCxPQUFTMG5CLE1BQVFBLE1BQU0xbkIsTUFBZCxDQUF1QixDQURwQyxDQUVJbW9CLFNBQVcsQ0FGZixDQUdJQyxPQUFTLEVBSGIsQ0FLQSxNQUFPLEVBQUU3YyxLQUFGLENBQVV2TCxNQUFqQixDQUF5QixDQUN2QixHQUFJckYsT0FBUStzQixNQUFNbmMsS0FBTixDQUFaLENBQ0EsR0FBSTBjLFVBQVV0dEIsS0FBVixDQUFpQjRRLEtBQWpCLENBQXdCbWMsS0FBeEIsQ0FBSixDQUFvQyxDQUNsQ1UsT0FBT0QsVUFBUCxFQUFxQnh0QixLQUFyQixDQUNELENBQ0YsQ0FDRCxNQUFPeXRCLE9BQVAsQ0FDRCxDQUVEOzs7Ozs7OztLQVNBLFFBQVNDLGNBQVQsQ0FBdUJYLEtBQXZCLENBQThCL3NCLEtBQTlCLENBQXFDLENBQ25DLEdBQUlxRixRQUFTMG5CLE1BQVFBLE1BQU0xbkIsTUFBZCxDQUF1QixDQUFwQyxDQUNBLE1BQU8sQ0FBQyxDQUFDQSxNQUFGLEVBQVlzb0IsWUFBWVosS0FBWixDQUFtQi9zQixLQUFuQixDQUEwQixDQUExQixFQUErQixDQUFDLENBQW5ELENBQ0QsQ0FFRDs7Ozs7Ozs7S0FTQSxRQUFTNHRCLGtCQUFULENBQTJCYixLQUEzQixDQUFrQy9zQixLQUFsQyxDQUF5QzZ0QixVQUF6QyxDQUFxRCxDQUNuRCxHQUFJamQsT0FBUSxDQUFDLENBQWIsQ0FDSXZMLE9BQVMwbkIsTUFBUUEsTUFBTTFuQixNQUFkLENBQXVCLENBRHBDLENBR0EsTUFBTyxFQUFFdUwsS0FBRixDQUFVdkwsTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSXdvQixXQUFXN3RCLEtBQVgsQ0FBa0Irc0IsTUFBTW5jLEtBQU4sQ0FBbEIsQ0FBSixDQUFxQyxDQUNuQyxNQUFPLEtBQVAsQ0FDRCxDQUNGLENBQ0QsTUFBTyxNQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7S0FTQSxRQUFTa2QsU0FBVCxDQUFrQmYsS0FBbEIsQ0FBeUJFLFFBQXpCLENBQW1DLENBQ2pDLEdBQUlyYyxPQUFRLENBQUMsQ0FBYixDQUNJdkwsT0FBUzBuQixNQUFRQSxNQUFNMW5CLE1BQWQsQ0FBdUIsQ0FEcEMsQ0FFSW9vQixPQUFTOWMsTUFBTXRMLE1BQU4sQ0FGYixDQUlBLE1BQU8sRUFBRXVMLEtBQUYsQ0FBVXZMLE1BQWpCLENBQXlCLENBQ3ZCb29CLE9BQU83YyxLQUFQLEVBQWdCcWMsU0FBU0YsTUFBTW5jLEtBQU4sQ0FBVCxDQUF1QkEsS0FBdkIsQ0FBOEJtYyxLQUE5QixDQUFoQixDQUNELENBQ0QsTUFBT1UsT0FBUCxDQUNELENBRUQ7Ozs7Ozs7S0FRQSxRQUFTTSxVQUFULENBQW1CaEIsS0FBbkIsQ0FBMEJsUyxNQUExQixDQUFrQyxDQUNoQyxHQUFJakssT0FBUSxDQUFDLENBQWIsQ0FDSXZMLE9BQVN3VixPQUFPeFYsTUFEcEIsQ0FFSW9LLE9BQVNzZCxNQUFNMW5CLE1BRm5CLENBSUEsTUFBTyxFQUFFdUwsS0FBRixDQUFVdkwsTUFBakIsQ0FBeUIsQ0FDdkIwbkIsTUFBTXRkLE9BQVNtQixLQUFmLEVBQXdCaUssT0FBT2pLLEtBQVAsQ0FBeEIsQ0FDRCxDQUNELE1BQU9tYyxNQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7S0FZQSxRQUFTaUIsWUFBVCxDQUFxQmpCLEtBQXJCLENBQTRCRSxRQUE1QixDQUFzQ0MsV0FBdEMsQ0FBbURlLFNBQW5ELENBQThELENBQzVELEdBQUlyZCxPQUFRLENBQUMsQ0FBYixDQUNJdkwsT0FBUzBuQixNQUFRQSxNQUFNMW5CLE1BQWQsQ0FBdUIsQ0FEcEMsQ0FHQSxHQUFJNG9CLFdBQWE1b0IsTUFBakIsQ0FBeUIsQ0FDdkI2bkIsWUFBY0gsTUFBTSxFQUFFbmMsS0FBUixDQUFkLENBQ0QsQ0FDRCxNQUFPLEVBQUVBLEtBQUYsQ0FBVXZMLE1BQWpCLENBQXlCLENBQ3ZCNm5CLFlBQWNELFNBQVNDLFdBQVQsQ0FBc0JILE1BQU1uYyxLQUFOLENBQXRCLENBQW9DQSxLQUFwQyxDQUEyQ21jLEtBQTNDLENBQWQsQ0FDRCxDQUNELE1BQU9HLFlBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7OztLQVlBLFFBQVNnQixpQkFBVCxDQUEwQm5CLEtBQTFCLENBQWlDRSxRQUFqQyxDQUEyQ0MsV0FBM0MsQ0FBd0RlLFNBQXhELENBQW1FLENBQ2pFLEdBQUk1b0IsUUFBUzBuQixNQUFRQSxNQUFNMW5CLE1BQWQsQ0FBdUIsQ0FBcEMsQ0FDQSxHQUFJNG9CLFdBQWE1b0IsTUFBakIsQ0FBeUIsQ0FDdkI2bkIsWUFBY0gsTUFBTSxFQUFFMW5CLE1BQVIsQ0FBZCxDQUNELENBQ0QsTUFBT0EsUUFBUCxDQUFpQixDQUNmNm5CLFlBQWNELFNBQVNDLFdBQVQsQ0FBc0JILE1BQU0xbkIsTUFBTixDQUF0QixDQUFxQ0EsTUFBckMsQ0FBNkMwbkIsS0FBN0MsQ0FBZCxDQUNELENBQ0QsTUFBT0csWUFBUCxDQUNELENBRUQ7Ozs7Ozs7OztLQVVBLFFBQVNpQixVQUFULENBQW1CcEIsS0FBbkIsQ0FBMEJPLFNBQTFCLENBQXFDLENBQ25DLEdBQUkxYyxPQUFRLENBQUMsQ0FBYixDQUNJdkwsT0FBUzBuQixNQUFRQSxNQUFNMW5CLE1BQWQsQ0FBdUIsQ0FEcEMsQ0FHQSxNQUFPLEVBQUV1TCxLQUFGLENBQVV2TCxNQUFqQixDQUF5QixDQUN2QixHQUFJaW9CLFVBQVVQLE1BQU1uYyxLQUFOLENBQVYsQ0FBd0JBLEtBQXhCLENBQStCbWMsS0FBL0IsQ0FBSixDQUEyQyxDQUN6QyxNQUFPLEtBQVAsQ0FDRCxDQUNGLENBQ0QsTUFBTyxNQUFQLENBQ0QsQ0FFRDs7Ozs7O0tBT0EsR0FBSXFCLFdBQVlDLGFBQWEsUUFBYixDQUFoQixDQUVBOzs7Ozs7S0FPQSxRQUFTQyxhQUFULENBQXNCN2YsTUFBdEIsQ0FBOEIsQ0FDNUIsTUFBT0EsUUFBT25RLEtBQVAsQ0FBYSxFQUFiLENBQVAsQ0FDRCxDQUVEOzs7Ozs7S0FPQSxRQUFTaXdCLFdBQVQsQ0FBb0I5ZixNQUFwQixDQUE0QixDQUMxQixNQUFPQSxRQUFPN0YsS0FBUCxDQUFhK2QsV0FBYixHQUE2QixFQUFwQyxDQUNELENBRUQ7Ozs7Ozs7Ozs7S0FXQSxRQUFTNkgsWUFBVCxDQUFxQkMsVUFBckIsQ0FBaUNuQixTQUFqQyxDQUE0Q29CLFFBQTVDLENBQXNELENBQ3BELEdBQUlqQixPQUFKLENBQ0FpQixTQUFTRCxVQUFULENBQXFCLFNBQVN6dUIsS0FBVCxDQUFnQkQsR0FBaEIsQ0FBcUIwdUIsVUFBckIsQ0FBaUMsQ0FDcEQsR0FBSW5CLFVBQVV0dEIsS0FBVixDQUFpQkQsR0FBakIsQ0FBc0IwdUIsVUFBdEIsQ0FBSixDQUF1QyxDQUNyQ2hCLE9BQVMxdEIsR0FBVCxDQUNBLE1BQU8sTUFBUCxDQUNELENBQ0YsQ0FMRCxFQU1BLE1BQU8wdEIsT0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7S0FXQSxRQUFTa0IsY0FBVCxDQUF1QjVCLEtBQXZCLENBQThCTyxTQUE5QixDQUF5Q3NCLFNBQXpDLENBQW9EQyxTQUFwRCxDQUErRCxDQUM3RCxHQUFJeHBCLFFBQVMwbkIsTUFBTTFuQixNQUFuQixDQUNJdUwsTUFBUWdlLFdBQWFDLFVBQVksQ0FBWixDQUFnQixDQUFDLENBQTlCLENBRFosQ0FHQSxNQUFRQSxVQUFZamUsT0FBWixDQUFzQixFQUFFQSxLQUFGLENBQVV2TCxNQUF4QyxDQUFpRCxDQUMvQyxHQUFJaW9CLFVBQVVQLE1BQU1uYyxLQUFOLENBQVYsQ0FBd0JBLEtBQXhCLENBQStCbWMsS0FBL0IsQ0FBSixDQUEyQyxDQUN6QyxNQUFPbmMsTUFBUCxDQUNELENBQ0YsQ0FDRCxNQUFPLENBQUMsQ0FBUixDQUNELENBRUQ7Ozs7Ozs7O0tBU0EsUUFBUytjLFlBQVQsQ0FBcUJaLEtBQXJCLENBQTRCL3NCLEtBQTVCLENBQW1DNHVCLFNBQW5DLENBQThDLENBQzVDLEdBQUk1dUIsUUFBVUEsS0FBZCxDQUFxQixDQUNuQixNQUFPMnVCLGVBQWM1QixLQUFkLENBQXFCK0IsU0FBckIsQ0FBZ0NGLFNBQWhDLENBQVAsQ0FDRCxDQUNELEdBQUloZSxPQUFRZ2UsVUFBWSxDQUF4QixDQUNJdnBCLE9BQVMwbkIsTUFBTTFuQixNQURuQixDQUdBLE1BQU8sRUFBRXVMLEtBQUYsQ0FBVXZMLE1BQWpCLENBQXlCLENBQ3ZCLEdBQUkwbkIsTUFBTW5jLEtBQU4sSUFBaUI1USxLQUFyQixDQUE0QixDQUMxQixNQUFPNFEsTUFBUCxDQUNELENBQ0YsQ0FDRCxNQUFPLENBQUMsQ0FBUixDQUNELENBRUQ7Ozs7Ozs7OztLQVVBLFFBQVNtZSxnQkFBVCxDQUF5QmhDLEtBQXpCLENBQWdDL3NCLEtBQWhDLENBQXVDNHVCLFNBQXZDLENBQWtEZixVQUFsRCxDQUE4RCxDQUM1RCxHQUFJamQsT0FBUWdlLFVBQVksQ0FBeEIsQ0FDSXZwQixPQUFTMG5CLE1BQU0xbkIsTUFEbkIsQ0FHQSxNQUFPLEVBQUV1TCxLQUFGLENBQVV2TCxNQUFqQixDQUF5QixDQUN2QixHQUFJd29CLFdBQVdkLE1BQU1uYyxLQUFOLENBQVgsQ0FBeUI1USxLQUF6QixDQUFKLENBQXFDLENBQ25DLE1BQU80USxNQUFQLENBQ0QsQ0FDRixDQUNELE1BQU8sQ0FBQyxDQUFSLENBQ0QsQ0FFRDs7Ozs7O0tBT0EsUUFBU2tlLFVBQVQsQ0FBbUI5dUIsS0FBbkIsQ0FBMEIsQ0FDeEIsTUFBT0EsU0FBVUEsS0FBakIsQ0FDRCxDQUVEOzs7Ozs7OztLQVNBLFFBQVNndkIsU0FBVCxDQUFrQmpDLEtBQWxCLENBQXlCRSxRQUF6QixDQUFtQyxDQUNqQyxHQUFJNW5CLFFBQVMwbkIsTUFBUUEsTUFBTTFuQixNQUFkLENBQXVCLENBQXBDLENBQ0EsTUFBT0EsUUFBVTRwQixRQUFRbEMsS0FBUixDQUFlRSxRQUFmLEVBQTJCNW5CLE1BQXJDLENBQStDNmQsR0FBdEQsQ0FDRCxDQUVEOzs7Ozs7S0FPQSxRQUFTbUwsYUFBVCxDQUFzQnR1QixHQUF0QixDQUEyQixDQUN6QixNQUFPLFVBQVNtdkIsTUFBVCxDQUFpQixDQUN0QixNQUFPQSxTQUFVLElBQVYsQ0FBaUJqcEIsU0FBakIsQ0FBNkJpcEIsT0FBT252QixHQUFQLENBQXBDLENBQ0QsQ0FGRCxDQUdELENBRUQ7Ozs7OztLQU9BLFFBQVNvdkIsZUFBVCxDQUF3QkQsTUFBeEIsQ0FBZ0MsQ0FDOUIsTUFBTyxVQUFTbnZCLEdBQVQsQ0FBYyxDQUNuQixNQUFPbXZCLFNBQVUsSUFBVixDQUFpQmpwQixTQUFqQixDQUE2QmlwQixPQUFPbnZCLEdBQVAsQ0FBcEMsQ0FDRCxDQUZELENBR0QsQ0FFRDs7Ozs7Ozs7Ozs7O0tBYUEsUUFBU3F2QixXQUFULENBQW9CWCxVQUFwQixDQUFnQ3hCLFFBQWhDLENBQTBDQyxXQUExQyxDQUF1RGUsU0FBdkQsQ0FBa0VTLFFBQWxFLENBQTRFLENBQzFFQSxTQUFTRCxVQUFULENBQXFCLFNBQVN6dUIsS0FBVCxDQUFnQjRRLEtBQWhCLENBQXVCNmQsVUFBdkIsQ0FBbUMsQ0FDdER2QixZQUFjZSxXQUNUQSxVQUFZLEtBQVosQ0FBbUJqdUIsS0FEVixFQUVWaXRCLFNBQVNDLFdBQVQsQ0FBc0JsdEIsS0FBdEIsQ0FBNkI0USxLQUE3QixDQUFvQzZkLFVBQXBDLENBRkosQ0FHRCxDQUpELEVBS0EsTUFBT3ZCLFlBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7S0FVQSxRQUFTbUMsV0FBVCxDQUFvQnRDLEtBQXBCLENBQTJCdUMsUUFBM0IsQ0FBcUMsQ0FDbkMsR0FBSWpxQixRQUFTMG5CLE1BQU0xbkIsTUFBbkIsQ0FFQTBuQixNQUFNclAsSUFBTixDQUFXNFIsUUFBWCxFQUNBLE1BQU9qcUIsUUFBUCxDQUFpQixDQUNmMG5CLE1BQU0xbkIsTUFBTixFQUFnQjBuQixNQUFNMW5CLE1BQU4sRUFBY3JGLEtBQTlCLENBQ0QsQ0FDRCxNQUFPK3NCLE1BQVAsQ0FDRCxDQUVEOzs7Ozs7OztLQVNBLFFBQVNrQyxRQUFULENBQWlCbEMsS0FBakIsQ0FBd0JFLFFBQXhCLENBQWtDLENBQ2hDLEdBQUlRLE9BQUosQ0FDSTdjLE1BQVEsQ0FBQyxDQURiLENBRUl2TCxPQUFTMG5CLE1BQU0xbkIsTUFGbkIsQ0FJQSxNQUFPLEVBQUV1TCxLQUFGLENBQVV2TCxNQUFqQixDQUF5QixDQUN2QixHQUFJNEksU0FBVWdmLFNBQVNGLE1BQU1uYyxLQUFOLENBQVQsQ0FBZCxDQUNBLEdBQUkzQyxVQUFZaEksU0FBaEIsQ0FBMkIsQ0FDekJ3bkIsT0FBU0EsU0FBV3huQixTQUFYLENBQXVCZ0ksT0FBdkIsQ0FBa0N3ZixPQUFTeGYsT0FBcEQsQ0FDRCxDQUNGLENBQ0QsTUFBT3dmLE9BQVAsQ0FDRCxDQUVEOzs7Ozs7OztLQVNBLFFBQVM4QixVQUFULENBQW1CQyxDQUFuQixDQUFzQnZDLFFBQXRCLENBQWdDLENBQzlCLEdBQUlyYyxPQUFRLENBQUMsQ0FBYixDQUNJNmMsT0FBUzljLE1BQU02ZSxDQUFOLENBRGIsQ0FHQSxNQUFPLEVBQUU1ZSxLQUFGLENBQVU0ZSxDQUFqQixDQUFvQixDQUNsQi9CLE9BQU83YyxLQUFQLEVBQWdCcWMsU0FBU3JjLEtBQVQsQ0FBaEIsQ0FDRCxDQUNELE1BQU82YyxPQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7S0FTQSxRQUFTZ0MsWUFBVCxDQUFxQlAsTUFBckIsQ0FBNkJRLEtBQTdCLENBQW9DLENBQ2xDLE1BQU81QixVQUFTNEIsS0FBVCxDQUFnQixTQUFTM3ZCLEdBQVQsQ0FBYyxDQUNuQyxNQUFPLENBQUNBLEdBQUQsQ0FBTW12QixPQUFPbnZCLEdBQVAsQ0FBTixDQUFQLENBQ0QsQ0FGTSxDQUFQLENBR0QsQ0FFRDs7Ozs7O0tBT0EsUUFBUzR2QixVQUFULENBQW1CaEQsSUFBbkIsQ0FBeUIsQ0FDdkIsTUFBTyxVQUFTM3NCLEtBQVQsQ0FBZ0IsQ0FDckIsTUFBTzJzQixNQUFLM3NCLEtBQUwsQ0FBUCxDQUNELENBRkQsQ0FHRCxDQUVEOzs7Ozs7Ozs7S0FVQSxRQUFTNHZCLFdBQVQsQ0FBb0JWLE1BQXBCLENBQTRCUSxLQUE1QixDQUFtQyxDQUNqQyxNQUFPNUIsVUFBUzRCLEtBQVQsQ0FBZ0IsU0FBUzN2QixHQUFULENBQWMsQ0FDbkMsTUFBT212QixRQUFPbnZCLEdBQVAsQ0FBUCxDQUNELENBRk0sQ0FBUCxDQUdELENBRUQ7Ozs7Ozs7S0FRQSxRQUFTOHZCLFNBQVQsQ0FBa0JDLEtBQWxCLENBQXlCL3ZCLEdBQXpCLENBQThCLENBQzVCLE1BQU8rdkIsT0FBTUMsR0FBTixDQUFVaHdCLEdBQVYsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7O0tBU0EsUUFBU2l3QixnQkFBVCxDQUF5QkMsVUFBekIsQ0FBcUNDLFVBQXJDLENBQWlELENBQy9DLEdBQUl0ZixPQUFRLENBQUMsQ0FBYixDQUNJdkwsT0FBUzRxQixXQUFXNXFCLE1BRHhCLENBR0EsTUFBTyxFQUFFdUwsS0FBRixDQUFVdkwsTUFBVixFQUFvQnNvQixZQUFZdUMsVUFBWixDQUF3QkQsV0FBV3JmLEtBQVgsQ0FBeEIsQ0FBMkMsQ0FBM0MsRUFBZ0QsQ0FBQyxDQUE1RSxDQUErRSxDQUFFLENBQ2pGLE1BQU9BLE1BQVAsQ0FDRCxDQUVEOzs7Ozs7OztLQVNBLFFBQVN1ZixjQUFULENBQXVCRixVQUF2QixDQUFtQ0MsVUFBbkMsQ0FBK0MsQ0FDN0MsR0FBSXRmLE9BQVFxZixXQUFXNXFCLE1BQXZCLENBRUEsTUFBT3VMLFNBQVcrYyxZQUFZdUMsVUFBWixDQUF3QkQsV0FBV3JmLEtBQVgsQ0FBeEIsQ0FBMkMsQ0FBM0MsRUFBZ0QsQ0FBQyxDQUFuRSxDQUFzRSxDQUFFLENBQ3hFLE1BQU9BLE1BQVAsQ0FDRCxDQUVEOzs7Ozs7O0tBUUEsUUFBU3dmLGFBQVQsQ0FBc0JyRCxLQUF0QixDQUE2QnNELFdBQTdCLENBQTBDLENBQ3hDLEdBQUlockIsUUFBUzBuQixNQUFNMW5CLE1BQW5CLENBQ0lvb0IsT0FBUyxDQURiLENBR0EsTUFBT3BvQixRQUFQLENBQWlCLENBQ2YsR0FBSTBuQixNQUFNMW5CLE1BQU4sSUFBa0JnckIsV0FBdEIsQ0FBbUMsQ0FDakM1QyxTQUNELENBQ0YsQ0FDRCxNQUFPQSxPQUFQLENBQ0QsQ0FFRDs7Ozs7OztLQVFBLEdBQUk2QyxjQUFlbkIsZUFBZTVFLGVBQWYsQ0FBbkIsQ0FFQTs7Ozs7O0tBT0EsR0FBSWdHLGdCQUFpQnBCLGVBQWUzRSxXQUFmLENBQXJCLENBRUE7Ozs7OztLQU9BLFFBQVNnRyxpQkFBVCxDQUEwQkMsR0FBMUIsQ0FBK0IsQ0FDN0IsTUFBTyxLQUFPL0YsY0FBYytGLEdBQWQsQ0FBZCxDQUNELENBRUQ7Ozs7Ozs7S0FRQSxRQUFTQyxTQUFULENBQWtCeEIsTUFBbEIsQ0FBMEJudkIsR0FBMUIsQ0FBK0IsQ0FDN0IsTUFBT212QixTQUFVLElBQVYsQ0FBaUJqcEIsU0FBakIsQ0FBNkJpcEIsT0FBT252QixHQUFQLENBQXBDLENBQ0QsQ0FFRDs7Ozs7O0tBT0EsUUFBUzR3QixXQUFULENBQW9CbGlCLE1BQXBCLENBQTRCLENBQzFCLE1BQU93YixjQUFhblYsSUFBYixDQUFrQnJHLE1BQWxCLENBQVAsQ0FDRCxDQUVEOzs7Ozs7S0FPQSxRQUFTbWlCLGVBQVQsQ0FBd0JuaUIsTUFBeEIsQ0FBZ0MsQ0FDOUIsTUFBT3liLGtCQUFpQnBWLElBQWpCLENBQXNCckcsTUFBdEIsQ0FBUCxDQUNELENBRUQ7Ozs7OztLQU9BLFFBQVNvaUIsYUFBVCxDQUFzQjd3QixLQUF0QixDQUE2QixDQUMzQjtBQUNBO0FBQ0EsR0FBSXl0QixRQUFTLEtBQWIsQ0FDQSxHQUFJenRCLE9BQVMsSUFBVCxFQUFpQixNQUFPQSxPQUFNOHdCLFFBQWIsRUFBeUIsVUFBOUMsQ0FBMEQsQ0FDeEQsR0FBSSxDQUNGckQsT0FBUyxDQUFDLEVBQUV6dEIsTUFBUSxFQUFWLENBQVYsQ0FDRCxDQUFDLE1BQU9zRyxDQUFQLENBQVUsQ0FBRSxDQUNmLENBQ0QsTUFBT21uQixPQUFQLENBQ0QsQ0FFRDs7Ozs7O0tBT0EsUUFBU3NELGdCQUFULENBQXlCQyxRQUF6QixDQUFtQyxDQUNqQyxHQUFJdHVCLEtBQUosQ0FDSStxQixPQUFTLEVBRGIsQ0FHQSxNQUFPLENBQUMsQ0FBQy9xQixLQUFPc3VCLFNBQVN2WixJQUFULEVBQVIsRUFBeUJ3WixJQUFqQyxDQUF1QyxDQUNyQ3hELE9BQU8za0IsSUFBUCxDQUFZcEcsS0FBSzFDLEtBQWpCLEVBQ0QsQ0FDRCxNQUFPeXRCLE9BQVAsQ0FDRCxDQUVEOzs7Ozs7S0FPQSxRQUFTeUQsV0FBVCxDQUFvQjdkLEdBQXBCLENBQXlCLENBQ3ZCLEdBQUl6QyxPQUFRLENBQUMsQ0FBYixDQUNJNmMsT0FBUzljLE1BQU0wQyxJQUFJOGQsSUFBVixDQURiLENBR0E5ZCxJQUFJNU8sT0FBSixDQUFZLFNBQVN6RSxLQUFULENBQWdCRCxHQUFoQixDQUFxQixDQUMvQjB0QixPQUFPLEVBQUU3YyxLQUFULEVBQWtCLENBQUM3USxHQUFELENBQU1DLEtBQU4sQ0FBbEIsQ0FDRCxDQUZELEVBR0EsTUFBT3l0QixPQUFQLENBQ0QsQ0FFRDs7Ozs7OztLQVFBLFFBQVMyRCxRQUFULENBQWlCekUsSUFBakIsQ0FBdUIwRSxTQUF2QixDQUFrQyxDQUNoQyxNQUFPLFVBQVNDLEdBQVQsQ0FBYyxDQUNuQixNQUFPM0UsTUFBSzBFLFVBQVVDLEdBQVYsQ0FBTCxDQUFQLENBQ0QsQ0FGRCxDQUdELENBRUQ7Ozs7Ozs7O0tBU0EsUUFBU0MsZUFBVCxDQUF3QnhFLEtBQXhCLENBQStCc0QsV0FBL0IsQ0FBNEMsQ0FDMUMsR0FBSXpmLE9BQVEsQ0FBQyxDQUFiLENBQ0l2TCxPQUFTMG5CLE1BQU0xbkIsTUFEbkIsQ0FFSW1vQixTQUFXLENBRmYsQ0FHSUMsT0FBUyxFQUhiLENBS0EsTUFBTyxFQUFFN2MsS0FBRixDQUFVdkwsTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSXJGLE9BQVErc0IsTUFBTW5jLEtBQU4sQ0FBWixDQUNBLEdBQUk1USxRQUFVcXdCLFdBQVYsRUFBeUJyd0IsUUFBVTJoQixXQUF2QyxDQUFvRCxDQUNsRG9MLE1BQU1uYyxLQUFOLEVBQWUrUSxXQUFmLENBQ0E4TCxPQUFPRCxVQUFQLEVBQXFCNWMsS0FBckIsQ0FDRCxDQUNGLENBQ0QsTUFBTzZjLE9BQVAsQ0FDRCxDQUVEOzs7Ozs7S0FPQSxRQUFTK0QsV0FBVCxDQUFvQjF4QixHQUFwQixDQUF5QixDQUN2QixHQUFJOFEsT0FBUSxDQUFDLENBQWIsQ0FDSTZjLE9BQVM5YyxNQUFNN1EsSUFBSXF4QixJQUFWLENBRGIsQ0FHQXJ4QixJQUFJMkUsT0FBSixDQUFZLFNBQVN6RSxLQUFULENBQWdCLENBQzFCeXRCLE9BQU8sRUFBRTdjLEtBQVQsRUFBa0I1USxLQUFsQixDQUNELENBRkQsRUFHQSxNQUFPeXRCLE9BQVAsQ0FDRCxDQUVEOzs7Ozs7S0FPQSxRQUFTZ0UsV0FBVCxDQUFvQjN4QixHQUFwQixDQUF5QixDQUN2QixHQUFJOFEsT0FBUSxDQUFDLENBQWIsQ0FDSTZjLE9BQVM5YyxNQUFNN1EsSUFBSXF4QixJQUFWLENBRGIsQ0FHQXJ4QixJQUFJMkUsT0FBSixDQUFZLFNBQVN6RSxLQUFULENBQWdCLENBQzFCeXRCLE9BQU8sRUFBRTdjLEtBQVQsRUFBa0IsQ0FBQzVRLEtBQUQsQ0FBUUEsS0FBUixDQUFsQixDQUNELENBRkQsRUFHQSxNQUFPeXRCLE9BQVAsQ0FDRCxDQUVEOzs7Ozs7S0FPQSxRQUFTaUUsV0FBVCxDQUFvQmpqQixNQUFwQixDQUE0QixDQUMxQixNQUFPa2lCLFlBQVdsaUIsTUFBWCxFQUNIa2pCLFlBQVlsakIsTUFBWixDQURHLENBRUgyZixVQUFVM2YsTUFBVixDQUZKLENBR0QsQ0FFRDs7Ozs7O0tBT0EsUUFBU21qQixjQUFULENBQXVCbmpCLE1BQXZCLENBQStCLENBQzdCLE1BQU9raUIsWUFBV2xpQixNQUFYLEVBQ0hvakIsZUFBZXBqQixNQUFmLENBREcsQ0FFSDZmLGFBQWE3ZixNQUFiLENBRkosQ0FHRCxDQUVEOzs7Ozs7S0FPQSxHQUFJcWpCLGtCQUFtQjNDLGVBQWUxRSxhQUFmLENBQXZCLENBRUE7Ozs7OztLQU9BLFFBQVNrSCxZQUFULENBQXFCbGpCLE1BQXJCLENBQTZCLENBQzNCLEdBQUlnZixRQUFTMUQsVUFBVWdJLFNBQVYsQ0FBc0IsQ0FBbkMsQ0FDQSxNQUFPaEksVUFBVWpWLElBQVYsQ0FBZXJHLE1BQWYsQ0FBUCxDQUErQixDQUM3QmdmLFNBQ0QsQ0FDRCxNQUFPQSxPQUFQLENBQ0QsQ0FFRDs7Ozs7O0tBT0EsUUFBU29FLGVBQVQsQ0FBd0JwakIsTUFBeEIsQ0FBZ0MsQ0FDOUIsTUFBT0EsUUFBTzdGLEtBQVAsQ0FBYW1oQixTQUFiLEdBQTJCLEVBQWxDLENBQ0QsQ0FFRDs7Ozs7O0tBT0EsUUFBU2lJLGFBQVQsQ0FBc0J2akIsTUFBdEIsQ0FBOEIsQ0FDNUIsTUFBT0EsUUFBTzdGLEtBQVAsQ0FBYW9oQixhQUFiLEdBQStCLEVBQXRDLENBQ0QsQ0FFRCw4RUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FvQ0EsUUFBU2lJLGFBQVQsQ0FBc0JDLE9BQXRCLENBQStCLENBQzdCQSxRQUFVQSxRQUFVL3RCLEVBQUVndUIsUUFBRixDQUFXbkgsS0FBSzFlLE1BQUwsRUFBWCxDQUEwQjRsQixPQUExQixDQUFtQy90QixFQUFFaXVCLElBQUYsQ0FBT3BILElBQVAsQ0FBYWIsWUFBYixDQUFuQyxDQUFWLENBQTJFYSxJQUFyRixDQUVBLHVDQUNBLEdBQUlyYSxPQUFRdWhCLFFBQVF2aEIsS0FBcEIsQ0FDSTlELEtBQU9xbEIsUUFBUXJsQixJQURuQixDQUVJbk8sTUFBUXd6QixRQUFReHpCLEtBRnBCLENBR0l1c0IsU0FBV2lILFFBQVFqSCxRQUh2QixDQUlJNW5CLEtBQU82dUIsUUFBUTd1QixJQUpuQixDQUtJaUosT0FBUzRsQixRQUFRNWxCLE1BTHJCLENBTUltWixPQUFTeU0sUUFBUXpNLE1BTnJCLENBT0k3a0IsT0FBU3N4QixRQUFRdHhCLE1BUHJCLENBUUl5eEIsVUFBWUgsUUFBUUcsU0FSeEIsQ0FVQSwyQ0FDQSxHQUFJQyxZQUFhM2hCLE1BQU00aEIsU0FBdkIsQ0FDSUMsVUFBWXZILFNBQVNzSCxTQUR6QixDQUVJRSxZQUFjbm1CLE9BQU9pbUIsU0FGekIsQ0FJQSxpREFDQSxHQUFJRyxZQUFhUixRQUFRLG9CQUFSLENBQWpCLENBRUEscURBQ0EsR0FBSVMsWUFBYyxVQUFXLENBQzNCLEdBQUk5dkIsS0FBTSxTQUFTK3ZCLElBQVQsQ0FBY0YsWUFBY0EsV0FBV0csSUFBekIsRUFBaUNILFdBQVdHLElBQVgsQ0FBZ0JDLFFBQWpELEVBQTZELEVBQTNFLENBQVYsQ0FDQSxNQUFPandCLEtBQU8saUJBQW1CQSxHQUExQixDQUFpQyxFQUF4QyxDQUNELENBSGlCLEVBQWxCLENBS0EsMERBQ0EsR0FBSWt3QixjQUFlUCxVQUFVMUIsUUFBN0IsQ0FFQSxnREFDQSxHQUFJa0MsZ0JBQWlCUCxZQUFZTyxjQUFqQyxDQUVBLG1DQUNBLEdBQUlDLFdBQVksQ0FBaEIsQ0FFQSw4Q0FDQSxHQUFJQyxrQkFBbUJILGFBQWFoWSxJQUFiLENBQWtCek8sTUFBbEIsQ0FBdkIsQ0FFQTs7OztPQUtBLEdBQUk2bUIsZ0JBQWlCVixZQUFZM0IsUUFBakMsQ0FFQSxvRUFDQSxHQUFJc0MsU0FBVXBJLEtBQUs3bUIsQ0FBbkIsQ0FFQSw0Q0FDQSxHQUFJa3ZCLFlBQWE1TixPQUFPLElBQ3RCc04sYUFBYWhZLElBQWIsQ0FBa0JpWSxjQUFsQixFQUFrQzdvQixPQUFsQyxDQUEwQ2djLFlBQTFDLENBQXdELE1BQXhELEVBQ0NoYyxPQURELENBQ1Msd0RBRFQsQ0FDbUUsT0FEbkUsQ0FEc0IsQ0FFd0QsR0FGL0QsQ0FBakIsQ0FLQSxpQ0FDQSxHQUFJbXBCLFFBQVMvSCxjQUFnQjJHLFFBQVFvQixNQUF4QixDQUFpQ3J0QixTQUE5QyxDQUNJc3RCLE9BQVNyQixRQUFRcUIsTUFEckIsQ0FFSUMsV0FBYXRCLFFBQVFzQixVQUZ6QixDQUdJQyxhQUFlckMsUUFBUTlrQixPQUFPb25CLGNBQWYsQ0FBK0JwbkIsTUFBL0IsQ0FIbkIsQ0FJSXFuQixlQUFpQkosT0FBU0EsT0FBT3ZDLFFBQWhCLENBQTJCL3FCLFNBSmhELENBS0kydEIsYUFBZXRuQixPQUFPeEwsTUFMMUIsQ0FNSSt5QixxQkFBdUJwQixZQUFZb0Isb0JBTnZDLENBT0kvVCxPQUFTd1MsV0FBV3hTLE1BUHhCLENBUUlnVSxpQkFBbUJQLE9BQVNBLE9BQU9RLGtCQUFoQixDQUFxQzl0QixTQVI1RCxDQVVBLHdCQUNBLEdBQUkrdEIsaUJBQWtCOUIsUUFBUW5lLFlBQVIsR0FBeUJpWCxLQUFLalgsWUFBOUIsRUFBOENtZSxRQUFRbmUsWUFBNUUsQ0FDSWtnQixPQUFTcG5CLE1BQVFBLEtBQUtDLEdBQUwsR0FBYWtlLEtBQUtuZSxJQUFMLENBQVVDLEdBQS9CLEVBQXNDRCxLQUFLQyxHQUR4RCxDQUVJb25CLGNBQWdCaEMsUUFBUWp1QixVQUFSLEdBQXVCK21CLEtBQUsvbUIsVUFBNUIsRUFBMENpdUIsUUFBUWp1QixVQUZ0RSxDQUlBLHdGQUNBLEdBQUlrd0IsWUFBYTl3QixLQUFLK3dCLElBQXRCLENBQ0lDLFlBQWNoeEIsS0FBS2l4QixLQUR2QixDQUVJQyxpQkFBbUJqb0IsT0FBT2tvQixxQkFGOUIsQ0FHSUMsZUFBaUJuQixPQUFTQSxPQUFPb0IsUUFBaEIsQ0FBMkJ6dUIsU0FIaEQsQ0FJSTB1QixlQUFpQnpDLFFBQVEwQyxRQUo3QixDQUtJQyxXQUFhdkMsV0FBV2hmLElBTDVCLENBTUl3aEIsV0FBYTFELFFBQVE5a0IsT0FBT3VtQixJQUFmLENBQXFCdm1CLE1BQXJCLENBTmpCLENBT0l5b0IsVUFBWTF4QixLQUFLc0osR0FQckIsQ0FRSXFvQixVQUFZM3hCLEtBQUs0eEIsR0FSckIsQ0FTSUMsZUFBaUJoRCxRQUFRNW5CLFFBVDdCLENBVUk2cUIsYUFBZTl4QixLQUFLQyxNQVZ4QixDQVdJOHhCLGNBQWdCOUMsV0FBV3BVLE9BWC9CLENBYUEsZ0VBQ0EsR0FBSW1YLFVBQVdDLFVBQVVwRCxPQUFWLENBQW1CLFVBQW5CLENBQWYsQ0FDSXFELElBQU1ELFVBQVVwRCxPQUFWLENBQW1CLEtBQW5CLENBRFYsQ0FFSWx2QixRQUFVc3lCLFVBQVVwRCxPQUFWLENBQW1CLFNBQW5CLENBRmQsQ0FHSXNELElBQU1GLFVBQVVwRCxPQUFWLENBQW1CLEtBQW5CLENBSFYsQ0FJSXVELFFBQVVILFVBQVVwRCxPQUFWLENBQW1CLFNBQW5CLENBSmQsQ0FLSXdELGFBQWVKLFVBQVVocEIsTUFBVixDQUFrQixRQUFsQixDQUxuQixDQU9BLHFDQUNBLEdBQUlxcEIsZ0JBQWtCLFVBQVcsQ0FDL0IsR0FBSWhKLE1BQU8ySSxVQUFVaHBCLE1BQVYsQ0FBa0IsZ0JBQWxCLENBQVgsQ0FDSWlELEtBQU8rbEIsVUFBVS9sQixJQURyQixDQUdBLE1BQVFBLE9BQVFBLEtBQUtsSyxNQUFMLENBQWMsQ0FBdkIsQ0FBNEJzbkIsSUFBNUIsQ0FBbUMxbUIsU0FBMUMsQ0FDRCxDQUxxQixFQUF0QixDQU9BLHVDQUNBLEdBQUkydkIsU0FBVUgsU0FBVyxHQUFJQSxRQUFKLEVBQXpCLENBRUEscUZBQ0EsR0FBSUksZ0JBQWlCLENBQUNoQyxxQkFBcUI5WSxJQUFyQixDQUEwQixDQUFFLFVBQVcsQ0FBYixDQUExQixDQUE0QyxTQUE1QyxDQUF0QixDQUVBLGdEQUNBLEdBQUkrYSxXQUFZLEVBQWhCLENBRUEsK0NBQ0EsR0FBSUMsb0JBQXFCQyxTQUFTWCxRQUFULENBQXpCLENBQ0lZLGNBQWdCRCxTQUFTVCxHQUFULENBRHBCLENBRUlXLGtCQUFvQkYsU0FBU2h6QixPQUFULENBRnhCLENBR0ltekIsY0FBZ0JILFNBQVNSLEdBQVQsQ0FIcEIsQ0FJSVksa0JBQW9CSixTQUFTUCxPQUFULENBSnhCLENBTUEseURBQ0EsR0FBSVksYUFBYzlDLE9BQVNBLE9BQU9oQixTQUFoQixDQUE0QnRzQixTQUE5QyxDQUNJcXdCLGNBQWdCRCxZQUFjQSxZQUFZRSxPQUExQixDQUFvQ3R3QixTQUR4RCxDQUVJdXdCLGVBQWlCSCxZQUFjQSxZQUFZdkYsUUFBMUIsQ0FBcUM3cUIsU0FGMUQsQ0FJQSw0RUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FxSEEsUUFBU3d3QixPQUFULENBQWdCejJCLEtBQWhCLENBQXVCLENBQ3JCLEdBQUkwMkIsYUFBYTEyQixLQUFiLEdBQXVCLENBQUM4ZSxRQUFROWUsS0FBUixDQUF4QixFQUEwQyxFQUFFQSxnQkFBaUIyMkIsWUFBbkIsQ0FBOUMsQ0FBK0UsQ0FDN0UsR0FBSTMyQixnQkFBaUI0MkIsY0FBckIsQ0FBb0MsQ0FDbEMsTUFBTzUyQixNQUFQLENBQ0QsQ0FDRCxHQUFJZ3pCLGVBQWVqWSxJQUFmLENBQW9CL2EsS0FBcEIsQ0FBMkIsYUFBM0IsQ0FBSixDQUErQyxDQUM3QyxNQUFPNjJCLGNBQWE3MkIsS0FBYixDQUFQLENBQ0QsQ0FDRixDQUNELE1BQU8sSUFBSTQyQixjQUFKLENBQWtCNTJCLEtBQWxCLENBQVAsQ0FDRCxDQUVEOzs7O09BS0EsUUFBUzgyQixXQUFULEVBQXNCLENBRXJCLENBREM7QUFHRjs7Ozs7O09BT0EsUUFBU0YsY0FBVCxDQUF1QjUyQixLQUF2QixDQUE4QisyQixRQUE5QixDQUF3QyxDQUN0QyxLQUFLQyxXQUFMLENBQW1CaDNCLEtBQW5CLENBQ0EsS0FBS2kzQixXQUFMLENBQW1CLEVBQW5CLENBQ0EsS0FBS0MsU0FBTCxDQUFpQixDQUFDLENBQUNILFFBQW5CLENBQ0EsS0FBS0ksU0FBTCxDQUFpQixDQUFqQixDQUNBLEtBQUtDLFVBQUwsQ0FBa0JueEIsU0FBbEIsQ0FDRCxDQUVEOzs7Ozs7OztPQVNBd3dCLE9BQU9ZLGdCQUFQLENBQTBCLENBRXhCOzs7OztTQU1BLFNBQVV6UixRQVJjLENBVXhCOzs7OztTQU1BLFdBQVlDLFVBaEJZLENBa0J4Qjs7Ozs7U0FNQSxjQUFlQyxhQXhCUyxDQTBCeEI7Ozs7O1NBTUEsV0FBWSxFQWhDWSxDQWtDeEI7Ozs7O1NBTUEsVUFBVyxDQUVUOzs7OztXQU1BLElBQUsyUSxNQVJJLENBeENhLENBQTFCLENBb0RBO0FBQ0FBLE9BQU9sRSxTQUFQLENBQW1CdUUsV0FBV3ZFLFNBQTlCLENBQ0FrRSxPQUFPbEUsU0FBUCxDQUFpQjV4QixXQUFqQixDQUErQjgxQixNQUEvQixDQUVBRyxjQUFjckUsU0FBZCxDQUEwQitFLFdBQVdSLFdBQVd2RSxTQUF0QixDQUExQixDQUNBcUUsY0FBY3JFLFNBQWQsQ0FBd0I1eEIsV0FBeEIsQ0FBc0NpMkIsYUFBdEMsQ0FFQSw0RUFFQTs7Ozs7O09BT0EsUUFBU0QsWUFBVCxDQUFxQjMyQixLQUFyQixDQUE0QixDQUMxQixLQUFLZzNCLFdBQUwsQ0FBbUJoM0IsS0FBbkIsQ0FDQSxLQUFLaTNCLFdBQUwsQ0FBbUIsRUFBbkIsQ0FDQSxLQUFLTSxPQUFMLENBQWUsQ0FBZixDQUNBLEtBQUtDLFlBQUwsQ0FBb0IsS0FBcEIsQ0FDQSxLQUFLQyxhQUFMLENBQXFCLEVBQXJCLENBQ0EsS0FBS0MsYUFBTCxDQUFxQnZVLGdCQUFyQixDQUNBLEtBQUt3VSxTQUFMLENBQWlCLEVBQWpCLENBQ0QsQ0FFRDs7Ozs7OztPQVFBLFFBQVNDLFVBQVQsRUFBcUIsQ0FDbkIsR0FBSW5LLFFBQVMsR0FBSWtKLFlBQUosQ0FBZ0IsS0FBS0ssV0FBckIsQ0FBYixDQUNBdkosT0FBT3dKLFdBQVAsQ0FBcUJZLFVBQVUsS0FBS1osV0FBZixDQUFyQixDQUNBeEosT0FBTzhKLE9BQVAsQ0FBaUIsS0FBS0EsT0FBdEIsQ0FDQTlKLE9BQU8rSixZQUFQLENBQXNCLEtBQUtBLFlBQTNCLENBQ0EvSixPQUFPZ0ssYUFBUCxDQUF1QkksVUFBVSxLQUFLSixhQUFmLENBQXZCLENBQ0FoSyxPQUFPaUssYUFBUCxDQUF1QixLQUFLQSxhQUE1QixDQUNBakssT0FBT2tLLFNBQVAsQ0FBbUJFLFVBQVUsS0FBS0YsU0FBZixDQUFuQixDQUNBLE1BQU9sSyxPQUFQLENBQ0QsQ0FFRDs7Ozs7OztPQVFBLFFBQVNxSyxZQUFULEVBQXVCLENBQ3JCLEdBQUksS0FBS04sWUFBVCxDQUF1QixDQUNyQixHQUFJL0osUUFBUyxHQUFJa0osWUFBSixDQUFnQixJQUFoQixDQUFiLENBQ0FsSixPQUFPOEosT0FBUCxDQUFpQixDQUFDLENBQWxCLENBQ0E5SixPQUFPK0osWUFBUCxDQUFzQixJQUF0QixDQUNELENBSkQsSUFJTyxDQUNML0osT0FBUyxLQUFLc0ssS0FBTCxFQUFULENBQ0F0SyxPQUFPOEosT0FBUCxFQUFrQixDQUFDLENBQW5CLENBQ0QsQ0FDRCxNQUFPOUosT0FBUCxDQUNELENBRUQ7Ozs7Ozs7T0FRQSxRQUFTdUssVUFBVCxFQUFxQixDQUNuQixHQUFJakwsT0FBUSxLQUFLaUssV0FBTCxDQUFpQmgzQixLQUFqQixFQUFaLENBQ0lpNEIsSUFBTSxLQUFLVixPQURmLENBRUlXLE1BQVFwWixRQUFRaU8sS0FBUixDQUZaLENBR0lvTCxRQUFVRixJQUFNLENBSHBCLENBSUlHLFVBQVlGLE1BQVFuTCxNQUFNMW5CLE1BQWQsQ0FBdUIsQ0FKdkMsQ0FLSWd6QixLQUFPQyxRQUFRLENBQVIsQ0FBV0YsU0FBWCxDQUFzQixLQUFLVCxTQUEzQixDQUxYLENBTUlZLE1BQVFGLEtBQUtFLEtBTmpCLENBT0lDLElBQU1ILEtBQUtHLEdBUGYsQ0FRSW56QixPQUFTbXpCLElBQU1ELEtBUm5CLENBU0kzbkIsTUFBUXVuQixRQUFVSyxHQUFWLENBQWlCRCxNQUFRLENBVHJDLENBVUlFLFVBQVksS0FBS2hCLGFBVnJCLENBV0lpQixXQUFhRCxVQUFVcHpCLE1BWDNCLENBWUltb0IsU0FBVyxDQVpmLENBYUltTCxVQUFZM0QsVUFBVTN2QixNQUFWLENBQWtCLEtBQUtxeUIsYUFBdkIsQ0FiaEIsQ0FlQSxHQUFJLENBQUNRLEtBQUQsRUFBVUUsVUFBWTVXLGdCQUF0QixFQUNDNFcsV0FBYS95QixNQUFiLEVBQXVCc3pCLFdBQWF0ekIsTUFEekMsQ0FDa0QsQ0FDaEQsTUFBT3V6QixrQkFBaUI3TCxLQUFqQixDQUF3QixLQUFLa0ssV0FBN0IsQ0FBUCxDQUNELENBQ0QsR0FBSXhKLFFBQVMsRUFBYixDQUVBb0wsTUFDQSxNQUFPeHpCLFVBQVltb0IsU0FBV21MLFNBQTlCLENBQXlDLENBQ3ZDL25CLE9BQVNxbkIsR0FBVCxDQUVBLEdBQUlhLFdBQVksQ0FBQyxDQUFqQixDQUNJOTRCLE1BQVErc0IsTUFBTW5jLEtBQU4sQ0FEWixDQUdBLE1BQU8sRUFBRWtvQixTQUFGLENBQWNKLFVBQXJCLENBQWlDLENBQy9CLEdBQUloMkIsTUFBTysxQixVQUFVSyxTQUFWLENBQVgsQ0FDSTdMLFNBQVd2cUIsS0FBS3VxQixRQURwQixDQUVJL3RCLEtBQU93RCxLQUFLeEQsSUFGaEIsQ0FHSTY1QixTQUFXOUwsU0FBU2p0QixLQUFULENBSGYsQ0FLQSxHQUFJZCxNQUFRMmpCLGFBQVosQ0FBMkIsQ0FDekI3aUIsTUFBUSs0QixRQUFSLENBQ0QsQ0FGRCxJQUVPLElBQUksQ0FBQ0EsUUFBTCxDQUFlLENBQ3BCLEdBQUk3NUIsTUFBUTBqQixnQkFBWixDQUE4QixDQUM1QixRQUFTaVcsTUFBVCxDQUNELENBRkQsSUFFTyxDQUNMLEtBQU1BLE1BQU4sQ0FDRCxDQUNGLENBQ0YsQ0FDRHBMLE9BQU9ELFVBQVAsRUFBcUJ4dEIsS0FBckIsQ0FDRCxDQUNELE1BQU95dEIsT0FBUCxDQUNELENBRUQ7QUFDQWtKLFlBQVlwRSxTQUFaLENBQXdCK0UsV0FBV1IsV0FBV3ZFLFNBQXRCLENBQXhCLENBQ0FvRSxZQUFZcEUsU0FBWixDQUFzQjV4QixXQUF0QixDQUFvQ2cyQixXQUFwQyxDQUVBLDRFQUVBOzs7Ozs7T0FPQSxRQUFTcUMsS0FBVCxDQUFjQyxPQUFkLENBQXVCLENBQ3JCLEdBQUlyb0IsT0FBUSxDQUFDLENBQWIsQ0FDSXZMLE9BQVM0ekIsUUFBVUEsUUFBUTV6QixNQUFsQixDQUEyQixDQUR4QyxDQUdBLEtBQUtuQixLQUFMLEdBQ0EsTUFBTyxFQUFFME0sS0FBRixDQUFVdkwsTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSTZ6QixPQUFRRCxRQUFRcm9CLEtBQVIsQ0FBWixDQUNBLEtBQUs5USxHQUFMLENBQVNvNUIsTUFBTSxDQUFOLENBQVQsQ0FBbUJBLE1BQU0sQ0FBTixDQUFuQixFQUNELENBQ0YsQ0FFRDs7Ozs7O09BT0EsUUFBU0MsVUFBVCxFQUFxQixDQUNuQixLQUFLQyxRQUFMLENBQWdCMUQsYUFBZUEsYUFBYSxJQUFiLENBQWYsQ0FBb0MsRUFBcEQsQ0FDRCxDQUVEOzs7Ozs7Ozs7T0FVQSxRQUFTMkQsV0FBVCxDQUFvQnQ1QixHQUFwQixDQUF5QixDQUN2QixNQUFPLE1BQUtnd0IsR0FBTCxDQUFTaHdCLEdBQVQsR0FBaUIsTUFBTyxNQUFLcTVCLFFBQUwsQ0FBY3I1QixHQUFkLENBQS9CLENBQ0QsQ0FFRDs7Ozs7Ozs7T0FTQSxRQUFTdTVCLFFBQVQsQ0FBaUJ2NUIsR0FBakIsQ0FBc0IsQ0FDcEIsR0FBSTJDLE1BQU8sS0FBSzAyQixRQUFoQixDQUNBLEdBQUkxRCxZQUFKLENBQWtCLENBQ2hCLEdBQUlqSSxRQUFTL3FCLEtBQUszQyxHQUFMLENBQWIsQ0FDQSxNQUFPMHRCLFVBQVcvTCxjQUFYLENBQTRCemIsU0FBNUIsQ0FBd0N3bkIsTUFBL0MsQ0FDRCxDQUNELE1BQU91RixnQkFBZWpZLElBQWYsQ0FBb0JyWSxJQUFwQixDQUEwQjNDLEdBQTFCLEVBQWlDMkMsS0FBSzNDLEdBQUwsQ0FBakMsQ0FBNkNrRyxTQUFwRCxDQUNELENBRUQ7Ozs7Ozs7O09BU0EsUUFBU3N6QixRQUFULENBQWlCeDVCLEdBQWpCLENBQXNCLENBQ3BCLEdBQUkyQyxNQUFPLEtBQUswMkIsUUFBaEIsQ0FDQSxNQUFPMUQsY0FBZWh6QixLQUFLM0MsR0FBTCxJQUFja0csU0FBN0IsQ0FBeUMrc0IsZUFBZWpZLElBQWYsQ0FBb0JyWSxJQUFwQixDQUEwQjNDLEdBQTFCLENBQWhELENBQ0QsQ0FFRDs7Ozs7Ozs7O09BVUEsUUFBU3k1QixRQUFULENBQWlCejVCLEdBQWpCLENBQXNCQyxLQUF0QixDQUE2QixDQUMzQixHQUFJMEMsTUFBTyxLQUFLMDJCLFFBQWhCLENBQ0ExMkIsS0FBSzNDLEdBQUwsRUFBYTIxQixjQUFnQjExQixRQUFVaUcsU0FBM0IsQ0FBd0N5YixjQUF4QyxDQUF5RDFoQixLQUFyRSxDQUNBLE1BQU8sS0FBUCxDQUNELENBRUQ7QUFDQWc1QixLQUFLekcsU0FBTCxDQUFlcnVCLEtBQWYsQ0FBdUJpMUIsU0FBdkIsQ0FDQUgsS0FBS3pHLFNBQUwsQ0FBZSxRQUFmLEVBQTJCOEcsVUFBM0IsQ0FDQUwsS0FBS3pHLFNBQUwsQ0FBZTd5QixHQUFmLENBQXFCNDVCLE9BQXJCLENBQ0FOLEtBQUt6RyxTQUFMLENBQWV4QyxHQUFmLENBQXFCd0osT0FBckIsQ0FDQVAsS0FBS3pHLFNBQUwsQ0FBZXp5QixHQUFmLENBQXFCMDVCLE9BQXJCLENBRUEsNEVBRUE7Ozs7OztPQU9BLFFBQVNDLFVBQVQsQ0FBbUJSLE9BQW5CLENBQTRCLENBQzFCLEdBQUlyb0IsT0FBUSxDQUFDLENBQWIsQ0FDSXZMLE9BQVM0ekIsUUFBVUEsUUFBUTV6QixNQUFsQixDQUEyQixDQUR4QyxDQUdBLEtBQUtuQixLQUFMLEdBQ0EsTUFBTyxFQUFFME0sS0FBRixDQUFVdkwsTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSTZ6QixPQUFRRCxRQUFRcm9CLEtBQVIsQ0FBWixDQUNBLEtBQUs5USxHQUFMLENBQVNvNUIsTUFBTSxDQUFOLENBQVQsQ0FBbUJBLE1BQU0sQ0FBTixDQUFuQixFQUNELENBQ0YsQ0FFRDs7Ozs7O09BT0EsUUFBU1EsZUFBVCxFQUEwQixDQUN4QixLQUFLTixRQUFMLENBQWdCLEVBQWhCLENBQ0QsQ0FFRDs7Ozs7Ozs7T0FTQSxRQUFTTyxnQkFBVCxDQUF5QjU1QixHQUF6QixDQUE4QixDQUM1QixHQUFJMkMsTUFBTyxLQUFLMDJCLFFBQWhCLENBQ0l4b0IsTUFBUWdwQixhQUFhbDNCLElBQWIsQ0FBbUIzQyxHQUFuQixDQURaLENBR0EsR0FBSTZRLE1BQVEsQ0FBWixDQUFlLENBQ2IsTUFBTyxNQUFQLENBQ0QsQ0FDRCxHQUFJbWhCLFdBQVlydkIsS0FBSzJDLE1BQUwsQ0FBYyxDQUE5QixDQUNBLEdBQUl1TCxPQUFTbWhCLFNBQWIsQ0FBd0IsQ0FDdEJydkIsS0FBS20zQixHQUFMLEdBQ0QsQ0FGRCxJQUVPLENBQ0wvWixPQUFPL0UsSUFBUCxDQUFZclksSUFBWixDQUFrQmtPLEtBQWxCLENBQXlCLENBQXpCLEVBQ0QsQ0FDRCxNQUFPLEtBQVAsQ0FDRCxDQUVEOzs7Ozs7OztPQVNBLFFBQVNrcEIsYUFBVCxDQUFzQi81QixHQUF0QixDQUEyQixDQUN6QixHQUFJMkMsTUFBTyxLQUFLMDJCLFFBQWhCLENBQ0l4b0IsTUFBUWdwQixhQUFhbDNCLElBQWIsQ0FBbUIzQyxHQUFuQixDQURaLENBR0EsTUFBTzZRLE9BQVEsQ0FBUixDQUFZM0ssU0FBWixDQUF3QnZELEtBQUtrTyxLQUFMLEVBQVksQ0FBWixDQUEvQixDQUNELENBRUQ7Ozs7Ozs7O09BU0EsUUFBU21wQixhQUFULENBQXNCaDZCLEdBQXRCLENBQTJCLENBQ3pCLE1BQU82NUIsY0FBYSxLQUFLUixRQUFsQixDQUE0QnI1QixHQUE1QixFQUFtQyxDQUFDLENBQTNDLENBQ0QsQ0FFRDs7Ozs7Ozs7O09BVUEsUUFBU2k2QixhQUFULENBQXNCajZCLEdBQXRCLENBQTJCQyxLQUEzQixDQUFrQyxDQUNoQyxHQUFJMEMsTUFBTyxLQUFLMDJCLFFBQWhCLENBQ0l4b0IsTUFBUWdwQixhQUFhbDNCLElBQWIsQ0FBbUIzQyxHQUFuQixDQURaLENBR0EsR0FBSTZRLE1BQVEsQ0FBWixDQUFlLENBQ2JsTyxLQUFLb0csSUFBTCxDQUFVLENBQUMvSSxHQUFELENBQU1DLEtBQU4sQ0FBVixFQUNELENBRkQsSUFFTyxDQUNMMEMsS0FBS2tPLEtBQUwsRUFBWSxDQUFaLEVBQWlCNVEsS0FBakIsQ0FDRCxDQUNELE1BQU8sS0FBUCxDQUNELENBRUQ7QUFDQXk1QixVQUFVbEgsU0FBVixDQUFvQnJ1QixLQUFwQixDQUE0QncxQixjQUE1QixDQUNBRCxVQUFVbEgsU0FBVixDQUFvQixRQUFwQixFQUFnQ29ILGVBQWhDLENBQ0FGLFVBQVVsSCxTQUFWLENBQW9CN3lCLEdBQXBCLENBQTBCbzZCLFlBQTFCLENBQ0FMLFVBQVVsSCxTQUFWLENBQW9CeEMsR0FBcEIsQ0FBMEJnSyxZQUExQixDQUNBTixVQUFVbEgsU0FBVixDQUFvQnp5QixHQUFwQixDQUEwQms2QixZQUExQixDQUVBLDRFQUVBOzs7Ozs7T0FPQSxRQUFTQyxTQUFULENBQWtCaEIsT0FBbEIsQ0FBMkIsQ0FDekIsR0FBSXJvQixPQUFRLENBQUMsQ0FBYixDQUNJdkwsT0FBUzR6QixRQUFVQSxRQUFRNXpCLE1BQWxCLENBQTJCLENBRHhDLENBR0EsS0FBS25CLEtBQUwsR0FDQSxNQUFPLEVBQUUwTSxLQUFGLENBQVV2TCxNQUFqQixDQUF5QixDQUN2QixHQUFJNnpCLE9BQVFELFFBQVFyb0IsS0FBUixDQUFaLENBQ0EsS0FBSzlRLEdBQUwsQ0FBU281QixNQUFNLENBQU4sQ0FBVCxDQUFtQkEsTUFBTSxDQUFOLENBQW5CLEVBQ0QsQ0FDRixDQUVEOzs7Ozs7T0FPQSxRQUFTZ0IsY0FBVCxFQUF5QixDQUN2QixLQUFLZCxRQUFMLENBQWdCLENBQ2QsT0FBUSxHQUFJSixLQUFKLEVBRE0sQ0FFZCxNQUFPLElBQUt6RCxLQUFPa0UsU0FBWixHQUZPLENBR2QsU0FBVSxHQUFJVCxLQUFKLEVBSEksQ0FBaEIsQ0FLRCxDQUVEOzs7Ozs7OztPQVNBLFFBQVNtQixlQUFULENBQXdCcDZCLEdBQXhCLENBQTZCLENBQzNCLE1BQU9xNkIsWUFBVyxJQUFYLENBQWlCcjZCLEdBQWpCLEVBQXNCLFFBQXRCLEVBQWdDQSxHQUFoQyxDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7T0FTQSxRQUFTczZCLFlBQVQsQ0FBcUJ0NkIsR0FBckIsQ0FBMEIsQ0FDeEIsTUFBT3E2QixZQUFXLElBQVgsQ0FBaUJyNkIsR0FBakIsRUFBc0JMLEdBQXRCLENBQTBCSyxHQUExQixDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7T0FTQSxRQUFTdTZCLFlBQVQsQ0FBcUJ2NkIsR0FBckIsQ0FBMEIsQ0FDeEIsTUFBT3E2QixZQUFXLElBQVgsQ0FBaUJyNkIsR0FBakIsRUFBc0Jnd0IsR0FBdEIsQ0FBMEJod0IsR0FBMUIsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7OztPQVVBLFFBQVN3NkIsWUFBVCxDQUFxQng2QixHQUFyQixDQUEwQkMsS0FBMUIsQ0FBaUMsQ0FDL0JvNkIsV0FBVyxJQUFYLENBQWlCcjZCLEdBQWpCLEVBQXNCRCxHQUF0QixDQUEwQkMsR0FBMUIsQ0FBK0JDLEtBQS9CLEVBQ0EsTUFBTyxLQUFQLENBQ0QsQ0FFRDtBQUNBaTZCLFNBQVMxSCxTQUFULENBQW1CcnVCLEtBQW5CLENBQTJCZzJCLGFBQTNCLENBQ0FELFNBQVMxSCxTQUFULENBQW1CLFFBQW5CLEVBQStCNEgsY0FBL0IsQ0FDQUYsU0FBUzFILFNBQVQsQ0FBbUI3eUIsR0FBbkIsQ0FBeUIyNkIsV0FBekIsQ0FDQUosU0FBUzFILFNBQVQsQ0FBbUJ4QyxHQUFuQixDQUF5QnVLLFdBQXpCLENBQ0FMLFNBQVMxSCxTQUFULENBQW1CenlCLEdBQW5CLENBQXlCeTZCLFdBQXpCLENBRUEsNEVBRUE7Ozs7Ozs7T0FRQSxRQUFTQyxTQUFULENBQWtCM2YsTUFBbEIsQ0FBMEIsQ0FDeEIsR0FBSWpLLE9BQVEsQ0FBQyxDQUFiLENBQ0l2TCxPQUFTd1YsT0FBU0EsT0FBT3hWLE1BQWhCLENBQXlCLENBRHRDLENBR0EsS0FBSyt6QixRQUFMLENBQWdCLEdBQUlhLFNBQUosRUFBaEIsQ0FDQSxNQUFPLEVBQUVycEIsS0FBRixDQUFVdkwsTUFBakIsQ0FBeUIsQ0FDdkIsS0FBS3FuQixHQUFMLENBQVM3UixPQUFPakssS0FBUCxDQUFULEVBQ0QsQ0FDRixDQUVEOzs7Ozs7Ozs7T0FVQSxRQUFTNnBCLFlBQVQsQ0FBcUJ6NkIsS0FBckIsQ0FBNEIsQ0FDMUIsS0FBS281QixRQUFMLENBQWN0NUIsR0FBZCxDQUFrQkUsS0FBbEIsQ0FBeUIwaEIsY0FBekIsRUFDQSxNQUFPLEtBQVAsQ0FDRCxDQUVEOzs7Ozs7OztPQVNBLFFBQVNnWixZQUFULENBQXFCMTZCLEtBQXJCLENBQTRCLENBQzFCLE1BQU8sTUFBS281QixRQUFMLENBQWNySixHQUFkLENBQWtCL3ZCLEtBQWxCLENBQVAsQ0FDRCxDQUVEO0FBQ0F3NkIsU0FBU2pJLFNBQVQsQ0FBbUI3RixHQUFuQixDQUF5QjhOLFNBQVNqSSxTQUFULENBQW1CenBCLElBQW5CLENBQTBCMnhCLFdBQW5ELENBQ0FELFNBQVNqSSxTQUFULENBQW1CeEMsR0FBbkIsQ0FBeUIySyxXQUF6QixDQUVBLDRFQUVBOzs7Ozs7T0FPQSxRQUFTQyxNQUFULENBQWUxQixPQUFmLENBQXdCLENBQ3RCLEtBQUtHLFFBQUwsQ0FBZ0IsR0FBSUssVUFBSixDQUFjUixPQUFkLENBQWhCLENBQ0QsQ0FFRDs7Ozs7O09BT0EsUUFBUzJCLFdBQVQsRUFBc0IsQ0FDcEIsS0FBS3hCLFFBQUwsQ0FBZ0IsR0FBSUssVUFBSixFQUFoQixDQUNELENBRUQ7Ozs7Ozs7O09BU0EsUUFBU29CLFlBQVQsQ0FBcUI5NkIsR0FBckIsQ0FBMEIsQ0FDeEIsTUFBTyxNQUFLcTVCLFFBQUwsQ0FBYyxRQUFkLEVBQXdCcjVCLEdBQXhCLENBQVAsQ0FDRCxDQUVEOzs7Ozs7OztPQVNBLFFBQVMrNkIsU0FBVCxDQUFrQi82QixHQUFsQixDQUF1QixDQUNyQixNQUFPLE1BQUtxNUIsUUFBTCxDQUFjMTVCLEdBQWQsQ0FBa0JLLEdBQWxCLENBQVAsQ0FDRCxDQUVEOzs7Ozs7OztPQVNBLFFBQVNnN0IsU0FBVCxDQUFrQmg3QixHQUFsQixDQUF1QixDQUNyQixNQUFPLE1BQUtxNUIsUUFBTCxDQUFjckosR0FBZCxDQUFrQmh3QixHQUFsQixDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7O09BVUEsUUFBU2k3QixTQUFULENBQWtCajdCLEdBQWxCLENBQXVCQyxLQUF2QixDQUE4QixDQUM1QixHQUFJOHZCLE9BQVEsS0FBS3NKLFFBQWpCLENBQ0EsR0FBSXRKLGdCQUFpQjJKLFVBQXJCLENBQWdDLENBQzlCLEdBQUl3QixPQUFRbkwsTUFBTXNKLFFBQWxCLENBQ0EsR0FBSSxDQUFDN0QsR0FBRCxFQUFTMEYsTUFBTTUxQixNQUFOLENBQWVtYyxpQkFBbUIsQ0FBL0MsQ0FBbUQsQ0FDakR5WixNQUFNbnlCLElBQU4sQ0FBVyxDQUFDL0ksR0FBRCxDQUFNQyxLQUFOLENBQVgsRUFDQSxNQUFPLEtBQVAsQ0FDRCxDQUNEOHZCLE1BQVEsS0FBS3NKLFFBQUwsQ0FBZ0IsR0FBSWEsU0FBSixDQUFhZ0IsS0FBYixDQUF4QixDQUNELENBQ0RuTCxNQUFNaHdCLEdBQU4sQ0FBVUMsR0FBVixDQUFlQyxLQUFmLEVBQ0EsTUFBTyxLQUFQLENBQ0QsQ0FFRDtBQUNBMjZCLE1BQU1wSSxTQUFOLENBQWdCcnVCLEtBQWhCLENBQXdCMDJCLFVBQXhCLENBQ0FELE1BQU1wSSxTQUFOLENBQWdCLFFBQWhCLEVBQTRCc0ksV0FBNUIsQ0FDQUYsTUFBTXBJLFNBQU4sQ0FBZ0I3eUIsR0FBaEIsQ0FBc0JvN0IsUUFBdEIsQ0FDQUgsTUFBTXBJLFNBQU4sQ0FBZ0J4QyxHQUFoQixDQUFzQmdMLFFBQXRCLENBQ0FKLE1BQU1wSSxTQUFOLENBQWdCenlCLEdBQWhCLENBQXNCazdCLFFBQXRCLENBRUEsNEVBRUE7Ozs7Ozs7T0FRQSxRQUFTRSxjQUFULENBQXVCbDdCLEtBQXZCLENBQThCbTdCLFNBQTlCLENBQXlDLENBQ3ZDO0FBQ0E7QUFDQSxHQUFJMU4sUUFBVTNPLFFBQVE5ZSxLQUFSLEdBQWtCbzdCLFlBQVlwN0IsS0FBWixDQUFuQixDQUNUdXZCLFVBQVV2dkIsTUFBTXFGLE1BQWhCLENBQXdCekUsTUFBeEIsQ0FEUyxDQUVULEVBRkosQ0FJQSxHQUFJeUUsUUFBU29vQixPQUFPcG9CLE1BQXBCLENBQ0lnMkIsWUFBYyxDQUFDLENBQUNoMkIsTUFEcEIsQ0FHQSxJQUFLLEdBQUl0RixJQUFULEdBQWdCQyxNQUFoQixDQUF1QixDQUNyQixHQUFJLENBQUNtN0IsV0FBYW5JLGVBQWVqWSxJQUFmLENBQW9CL2EsS0FBcEIsQ0FBMkJELEdBQTNCLENBQWQsR0FDQSxFQUFFczdCLGNBQWdCdDdCLEtBQU8sUUFBUCxFQUFtQnU3QixRQUFRdjdCLEdBQVIsQ0FBYXNGLE1BQWIsQ0FBbkMsQ0FBRixDQURKLENBQ2lFLENBQy9Eb29CLE9BQU8za0IsSUFBUCxDQUFZL0ksR0FBWixFQUNELENBQ0YsQ0FDRCxNQUFPMHRCLE9BQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7T0FVQSxRQUFTOE4saUJBQVQsQ0FBMEJDLFFBQTFCLENBQW9DQyxRQUFwQyxDQUE4QzE3QixHQUE5QyxDQUFtRG12QixNQUFuRCxDQUEyRCxDQUN6RCxHQUFJc00sV0FBYXYxQixTQUFiLEVBQ0N5MUIsR0FBR0YsUUFBSCxDQUFhL0ksWUFBWTF5QixHQUFaLENBQWIsR0FBa0MsQ0FBQ2l6QixlQUFlalksSUFBZixDQUFvQm1VLE1BQXBCLENBQTRCbnZCLEdBQTVCLENBRHhDLENBQzJFLENBQ3pFLE1BQU8wN0IsU0FBUCxDQUNELENBQ0QsTUFBT0QsU0FBUCxDQUNELENBRUQ7Ozs7Ozs7O09BU0EsUUFBU0csaUJBQVQsQ0FBMEJ6TSxNQUExQixDQUFrQ252QixHQUFsQyxDQUF1Q0MsS0FBdkMsQ0FBOEMsQ0FDNUMsR0FBS0EsUUFBVWlHLFNBQVYsRUFBdUIsQ0FBQ3kxQixHQUFHeE0sT0FBT252QixHQUFQLENBQUgsQ0FBZ0JDLEtBQWhCLENBQXpCLEVBQ0MsTUFBT0QsSUFBUCxFQUFjLFFBQWQsRUFBMEJDLFFBQVVpRyxTQUFwQyxFQUFpRCxFQUFFbEcsTUFBT212QixPQUFULENBRHRELENBQ3lFLENBQ3ZFQSxPQUFPbnZCLEdBQVAsRUFBY0MsS0FBZCxDQUNELENBQ0YsQ0FFRDs7Ozs7Ozs7O09BVUEsUUFBUzQ3QixZQUFULENBQXFCMU0sTUFBckIsQ0FBNkJudkIsR0FBN0IsQ0FBa0NDLEtBQWxDLENBQXlDLENBQ3ZDLEdBQUl3N0IsVUFBV3RNLE9BQU9udkIsR0FBUCxDQUFmLENBQ0EsR0FBSSxFQUFFaXpCLGVBQWVqWSxJQUFmLENBQW9CbVUsTUFBcEIsQ0FBNEJudkIsR0FBNUIsR0FBb0MyN0IsR0FBR0YsUUFBSCxDQUFheDdCLEtBQWIsQ0FBdEMsR0FDQ0EsUUFBVWlHLFNBQVYsRUFBdUIsRUFBRWxHLE1BQU9tdkIsT0FBVCxDQUQ1QixDQUMrQyxDQUM3Q0EsT0FBT252QixHQUFQLEVBQWNDLEtBQWQsQ0FDRCxDQUNGLENBRUQ7Ozs7Ozs7T0FRQSxRQUFTNDVCLGFBQVQsQ0FBc0I3TSxLQUF0QixDQUE2Qmh0QixHQUE3QixDQUFrQyxDQUNoQyxHQUFJc0YsUUFBUzBuQixNQUFNMW5CLE1BQW5CLENBQ0EsTUFBT0EsUUFBUCxDQUFpQixDQUNmLEdBQUlxMkIsR0FBRzNPLE1BQU0xbkIsTUFBTixFQUFjLENBQWQsQ0FBSCxDQUFxQnRGLEdBQXJCLENBQUosQ0FBK0IsQ0FDN0IsTUFBT3NGLE9BQVAsQ0FDRCxDQUNGLENBQ0QsTUFBTyxDQUFDLENBQVIsQ0FDRCxDQUVEOzs7Ozs7Ozs7O09BV0EsUUFBU3cyQixlQUFULENBQXdCcE4sVUFBeEIsQ0FBb0N6QixNQUFwQyxDQUE0Q0MsUUFBNUMsQ0FBc0RDLFdBQXRELENBQW1FLENBQ2pFNE8sU0FBU3JOLFVBQVQsQ0FBcUIsU0FBU3p1QixLQUFULENBQWdCRCxHQUFoQixDQUFxQjB1QixVQUFyQixDQUFpQyxDQUNwRHpCLE9BQU9FLFdBQVAsQ0FBb0JsdEIsS0FBcEIsQ0FBMkJpdEIsU0FBU2p0QixLQUFULENBQTNCLENBQTRDeXVCLFVBQTVDLEVBQ0QsQ0FGRCxFQUdBLE1BQU92QixZQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7T0FTQSxRQUFTNk8sV0FBVCxDQUFvQjdNLE1BQXBCLENBQTRCeEosTUFBNUIsQ0FBb0MsQ0FDbEMsTUFBT3dKLFNBQVU4TSxXQUFXdFcsTUFBWCxDQUFtQm1OLEtBQUtuTixNQUFMLENBQW5CLENBQWlDd0osTUFBakMsQ0FBakIsQ0FDRCxDQUVEOzs7Ozs7O09BUUEsUUFBUytNLE9BQVQsQ0FBZ0IvTSxNQUFoQixDQUF3QmdOLEtBQXhCLENBQStCLENBQzdCLEdBQUl0ckIsT0FBUSxDQUFDLENBQWIsQ0FDSXVyQixNQUFRak4sUUFBVSxJQUR0QixDQUVJN3BCLE9BQVM2MkIsTUFBTTcyQixNQUZuQixDQUdJb29CLE9BQVM5YyxNQUFNdEwsTUFBTixDQUhiLENBS0EsTUFBTyxFQUFFdUwsS0FBRixDQUFVdkwsTUFBakIsQ0FBeUIsQ0FDdkJvb0IsT0FBTzdjLEtBQVAsRUFBZ0J1ckIsTUFBUWwyQixTQUFSLENBQW9CdkcsSUFBSXd2QixNQUFKLENBQVlnTixNQUFNdHJCLEtBQU4sQ0FBWixDQUFwQyxDQUNELENBQ0QsTUFBTzZjLE9BQVAsQ0FDRCxDQUVEOzs7Ozs7OztPQVNBLFFBQVMyTyxVQUFULENBQW1CQyxNQUFuQixDQUEyQkMsS0FBM0IsQ0FBa0NDLEtBQWxDLENBQXlDLENBQ3ZDLEdBQUlGLFNBQVdBLE1BQWYsQ0FBdUIsQ0FDckIsR0FBSUUsUUFBVXQyQixTQUFkLENBQXlCLENBQ3ZCbzJCLE9BQVNBLFFBQVVFLEtBQVYsQ0FBa0JGLE1BQWxCLENBQTJCRSxLQUFwQyxDQUNELENBQ0QsR0FBSUQsUUFBVXIyQixTQUFkLENBQXlCLENBQ3ZCbzJCLE9BQVNBLFFBQVVDLEtBQVYsQ0FBa0JELE1BQWxCLENBQTJCQyxLQUFwQyxDQUNELENBQ0YsQ0FDRCxNQUFPRCxPQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7OztPQWNBLFFBQVNHLFVBQVQsQ0FBbUJ4OEIsS0FBbkIsQ0FBMEJ5OEIsTUFBMUIsQ0FBa0NDLE1BQWxDLENBQTBDQyxVQUExQyxDQUFzRDU4QixHQUF0RCxDQUEyRG12QixNQUEzRCxDQUFtRXR3QixLQUFuRSxDQUEwRSxDQUN4RSxHQUFJNnVCLE9BQUosQ0FDQSxHQUFJa1AsVUFBSixDQUFnQixDQUNkbFAsT0FBU3lCLE9BQVN5TixXQUFXMzhCLEtBQVgsQ0FBa0JELEdBQWxCLENBQXVCbXZCLE1BQXZCLENBQStCdHdCLEtBQS9CLENBQVQsQ0FBaUQrOUIsV0FBVzM4QixLQUFYLENBQTFELENBQ0QsQ0FDRCxHQUFJeXRCLFNBQVd4bkIsU0FBZixDQUEwQixDQUN4QixNQUFPd25CLE9BQVAsQ0FDRCxDQUNELEdBQUksQ0FBQ21QLFNBQVM1OEIsS0FBVCxDQUFMLENBQXNCLENBQ3BCLE1BQU9BLE1BQVAsQ0FDRCxDQUNELEdBQUlrNEIsT0FBUXBaLFFBQVE5ZSxLQUFSLENBQVosQ0FDQSxHQUFJazRCLEtBQUosQ0FBVyxDQUNUekssT0FBU29QLGVBQWU3OEIsS0FBZixDQUFULENBQ0EsR0FBSSxDQUFDeThCLE1BQUwsQ0FBYSxDQUNYLE1BQU81RSxXQUFVNzNCLEtBQVYsQ0FBaUJ5dEIsTUFBakIsQ0FBUCxDQUNELENBQ0YsQ0FMRCxJQUtPLENBQ0wsR0FBSXJYLEtBQU0wbUIsT0FBTzk4QixLQUFQLENBQVYsQ0FDSSs4QixPQUFTM21CLEtBQU93TixPQUFQLEVBQWtCeE4sS0FBT3lOLE1BRHRDLENBR0EsR0FBSTZRLFNBQVMxMEIsS0FBVCxDQUFKLENBQXFCLENBQ25CLE1BQU9nOUIsYUFBWWg5QixLQUFaLENBQW1CeThCLE1BQW5CLENBQVAsQ0FDRCxDQUNELEdBQUlybUIsS0FBTzROLFNBQVAsRUFBb0I1TixLQUFPbU4sT0FBM0IsRUFBdUN3WixRQUFVLENBQUM3TixNQUF0RCxDQUErRCxDQUM3RCxHQUFJMkIsYUFBYTd3QixLQUFiLENBQUosQ0FBeUIsQ0FDdkIsTUFBT2t2QixRQUFTbHZCLEtBQVQsQ0FBaUIsRUFBeEIsQ0FDRCxDQUNEeXRCLE9BQVN3UCxnQkFBZ0JGLE9BQVMsRUFBVCxDQUFjLzhCLEtBQTlCLENBQVQsQ0FDQSxHQUFJLENBQUN5OEIsTUFBTCxDQUFhLENBQ1gsTUFBT1MsYUFBWWw5QixLQUFaLENBQW1CKzdCLFdBQVd0TyxNQUFYLENBQW1CenRCLEtBQW5CLENBQW5CLENBQVAsQ0FDRCxDQUNGLENBUkQsSUFRTyxDQUNMLEdBQUksQ0FBQ3NxQixjQUFjbFUsR0FBZCxDQUFMLENBQXlCLENBQ3ZCLE1BQU84WSxRQUFTbHZCLEtBQVQsQ0FBaUIsRUFBeEIsQ0FDRCxDQUNEeXRCLE9BQVMwUCxlQUFlbjlCLEtBQWYsQ0FBc0JvVyxHQUF0QixDQUEyQm9tQixTQUEzQixDQUFzQ0MsTUFBdEMsQ0FBVCxDQUNELENBQ0YsQ0FDRDtBQUNBNzlCLFFBQVVBLE1BQVEsR0FBSSs3QixNQUFKLEVBQWxCLEVBQ0EsR0FBSXlDLFNBQVV4K0IsTUFBTWMsR0FBTixDQUFVTSxLQUFWLENBQWQsQ0FDQSxHQUFJbzlCLE9BQUosQ0FBYSxDQUNYLE1BQU9BLFFBQVAsQ0FDRCxDQUNEeCtCLE1BQU1rQixHQUFOLENBQVVFLEtBQVYsQ0FBaUJ5dEIsTUFBakIsRUFFQSxHQUFJLENBQUN5SyxLQUFMLENBQVksQ0FDVixHQUFJeEksT0FBUWdOLE9BQVNXLFdBQVdyOUIsS0FBWCxDQUFULENBQTZCNnlCLEtBQUs3eUIsS0FBTCxDQUF6QyxDQUNELENBQ0RtdEIsVUFBVXVDLE9BQVMxdkIsS0FBbkIsQ0FBMEIsU0FBU3M5QixRQUFULENBQW1CdjlCLEdBQW5CLENBQXdCLENBQ2hELEdBQUkydkIsS0FBSixDQUFXLENBQ1QzdkIsSUFBTXU5QixRQUFOLENBQ0FBLFNBQVd0OUIsTUFBTUQsR0FBTixDQUFYLENBQ0QsQ0FDRDtBQUNBNjdCLFlBQVluTyxNQUFaLENBQW9CMXRCLEdBQXBCLENBQXlCeThCLFVBQVVjLFFBQVYsQ0FBb0JiLE1BQXBCLENBQTRCQyxNQUE1QixDQUFvQ0MsVUFBcEMsQ0FBZ0Q1OEIsR0FBaEQsQ0FBcURDLEtBQXJELENBQTREcEIsS0FBNUQsQ0FBekIsRUFDRCxDQVBELEVBUUEsTUFBTzZ1QixPQUFQLENBQ0QsQ0FFRDs7Ozs7O09BT0EsUUFBUzhQLGFBQVQsQ0FBc0I3WCxNQUF0QixDQUE4QixDQUM1QixHQUFJZ0ssT0FBUW1ELEtBQUtuTixNQUFMLENBQVosQ0FDQSxNQUFPLFVBQVN3SixNQUFULENBQWlCLENBQ3RCLE1BQU9zTyxnQkFBZXRPLE1BQWYsQ0FBdUJ4SixNQUF2QixDQUErQmdLLEtBQS9CLENBQVAsQ0FDRCxDQUZELENBR0QsQ0FFRDs7Ozs7OztPQVFBLFFBQVM4TixlQUFULENBQXdCdE8sTUFBeEIsQ0FBZ0N4SixNQUFoQyxDQUF3Q2dLLEtBQXhDLENBQStDLENBQzdDLEdBQUlycUIsUUFBU3FxQixNQUFNcnFCLE1BQW5CLENBQ0EsR0FBSTZwQixRQUFVLElBQWQsQ0FBb0IsQ0FDbEIsTUFBTyxDQUFDN3BCLE1BQVIsQ0FDRCxDQUNENnBCLE9BQVM1aUIsT0FBTzRpQixNQUFQLENBQVQsQ0FDQSxNQUFPN3BCLFFBQVAsQ0FBaUIsQ0FDZixHQUFJdEYsS0FBTTJ2QixNQUFNcnFCLE1BQU4sQ0FBVixDQUNJaW9CLFVBQVk1SCxPQUFPM2xCLEdBQVAsQ0FEaEIsQ0FFSUMsTUFBUWt2QixPQUFPbnZCLEdBQVAsQ0FGWixDQUlBLEdBQUtDLFFBQVVpRyxTQUFWLEVBQXVCLEVBQUVsRyxNQUFPbXZCLE9BQVQsQ0FBeEIsRUFBNkMsQ0FBQzVCLFVBQVV0dEIsS0FBVixDQUFsRCxDQUFvRSxDQUNsRSxNQUFPLE1BQVAsQ0FDRCxDQUNGLENBQ0QsTUFBTyxLQUFQLENBQ0QsQ0FFRDs7Ozs7OztPQVFBLFFBQVNzM0IsV0FBVCxDQUFvQm1HLEtBQXBCLENBQTJCLENBQ3pCLE1BQU9iLFVBQVNhLEtBQVQsRUFBa0I3SixhQUFhNkosS0FBYixDQUFsQixDQUF3QyxFQUEvQyxDQUNELENBRUQ7Ozs7Ozs7OztPQVVBLFFBQVNDLFVBQVQsQ0FBbUIvUSxJQUFuQixDQUF5QmdSLElBQXpCLENBQStCOVEsSUFBL0IsQ0FBcUMsQ0FDbkMsR0FBSSxNQUFPRixLQUFQLEVBQWUsVUFBbkIsQ0FBK0IsQ0FDN0IsS0FBTSxJQUFJMEYsVUFBSixDQUFjNVEsZUFBZCxDQUFOLENBQ0QsQ0FDRCxNQUFPeGQsWUFBVyxVQUFXLENBQUUwb0IsS0FBSzlMLEtBQUwsQ0FBVzVhLFNBQVgsQ0FBc0I0bUIsSUFBdEIsRUFBOEIsQ0FBdEQsQ0FBd0Q4USxJQUF4RCxDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7OztPQVdBLFFBQVNDLGVBQVQsQ0FBd0I3USxLQUF4QixDQUErQmxTLE1BQS9CLENBQXVDb1MsUUFBdkMsQ0FBaURZLFVBQWpELENBQTZELENBQzNELEdBQUlqZCxPQUFRLENBQUMsQ0FBYixDQUNJaXRCLFNBQVduUSxhQURmLENBRUlvUSxTQUFXLElBRmYsQ0FHSXo0QixPQUFTMG5CLE1BQU0xbkIsTUFIbkIsQ0FJSW9vQixPQUFTLEVBSmIsQ0FLSXNRLGFBQWVsakIsT0FBT3hWLE1BTDFCLENBT0EsR0FBSSxDQUFDQSxNQUFMLENBQWEsQ0FDWCxNQUFPb29CLE9BQVAsQ0FDRCxDQUNELEdBQUlSLFFBQUosQ0FBYyxDQUNacFMsT0FBU2lULFNBQVNqVCxNQUFULENBQWlCOFUsVUFBVTFDLFFBQVYsQ0FBakIsQ0FBVCxDQUNELENBQ0QsR0FBSVksVUFBSixDQUFnQixDQUNkZ1EsU0FBV2pRLGlCQUFYLENBQ0FrUSxTQUFXLEtBQVgsQ0FDRCxDQUhELElBSUssSUFBSWpqQixPQUFPeFYsTUFBUCxFQUFpQm1jLGdCQUFyQixDQUF1QyxDQUMxQ3FjLFNBQVdoTyxRQUFYLENBQ0FpTyxTQUFXLEtBQVgsQ0FDQWpqQixPQUFTLEdBQUkyZixTQUFKLENBQWEzZixNQUFiLENBQVQsQ0FDRCxDQUNEZ2UsTUFDQSxNQUFPLEVBQUVqb0IsS0FBRixDQUFVdkwsTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSXJGLE9BQVErc0IsTUFBTW5jLEtBQU4sQ0FBWixDQUNJbW9CLFNBQVc5TCxTQUFXQSxTQUFTanRCLEtBQVQsQ0FBWCxDQUE2QkEsS0FENUMsQ0FHQUEsTUFBUzZ0QixZQUFjN3RCLFFBQVUsQ0FBekIsQ0FBOEJBLEtBQTlCLENBQXNDLENBQTlDLENBQ0EsR0FBSTg5QixVQUFZL0UsV0FBYUEsUUFBN0IsQ0FBdUMsQ0FDckMsR0FBSWlGLGFBQWNELFlBQWxCLENBQ0EsTUFBT0MsYUFBUCxDQUFzQixDQUNwQixHQUFJbmpCLE9BQU9takIsV0FBUCxJQUF3QmpGLFFBQTVCLENBQXNDLENBQ3BDLFFBQVNGLE1BQVQsQ0FDRCxDQUNGLENBQ0RwTCxPQUFPM2tCLElBQVAsQ0FBWTlJLEtBQVosRUFDRCxDQVJELElBU0ssSUFBSSxDQUFDNjlCLFNBQVNoakIsTUFBVCxDQUFpQmtlLFFBQWpCLENBQTJCbEwsVUFBM0IsQ0FBTCxDQUE2QyxDQUNoREosT0FBTzNrQixJQUFQLENBQVk5SSxLQUFaLEVBQ0QsQ0FDRixDQUNELE1BQU95dEIsT0FBUCxDQUNELENBRUQ7Ozs7Ozs7T0FRQSxHQUFJcU8sVUFBV21DLGVBQWVDLFVBQWYsQ0FBZixDQUVBOzs7Ozs7O09BUUEsR0FBSUMsZUFBZ0JGLGVBQWVHLGVBQWYsQ0FBZ0MsSUFBaEMsQ0FBcEIsQ0FFQTs7Ozs7Ozs7T0FTQSxRQUFTQyxVQUFULENBQW1CNVAsVUFBbkIsQ0FBK0JuQixTQUEvQixDQUEwQyxDQUN4QyxHQUFJRyxRQUFTLElBQWIsQ0FDQXFPLFNBQVNyTixVQUFULENBQXFCLFNBQVN6dUIsS0FBVCxDQUFnQjRRLEtBQWhCLENBQXVCNmQsVUFBdkIsQ0FBbUMsQ0FDdERoQixPQUFTLENBQUMsQ0FBQ0gsVUFBVXR0QixLQUFWLENBQWlCNFEsS0FBakIsQ0FBd0I2ZCxVQUF4QixDQUFYLENBQ0EsTUFBT2hCLE9BQVAsQ0FDRCxDQUhELEVBSUEsTUFBT0EsT0FBUCxDQUNELENBRUQ7Ozs7Ozs7OztPQVVBLFFBQVM2USxhQUFULENBQXNCdlIsS0FBdEIsQ0FBNkJFLFFBQTdCLENBQXVDWSxVQUF2QyxDQUFtRCxDQUNqRCxHQUFJamQsT0FBUSxDQUFDLENBQWIsQ0FDSXZMLE9BQVMwbkIsTUFBTTFuQixNQURuQixDQUdBLE1BQU8sRUFBRXVMLEtBQUYsQ0FBVXZMLE1BQWpCLENBQXlCLENBQ3ZCLEdBQUlyRixPQUFRK3NCLE1BQU1uYyxLQUFOLENBQVosQ0FDSTNDLFFBQVVnZixTQUFTanRCLEtBQVQsQ0FEZCxDQUdBLEdBQUlpTyxTQUFXLElBQVgsR0FBb0I4cUIsV0FBYTl5QixTQUFiLENBQ2ZnSSxVQUFZQSxPQUFaLEVBQXVCLENBQUNzd0IsU0FBU3R3QixPQUFULENBRFQsQ0FFaEI0ZixXQUFXNWYsT0FBWCxDQUFvQjhxQixRQUFwQixDQUZKLENBQUosQ0FHTyxDQUNMLEdBQUlBLFVBQVc5cUIsT0FBZixDQUNJd2YsT0FBU3p0QixLQURiLENBRUQsQ0FDRixDQUNELE1BQU95dEIsT0FBUCxDQUNELENBRUQ7Ozs7Ozs7OztPQVVBLFFBQVMrUSxTQUFULENBQWtCelIsS0FBbEIsQ0FBeUIvc0IsS0FBekIsQ0FBZ0N1NEIsS0FBaEMsQ0FBdUNDLEdBQXZDLENBQTRDLENBQzFDLEdBQUluekIsUUFBUzBuQixNQUFNMW5CLE1BQW5CLENBRUFrekIsTUFBUWtHLFVBQVVsRyxLQUFWLENBQVIsQ0FDQSxHQUFJQSxNQUFRLENBQVosQ0FBZSxDQUNiQSxNQUFRLENBQUNBLEtBQUQsQ0FBU2x6QixNQUFULENBQWtCLENBQWxCLENBQXVCQSxPQUFTa3pCLEtBQXhDLENBQ0QsQ0FDREMsSUFBT0EsTUFBUXZ5QixTQUFSLEVBQXFCdXlCLElBQU1uekIsTUFBNUIsQ0FBc0NBLE1BQXRDLENBQStDbzVCLFVBQVVqRyxHQUFWLENBQXJELENBQ0EsR0FBSUEsSUFBTSxDQUFWLENBQWEsQ0FDWEEsS0FBT256QixNQUFQLENBQ0QsQ0FDRG16QixJQUFNRCxNQUFRQyxHQUFSLENBQWMsQ0FBZCxDQUFrQmtHLFNBQVNsRyxHQUFULENBQXhCLENBQ0EsTUFBT0QsTUFBUUMsR0FBZixDQUFvQixDQUNsQnpMLE1BQU13TCxPQUFOLEVBQWlCdjRCLEtBQWpCLENBQ0QsQ0FDRCxNQUFPK3NCLE1BQVAsQ0FDRCxDQUVEOzs7Ozs7O09BUUEsUUFBUzRSLFdBQVQsQ0FBb0JsUSxVQUFwQixDQUFnQ25CLFNBQWhDLENBQTJDLENBQ3pDLEdBQUlHLFFBQVMsRUFBYixDQUNBcU8sU0FBU3JOLFVBQVQsQ0FBcUIsU0FBU3p1QixLQUFULENBQWdCNFEsS0FBaEIsQ0FBdUI2ZCxVQUF2QixDQUFtQyxDQUN0RCxHQUFJbkIsVUFBVXR0QixLQUFWLENBQWlCNFEsS0FBakIsQ0FBd0I2ZCxVQUF4QixDQUFKLENBQXlDLENBQ3ZDaEIsT0FBTzNrQixJQUFQLENBQVk5SSxLQUFaLEVBQ0QsQ0FDRixDQUpELEVBS0EsTUFBT3l0QixPQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7OztPQVdBLFFBQVNtUixZQUFULENBQXFCN1IsS0FBckIsQ0FBNEI4UixLQUE1QixDQUFtQ3ZSLFNBQW5DLENBQThDd1IsUUFBOUMsQ0FBd0RyUixNQUF4RCxDQUFnRSxDQUM5RCxHQUFJN2MsT0FBUSxDQUFDLENBQWIsQ0FDSXZMLE9BQVMwbkIsTUFBTTFuQixNQURuQixDQUdBaW9CLFlBQWNBLFVBQVl5UixhQUExQixFQUNBdFIsU0FBV0EsT0FBUyxFQUFwQixFQUVBLE1BQU8sRUFBRTdjLEtBQUYsQ0FBVXZMLE1BQWpCLENBQXlCLENBQ3ZCLEdBQUlyRixPQUFRK3NCLE1BQU1uYyxLQUFOLENBQVosQ0FDQSxHQUFJaXVCLE1BQVEsQ0FBUixFQUFhdlIsVUFBVXR0QixLQUFWLENBQWpCLENBQW1DLENBQ2pDLEdBQUk2K0IsTUFBUSxDQUFaLENBQWUsQ0FDYjtBQUNBRCxZQUFZNStCLEtBQVosQ0FBbUI2K0IsTUFBUSxDQUEzQixDQUE4QnZSLFNBQTlCLENBQXlDd1IsUUFBekMsQ0FBbURyUixNQUFuRCxFQUNELENBSEQsSUFHTyxDQUNMTSxVQUFVTixNQUFWLENBQWtCenRCLEtBQWxCLEVBQ0QsQ0FDRixDQVBELElBT08sSUFBSSxDQUFDOCtCLFFBQUwsQ0FBZSxDQUNwQnJSLE9BQU9BLE9BQU9wb0IsTUFBZCxFQUF3QnJGLEtBQXhCLENBQ0QsQ0FDRixDQUNELE1BQU95dEIsT0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7T0FXQSxHQUFJdVIsU0FBVUMsZUFBZCxDQUVBOzs7Ozs7Ozs7T0FVQSxHQUFJQyxjQUFlRCxjQUFjLElBQWQsQ0FBbkIsQ0FFQTs7Ozs7OztPQVFBLFFBQVNmLFdBQVQsQ0FBb0JoUCxNQUFwQixDQUE0QmpDLFFBQTVCLENBQXNDLENBQ3BDLE1BQU9pQyxTQUFVOFAsUUFBUTlQLE1BQVIsQ0FBZ0JqQyxRQUFoQixDQUEwQjRGLElBQTFCLENBQWpCLENBQ0QsQ0FFRDs7Ozs7OztPQVFBLFFBQVN1TCxnQkFBVCxDQUF5QmxQLE1BQXpCLENBQWlDakMsUUFBakMsQ0FBMkMsQ0FDekMsTUFBT2lDLFNBQVVnUSxhQUFhaFEsTUFBYixDQUFxQmpDLFFBQXJCLENBQStCNEYsSUFBL0IsQ0FBakIsQ0FDRCxDQUVEOzs7Ozs7OztPQVNBLFFBQVNzTSxjQUFULENBQXVCalEsTUFBdkIsQ0FBK0JRLEtBQS9CLENBQXNDLENBQ3BDLE1BQU9uQyxhQUFZbUMsS0FBWixDQUFtQixTQUFTM3ZCLEdBQVQsQ0FBYyxDQUN0QyxNQUFPcS9CLFlBQVdsUSxPQUFPbnZCLEdBQVAsQ0FBWCxDQUFQLENBQ0QsQ0FGTSxDQUFQLENBR0QsQ0FFRDs7Ozs7OztPQVFBLFFBQVNzL0IsUUFBVCxDQUFpQm5RLE1BQWpCLENBQXlCb1EsSUFBekIsQ0FBK0IsQ0FDN0JBLEtBQU9DLE1BQU1ELElBQU4sQ0FBWXBRLE1BQVosRUFBc0IsQ0FBQ29RLElBQUQsQ0FBdEIsQ0FBK0JFLFNBQVNGLElBQVQsQ0FBdEMsQ0FFQSxHQUFJMXVCLE9BQVEsQ0FBWixDQUNJdkwsT0FBU2k2QixLQUFLajZCLE1BRGxCLENBR0EsTUFBTzZwQixRQUFVLElBQVYsRUFBa0J0ZSxNQUFRdkwsTUFBakMsQ0FBeUMsQ0FDdkM2cEIsT0FBU0EsT0FBT3VRLE1BQU1ILEtBQUsxdUIsT0FBTCxDQUFOLENBQVAsQ0FBVCxDQUNELENBQ0QsTUFBUUEsUUFBU0EsT0FBU3ZMLE1BQW5CLENBQTZCNnBCLE1BQTdCLENBQXNDanBCLFNBQTdDLENBQ0QsQ0FFRDs7Ozs7Ozs7OztPQVdBLFFBQVN5NUIsZUFBVCxDQUF3QnhRLE1BQXhCLENBQWdDeVEsUUFBaEMsQ0FBMENDLFdBQTFDLENBQXVELENBQ3JELEdBQUluUyxRQUFTa1MsU0FBU3pRLE1BQVQsQ0FBYixDQUNBLE1BQU9wUSxTQUFRb1EsTUFBUixFQUFrQnpCLE1BQWxCLENBQTJCTSxVQUFVTixNQUFWLENBQWtCbVMsWUFBWTFRLE1BQVosQ0FBbEIsQ0FBbEMsQ0FDRCxDQUVEOzs7Ozs7T0FPQSxRQUFTMlEsV0FBVCxDQUFvQjcvQixLQUFwQixDQUEyQixDQUN6QixNQUFPbXpCLGdCQUFlcFksSUFBZixDQUFvQi9hLEtBQXBCLENBQVAsQ0FDRCxDQUVEOzs7Ozs7OztPQVNBLFFBQVM4L0IsT0FBVCxDQUFnQjkvQixLQUFoQixDQUF1QisvQixLQUF2QixDQUE4QixDQUM1QixNQUFPLy9CLE9BQVErL0IsS0FBZixDQUNELENBRUQ7Ozs7Ozs7T0FRQSxRQUFTQyxRQUFULENBQWlCOVEsTUFBakIsQ0FBeUJudkIsR0FBekIsQ0FBOEIsQ0FDNUIsTUFBT212QixTQUFVLElBQVYsRUFBa0I4RCxlQUFlalksSUFBZixDQUFvQm1VLE1BQXBCLENBQTRCbnZCLEdBQTVCLENBQXpCLENBQ0QsQ0FFRDs7Ozs7OztPQVFBLFFBQVNrZ0MsVUFBVCxDQUFtQi9RLE1BQW5CLENBQTJCbnZCLEdBQTNCLENBQWdDLENBQzlCLE1BQU9tdkIsU0FBVSxJQUFWLEVBQWtCbnZCLE1BQU91TSxRQUFPNGlCLE1BQVAsQ0FBaEMsQ0FDRCxDQUVEOzs7Ozs7OztPQVNBLFFBQVNnUixZQUFULENBQXFCN0QsTUFBckIsQ0FBNkI5RCxLQUE3QixDQUFvQ0MsR0FBcEMsQ0FBeUMsQ0FDdkMsTUFBTzZELFNBQVVySCxVQUFVdUQsS0FBVixDQUFpQkMsR0FBakIsQ0FBVixFQUFtQzZELE9BQVN0SCxVQUFVd0QsS0FBVixDQUFpQkMsR0FBakIsQ0FBbkQsQ0FDRCxDQUVEOzs7Ozs7Ozs7T0FVQSxRQUFTMkgsaUJBQVQsQ0FBMEJDLE1BQTFCLENBQWtDblQsUUFBbEMsQ0FBNENZLFVBQTVDLENBQXdELENBQ3RELEdBQUlnUSxVQUFXaFEsV0FBYUQsaUJBQWIsQ0FBaUNGLGFBQWhELENBQ0lyb0IsT0FBUys2QixPQUFPLENBQVAsRUFBVS82QixNQUR2QixDQUVJZzdCLFVBQVlELE9BQU8vNkIsTUFGdkIsQ0FHSWk3QixTQUFXRCxTQUhmLENBSUlFLE9BQVM1dkIsTUFBTTB2QixTQUFOLENBSmIsQ0FLSUcsVUFBWUMsUUFMaEIsQ0FNSWhULE9BQVMsRUFOYixDQVFBLE1BQU82UyxVQUFQLENBQW1CLENBQ2pCLEdBQUl2VCxPQUFRcVQsT0FBT0UsUUFBUCxDQUFaLENBQ0EsR0FBSUEsVUFBWXJULFFBQWhCLENBQTBCLENBQ3hCRixNQUFRZSxTQUFTZixLQUFULENBQWdCNEMsVUFBVTFDLFFBQVYsQ0FBaEIsQ0FBUixDQUNELENBQ0R1VCxVQUFZeEwsVUFBVWpJLE1BQU0xbkIsTUFBaEIsQ0FBd0JtN0IsU0FBeEIsQ0FBWixDQUNBRCxPQUFPRCxRQUFQLEVBQW1CLENBQUN6UyxVQUFELEdBQWdCWixVQUFhNW5CLFFBQVUsR0FBVixFQUFpQjBuQixNQUFNMW5CLE1BQU4sRUFBZ0IsR0FBOUQsRUFDZixHQUFJbTFCLFNBQUosQ0FBYThGLFVBQVl2VCxLQUF6QixDQURlLENBRWY5bUIsU0FGSixDQUdELENBQ0Q4bUIsTUFBUXFULE9BQU8sQ0FBUCxDQUFSLENBRUEsR0FBSXh2QixPQUFRLENBQUMsQ0FBYixDQUNJOHZCLEtBQU9ILE9BQU8sQ0FBUCxDQURYLENBR0ExSCxNQUNBLE1BQU8sRUFBRWpvQixLQUFGLENBQVV2TCxNQUFWLEVBQW9Cb29CLE9BQU9wb0IsTUFBUCxDQUFnQm03QixTQUEzQyxDQUFzRCxDQUNwRCxHQUFJeGdDLE9BQVErc0IsTUFBTW5jLEtBQU4sQ0FBWixDQUNJbW9CLFNBQVc5TCxTQUFXQSxTQUFTanRCLEtBQVQsQ0FBWCxDQUE2QkEsS0FENUMsQ0FHQUEsTUFBUzZ0QixZQUFjN3RCLFFBQVUsQ0FBekIsQ0FBOEJBLEtBQTlCLENBQXNDLENBQTlDLENBQ0EsR0FBSSxFQUFFMGdDLEtBQ0U3USxTQUFTNlEsSUFBVCxDQUFlM0gsUUFBZixDQURGLENBRUU4RSxTQUFTcFEsTUFBVCxDQUFpQnNMLFFBQWpCLENBQTJCbEwsVUFBM0IsQ0FGSixDQUFKLENBR08sQ0FDTHlTLFNBQVdELFNBQVgsQ0FDQSxNQUFPLEVBQUVDLFFBQVQsQ0FBbUIsQ0FDakIsR0FBSXhRLE9BQVF5USxPQUFPRCxRQUFQLENBQVosQ0FDQSxHQUFJLEVBQUV4USxNQUNFRCxTQUFTQyxLQUFULENBQWdCaUosUUFBaEIsQ0FERixDQUVFOEUsU0FBU3VDLE9BQU9FLFFBQVAsQ0FBVCxDQUEyQnZILFFBQTNCLENBQXFDbEwsVUFBckMsQ0FGSixDQUFKLENBR00sQ0FDSixRQUFTZ0wsTUFBVCxDQUNELENBQ0YsQ0FDRCxHQUFJNkgsSUFBSixDQUFVLENBQ1JBLEtBQUs1M0IsSUFBTCxDQUFVaXdCLFFBQVYsRUFDRCxDQUNEdEwsT0FBTzNrQixJQUFQLENBQVk5SSxLQUFaLEVBQ0QsQ0FDRixDQUNELE1BQU95dEIsT0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7T0FXQSxRQUFTa1QsYUFBVCxDQUFzQnpSLE1BQXRCLENBQThCbEMsTUFBOUIsQ0FBc0NDLFFBQXRDLENBQWdEQyxXQUFoRCxDQUE2RCxDQUMzRGdSLFdBQVdoUCxNQUFYLENBQW1CLFNBQVNsdkIsS0FBVCxDQUFnQkQsR0FBaEIsQ0FBcUJtdkIsTUFBckIsQ0FBNkIsQ0FDOUNsQyxPQUFPRSxXQUFQLENBQW9CRCxTQUFTanRCLEtBQVQsQ0FBcEIsQ0FBcUNELEdBQXJDLENBQTBDbXZCLE1BQTFDLEVBQ0QsQ0FGRCxFQUdBLE1BQU9oQyxZQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7O09BVUEsUUFBUzBULFdBQVQsQ0FBb0IxUixNQUFwQixDQUE0Qm9RLElBQTVCLENBQWtDelMsSUFBbEMsQ0FBd0MsQ0FDdEMsR0FBSSxDQUFDMFMsTUFBTUQsSUFBTixDQUFZcFEsTUFBWixDQUFMLENBQTBCLENBQ3hCb1EsS0FBT0UsU0FBU0YsSUFBVCxDQUFQLENBQ0FwUSxPQUFTMlIsT0FBTzNSLE1BQVAsQ0FBZW9RLElBQWYsQ0FBVCxDQUNBQSxLQUFPd0IsS0FBS3hCLElBQUwsQ0FBUCxDQUNELENBQ0QsR0FBSTNTLE1BQU91QyxRQUFVLElBQVYsQ0FBaUJBLE1BQWpCLENBQTBCQSxPQUFPdVEsTUFBTUgsSUFBTixDQUFQLENBQXJDLENBQ0EsTUFBTzNTLE9BQVEsSUFBUixDQUFlMW1CLFNBQWYsQ0FBMkI0YSxNQUFNOEwsSUFBTixDQUFZdUMsTUFBWixDQUFvQnJDLElBQXBCLENBQWxDLENBQ0QsQ0FFRDs7Ozs7O09BT0EsUUFBU2tVLGtCQUFULENBQTJCL2dDLEtBQTNCLENBQWtDLENBQ2hDLE1BQU8wMkIsY0FBYTEyQixLQUFiLEdBQXVCbXpCLGVBQWVwWSxJQUFmLENBQW9CL2EsS0FBcEIsR0FBOEJ3a0IsY0FBNUQsQ0FDRCxDQUVEOzs7Ozs7T0FPQSxRQUFTd2MsV0FBVCxDQUFvQmhoQyxLQUFwQixDQUEyQixDQUN6QixNQUFPMDJCLGNBQWExMkIsS0FBYixHQUF1Qm16QixlQUFlcFksSUFBZixDQUFvQi9hLEtBQXBCLEdBQThCMGpCLE9BQTVELENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7T0FlQSxRQUFTdWQsWUFBVCxDQUFxQmpoQyxLQUFyQixDQUE0QisvQixLQUE1QixDQUFtQ3BELFVBQW5DLENBQStDdUUsT0FBL0MsQ0FBd0R0aUMsS0FBeEQsQ0FBK0QsQ0FDN0QsR0FBSW9CLFFBQVUrL0IsS0FBZCxDQUFxQixDQUNuQixNQUFPLEtBQVAsQ0FDRCxDQUNELEdBQUkvL0IsT0FBUyxJQUFULEVBQWlCKy9CLE9BQVMsSUFBMUIsRUFBbUMsQ0FBQ25ELFNBQVM1OEIsS0FBVCxDQUFELEVBQW9CLENBQUMwMkIsYUFBYXFKLEtBQWIsQ0FBNUQsQ0FBa0YsQ0FDaEYsTUFBTy8vQixTQUFVQSxLQUFWLEVBQW1CKy9CLFFBQVVBLEtBQXBDLENBQ0QsQ0FDRCxNQUFPb0IsaUJBQWdCbmhDLEtBQWhCLENBQXVCKy9CLEtBQXZCLENBQThCa0IsV0FBOUIsQ0FBMkN0RSxVQUEzQyxDQUF1RHVFLE9BQXZELENBQWdFdGlDLEtBQWhFLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7OztPQWVBLFFBQVN1aUMsZ0JBQVQsQ0FBeUJqUyxNQUF6QixDQUFpQzZRLEtBQWpDLENBQXdDcUIsU0FBeEMsQ0FBbUR6RSxVQUFuRCxDQUErRHVFLE9BQS9ELENBQXdFdGlDLEtBQXhFLENBQStFLENBQzdFLEdBQUl5aUMsVUFBV3ZpQixRQUFRb1EsTUFBUixDQUFmLENBQ0lvUyxTQUFXeGlCLFFBQVFpaEIsS0FBUixDQURmLENBRUl3QixPQUFTL2QsUUFGYixDQUdJZ2UsT0FBU2hlLFFBSGIsQ0FLQSxHQUFJLENBQUM2ZCxRQUFMLENBQWUsQ0FDYkUsT0FBU3pFLE9BQU81TixNQUFQLENBQVQsQ0FDQXFTLE9BQVNBLFFBQVVoZSxPQUFWLENBQW9CUyxTQUFwQixDQUFnQ3VkLE1BQXpDLENBQ0QsQ0FDRCxHQUFJLENBQUNELFFBQUwsQ0FBZSxDQUNiRSxPQUFTMUUsT0FBT2lELEtBQVAsQ0FBVCxDQUNBeUIsT0FBU0EsUUFBVWplLE9BQVYsQ0FBb0JTLFNBQXBCLENBQWdDd2QsTUFBekMsQ0FDRCxDQUNELEdBQUlDLFVBQVdGLFFBQVV2ZCxTQUFWLEVBQXVCLENBQUM2TSxhQUFhM0IsTUFBYixDQUF2QyxDQUNJd1MsU0FBV0YsUUFBVXhkLFNBQVYsRUFBdUIsQ0FBQzZNLGFBQWFrUCxLQUFiLENBRHZDLENBRUk0QixVQUFZSixRQUFVQyxNQUYxQixDQUlBLEdBQUlHLFdBQWEsQ0FBQ0YsUUFBbEIsQ0FBNEIsQ0FDMUI3aUMsUUFBVUEsTUFBUSxHQUFJKzdCLE1BQUosRUFBbEIsRUFDQSxNQUFRMEcsV0FBWS9VLGFBQWE0QyxNQUFiLENBQWIsQ0FDSDBTLFlBQVkxUyxNQUFaLENBQW9CNlEsS0FBcEIsQ0FBMkJxQixTQUEzQixDQUFzQ3pFLFVBQXRDLENBQWtEdUUsT0FBbEQsQ0FBMkR0aUMsS0FBM0QsQ0FERyxDQUVIaWpDLFdBQVczUyxNQUFYLENBQW1CNlEsS0FBbkIsQ0FBMEJ3QixNQUExQixDQUFrQ0gsU0FBbEMsQ0FBNkN6RSxVQUE3QyxDQUF5RHVFLE9BQXpELENBQWtFdGlDLEtBQWxFLENBRkosQ0FHRCxDQUNELEdBQUksRUFBRXNpQyxRQUFVM2Usb0JBQVosQ0FBSixDQUF1QyxDQUNyQyxHQUFJdWYsY0FBZUwsVUFBWXpPLGVBQWVqWSxJQUFmLENBQW9CbVUsTUFBcEIsQ0FBNEIsYUFBNUIsQ0FBL0IsQ0FDSTZTLGFBQWVMLFVBQVkxTyxlQUFlalksSUFBZixDQUFvQmdsQixLQUFwQixDQUEyQixhQUEzQixDQUQvQixDQUdBLEdBQUkrQixjQUFnQkMsWUFBcEIsQ0FBa0MsQ0FDaEMsR0FBSUMsY0FBZUYsYUFBZTVTLE9BQU9sdkIsS0FBUCxFQUFmLENBQWdDa3ZCLE1BQW5ELENBQ0krUyxhQUFlRixhQUFlaEMsTUFBTS8vQixLQUFOLEVBQWYsQ0FBK0IrL0IsS0FEbEQsQ0FHQW5oQyxRQUFVQSxNQUFRLEdBQUkrN0IsTUFBSixFQUFsQixFQUNBLE1BQU95RyxXQUFVWSxZQUFWLENBQXdCQyxZQUF4QixDQUFzQ3RGLFVBQXRDLENBQWtEdUUsT0FBbEQsQ0FBMkR0aUMsS0FBM0QsQ0FBUCxDQUNELENBQ0YsQ0FDRCxHQUFJLENBQUMraUMsU0FBTCxDQUFnQixDQUNkLE1BQU8sTUFBUCxDQUNELENBQ0QvaUMsUUFBVUEsTUFBUSxHQUFJKzdCLE1BQUosRUFBbEIsRUFDQSxNQUFPdUgsY0FBYWhULE1BQWIsQ0FBcUI2USxLQUFyQixDQUE0QnFCLFNBQTVCLENBQXVDekUsVUFBdkMsQ0FBbUR1RSxPQUFuRCxDQUE0RHRpQyxLQUE1RCxDQUFQLENBQ0QsQ0FFRDs7Ozs7O09BT0EsUUFBU3VqQyxVQUFULENBQW1CbmlDLEtBQW5CLENBQTBCLENBQ3hCLE1BQU8wMkIsY0FBYTEyQixLQUFiLEdBQXVCODhCLE9BQU85OEIsS0FBUCxHQUFpQjhqQixNQUEvQyxDQUNELENBRUQ7Ozs7Ozs7OztPQVVBLFFBQVNzZSxZQUFULENBQXFCbFQsTUFBckIsQ0FBNkJ4SixNQUE3QixDQUFxQzJjLFNBQXJDLENBQWdEMUYsVUFBaEQsQ0FBNEQsQ0FDMUQsR0FBSS9yQixPQUFReXhCLFVBQVVoOUIsTUFBdEIsQ0FDSUEsT0FBU3VMLEtBRGIsQ0FFSTB4QixhQUFlLENBQUMzRixVQUZwQixDQUlBLEdBQUl6TixRQUFVLElBQWQsQ0FBb0IsQ0FDbEIsTUFBTyxDQUFDN3BCLE1BQVIsQ0FDRCxDQUNENnBCLE9BQVM1aUIsT0FBTzRpQixNQUFQLENBQVQsQ0FDQSxNQUFPdGUsT0FBUCxDQUFnQixDQUNkLEdBQUlsTyxNQUFPMi9CLFVBQVV6eEIsS0FBVixDQUFYLENBQ0EsR0FBSzB4QixjQUFnQjUvQixLQUFLLENBQUwsQ0FBakIsQ0FDSUEsS0FBSyxDQUFMLElBQVl3c0IsT0FBT3hzQixLQUFLLENBQUwsQ0FBUCxDQURoQixDQUVJLEVBQUVBLEtBQUssQ0FBTCxHQUFXd3NCLE9BQWIsQ0FGUixDQUdNLENBQ0osTUFBTyxNQUFQLENBQ0QsQ0FDRixDQUNELE1BQU8sRUFBRXRlLEtBQUYsQ0FBVXZMLE1BQWpCLENBQXlCLENBQ3ZCM0MsS0FBTzIvQixVQUFVenhCLEtBQVYsQ0FBUCxDQUNBLEdBQUk3USxLQUFNMkMsS0FBSyxDQUFMLENBQVYsQ0FDSTg0QixTQUFXdE0sT0FBT252QixHQUFQLENBRGYsQ0FFSTA3QixTQUFXLzRCLEtBQUssQ0FBTCxDQUZmLENBSUEsR0FBSTQvQixjQUFnQjUvQixLQUFLLENBQUwsQ0FBcEIsQ0FBNkIsQ0FDM0IsR0FBSTg0QixXQUFhdjFCLFNBQWIsRUFBMEIsRUFBRWxHLE1BQU9tdkIsT0FBVCxDQUE5QixDQUFnRCxDQUM5QyxNQUFPLE1BQVAsQ0FDRCxDQUNGLENBSkQsSUFJTyxDQUNMLEdBQUl0d0IsT0FBUSxHQUFJKzdCLE1BQUosRUFBWixDQUNBLEdBQUlnQyxVQUFKLENBQWdCLENBQ2QsR0FBSWxQLFFBQVNrUCxXQUFXbkIsUUFBWCxDQUFxQkMsUUFBckIsQ0FBK0IxN0IsR0FBL0IsQ0FBb0NtdkIsTUFBcEMsQ0FBNEN4SixNQUE1QyxDQUFvRDltQixLQUFwRCxDQUFiLENBQ0QsQ0FDRCxHQUFJLEVBQUU2dUIsU0FBV3huQixTQUFYLENBQ0VnN0IsWUFBWXhGLFFBQVosQ0FBc0JELFFBQXRCLENBQWdDbUIsVUFBaEMsQ0FBNENyYSx1QkFBeUJDLG9CQUFyRSxDQUEyRjNqQixLQUEzRixDQURGLENBRUU2dUIsTUFGSixDQUFKLENBR08sQ0FDTCxNQUFPLE1BQVAsQ0FDRCxDQUNGLENBQ0YsQ0FDRCxNQUFPLEtBQVAsQ0FDRCxDQUVEOzs7Ozs7O09BUUEsUUFBUzhVLGFBQVQsQ0FBc0J2aUMsS0FBdEIsQ0FBNkIsQ0FDM0IsR0FBSSxDQUFDNDhCLFNBQVM1OEIsS0FBVCxDQUFELEVBQW9Cd2lDLFNBQVN4aUMsS0FBVCxDQUF4QixDQUF5QyxDQUN2QyxNQUFPLE1BQVAsQ0FDRCxDQUNELEdBQUl5aUMsU0FBV3JELFdBQVdwL0IsS0FBWCxHQUFxQjZ3QixhQUFhN3dCLEtBQWIsQ0FBdEIsQ0FBNkNxekIsVUFBN0MsQ0FBMERuTSxZQUF4RSxDQUNBLE1BQU91YixTQUFRM3RCLElBQVIsQ0FBYWtoQixTQUFTaDJCLEtBQVQsQ0FBYixDQUFQLENBQ0QsQ0FFRDs7Ozs7O09BT0EsUUFBUzBpQyxhQUFULENBQXNCMWlDLEtBQXRCLENBQTZCLENBQzNCLE1BQU80OEIsVUFBUzU4QixLQUFULEdBQW1CbXpCLGVBQWVwWSxJQUFmLENBQW9CL2EsS0FBcEIsR0FBOEJra0IsU0FBeEQsQ0FDRCxDQUVEOzs7Ozs7T0FPQSxRQUFTeWUsVUFBVCxDQUFtQjNpQyxLQUFuQixDQUEwQixDQUN4QixNQUFPMDJCLGNBQWExMkIsS0FBYixHQUF1Qjg4QixPQUFPOThCLEtBQVAsR0FBaUJta0IsTUFBL0MsQ0FDRCxDQUVEOzs7Ozs7T0FPQSxRQUFTeWUsaUJBQVQsQ0FBMEI1aUMsS0FBMUIsQ0FBaUMsQ0FDL0IsTUFBTzAyQixjQUFhMTJCLEtBQWIsR0FDTDZpQyxTQUFTN2lDLE1BQU1xRixNQUFmLENBREssRUFDcUIsQ0FBQyxDQUFDZ2xCLGVBQWU4SSxlQUFlcFksSUFBZixDQUFvQi9hLEtBQXBCLENBQWYsQ0FEOUIsQ0FFRCxDQUVEOzs7Ozs7T0FPQSxRQUFTOGlDLGFBQVQsQ0FBc0I5aUMsS0FBdEIsQ0FBNkIsQ0FDM0I7QUFDQTtBQUNBLEdBQUksTUFBT0EsTUFBUCxFQUFnQixVQUFwQixDQUFnQyxDQUM5QixNQUFPQSxNQUFQLENBQ0QsQ0FDRCxHQUFJQSxPQUFTLElBQWIsQ0FBbUIsQ0FDakIsTUFBTytpQyxTQUFQLENBQ0QsQ0FDRCxHQUFJLE1BQU8vaUMsTUFBUCxFQUFnQixRQUFwQixDQUE4QixDQUM1QixNQUFPOGUsU0FBUTllLEtBQVIsRUFDSGdqQyxvQkFBb0JoakMsTUFBTSxDQUFOLENBQXBCLENBQThCQSxNQUFNLENBQU4sQ0FBOUIsQ0FERyxDQUVIaWpDLFlBQVlqakMsS0FBWixDQUZKLENBR0QsQ0FDRCxNQUFPa2pDLFVBQVNsakMsS0FBVCxDQUFQLENBQ0QsQ0FFRDs7Ozs7O09BT0EsUUFBU21qQyxTQUFULENBQWtCalUsTUFBbEIsQ0FBMEIsQ0FDeEIsR0FBSSxDQUFDa1UsWUFBWWxVLE1BQVosQ0FBTCxDQUEwQixDQUN4QixNQUFPNEYsWUFBVzVGLE1BQVgsQ0FBUCxDQUNELENBQ0QsR0FBSXpCLFFBQVMsRUFBYixDQUNBLElBQUssR0FBSTF0QixJQUFULEdBQWdCdU0sUUFBTzRpQixNQUFQLENBQWhCLENBQWdDLENBQzlCLEdBQUk4RCxlQUFlalksSUFBZixDQUFvQm1VLE1BQXBCLENBQTRCbnZCLEdBQTVCLEdBQW9DQSxLQUFPLGFBQS9DLENBQThELENBQzVEMHRCLE9BQU8za0IsSUFBUCxDQUFZL0ksR0FBWixFQUNELENBQ0YsQ0FDRCxNQUFPMHRCLE9BQVAsQ0FDRCxDQUVEOzs7Ozs7T0FPQSxRQUFTNFYsV0FBVCxDQUFvQm5VLE1BQXBCLENBQTRCLENBQzFCLEdBQUksQ0FBQzBOLFNBQVMxTixNQUFULENBQUwsQ0FBdUIsQ0FDckIsTUFBT29VLGNBQWFwVSxNQUFiLENBQVAsQ0FDRCxDQUNELEdBQUlxVSxTQUFVSCxZQUFZbFUsTUFBWixDQUFkLENBQ0l6QixPQUFTLEVBRGIsQ0FHQSxJQUFLLEdBQUkxdEIsSUFBVCxHQUFnQm12QixPQUFoQixDQUF3QixDQUN0QixHQUFJLEVBQUVudkIsS0FBTyxhQUFQLEdBQXlCd2pDLFNBQVcsQ0FBQ3ZRLGVBQWVqWSxJQUFmLENBQW9CbVUsTUFBcEIsQ0FBNEJudkIsR0FBNUIsQ0FBckMsQ0FBRixDQUFKLENBQStFLENBQzdFMHRCLE9BQU8za0IsSUFBUCxDQUFZL0ksR0FBWixFQUNELENBQ0YsQ0FDRCxNQUFPMHRCLE9BQVAsQ0FDRCxDQUVEOzs7Ozs7OztPQVNBLFFBQVMrVixPQUFULENBQWdCeGpDLEtBQWhCLENBQXVCKy9CLEtBQXZCLENBQThCLENBQzVCLE1BQU8vL0IsT0FBUSsvQixLQUFmLENBQ0QsQ0FFRDs7Ozs7OztPQVFBLFFBQVMwRCxRQUFULENBQWlCaFYsVUFBakIsQ0FBNkJ4QixRQUE3QixDQUF1QyxDQUNyQyxHQUFJcmMsT0FBUSxDQUFDLENBQWIsQ0FDSTZjLE9BQVNpVyxZQUFZalYsVUFBWixFQUEwQjlkLE1BQU04ZCxXQUFXcHBCLE1BQWpCLENBQTFCLENBQXFELEVBRGxFLENBR0F5MkIsU0FBU3JOLFVBQVQsQ0FBcUIsU0FBU3p1QixLQUFULENBQWdCRCxHQUFoQixDQUFxQjB1QixVQUFyQixDQUFpQyxDQUNwRGhCLE9BQU8sRUFBRTdjLEtBQVQsRUFBa0JxYyxTQUFTanRCLEtBQVQsQ0FBZ0JELEdBQWhCLENBQXFCMHVCLFVBQXJCLENBQWxCLENBQ0QsQ0FGRCxFQUdBLE1BQU9oQixPQUFQLENBQ0QsQ0FFRDs7Ozs7O09BT0EsUUFBU3dWLFlBQVQsQ0FBcUJ2ZCxNQUFyQixDQUE2QixDQUMzQixHQUFJMmMsV0FBWXNCLGFBQWFqZSxNQUFiLENBQWhCLENBQ0EsR0FBSTJjLFVBQVVoOUIsTUFBVixFQUFvQixDQUFwQixFQUF5Qmc5QixVQUFVLENBQVYsRUFBYSxDQUFiLENBQTdCLENBQThDLENBQzVDLE1BQU91Qix5QkFBd0J2QixVQUFVLENBQVYsRUFBYSxDQUFiLENBQXhCLENBQXlDQSxVQUFVLENBQVYsRUFBYSxDQUFiLENBQXpDLENBQVAsQ0FDRCxDQUNELE1BQU8sVUFBU25ULE1BQVQsQ0FBaUIsQ0FDdEIsTUFBT0EsVUFBV3hKLE1BQVgsRUFBcUIwYyxZQUFZbFQsTUFBWixDQUFvQnhKLE1BQXBCLENBQTRCMmMsU0FBNUIsQ0FBNUIsQ0FDRCxDQUZELENBR0QsQ0FFRDs7Ozs7OztPQVFBLFFBQVNXLG9CQUFULENBQTZCMUQsSUFBN0IsQ0FBbUM3RCxRQUFuQyxDQUE2QyxDQUMzQyxHQUFJOEQsTUFBTUQsSUFBTixHQUFldUUsbUJBQW1CcEksUUFBbkIsQ0FBbkIsQ0FBaUQsQ0FDL0MsTUFBT21JLHlCQUF3Qm5FLE1BQU1ILElBQU4sQ0FBeEIsQ0FBcUM3RCxRQUFyQyxDQUFQLENBQ0QsQ0FDRCxNQUFPLFVBQVN2TSxNQUFULENBQWlCLENBQ3RCLEdBQUlzTSxVQUFXOTdCLElBQUl3dkIsTUFBSixDQUFZb1EsSUFBWixDQUFmLENBQ0EsTUFBUTlELFlBQWF2MUIsU0FBYixFQUEwQnUxQixXQUFhQyxRQUF4QyxDQUNIcUksTUFBTTVVLE1BQU4sQ0FBY29RLElBQWQsQ0FERyxDQUVIMkIsWUFBWXhGLFFBQVosQ0FBc0JELFFBQXRCLENBQWdDdjFCLFNBQWhDLENBQTJDcWMsdUJBQXlCQyxvQkFBcEUsQ0FGSixDQUdELENBTEQsQ0FNRCxDQUVEOzs7Ozs7Ozs7O09BV0EsUUFBU3doQixVQUFULENBQW1CN1UsTUFBbkIsQ0FBMkJ4SixNQUEzQixDQUFtQ3NlLFFBQW5DLENBQTZDckgsVUFBN0MsQ0FBeUQvOUIsS0FBekQsQ0FBZ0UsQ0FDOUQsR0FBSXN3QixTQUFXeEosTUFBZixDQUF1QixDQUNyQixPQUNELENBQ0QsR0FBSSxFQUFFNUcsUUFBUTRHLE1BQVIsR0FBbUI0RyxhQUFhNUcsTUFBYixDQUFyQixDQUFKLENBQWdELENBQzlDLEdBQUlnSyxPQUFRMlQsV0FBVzNkLE1BQVgsQ0FBWixDQUNELENBQ0R5SCxVQUFVdUMsT0FBU2hLLE1BQW5CLENBQTJCLFNBQVMrVixRQUFULENBQW1CMTdCLEdBQW5CLENBQXdCLENBQ2pELEdBQUkydkIsS0FBSixDQUFXLENBQ1QzdkIsSUFBTTA3QixRQUFOLENBQ0FBLFNBQVcvVixPQUFPM2xCLEdBQVAsQ0FBWCxDQUNELENBQ0QsR0FBSTY4QixTQUFTbkIsUUFBVCxDQUFKLENBQXdCLENBQ3RCNzhCLFFBQVVBLE1BQVEsR0FBSSs3QixNQUFKLEVBQWxCLEVBQ0FzSixjQUFjL1UsTUFBZCxDQUFzQnhKLE1BQXRCLENBQThCM2xCLEdBQTlCLENBQW1DaWtDLFFBQW5DLENBQTZDRCxTQUE3QyxDQUF3RHBILFVBQXhELENBQW9FLzlCLEtBQXBFLEVBQ0QsQ0FIRCxJQUlLLENBQ0gsR0FBSXNsQyxVQUFXdkgsV0FDWEEsV0FBV3pOLE9BQU9udkIsR0FBUCxDQUFYLENBQXdCMDdCLFFBQXhCLENBQW1DMTdCLElBQU0sRUFBekMsQ0FBOENtdkIsTUFBOUMsQ0FBc0R4SixNQUF0RCxDQUE4RDltQixLQUE5RCxDQURXLENBRVhxSCxTQUZKLENBSUEsR0FBSWkrQixXQUFhaitCLFNBQWpCLENBQTRCLENBQzFCaStCLFNBQVd6SSxRQUFYLENBQ0QsQ0FDREUsaUJBQWlCek0sTUFBakIsQ0FBeUJudkIsR0FBekIsQ0FBOEJta0MsUUFBOUIsRUFDRCxDQUNGLENBbkJELEVBb0JELENBRUQ7Ozs7Ozs7Ozs7Ozs7O09BZUEsUUFBU0QsY0FBVCxDQUF1Qi9VLE1BQXZCLENBQStCeEosTUFBL0IsQ0FBdUMzbEIsR0FBdkMsQ0FBNENpa0MsUUFBNUMsQ0FBc0RHLFNBQXRELENBQWlFeEgsVUFBakUsQ0FBNkUvOUIsS0FBN0UsQ0FBb0YsQ0FDbEYsR0FBSTQ4QixVQUFXdE0sT0FBT252QixHQUFQLENBQWYsQ0FDSTA3QixTQUFXL1YsT0FBTzNsQixHQUFQLENBRGYsQ0FFSXE5QixRQUFVeCtCLE1BQU1jLEdBQU4sQ0FBVSs3QixRQUFWLENBRmQsQ0FJQSxHQUFJMkIsT0FBSixDQUFhLENBQ1h6QixpQkFBaUJ6TSxNQUFqQixDQUF5Qm52QixHQUF6QixDQUE4QnE5QixPQUE5QixFQUNBLE9BQ0QsQ0FDRCxHQUFJOEcsVUFBV3ZILFdBQ1hBLFdBQVduQixRQUFYLENBQXFCQyxRQUFyQixDQUFnQzE3QixJQUFNLEVBQXRDLENBQTJDbXZCLE1BQTNDLENBQW1EeEosTUFBbkQsQ0FBMkQ5bUIsS0FBM0QsQ0FEVyxDQUVYcUgsU0FGSixDQUlBLEdBQUk2M0IsVUFBV29HLFdBQWFqK0IsU0FBNUIsQ0FFQSxHQUFJNjNCLFFBQUosQ0FBYyxDQUNab0csU0FBV3pJLFFBQVgsQ0FDQSxHQUFJM2MsUUFBUTJjLFFBQVIsR0FBcUJuUCxhQUFhbVAsUUFBYixDQUF6QixDQUFpRCxDQUMvQyxHQUFJM2MsUUFBUTBjLFFBQVIsQ0FBSixDQUF1QixDQUNyQjBJLFNBQVcxSSxRQUFYLENBQ0QsQ0FGRCxJQUdLLElBQUk0SSxrQkFBa0I1SSxRQUFsQixDQUFKLENBQWlDLENBQ3BDMEksU0FBV3JNLFVBQVUyRCxRQUFWLENBQVgsQ0FDRCxDQUZJLElBR0EsQ0FDSHNDLFNBQVcsS0FBWCxDQUNBb0csU0FBVzFILFVBQVVmLFFBQVYsQ0FBb0IsSUFBcEIsQ0FBWCxDQUNELENBQ0YsQ0FYRCxJQVlLLElBQUk0SSxjQUFjNUksUUFBZCxHQUEyQkwsWUFBWUssUUFBWixDQUEvQixDQUFzRCxDQUN6RCxHQUFJTCxZQUFZSSxRQUFaLENBQUosQ0FBMkIsQ0FDekIwSSxTQUFXSSxjQUFjOUksUUFBZCxDQUFYLENBQ0QsQ0FGRCxJQUdLLElBQUksQ0FBQ29CLFNBQVNwQixRQUFULENBQUQsRUFBd0J3SSxVQUFZNUUsV0FBVzVELFFBQVgsQ0FBeEMsQ0FBK0QsQ0FDbEVzQyxTQUFXLEtBQVgsQ0FDQW9HLFNBQVcxSCxVQUFVZixRQUFWLENBQW9CLElBQXBCLENBQVgsQ0FDRCxDQUhJLElBSUEsQ0FDSHlJLFNBQVcxSSxRQUFYLENBQ0QsQ0FDRixDQVhJLElBWUEsQ0FDSHNDLFNBQVcsS0FBWCxDQUNELENBQ0YsQ0FDRCxHQUFJQSxRQUFKLENBQWMsQ0FDWjtBQUNBbC9CLE1BQU1rQixHQUFOLENBQVUyN0IsUUFBVixDQUFvQnlJLFFBQXBCLEVBQ0FDLFVBQVVELFFBQVYsQ0FBb0J6SSxRQUFwQixDQUE4QnVJLFFBQTlCLENBQXdDckgsVUFBeEMsQ0FBb0QvOUIsS0FBcEQsRUFDQUEsTUFBTSxRQUFOLEVBQWdCNjhCLFFBQWhCLEVBQ0QsQ0FDREUsaUJBQWlCek0sTUFBakIsQ0FBeUJudkIsR0FBekIsQ0FBOEJta0MsUUFBOUIsRUFDRCxDQUVEOzs7Ozs7O09BUUEsUUFBU0ssUUFBVCxDQUFpQnhYLEtBQWpCLENBQXdCeUMsQ0FBeEIsQ0FBMkIsQ0FDekIsR0FBSW5xQixRQUFTMG5CLE1BQU0xbkIsTUFBbkIsQ0FDQSxHQUFJLENBQUNBLE1BQUwsQ0FBYSxDQUNYLE9BQ0QsQ0FDRG1xQixHQUFLQSxFQUFJLENBQUosQ0FBUW5xQixNQUFSLENBQWlCLENBQXRCLENBQ0EsTUFBT2kyQixTQUFROUwsQ0FBUixDQUFXbnFCLE1BQVgsRUFBcUIwbkIsTUFBTXlDLENBQU4sQ0FBckIsQ0FBZ0N2cEIsU0FBdkMsQ0FDRCxDQUVEOzs7Ozs7OztPQVNBLFFBQVN1K0IsWUFBVCxDQUFxQi9WLFVBQXJCLENBQWlDZ0ssU0FBakMsQ0FBNENnTSxNQUE1QyxDQUFvRCxDQUNsRCxHQUFJN3pCLE9BQVEsQ0FBQyxDQUFiLENBQ0E2bkIsVUFBWTNLLFNBQVMySyxVQUFVcHpCLE1BQVYsQ0FBbUJvekIsU0FBbkIsQ0FBK0IsQ0FBQ3NLLFFBQUQsQ0FBeEMsQ0FBb0RwVCxVQUFVK1UsYUFBVixDQUFwRCxDQUFaLENBRUEsR0FBSWpYLFFBQVNnVyxRQUFRaFYsVUFBUixDQUFvQixTQUFTenVCLEtBQVQsQ0FBZ0JELEdBQWhCLENBQXFCMHVCLFVBQXJCLENBQWlDLENBQ2hFLEdBQUlrVyxVQUFXN1csU0FBUzJLLFNBQVQsQ0FBb0IsU0FBU3hMLFFBQVQsQ0FBbUIsQ0FDcEQsTUFBT0EsVUFBU2p0QixLQUFULENBQVAsQ0FDRCxDQUZjLENBQWYsQ0FHQSxNQUFPLENBQUUsV0FBWTJrQyxRQUFkLENBQXdCLFFBQVMsRUFBRS96QixLQUFuQyxDQUEwQyxRQUFTNVEsS0FBbkQsQ0FBUCxDQUNELENBTFksQ0FBYixDQU9BLE1BQU9xdkIsWUFBVzVCLE1BQVgsQ0FBbUIsU0FBU3lCLE1BQVQsQ0FBaUI2USxLQUFqQixDQUF3QixDQUNoRCxNQUFPNkUsaUJBQWdCMVYsTUFBaEIsQ0FBd0I2USxLQUF4QixDQUErQjBFLE1BQS9CLENBQVAsQ0FDRCxDQUZNLENBQVAsQ0FHRCxDQUVEOzs7Ozs7OztPQVNBLFFBQVNJLFNBQVQsQ0FBa0IzVixNQUFsQixDQUEwQlEsS0FBMUIsQ0FBaUMsQ0FDL0JSLE9BQVM1aUIsT0FBTzRpQixNQUFQLENBQVQsQ0FDQSxNQUFPNFYsWUFBVzVWLE1BQVgsQ0FBbUJRLEtBQW5CLENBQTBCLFNBQVMxdkIsS0FBVCxDQUFnQkQsR0FBaEIsQ0FBcUIsQ0FDcEQsTUFBT0EsT0FBT212QixPQUFkLENBQ0QsQ0FGTSxDQUFQLENBR0QsQ0FFRDs7Ozs7Ozs7T0FTQSxRQUFTNFYsV0FBVCxDQUFvQjVWLE1BQXBCLENBQTRCUSxLQUE1QixDQUFtQ3BDLFNBQW5DLENBQThDLENBQzVDLEdBQUkxYyxPQUFRLENBQUMsQ0FBYixDQUNJdkwsT0FBU3FxQixNQUFNcnFCLE1BRG5CLENBRUlvb0IsT0FBUyxFQUZiLENBSUEsTUFBTyxFQUFFN2MsS0FBRixDQUFVdkwsTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSXRGLEtBQU0ydkIsTUFBTTllLEtBQU4sQ0FBVixDQUNJNVEsTUFBUWt2QixPQUFPbnZCLEdBQVAsQ0FEWixDQUdBLEdBQUl1dEIsVUFBVXR0QixLQUFWLENBQWlCRCxHQUFqQixDQUFKLENBQTJCLENBQ3pCMHRCLE9BQU8xdEIsR0FBUCxFQUFjQyxLQUFkLENBQ0QsQ0FDRixDQUNELE1BQU95dEIsT0FBUCxDQUNELENBRUQ7Ozs7OztPQU9BLFFBQVNzWCxpQkFBVCxDQUEwQnpGLElBQTFCLENBQWdDLENBQzlCLE1BQU8sVUFBU3BRLE1BQVQsQ0FBaUIsQ0FDdEIsTUFBT21RLFNBQVFuUSxNQUFSLENBQWdCb1EsSUFBaEIsQ0FBUCxDQUNELENBRkQsQ0FHRCxDQUVEOzs7Ozs7Ozs7O09BV0EsUUFBUzBGLFlBQVQsQ0FBcUJqWSxLQUFyQixDQUE0QmxTLE1BQTVCLENBQW9Db1MsUUFBcEMsQ0FBOENZLFVBQTlDLENBQTBELENBQ3hELEdBQUl6VSxTQUFVeVUsV0FBYWtCLGVBQWIsQ0FBK0JwQixXQUE3QyxDQUNJL2MsTUFBUSxDQUFDLENBRGIsQ0FFSXZMLE9BQVN3VixPQUFPeFYsTUFGcEIsQ0FHSXE3QixLQUFPM1QsS0FIWCxDQUtBLEdBQUlBLFFBQVVsUyxNQUFkLENBQXNCLENBQ3BCQSxPQUFTZ2QsVUFBVWhkLE1BQVYsQ0FBVCxDQUNELENBQ0QsR0FBSW9TLFFBQUosQ0FBYyxDQUNaeVQsS0FBTzVTLFNBQVNmLEtBQVQsQ0FBZ0I0QyxVQUFVMUMsUUFBVixDQUFoQixDQUFQLENBQ0QsQ0FDRCxNQUFPLEVBQUVyYyxLQUFGLENBQVV2TCxNQUFqQixDQUF5QixDQUN2QixHQUFJdXBCLFdBQVksQ0FBaEIsQ0FDSTV1QixNQUFRNmEsT0FBT2pLLEtBQVAsQ0FEWixDQUVJbW9CLFNBQVc5TCxTQUFXQSxTQUFTanRCLEtBQVQsQ0FBWCxDQUE2QkEsS0FGNUMsQ0FJQSxNQUFPLENBQUM0dUIsVUFBWXhWLFFBQVFzbkIsSUFBUixDQUFjM0gsUUFBZCxDQUF3Qm5LLFNBQXhCLENBQW1DZixVQUFuQyxDQUFiLEVBQStELENBQUMsQ0FBdkUsQ0FBMEUsQ0FDeEUsR0FBSTZTLE9BQVMzVCxLQUFiLENBQW9CLENBQ2xCak4sT0FBTy9FLElBQVAsQ0FBWTJsQixJQUFaLENBQWtCOVIsU0FBbEIsQ0FBNkIsQ0FBN0IsRUFDRCxDQUNEOU8sT0FBTy9FLElBQVAsQ0FBWWdTLEtBQVosQ0FBbUI2QixTQUFuQixDQUE4QixDQUE5QixFQUNELENBQ0YsQ0FDRCxNQUFPN0IsTUFBUCxDQUNELENBRUQ7Ozs7Ozs7O09BU0EsUUFBU2tZLFdBQVQsQ0FBb0JsWSxLQUFwQixDQUEyQm1ZLE9BQTNCLENBQW9DLENBQ2xDLEdBQUk3L0IsUUFBUzBuQixNQUFRbVksUUFBUTcvQixNQUFoQixDQUF5QixDQUF0QyxDQUNJMHNCLFVBQVkxc0IsT0FBUyxDQUR6QixDQUdBLE1BQU9BLFFBQVAsQ0FBaUIsQ0FDZixHQUFJdUwsT0FBUXMwQixRQUFRNy9CLE1BQVIsQ0FBWixDQUNBLEdBQUlBLFFBQVUwc0IsU0FBVixFQUF1Qm5oQixRQUFVdTBCLFFBQXJDLENBQStDLENBQzdDLEdBQUlBLFVBQVd2MEIsS0FBZixDQUNBLEdBQUkwcUIsUUFBUTFxQixLQUFSLENBQUosQ0FBb0IsQ0FDbEJrUCxPQUFPL0UsSUFBUCxDQUFZZ1MsS0FBWixDQUFtQm5jLEtBQW5CLENBQTBCLENBQTFCLEVBQ0QsQ0FGRCxJQUdLLElBQUksQ0FBQzJ1QixNQUFNM3VCLEtBQU4sQ0FBYW1jLEtBQWIsQ0FBTCxDQUEwQixDQUM3QixHQUFJdVMsTUFBT0UsU0FBUzV1QixLQUFULENBQVgsQ0FDSXNlLE9BQVMyUixPQUFPOVQsS0FBUCxDQUFjdVMsSUFBZCxDQURiLENBR0EsR0FBSXBRLFFBQVUsSUFBZCxDQUFvQixDQUNsQixNQUFPQSxRQUFPdVEsTUFBTXFCLEtBQUt4QixJQUFMLENBQU4sQ0FBUCxDQUFQLENBQ0QsQ0FDRixDQVBJLElBUUEsQ0FDSCxNQUFPdlMsT0FBTTBTLE1BQU03dUIsS0FBTixDQUFOLENBQVAsQ0FDRCxDQUNGLENBQ0YsQ0FDRCxNQUFPbWMsTUFBUCxDQUNELENBRUQ7Ozs7Ozs7O09BU0EsUUFBU3FZLFdBQVQsQ0FBb0I5SSxLQUFwQixDQUEyQkMsS0FBM0IsQ0FBa0MsQ0FDaEMsTUFBT0QsT0FBUWpJLFlBQVljLGdCQUFrQm9ILE1BQVFELEtBQVIsQ0FBZ0IsQ0FBbEMsQ0FBWixDQUFmLENBQ0QsQ0FFRDs7Ozs7Ozs7OztPQVdBLFFBQVMrSSxVQUFULENBQW1COU0sS0FBbkIsQ0FBMEJDLEdBQTFCLENBQStCeGhCLElBQS9CLENBQXFDNlgsU0FBckMsQ0FBZ0QsQ0FDOUMsR0FBSWplLE9BQVEsQ0FBQyxDQUFiLENBQ0l2TCxPQUFTMHZCLFVBQVVaLFdBQVcsQ0FBQ3FFLElBQU1ELEtBQVAsR0FBaUJ2aEIsTUFBUSxDQUF6QixDQUFYLENBQVYsQ0FBbUQsQ0FBbkQsQ0FEYixDQUVJeVcsT0FBUzljLE1BQU10TCxNQUFOLENBRmIsQ0FJQSxNQUFPQSxRQUFQLENBQWlCLENBQ2Zvb0IsT0FBT29CLFVBQVl4cEIsTUFBWixDQUFxQixFQUFFdUwsS0FBOUIsRUFBdUMybkIsS0FBdkMsQ0FDQUEsT0FBU3ZoQixJQUFULENBQ0QsQ0FDRCxNQUFPeVcsT0FBUCxDQUNELENBRUQ7Ozs7Ozs7T0FRQSxRQUFTNlgsV0FBVCxDQUFvQjcyQixNQUFwQixDQUE0QitnQixDQUE1QixDQUErQixDQUM3QixHQUFJL0IsUUFBUyxFQUFiLENBQ0EsR0FBSSxDQUFDaGYsTUFBRCxFQUFXK2dCLEVBQUksQ0FBZixFQUFvQkEsRUFBSXhNLGdCQUE1QixDQUE4QyxDQUM1QyxNQUFPeUssT0FBUCxDQUNELENBQ0Q7QUFDQTtBQUNBLEVBQUcsQ0FDRCxHQUFJK0IsRUFBSSxDQUFSLENBQVcsQ0FDVC9CLFFBQVVoZixNQUFWLENBQ0QsQ0FDRCtnQixFQUFJNkUsWUFBWTdFLEVBQUksQ0FBaEIsQ0FBSixDQUNBLEdBQUlBLENBQUosQ0FBTyxDQUNML2dCLFFBQVVBLE1BQVYsQ0FDRCxDQUNGLENBUkQsTUFRUytnQixDQVJULEVBVUEsTUFBTy9CLE9BQVAsQ0FDRCxDQUVEOzs7Ozs7O09BUUEsUUFBUzhYLFNBQVQsQ0FBa0I1WSxJQUFsQixDQUF3QjRMLEtBQXhCLENBQStCLENBQzdCQSxNQUFReEQsVUFBVXdELFFBQVV0eUIsU0FBVixDQUF1QjBtQixLQUFLdG5CLE1BQUwsQ0FBYyxDQUFyQyxDQUEwQ2t6QixLQUFwRCxDQUEyRCxDQUEzRCxDQUFSLENBQ0EsTUFBTyxXQUFXLENBQ2hCLEdBQUkxTCxNQUFPMlksU0FBWCxDQUNJNTBCLE1BQVEsQ0FBQyxDQURiLENBRUl2TCxPQUFTMHZCLFVBQVVsSSxLQUFLeG5CLE1BQUwsQ0FBY2t6QixLQUF4QixDQUErQixDQUEvQixDQUZiLENBR0l4TCxNQUFRcGMsTUFBTXRMLE1BQU4sQ0FIWixDQUtBLE1BQU8sRUFBRXVMLEtBQUYsQ0FBVXZMLE1BQWpCLENBQXlCLENBQ3ZCMG5CLE1BQU1uYyxLQUFOLEVBQWVpYyxLQUFLMEwsTUFBUTNuQixLQUFiLENBQWYsQ0FDRCxDQUNEQSxNQUFRLENBQUMsQ0FBVCxDQUNBLEdBQUk2MEIsV0FBWTkwQixNQUFNNG5CLE1BQVEsQ0FBZCxDQUFoQixDQUNBLE1BQU8sRUFBRTNuQixLQUFGLENBQVUybkIsS0FBakIsQ0FBd0IsQ0FDdEJrTixVQUFVNzBCLEtBQVYsRUFBbUJpYyxLQUFLamMsS0FBTCxDQUFuQixDQUNELENBQ0Q2MEIsVUFBVWxOLEtBQVYsRUFBbUJ4TCxLQUFuQixDQUNBLE1BQU9sTSxPQUFNOEwsSUFBTixDQUFZLElBQVosQ0FBa0I4WSxTQUFsQixDQUFQLENBQ0QsQ0FoQkQsQ0FpQkQsQ0FFRDs7Ozs7Ozs7O09BVUEsUUFBU0MsUUFBVCxDQUFpQnhXLE1BQWpCLENBQXlCb1EsSUFBekIsQ0FBK0J0L0IsS0FBL0IsQ0FBc0MyOEIsVUFBdEMsQ0FBa0QsQ0FDaEQsR0FBSSxDQUFDQyxTQUFTMU4sTUFBVCxDQUFMLENBQXVCLENBQ3JCLE1BQU9BLE9BQVAsQ0FDRCxDQUNEb1EsS0FBT0MsTUFBTUQsSUFBTixDQUFZcFEsTUFBWixFQUFzQixDQUFDb1EsSUFBRCxDQUF0QixDQUErQkUsU0FBU0YsSUFBVCxDQUF0QyxDQUVBLEdBQUkxdUIsT0FBUSxDQUFDLENBQWIsQ0FDSXZMLE9BQVNpNkIsS0FBS2o2QixNQURsQixDQUVJMHNCLFVBQVkxc0IsT0FBUyxDQUZ6QixDQUdJc2dDLE9BQVN6VyxNQUhiLENBS0EsTUFBT3lXLFFBQVUsSUFBVixFQUFrQixFQUFFLzBCLEtBQUYsQ0FBVXZMLE1BQW5DLENBQTJDLENBQ3pDLEdBQUl0RixLQUFNMC9CLE1BQU1ILEtBQUsxdUIsS0FBTCxDQUFOLENBQVYsQ0FDSXN6QixTQUFXbGtDLEtBRGYsQ0FHQSxHQUFJNFEsT0FBU21oQixTQUFiLENBQXdCLENBQ3RCLEdBQUl5SixVQUFXbUssT0FBTzVsQyxHQUFQLENBQWYsQ0FDQW1rQyxTQUFXdkgsV0FBYUEsV0FBV25CLFFBQVgsQ0FBcUJ6N0IsR0FBckIsQ0FBMEI0bEMsTUFBMUIsQ0FBYixDQUFpRDEvQixTQUE1RCxDQUNBLEdBQUlpK0IsV0FBYWorQixTQUFqQixDQUE0QixDQUMxQmkrQixTQUFXdEgsU0FBU3BCLFFBQVQsRUFDUEEsUUFETyxDQUVORixRQUFRZ0UsS0FBSzF1QixNQUFRLENBQWIsQ0FBUixFQUEyQixFQUEzQixDQUFnQyxFQUZyQyxDQUdELENBQ0YsQ0FDRGdyQixZQUFZK0osTUFBWixDQUFvQjVsQyxHQUFwQixDQUF5Qm1rQyxRQUF6QixFQUNBeUIsT0FBU0EsT0FBTzVsQyxHQUFQLENBQVQsQ0FDRCxDQUNELE1BQU9tdkIsT0FBUCxDQUNELENBRUQ7Ozs7Ozs7T0FRQSxHQUFJMFcsYUFBYyxDQUFDaFEsT0FBRCxDQUFXbU4sUUFBWCxDQUFzQixTQUFTcFcsSUFBVCxDQUFlanFCLElBQWYsQ0FBcUIsQ0FDM0RrekIsUUFBUTkxQixHQUFSLENBQVk2c0IsSUFBWixDQUFrQmpxQixJQUFsQixFQUNBLE1BQU9pcUIsS0FBUCxDQUNELENBSEQsQ0FLQTs7Ozs7Ozs7T0FTQSxRQUFTa1osVUFBVCxDQUFtQjlZLEtBQW5CLENBQTBCd0wsS0FBMUIsQ0FBaUNDLEdBQWpDLENBQXNDLENBQ3BDLEdBQUk1bkIsT0FBUSxDQUFDLENBQWIsQ0FDSXZMLE9BQVMwbkIsTUFBTTFuQixNQURuQixDQUdBLEdBQUlrekIsTUFBUSxDQUFaLENBQWUsQ0FDYkEsTUFBUSxDQUFDQSxLQUFELENBQVNsekIsTUFBVCxDQUFrQixDQUFsQixDQUF1QkEsT0FBU2t6QixLQUF4QyxDQUNELENBQ0RDLElBQU1BLElBQU1uekIsTUFBTixDQUFlQSxNQUFmLENBQXdCbXpCLEdBQTlCLENBQ0EsR0FBSUEsSUFBTSxDQUFWLENBQWEsQ0FDWEEsS0FBT256QixNQUFQLENBQ0QsQ0FDREEsT0FBU2t6QixNQUFRQyxHQUFSLENBQWMsQ0FBZCxDQUFvQkEsSUFBTUQsS0FBUCxHQUFrQixDQUE5QyxDQUNBQSxTQUFXLENBQVgsQ0FFQSxHQUFJOUssUUFBUzljLE1BQU10TCxNQUFOLENBQWIsQ0FDQSxNQUFPLEVBQUV1TCxLQUFGLENBQVV2TCxNQUFqQixDQUF5QixDQUN2Qm9vQixPQUFPN2MsS0FBUCxFQUFnQm1jLE1BQU1uYyxNQUFRMm5CLEtBQWQsQ0FBaEIsQ0FDRCxDQUNELE1BQU85SyxPQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7T0FTQSxRQUFTcVksU0FBVCxDQUFrQnJYLFVBQWxCLENBQThCbkIsU0FBOUIsQ0FBeUMsQ0FDdkMsR0FBSUcsT0FBSixDQUVBcU8sU0FBU3JOLFVBQVQsQ0FBcUIsU0FBU3p1QixLQUFULENBQWdCNFEsS0FBaEIsQ0FBdUI2ZCxVQUF2QixDQUFtQyxDQUN0RGhCLE9BQVNILFVBQVV0dEIsS0FBVixDQUFpQjRRLEtBQWpCLENBQXdCNmQsVUFBeEIsQ0FBVCxDQUNBLE1BQU8sQ0FBQ2hCLE1BQVIsQ0FDRCxDQUhELEVBSUEsTUFBTyxDQUFDLENBQUNBLE1BQVQsQ0FDRCxDQUVEOzs7Ozs7Ozs7OztPQVlBLFFBQVNzWSxnQkFBVCxDQUF5QmhaLEtBQXpCLENBQWdDL3NCLEtBQWhDLENBQXVDZ21DLFVBQXZDLENBQW1ELENBQ2pELEdBQUlDLEtBQU0sQ0FBVixDQUNJQyxLQUFPblosTUFBUUEsTUFBTTFuQixNQUFkLENBQXVCNGdDLEdBRGxDLENBR0EsR0FBSSxNQUFPam1DLE1BQVAsRUFBZ0IsUUFBaEIsRUFBNEJBLFFBQVVBLEtBQXRDLEVBQStDa21DLE1BQVE3aUIscUJBQTNELENBQWtGLENBQ2hGLE1BQU80aUIsSUFBTUMsSUFBYixDQUFtQixDQUNqQixHQUFJajlCLEtBQU9nOUIsSUFBTUMsSUFBUCxHQUFpQixDQUEzQixDQUNJbk4sU0FBV2hNLE1BQU05akIsR0FBTixDQURmLENBR0EsR0FBSTh2QixXQUFhLElBQWIsRUFBcUIsQ0FBQ3dGLFNBQVN4RixRQUFULENBQXRCLEdBQ0NpTixXQUFjak4sVUFBWS80QixLQUExQixDQUFvQys0QixTQUFXLzRCLEtBRGhELENBQUosQ0FDNkQsQ0FDM0RpbUMsSUFBTWg5QixJQUFNLENBQVosQ0FDRCxDQUhELElBR08sQ0FDTGk5QixLQUFPajlCLEdBQVAsQ0FDRCxDQUNGLENBQ0QsTUFBT2k5QixLQUFQLENBQ0QsQ0FDRCxNQUFPQyxtQkFBa0JwWixLQUFsQixDQUF5Qi9zQixLQUF6QixDQUFnQytpQyxRQUFoQyxDQUEwQ2lELFVBQTFDLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7T0FhQSxRQUFTRyxrQkFBVCxDQUEyQnBaLEtBQTNCLENBQWtDL3NCLEtBQWxDLENBQXlDaXRCLFFBQXpDLENBQW1EK1ksVUFBbkQsQ0FBK0QsQ0FDN0RobUMsTUFBUWl0QixTQUFTanRCLEtBQVQsQ0FBUixDQUVBLEdBQUlpbUMsS0FBTSxDQUFWLENBQ0lDLEtBQU9uWixNQUFRQSxNQUFNMW5CLE1BQWQsQ0FBdUIsQ0FEbEMsQ0FFSStnQyxTQUFXcG1DLFFBQVVBLEtBRnpCLENBR0lxbUMsVUFBWXJtQyxRQUFVLElBSDFCLENBSUlzbUMsWUFBYy9ILFNBQVN2K0IsS0FBVCxDQUpsQixDQUtJdW1DLGVBQWlCdm1DLFFBQVVpRyxTQUwvQixDQU9BLE1BQU9nZ0MsSUFBTUMsSUFBYixDQUFtQixDQUNqQixHQUFJajlCLEtBQU1vckIsWUFBWSxDQUFDNFIsSUFBTUMsSUFBUCxFQUFlLENBQTNCLENBQVYsQ0FDSW5OLFNBQVc5TCxTQUFTRixNQUFNOWpCLEdBQU4sQ0FBVCxDQURmLENBRUl1OUIsYUFBZXpOLFdBQWE5eUIsU0FGaEMsQ0FHSXdnQyxVQUFZMU4sV0FBYSxJQUg3QixDQUlJMk4sZUFBaUIzTixXQUFhQSxRQUpsQyxDQUtJNE4sWUFBY3BJLFNBQVN4RixRQUFULENBTGxCLENBT0EsR0FBSXFOLFFBQUosQ0FBYyxDQUNaLEdBQUlRLFFBQVNaLFlBQWNVLGNBQTNCLENBQ0QsQ0FGRCxJQUVPLElBQUlILGNBQUosQ0FBb0IsQ0FDekJLLE9BQVNGLGlCQUFtQlYsWUFBY1EsWUFBakMsQ0FBVCxDQUNELENBRk0sSUFFQSxJQUFJSCxTQUFKLENBQWUsQ0FDcEJPLE9BQVNGLGdCQUFrQkYsWUFBbEIsR0FBbUNSLFlBQWMsQ0FBQ1MsU0FBbEQsQ0FBVCxDQUNELENBRk0sSUFFQSxJQUFJSCxXQUFKLENBQWlCLENBQ3RCTSxPQUFTRixnQkFBa0JGLFlBQWxCLEVBQWtDLENBQUNDLFNBQW5DLEdBQWlEVCxZQUFjLENBQUNXLFdBQWhFLENBQVQsQ0FDRCxDQUZNLElBRUEsSUFBSUYsV0FBYUUsV0FBakIsQ0FBOEIsQ0FDbkNDLE9BQVMsS0FBVCxDQUNELENBRk0sSUFFQSxDQUNMQSxPQUFTWixXQUFjak4sVUFBWS80QixLQUExQixDQUFvQys0QixTQUFXLzRCLEtBQXhELENBQ0QsQ0FDRCxHQUFJNG1DLE1BQUosQ0FBWSxDQUNWWCxJQUFNaDlCLElBQU0sQ0FBWixDQUNELENBRkQsSUFFTyxDQUNMaTlCLEtBQU9qOUIsR0FBUCxDQUNELENBQ0YsQ0FDRCxNQUFPK3JCLFdBQVVrUixJQUFWLENBQWdCOWlCLGVBQWhCLENBQVAsQ0FDRCxDQUVEOzs7Ozs7OztPQVNBLFFBQVN5akIsZUFBVCxDQUF3QjlaLEtBQXhCLENBQStCRSxRQUEvQixDQUF5QyxDQUN2QyxHQUFJcmMsT0FBUSxDQUFDLENBQWIsQ0FDSXZMLE9BQVMwbkIsTUFBTTFuQixNQURuQixDQUVJbW9CLFNBQVcsQ0FGZixDQUdJQyxPQUFTLEVBSGIsQ0FLQSxNQUFPLEVBQUU3YyxLQUFGLENBQVV2TCxNQUFqQixDQUF5QixDQUN2QixHQUFJckYsT0FBUStzQixNQUFNbmMsS0FBTixDQUFaLENBQ0ltb0IsU0FBVzlMLFNBQVdBLFNBQVNqdEIsS0FBVCxDQUFYLENBQTZCQSxLQUQ1QyxDQUdBLEdBQUksQ0FBQzRRLEtBQUQsRUFBVSxDQUFDOHFCLEdBQUczQyxRQUFILENBQWEySCxJQUFiLENBQWYsQ0FBbUMsQ0FDakMsR0FBSUEsTUFBTzNILFFBQVgsQ0FDQXRMLE9BQU9ELFVBQVAsRUFBcUJ4dEIsUUFBVSxDQUFWLENBQWMsQ0FBZCxDQUFrQkEsS0FBdkMsQ0FDRCxDQUNGLENBQ0QsTUFBT3l0QixPQUFQLENBQ0QsQ0FFRDs7Ozs7OztPQVFBLFFBQVNxWixhQUFULENBQXNCOW1DLEtBQXRCLENBQTZCLENBQzNCLEdBQUksTUFBT0EsTUFBUCxFQUFnQixRQUFwQixDQUE4QixDQUM1QixNQUFPQSxNQUFQLENBQ0QsQ0FDRCxHQUFJdStCLFNBQVN2K0IsS0FBVCxDQUFKLENBQXFCLENBQ25CLE1BQU9rakIsSUFBUCxDQUNELENBQ0QsTUFBTyxDQUFDbGpCLEtBQVIsQ0FDRCxDQUVEOzs7Ozs7O09BUUEsUUFBUyttQyxhQUFULENBQXNCL21DLEtBQXRCLENBQTZCLENBQzNCO0FBQ0EsR0FBSSxNQUFPQSxNQUFQLEVBQWdCLFFBQXBCLENBQThCLENBQzVCLE1BQU9BLE1BQVAsQ0FDRCxDQUNELEdBQUl1K0IsU0FBU3YrQixLQUFULENBQUosQ0FBcUIsQ0FDbkIsTUFBT3cyQixnQkFBaUJBLGVBQWV6YixJQUFmLENBQW9CL2EsS0FBcEIsQ0FBakIsQ0FBOEMsRUFBckQsQ0FDRCxDQUNELEdBQUl5dEIsUUFBVXp0QixNQUFRLEVBQXRCLENBQ0EsTUFBUXl0QixTQUFVLEdBQVYsRUFBa0IsRUFBSXp0QixLQUFMLEVBQWUsQ0FBQytpQixRQUFsQyxDQUE4QyxJQUE5QyxDQUFxRDBLLE1BQTVELENBQ0QsQ0FFRDs7Ozs7Ozs7T0FTQSxRQUFTdVosU0FBVCxDQUFrQmphLEtBQWxCLENBQXlCRSxRQUF6QixDQUFtQ1ksVUFBbkMsQ0FBK0MsQ0FDN0MsR0FBSWpkLE9BQVEsQ0FBQyxDQUFiLENBQ0lpdEIsU0FBV25RLGFBRGYsQ0FFSXJvQixPQUFTMG5CLE1BQU0xbkIsTUFGbkIsQ0FHSXk0QixTQUFXLElBSGYsQ0FJSXJRLE9BQVMsRUFKYixDQUtJaVQsS0FBT2pULE1BTFgsQ0FPQSxHQUFJSSxVQUFKLENBQWdCLENBQ2RpUSxTQUFXLEtBQVgsQ0FDQUQsU0FBV2pRLGlCQUFYLENBQ0QsQ0FIRCxJQUlLLElBQUl2b0IsUUFBVW1jLGdCQUFkLENBQWdDLENBQ25DLEdBQUkxaEIsS0FBTW10QixTQUFXLElBQVgsQ0FBa0JnYSxVQUFVbGEsS0FBVixDQUE1QixDQUNBLEdBQUlqdEIsR0FBSixDQUFTLENBQ1AsTUFBTzB4QixZQUFXMXhCLEdBQVgsQ0FBUCxDQUNELENBQ0RnK0IsU0FBVyxLQUFYLENBQ0FELFNBQVdoTyxRQUFYLENBQ0E2USxLQUFPLEdBQUlsRyxTQUFKLEVBQVAsQ0FDRCxDQVJJLElBU0EsQ0FDSGtHLEtBQU96VCxTQUFXLEVBQVgsQ0FBZ0JRLE1BQXZCLENBQ0QsQ0FDRG9MLE1BQ0EsTUFBTyxFQUFFam9CLEtBQUYsQ0FBVXZMLE1BQWpCLENBQXlCLENBQ3ZCLEdBQUlyRixPQUFRK3NCLE1BQU1uYyxLQUFOLENBQVosQ0FDSW1vQixTQUFXOUwsU0FBV0EsU0FBU2p0QixLQUFULENBQVgsQ0FBNkJBLEtBRDVDLENBR0FBLE1BQVM2dEIsWUFBYzd0QixRQUFVLENBQXpCLENBQThCQSxLQUE5QixDQUFzQyxDQUE5QyxDQUNBLEdBQUk4OUIsVUFBWS9FLFdBQWFBLFFBQTdCLENBQXVDLENBQ3JDLEdBQUltTyxXQUFZeEcsS0FBS3I3QixNQUFyQixDQUNBLE1BQU82aEMsV0FBUCxDQUFvQixDQUNsQixHQUFJeEcsS0FBS3dHLFNBQUwsSUFBb0JuTyxRQUF4QixDQUFrQyxDQUNoQyxRQUFTRixNQUFULENBQ0QsQ0FDRixDQUNELEdBQUk1TCxRQUFKLENBQWMsQ0FDWnlULEtBQUs1M0IsSUFBTCxDQUFVaXdCLFFBQVYsRUFDRCxDQUNEdEwsT0FBTzNrQixJQUFQLENBQVk5SSxLQUFaLEVBQ0QsQ0FYRCxJQVlLLElBQUksQ0FBQzY5QixTQUFTNkMsSUFBVCxDQUFlM0gsUUFBZixDQUF5QmxMLFVBQXpCLENBQUwsQ0FBMkMsQ0FDOUMsR0FBSTZTLE9BQVNqVCxNQUFiLENBQXFCLENBQ25CaVQsS0FBSzUzQixJQUFMLENBQVVpd0IsUUFBVixFQUNELENBQ0R0TCxPQUFPM2tCLElBQVAsQ0FBWTlJLEtBQVosRUFDRCxDQUNGLENBQ0QsTUFBT3l0QixPQUFQLENBQ0QsQ0FFRDs7Ozs7OztPQVFBLFFBQVMwWixVQUFULENBQW1CalksTUFBbkIsQ0FBMkJvUSxJQUEzQixDQUFpQyxDQUMvQkEsS0FBT0MsTUFBTUQsSUFBTixDQUFZcFEsTUFBWixFQUFzQixDQUFDb1EsSUFBRCxDQUF0QixDQUErQkUsU0FBU0YsSUFBVCxDQUF0QyxDQUNBcFEsT0FBUzJSLE9BQU8zUixNQUFQLENBQWVvUSxJQUFmLENBQVQsQ0FFQSxHQUFJdi9CLEtBQU0wL0IsTUFBTXFCLEtBQUt4QixJQUFMLENBQU4sQ0FBVixDQUNBLE1BQU8sRUFBRXBRLFFBQVUsSUFBVixFQUFrQjhELGVBQWVqWSxJQUFmLENBQW9CbVUsTUFBcEIsQ0FBNEJudkIsR0FBNUIsQ0FBcEIsR0FBeUQsTUFBT212QixRQUFPbnZCLEdBQVAsQ0FBdkUsQ0FDRCxDQUVEOzs7Ozs7Ozs7T0FVQSxRQUFTcW5DLFdBQVQsQ0FBb0JsWSxNQUFwQixDQUE0Qm9RLElBQTVCLENBQWtDK0gsT0FBbEMsQ0FBMkMxSyxVQUEzQyxDQUF1RCxDQUNyRCxNQUFPK0ksU0FBUXhXLE1BQVIsQ0FBZ0JvUSxJQUFoQixDQUFzQitILFFBQVFoSSxRQUFRblEsTUFBUixDQUFnQm9RLElBQWhCLENBQVIsQ0FBdEIsQ0FBc0QzQyxVQUF0RCxDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7OztPQVdBLFFBQVMySyxVQUFULENBQW1CdmEsS0FBbkIsQ0FBMEJPLFNBQTFCLENBQXFDaWEsTUFBckMsQ0FBNkMxWSxTQUE3QyxDQUF3RCxDQUN0RCxHQUFJeHBCLFFBQVMwbkIsTUFBTTFuQixNQUFuQixDQUNJdUwsTUFBUWllLFVBQVl4cEIsTUFBWixDQUFxQixDQUFDLENBRGxDLENBR0EsTUFBTyxDQUFDd3BCLFVBQVlqZSxPQUFaLENBQXNCLEVBQUVBLEtBQUYsQ0FBVXZMLE1BQWpDLEdBQ0xpb0IsVUFBVVAsTUFBTW5jLEtBQU4sQ0FBVixDQUF3QkEsS0FBeEIsQ0FBK0JtYyxLQUEvQixDQURGLENBQ3lDLENBQUUsQ0FFM0MsTUFBT3dhLFFBQ0gxQixVQUFVOVksS0FBVixDQUFrQjhCLFVBQVksQ0FBWixDQUFnQmplLEtBQWxDLENBQTJDaWUsVUFBWWplLE1BQVEsQ0FBcEIsQ0FBd0J2TCxNQUFuRSxDQURHLENBRUh3Z0MsVUFBVTlZLEtBQVYsQ0FBa0I4QixVQUFZamUsTUFBUSxDQUFwQixDQUF3QixDQUExQyxDQUErQ2llLFVBQVl4cEIsTUFBWixDQUFxQnVMLEtBQXBFLENBRkosQ0FHRCxDQUVEOzs7Ozs7Ozs7T0FVQSxRQUFTZ29CLGlCQUFULENBQTBCNTRCLEtBQTFCLENBQWlDd25DLE9BQWpDLENBQTBDLENBQ3hDLEdBQUkvWixRQUFTenRCLEtBQWIsQ0FDQSxHQUFJeXRCLGlCQUFrQmtKLFlBQXRCLENBQW1DLENBQ2pDbEosT0FBU0EsT0FBT3p0QixLQUFQLEVBQVQsQ0FDRCxDQUNELE1BQU9ndUIsYUFBWXdaLE9BQVosQ0FBcUIsU0FBUy9aLE1BQVQsQ0FBaUJoa0IsTUFBakIsQ0FBeUIsQ0FDbkQsTUFBT0EsUUFBT2tqQixJQUFQLENBQVk5TCxLQUFaLENBQWtCcFgsT0FBT21qQixPQUF6QixDQUFrQ21CLFVBQVUsQ0FBQ04sTUFBRCxDQUFWLENBQW9CaGtCLE9BQU9vakIsSUFBM0IsQ0FBbEMsQ0FBUCxDQUNELENBRk0sQ0FFSlksTUFGSSxDQUFQLENBR0QsQ0FFRDs7Ozs7Ozs7O09BVUEsUUFBU2dhLFFBQVQsQ0FBaUJySCxNQUFqQixDQUF5Qm5ULFFBQXpCLENBQW1DWSxVQUFuQyxDQUErQyxDQUM3QyxHQUFJamQsT0FBUSxDQUFDLENBQWIsQ0FDSXZMLE9BQVMrNkIsT0FBTy82QixNQURwQixDQUdBLE1BQU8sRUFBRXVMLEtBQUYsQ0FBVXZMLE1BQWpCLENBQXlCLENBQ3ZCLEdBQUlvb0IsUUFBU0EsT0FDVE0sVUFDRTZQLGVBQWVuUSxNQUFmLENBQXVCMlMsT0FBT3h2QixLQUFQLENBQXZCLENBQXNDcWMsUUFBdEMsQ0FBZ0RZLFVBQWhELENBREYsQ0FFRStQLGVBQWV3QyxPQUFPeHZCLEtBQVAsQ0FBZixDQUE4QjZjLE1BQTlCLENBQXNDUixRQUF0QyxDQUFnRFksVUFBaEQsQ0FGRixDQURTLENBS1R1UyxPQUFPeHZCLEtBQVAsQ0FMSixDQU1ELENBQ0QsTUFBUTZjLFNBQVVBLE9BQU9wb0IsTUFBbEIsQ0FBNEIyaEMsU0FBU3ZaLE1BQVQsQ0FBaUJSLFFBQWpCLENBQTJCWSxVQUEzQixDQUE1QixDQUFxRSxFQUE1RSxDQUNELENBRUQ7Ozs7Ozs7O09BU0EsUUFBUzZaLGNBQVQsQ0FBdUJoWSxLQUF2QixDQUE4QjdVLE1BQTlCLENBQXNDOHNCLFVBQXRDLENBQWtELENBQ2hELEdBQUkvMkIsT0FBUSxDQUFDLENBQWIsQ0FDSXZMLE9BQVNxcUIsTUFBTXJxQixNQURuQixDQUVJdWlDLFdBQWEvc0IsT0FBT3hWLE1BRnhCLENBR0lvb0IsT0FBUyxFQUhiLENBS0EsTUFBTyxFQUFFN2MsS0FBRixDQUFVdkwsTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSXJGLE9BQVE0USxNQUFRZzNCLFVBQVIsQ0FBcUIvc0IsT0FBT2pLLEtBQVAsQ0FBckIsQ0FBcUMzSyxTQUFqRCxDQUNBMGhDLFdBQVdsYSxNQUFYLENBQW1CaUMsTUFBTTllLEtBQU4sQ0FBbkIsQ0FBaUM1USxLQUFqQyxFQUNELENBQ0QsTUFBT3l0QixPQUFQLENBQ0QsQ0FFRDs7Ozs7O09BT0EsUUFBU29hLG9CQUFULENBQTZCN25DLEtBQTdCLENBQW9DLENBQ2xDLE1BQU9va0MsbUJBQWtCcGtDLEtBQWxCLEVBQTJCQSxLQUEzQixDQUFtQyxFQUExQyxDQUNELENBRUQ7Ozs7OztPQU9BLFFBQVM4bkMsYUFBVCxDQUFzQjluQyxLQUF0QixDQUE2QixDQUMzQixNQUFPLE9BQU9BLE1BQVAsRUFBZ0IsVUFBaEIsQ0FBNkJBLEtBQTdCLENBQXFDK2lDLFFBQTVDLENBQ0QsQ0FFRDs7Ozs7O09BT0EsUUFBU3ZELFNBQVQsQ0FBa0J4L0IsS0FBbEIsQ0FBeUIsQ0FDdkIsTUFBTzhlLFNBQVE5ZSxLQUFSLEVBQWlCQSxLQUFqQixDQUF5QituQyxhQUFhL25DLEtBQWIsQ0FBaEMsQ0FDRCxDQUVEOzs7Ozs7OztPQVNBLFFBQVNnb0MsVUFBVCxDQUFtQmpiLEtBQW5CLENBQTBCd0wsS0FBMUIsQ0FBaUNDLEdBQWpDLENBQXNDLENBQ3BDLEdBQUluekIsUUFBUzBuQixNQUFNMW5CLE1BQW5CLENBQ0FtekIsSUFBTUEsTUFBUXZ5QixTQUFSLENBQW9CWixNQUFwQixDQUE2Qm16QixHQUFuQyxDQUNBLE1BQVEsQ0FBQ0QsS0FBRCxFQUFVQyxLQUFPbnpCLE1BQWxCLENBQTRCMG5CLEtBQTVCLENBQW9DOFksVUFBVTlZLEtBQVYsQ0FBaUJ3TCxLQUFqQixDQUF3QkMsR0FBeEIsQ0FBM0MsQ0FDRCxDQUVEOzs7OztPQU1BLEdBQUl6a0IsY0FBZWlnQixpQkFBbUIsU0FBUzV3QixFQUFULENBQWEsQ0FDakQsTUFBTzRuQixNQUFLalgsWUFBTCxDQUFrQjNRLEVBQWxCLENBQVAsQ0FDRCxDQUZELENBSUE7Ozs7Ozs7T0FRQSxRQUFTNDVCLFlBQVQsQ0FBcUJpTCxNQUFyQixDQUE2QnhMLE1BQTdCLENBQXFDLENBQ25DLEdBQUlBLE1BQUosQ0FBWSxDQUNWLE1BQU93TCxRQUFPQyxLQUFQLEVBQVAsQ0FDRCxDQUNELEdBQUl6YSxRQUFTLEdBQUl3YSxRQUFPdG5DLFdBQVgsQ0FBdUJzbkMsT0FBTzVpQyxNQUE5QixDQUFiLENBQ0E0aUMsT0FBT0UsSUFBUCxDQUFZMWEsTUFBWixFQUNBLE1BQU9BLE9BQVAsQ0FDRCxDQUVEOzs7Ozs7T0FPQSxRQUFTMmEsaUJBQVQsQ0FBMEJDLFdBQTFCLENBQXVDLENBQ3JDLEdBQUk1YSxRQUFTLEdBQUk0YSxhQUFZMW5DLFdBQWhCLENBQTRCMG5DLFlBQVlDLFVBQXhDLENBQWIsQ0FDQSxHQUFJOVUsV0FBSixDQUFlL0YsTUFBZixFQUF1QjN0QixHQUF2QixDQUEyQixHQUFJMHpCLFdBQUosQ0FBZTZVLFdBQWYsQ0FBM0IsRUFDQSxNQUFPNWEsT0FBUCxDQUNELENBRUQ7Ozs7Ozs7T0FRQSxRQUFTOGEsY0FBVCxDQUF1QkMsUUFBdkIsQ0FBaUMvTCxNQUFqQyxDQUF5QyxDQUN2QyxHQUFJd0wsUUFBU3hMLE9BQVMyTCxpQkFBaUJJLFNBQVNQLE1BQTFCLENBQVQsQ0FBNkNPLFNBQVNQLE1BQW5FLENBQ0EsTUFBTyxJQUFJTyxVQUFTN25DLFdBQWIsQ0FBeUJzbkMsTUFBekIsQ0FBaUNPLFNBQVNDLFVBQTFDLENBQXNERCxTQUFTRixVQUEvRCxDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7T0FTQSxRQUFTSSxTQUFULENBQWtCcjFCLEdBQWxCLENBQXVCb3BCLE1BQXZCLENBQStCa00sU0FBL0IsQ0FBMEMsQ0FDeEMsR0FBSTViLE9BQVEwUCxPQUFTa00sVUFBVXpYLFdBQVc3ZCxHQUFYLENBQVYsQ0FBMkIsSUFBM0IsQ0FBVCxDQUE0QzZkLFdBQVc3ZCxHQUFYLENBQXhELENBQ0EsTUFBTzJhLGFBQVlqQixLQUFaLENBQW1CUixXQUFuQixDQUFnQyxHQUFJbFosS0FBSTFTLFdBQVIsRUFBaEMsQ0FBUCxDQUNELENBRUQ7Ozs7OztPQU9BLFFBQVNpb0MsWUFBVCxDQUFxQkMsTUFBckIsQ0FBNkIsQ0FDM0IsR0FBSXBiLFFBQVMsR0FBSW9iLFFBQU9sb0MsV0FBWCxDQUF1QmtvQyxPQUFPbmpCLE1BQTlCLENBQXNDb0IsUUFBUThMLElBQVIsQ0FBYWlXLE1BQWIsQ0FBdEMsQ0FBYixDQUNBcGIsT0FBT3NFLFNBQVAsQ0FBbUI4VyxPQUFPOVcsU0FBMUIsQ0FDQSxNQUFPdEUsT0FBUCxDQUNELENBRUQ7Ozs7Ozs7O09BU0EsUUFBU3FiLFNBQVQsQ0FBa0JocEMsR0FBbEIsQ0FBdUIyOEIsTUFBdkIsQ0FBK0JrTSxTQUEvQixDQUEwQyxDQUN4QyxHQUFJNWIsT0FBUTBQLE9BQVNrTSxVQUFVblgsV0FBVzF4QixHQUFYLENBQVYsQ0FBMkIsSUFBM0IsQ0FBVCxDQUE0QzB4QixXQUFXMXhCLEdBQVgsQ0FBeEQsQ0FDQSxNQUFPa3VCLGFBQVlqQixLQUFaLENBQW1CTixXQUFuQixDQUFnQyxHQUFJM3NCLEtBQUlhLFdBQVIsRUFBaEMsQ0FBUCxDQUNELENBRUQ7Ozs7OztPQU9BLFFBQVNvb0MsWUFBVCxDQUFxQkMsTUFBckIsQ0FBNkIsQ0FDM0IsTUFBTzFTLGVBQWdCaHFCLE9BQU9ncUIsY0FBY3ZiLElBQWQsQ0FBbUJpdUIsTUFBbkIsQ0FBUCxDQUFoQixDQUFxRCxFQUE1RCxDQUNELENBRUQ7Ozs7Ozs7T0FRQSxRQUFTQyxnQkFBVCxDQUF5QkMsVUFBekIsQ0FBcUN6TSxNQUFyQyxDQUE2QyxDQUMzQyxHQUFJd0wsUUFBU3hMLE9BQVMyTCxpQkFBaUJjLFdBQVdqQixNQUE1QixDQUFULENBQStDaUIsV0FBV2pCLE1BQXZFLENBQ0EsTUFBTyxJQUFJaUIsWUFBV3ZvQyxXQUFmLENBQTJCc25DLE1BQTNCLENBQW1DaUIsV0FBV1QsVUFBOUMsQ0FBMERTLFdBQVc3akMsTUFBckUsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7T0FRQSxRQUFTOGpDLGlCQUFULENBQTBCbnBDLEtBQTFCLENBQWlDKy9CLEtBQWpDLENBQXdDLENBQ3RDLEdBQUkvL0IsUUFBVSsvQixLQUFkLENBQXFCLENBQ25CLEdBQUlxSixjQUFlcHBDLFFBQVVpRyxTQUE3QixDQUNJb2dDLFVBQVlybUMsUUFBVSxJQUQxQixDQUVJcXBDLGVBQWlCcnBDLFFBQVVBLEtBRi9CLENBR0lzbUMsWUFBYy9ILFNBQVN2K0IsS0FBVCxDQUhsQixDQUtBLEdBQUl3bUMsY0FBZXpHLFFBQVU5NUIsU0FBN0IsQ0FDSXdnQyxVQUFZMUcsUUFBVSxJQUQxQixDQUVJMkcsZUFBaUIzRyxRQUFVQSxLQUYvQixDQUdJNEcsWUFBY3BJLFNBQVN3QixLQUFULENBSGxCLENBS0EsR0FBSyxDQUFDMEcsU0FBRCxFQUFjLENBQUNFLFdBQWYsRUFBOEIsQ0FBQ0wsV0FBL0IsRUFBOEN0bUMsTUFBUSsvQixLQUF2RCxFQUNDdUcsYUFBZUUsWUFBZixFQUErQkUsY0FBL0IsRUFBaUQsQ0FBQ0QsU0FBbEQsRUFBK0QsQ0FBQ0UsV0FEakUsRUFFQ04sV0FBYUcsWUFBYixFQUE2QkUsY0FGOUIsRUFHQyxDQUFDMEMsWUFBRCxFQUFpQjFDLGNBSGxCLEVBSUEsQ0FBQzJDLGNBSkwsQ0FJcUIsQ0FDbkIsTUFBTyxFQUFQLENBQ0QsQ0FDRCxHQUFLLENBQUNoRCxTQUFELEVBQWMsQ0FBQ0MsV0FBZixFQUE4QixDQUFDSyxXQUEvQixFQUE4QzNtQyxNQUFRKy9CLEtBQXZELEVBQ0M0RyxhQUFleUMsWUFBZixFQUErQkMsY0FBL0IsRUFBaUQsQ0FBQ2hELFNBQWxELEVBQStELENBQUNDLFdBRGpFLEVBRUNHLFdBQWEyQyxZQUFiLEVBQTZCQyxjQUY5QixFQUdDLENBQUM3QyxZQUFELEVBQWlCNkMsY0FIbEIsRUFJQSxDQUFDM0MsY0FKTCxDQUlxQixDQUNuQixNQUFPLENBQUMsQ0FBUixDQUNELENBQ0YsQ0FDRCxNQUFPLEVBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7O09BY0EsUUFBUzlCLGdCQUFULENBQXlCMVYsTUFBekIsQ0FBaUM2USxLQUFqQyxDQUF3QzBFLE1BQXhDLENBQWdELENBQzlDLEdBQUk3ekIsT0FBUSxDQUFDLENBQWIsQ0FDSTA0QixZQUFjcGEsT0FBT3lWLFFBRHpCLENBRUk0RSxZQUFjeEosTUFBTTRFLFFBRnhCLENBR0l0L0IsT0FBU2lrQyxZQUFZamtDLE1BSHpCLENBSUlta0MsYUFBZS9FLE9BQU9wL0IsTUFKMUIsQ0FNQSxNQUFPLEVBQUV1TCxLQUFGLENBQVV2TCxNQUFqQixDQUF5QixDQUN2QixHQUFJb29CLFFBQVMwYixpQkFBaUJHLFlBQVkxNEIsS0FBWixDQUFqQixDQUFxQzI0QixZQUFZMzRCLEtBQVosQ0FBckMsQ0FBYixDQUNBLEdBQUk2YyxNQUFKLENBQVksQ0FDVixHQUFJN2MsT0FBUzQ0QixZQUFiLENBQTJCLENBQ3pCLE1BQU8vYixPQUFQLENBQ0QsQ0FDRCxHQUFJZ2MsT0FBUWhGLE9BQU83ekIsS0FBUCxDQUFaLENBQ0EsTUFBTzZjLFNBQVVnYyxPQUFTLE1BQVQsQ0FBa0IsQ0FBQyxDQUFuQixDQUF1QixDQUFqQyxDQUFQLENBQ0QsQ0FDRixDQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBT3ZhLFFBQU90ZSxLQUFQLENBQWVtdkIsTUFBTW52QixLQUE1QixDQUNELENBRUQ7Ozs7Ozs7Ozs7T0FXQSxRQUFTODRCLFlBQVQsQ0FBcUI3YyxJQUFyQixDQUEyQjhjLFFBQTNCLENBQXFDQyxPQUFyQyxDQUE4Q0MsU0FBOUMsQ0FBeUQsQ0FDdkQsR0FBSUMsV0FBWSxDQUFDLENBQWpCLENBQ0lDLFdBQWFsZCxLQUFLeG5CLE1BRHRCLENBRUkya0MsY0FBZ0JKLFFBQVF2a0MsTUFGNUIsQ0FHSTRrQyxVQUFZLENBQUMsQ0FIakIsQ0FJSUMsV0FBYVAsU0FBU3RrQyxNQUoxQixDQUtJOGtDLFlBQWNwVixVQUFVZ1YsV0FBYUMsYUFBdkIsQ0FBc0MsQ0FBdEMsQ0FMbEIsQ0FNSXZjLE9BQVM5YyxNQUFNdTVCLFdBQWFDLFdBQW5CLENBTmIsQ0FPSUMsWUFBYyxDQUFDUCxTQVBuQixDQVNBLE1BQU8sRUFBRUksU0FBRixDQUFjQyxVQUFyQixDQUFpQyxDQUMvQnpjLE9BQU93YyxTQUFQLEVBQW9CTixTQUFTTSxTQUFULENBQXBCLENBQ0QsQ0FDRCxNQUFPLEVBQUVILFNBQUYsQ0FBY0UsYUFBckIsQ0FBb0MsQ0FDbEMsR0FBSUksYUFBZU4sVUFBWUMsVUFBL0IsQ0FBMkMsQ0FDekN0YyxPQUFPbWMsUUFBUUUsU0FBUixDQUFQLEVBQTZCamQsS0FBS2lkLFNBQUwsQ0FBN0IsQ0FDRCxDQUNGLENBQ0QsTUFBT0ssYUFBUCxDQUFzQixDQUNwQjFjLE9BQU93YyxXQUFQLEVBQXNCcGQsS0FBS2lkLFdBQUwsQ0FBdEIsQ0FDRCxDQUNELE1BQU9yYyxPQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7OztPQVdBLFFBQVM0YyxpQkFBVCxDQUEwQnhkLElBQTFCLENBQWdDOGMsUUFBaEMsQ0FBMENDLE9BQTFDLENBQW1EQyxTQUFuRCxDQUE4RCxDQUM1RCxHQUFJQyxXQUFZLENBQUMsQ0FBakIsQ0FDSUMsV0FBYWxkLEtBQUt4bkIsTUFEdEIsQ0FFSWlsQyxhQUFlLENBQUMsQ0FGcEIsQ0FHSU4sY0FBZ0JKLFFBQVF2a0MsTUFINUIsQ0FJSWtsQyxXQUFhLENBQUMsQ0FKbEIsQ0FLSUMsWUFBY2IsU0FBU3RrQyxNQUwzQixDQU1JOGtDLFlBQWNwVixVQUFVZ1YsV0FBYUMsYUFBdkIsQ0FBc0MsQ0FBdEMsQ0FObEIsQ0FPSXZjLE9BQVM5YyxNQUFNdzVCLFlBQWNLLFdBQXBCLENBUGIsQ0FRSUosWUFBYyxDQUFDUCxTQVJuQixDQVVBLE1BQU8sRUFBRUMsU0FBRixDQUFjSyxXQUFyQixDQUFrQyxDQUNoQzFjLE9BQU9xYyxTQUFQLEVBQW9CamQsS0FBS2lkLFNBQUwsQ0FBcEIsQ0FDRCxDQUNELEdBQUlyNkIsUUFBU3E2QixTQUFiLENBQ0EsTUFBTyxFQUFFUyxVQUFGLENBQWVDLFdBQXRCLENBQW1DLENBQ2pDL2MsT0FBT2hlLE9BQVM4NkIsVUFBaEIsRUFBOEJaLFNBQVNZLFVBQVQsQ0FBOUIsQ0FDRCxDQUNELE1BQU8sRUFBRUQsWUFBRixDQUFpQk4sYUFBeEIsQ0FBdUMsQ0FDckMsR0FBSUksYUFBZU4sVUFBWUMsVUFBL0IsQ0FBMkMsQ0FDekN0YyxPQUFPaGUsT0FBU202QixRQUFRVSxZQUFSLENBQWhCLEVBQXlDemQsS0FBS2lkLFdBQUwsQ0FBekMsQ0FDRCxDQUNGLENBQ0QsTUFBT3JjLE9BQVAsQ0FDRCxDQUVEOzs7Ozs7O09BUUEsUUFBU29LLFVBQVQsQ0FBbUJuUyxNQUFuQixDQUEyQnFILEtBQTNCLENBQWtDLENBQ2hDLEdBQUluYyxPQUFRLENBQUMsQ0FBYixDQUNJdkwsT0FBU3FnQixPQUFPcmdCLE1BRHBCLENBR0EwbkIsUUFBVUEsTUFBUXBjLE1BQU10TCxNQUFOLENBQWxCLEVBQ0EsTUFBTyxFQUFFdUwsS0FBRixDQUFVdkwsTUFBakIsQ0FBeUIsQ0FDdkIwbkIsTUFBTW5jLEtBQU4sRUFBZThVLE9BQU85VSxLQUFQLENBQWYsQ0FDRCxDQUNELE1BQU9tYyxNQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7O09BVUEsUUFBU2lQLFdBQVQsQ0FBb0J0VyxNQUFwQixDQUE0QmdLLEtBQTVCLENBQW1DUixNQUFuQyxDQUEyQ3lOLFVBQTNDLENBQXVELENBQ3JEek4sU0FBV0EsT0FBUyxFQUFwQixFQUVBLEdBQUl0ZSxPQUFRLENBQUMsQ0FBYixDQUNJdkwsT0FBU3FxQixNQUFNcnFCLE1BRG5CLENBR0EsTUFBTyxFQUFFdUwsS0FBRixDQUFVdkwsTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSXRGLEtBQU0ydkIsTUFBTTllLEtBQU4sQ0FBVixDQUVBLEdBQUlzekIsVUFBV3ZILFdBQ1hBLFdBQVd6TixPQUFPbnZCLEdBQVAsQ0FBWCxDQUF3QjJsQixPQUFPM2xCLEdBQVAsQ0FBeEIsQ0FBcUNBLEdBQXJDLENBQTBDbXZCLE1BQTFDLENBQWtEeEosTUFBbEQsQ0FEVyxDQUVYemYsU0FGSixDQUlBMjFCLFlBQVkxTSxNQUFaLENBQW9CbnZCLEdBQXBCLENBQXlCbWtDLFdBQWFqK0IsU0FBYixDQUF5QnlmLE9BQU8zbEIsR0FBUCxDQUF6QixDQUF1Q21rQyxRQUFoRSxFQUNELENBQ0QsTUFBT2hWLE9BQVAsQ0FDRCxDQUVEOzs7Ozs7O09BUUEsUUFBU2dPLFlBQVQsQ0FBcUJ4WCxNQUFyQixDQUE2QndKLE1BQTdCLENBQXFDLENBQ25DLE1BQU84TSxZQUFXdFcsTUFBWCxDQUFtQitrQixXQUFXL2tCLE1BQVgsQ0FBbkIsQ0FBdUN3SixNQUF2QyxDQUFQLENBQ0QsQ0FFRDs7Ozs7OztPQVFBLFFBQVN3YixpQkFBVCxDQUEwQjFkLE1BQTFCLENBQWtDMmQsV0FBbEMsQ0FBK0MsQ0FDN0MsTUFBTyxVQUFTbGMsVUFBVCxDQUFxQnhCLFFBQXJCLENBQStCLENBQ3BDLEdBQUlOLE1BQU83TixRQUFRMlAsVUFBUixFQUFzQjNCLGVBQXRCLENBQXdDK08sY0FBbkQsQ0FDSTNPLFlBQWN5ZCxZQUFjQSxhQUFkLENBQThCLEVBRGhELENBR0EsTUFBT2hlLE1BQUs4QixVQUFMLENBQWlCekIsTUFBakIsQ0FBeUIwWCxZQUFZelgsUUFBWixDQUFzQixDQUF0QixDQUF6QixDQUFtREMsV0FBbkQsQ0FBUCxDQUNELENBTEQsQ0FNRCxDQUVEOzs7Ozs7T0FPQSxRQUFTMGQsZUFBVCxDQUF3QkMsUUFBeEIsQ0FBa0MsQ0FDaEMsTUFBT3RGLFVBQVMsU0FBU3JXLE1BQVQsQ0FBaUI0YixPQUFqQixDQUEwQixDQUN4QyxHQUFJbDZCLE9BQVEsQ0FBQyxDQUFiLENBQ0l2TCxPQUFTeWxDLFFBQVF6bEMsTUFEckIsQ0FFSXMzQixXQUFhdDNCLE9BQVMsQ0FBVCxDQUFheWxDLFFBQVF6bEMsT0FBUyxDQUFqQixDQUFiLENBQW1DWSxTQUZwRCxDQUdJOGtDLE1BQVExbEMsT0FBUyxDQUFULENBQWF5bEMsUUFBUSxDQUFSLENBQWIsQ0FBMEI3a0MsU0FIdEMsQ0FLQTAyQixXQUFja08sU0FBU3hsQyxNQUFULENBQWtCLENBQWxCLEVBQXVCLE1BQU9zM0IsV0FBUCxFQUFxQixVQUE3QyxFQUNSdDNCLFNBQVVzM0IsVUFERixFQUVUMTJCLFNBRkosQ0FJQSxHQUFJOGtDLE9BQVNDLGVBQWVGLFFBQVEsQ0FBUixDQUFmLENBQTJCQSxRQUFRLENBQVIsQ0FBM0IsQ0FBdUNDLEtBQXZDLENBQWIsQ0FBNEQsQ0FDMURwTyxXQUFhdDNCLE9BQVMsQ0FBVCxDQUFhWSxTQUFiLENBQXlCMDJCLFVBQXRDLENBQ0F0M0IsT0FBUyxDQUFULENBQ0QsQ0FDRDZwQixPQUFTNWlCLE9BQU80aUIsTUFBUCxDQUFULENBQ0EsTUFBTyxFQUFFdGUsS0FBRixDQUFVdkwsTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSXFnQixRQUFTb2xCLFFBQVFsNkIsS0FBUixDQUFiLENBQ0EsR0FBSThVLE1BQUosQ0FBWSxDQUNWbWxCLFNBQVMzYixNQUFULENBQWlCeEosTUFBakIsQ0FBeUI5VSxLQUF6QixDQUFnQytyQixVQUFoQyxFQUNELENBQ0YsQ0FDRCxNQUFPek4sT0FBUCxDQUNELENBdEJNLENBQVAsQ0F1QkQsQ0FFRDs7Ozs7OztPQVFBLFFBQVMrTyxlQUFULENBQXdCdlAsUUFBeEIsQ0FBa0NHLFNBQWxDLENBQTZDLENBQzNDLE1BQU8sVUFBU0osVUFBVCxDQUFxQnhCLFFBQXJCLENBQStCLENBQ3BDLEdBQUl3QixZQUFjLElBQWxCLENBQXdCLENBQ3RCLE1BQU9BLFdBQVAsQ0FDRCxDQUNELEdBQUksQ0FBQ2lWLFlBQVlqVixVQUFaLENBQUwsQ0FBOEIsQ0FDNUIsTUFBT0MsVUFBU0QsVUFBVCxDQUFxQnhCLFFBQXJCLENBQVAsQ0FDRCxDQUNELEdBQUk1bkIsUUFBU29wQixXQUFXcHBCLE1BQXhCLENBQ0l1TCxNQUFRaWUsVUFBWXhwQixNQUFaLENBQXFCLENBQUMsQ0FEbEMsQ0FFSTRsQyxTQUFXMytCLE9BQU9taUIsVUFBUCxDQUZmLENBSUEsTUFBUUksVUFBWWplLE9BQVosQ0FBc0IsRUFBRUEsS0FBRixDQUFVdkwsTUFBeEMsQ0FBaUQsQ0FDL0MsR0FBSTRuQixTQUFTZ2UsU0FBU3I2QixLQUFULENBQVQsQ0FBMEJBLEtBQTFCLENBQWlDcTZCLFFBQWpDLElBQStDLEtBQW5ELENBQTBELENBQ3hELE1BQ0QsQ0FDRixDQUNELE1BQU94YyxXQUFQLENBQ0QsQ0FqQkQsQ0FrQkQsQ0FFRDs7Ozs7O09BT0EsUUFBU3dRLGNBQVQsQ0FBdUJwUSxTQUF2QixDQUFrQyxDQUNoQyxNQUFPLFVBQVNLLE1BQVQsQ0FBaUJqQyxRQUFqQixDQUEyQjBTLFFBQTNCLENBQXFDLENBQzFDLEdBQUkvdUIsT0FBUSxDQUFDLENBQWIsQ0FDSXE2QixTQUFXMytCLE9BQU80aUIsTUFBUCxDQURmLENBRUlRLE1BQVFpUSxTQUFTelEsTUFBVCxDQUZaLENBR0k3cEIsT0FBU3FxQixNQUFNcnFCLE1BSG5CLENBS0EsTUFBT0EsUUFBUCxDQUFpQixDQUNmLEdBQUl0RixLQUFNMnZCLE1BQU1iLFVBQVl4cEIsTUFBWixDQUFxQixFQUFFdUwsS0FBN0IsQ0FBVixDQUNBLEdBQUlxYyxTQUFTZ2UsU0FBU2xyQyxHQUFULENBQVQsQ0FBd0JBLEdBQXhCLENBQTZCa3JDLFFBQTdCLElBQTJDLEtBQS9DLENBQXNELENBQ3BELE1BQ0QsQ0FDRixDQUNELE1BQU8vYixPQUFQLENBQ0QsQ0FiRCxDQWNELENBRUQ7Ozs7Ozs7OztPQVVBLFFBQVNnYyxXQUFULENBQW9CdmUsSUFBcEIsQ0FBMEJ1VSxPQUExQixDQUFtQ3RVLE9BQW5DLENBQTRDLENBQzFDLEdBQUl1ZSxRQUFTakssUUFBVXRmLFNBQXZCLENBQ0l3cEIsS0FBT0MsV0FBVzFlLElBQVgsQ0FEWCxDQUdBLFFBQVMyZSxRQUFULEVBQW1CLENBQ2pCLEdBQUl0ckIsSUFBTSxNQUFRLE9BQVNnTCxJQUFqQixFQUF5QixlQUFnQnNnQixRQUExQyxDQUFxREYsSUFBckQsQ0FBNER6ZSxJQUFyRSxDQUNBLE1BQU8zTSxJQUFHYSxLQUFILENBQVNzcUIsT0FBU3ZlLE9BQVQsQ0FBbUIsSUFBNUIsQ0FBa0M0WSxTQUFsQyxDQUFQLENBQ0QsQ0FDRCxNQUFPOEYsUUFBUCxDQUNELENBRUQ7Ozs7OztPQU9BLFFBQVNDLGdCQUFULENBQXlCQyxVQUF6QixDQUFxQyxDQUNuQyxNQUFPLFVBQVMvOEIsTUFBVCxDQUFpQixDQUN0QkEsT0FBU3FpQixTQUFTcmlCLE1BQVQsQ0FBVCxDQUVBLEdBQUl3aEIsWUFBYVUsV0FBV2xpQixNQUFYLEVBQ2JtakIsY0FBY25qQixNQUFkLENBRGEsQ0FFYnhJLFNBRkosQ0FJQSxHQUFJd3FCLEtBQU1SLFdBQ05BLFdBQVcsQ0FBWCxDQURNLENBRU54aEIsT0FBT2c5QixNQUFQLENBQWMsQ0FBZCxDQUZKLENBSUEsR0FBSUMsVUFBV3piLFdBQ1grWCxVQUFVL1gsVUFBVixDQUFzQixDQUF0QixFQUF5QjNjLElBQXpCLENBQThCLEVBQTlCLENBRFcsQ0FFWDdFLE9BQU95NUIsS0FBUCxDQUFhLENBQWIsQ0FGSixDQUlBLE1BQU96WCxLQUFJK2EsVUFBSixJQUFvQkUsUUFBM0IsQ0FDRCxDQWhCRCxDQWlCRCxDQUVEOzs7Ozs7T0FPQSxRQUFTQyxpQkFBVCxDQUEwQmxnQyxRQUExQixDQUFvQyxDQUNsQyxNQUFPLFVBQVNnRCxNQUFULENBQWlCLENBQ3RCLE1BQU91ZixhQUFZNGQsTUFBTUMsT0FBT3A5QixNQUFQLEVBQWV0RSxPQUFmLENBQXVCMGYsTUFBdkIsQ0FBK0IsRUFBL0IsQ0FBTixDQUFaLENBQXVEcGUsUUFBdkQsQ0FBaUUsRUFBakUsQ0FBUCxDQUNELENBRkQsQ0FHRCxDQUVEOzs7Ozs7O09BUUEsUUFBUzQvQixXQUFULENBQW9CRCxJQUFwQixDQUEwQixDQUN4QixNQUFPLFdBQVcsQ0FDaEI7QUFDQTtBQUNBO0FBQ0EsR0FBSXZlLE1BQU8yWSxTQUFYLENBQ0EsT0FBUTNZLEtBQUt4bkIsTUFBYixFQUNFLElBQUssRUFBTCxDQUFRLE1BQU8sSUFBSStsQyxLQUFKLEVBQVAsQ0FDUixJQUFLLEVBQUwsQ0FBUSxNQUFPLElBQUlBLEtBQUosQ0FBU3ZlLEtBQUssQ0FBTCxDQUFULENBQVAsQ0FDUixJQUFLLEVBQUwsQ0FBUSxNQUFPLElBQUl1ZSxLQUFKLENBQVN2ZSxLQUFLLENBQUwsQ0FBVCxDQUFrQkEsS0FBSyxDQUFMLENBQWxCLENBQVAsQ0FDUixJQUFLLEVBQUwsQ0FBUSxNQUFPLElBQUl1ZSxLQUFKLENBQVN2ZSxLQUFLLENBQUwsQ0FBVCxDQUFrQkEsS0FBSyxDQUFMLENBQWxCLENBQTJCQSxLQUFLLENBQUwsQ0FBM0IsQ0FBUCxDQUNSLElBQUssRUFBTCxDQUFRLE1BQU8sSUFBSXVlLEtBQUosQ0FBU3ZlLEtBQUssQ0FBTCxDQUFULENBQWtCQSxLQUFLLENBQUwsQ0FBbEIsQ0FBMkJBLEtBQUssQ0FBTCxDQUEzQixDQUFvQ0EsS0FBSyxDQUFMLENBQXBDLENBQVAsQ0FDUixJQUFLLEVBQUwsQ0FBUSxNQUFPLElBQUl1ZSxLQUFKLENBQVN2ZSxLQUFLLENBQUwsQ0FBVCxDQUFrQkEsS0FBSyxDQUFMLENBQWxCLENBQTJCQSxLQUFLLENBQUwsQ0FBM0IsQ0FBb0NBLEtBQUssQ0FBTCxDQUFwQyxDQUE2Q0EsS0FBSyxDQUFMLENBQTdDLENBQVAsQ0FDUixJQUFLLEVBQUwsQ0FBUSxNQUFPLElBQUl1ZSxLQUFKLENBQVN2ZSxLQUFLLENBQUwsQ0FBVCxDQUFrQkEsS0FBSyxDQUFMLENBQWxCLENBQTJCQSxLQUFLLENBQUwsQ0FBM0IsQ0FBb0NBLEtBQUssQ0FBTCxDQUFwQyxDQUE2Q0EsS0FBSyxDQUFMLENBQTdDLENBQXNEQSxLQUFLLENBQUwsQ0FBdEQsQ0FBUCxDQUNSLElBQUssRUFBTCxDQUFRLE1BQU8sSUFBSXVlLEtBQUosQ0FBU3ZlLEtBQUssQ0FBTCxDQUFULENBQWtCQSxLQUFLLENBQUwsQ0FBbEIsQ0FBMkJBLEtBQUssQ0FBTCxDQUEzQixDQUFvQ0EsS0FBSyxDQUFMLENBQXBDLENBQTZDQSxLQUFLLENBQUwsQ0FBN0MsQ0FBc0RBLEtBQUssQ0FBTCxDQUF0RCxDQUErREEsS0FBSyxDQUFMLENBQS9ELENBQVAsQ0FSVixDQVVBLEdBQUlpZixhQUFjeFUsV0FBVzhULEtBQUs3WSxTQUFoQixDQUFsQixDQUNJOUUsT0FBUzJkLEtBQUt2cUIsS0FBTCxDQUFXaXJCLFdBQVgsQ0FBd0JqZixJQUF4QixDQURiLENBR0E7QUFDQTtBQUNBLE1BQU8rUCxVQUFTblAsTUFBVCxFQUFtQkEsTUFBbkIsQ0FBNEJxZSxXQUFuQyxDQUNELENBckJELENBc0JELENBRUQ7Ozs7Ozs7O09BU0EsUUFBU0MsWUFBVCxDQUFxQnBmLElBQXJCLENBQTJCdVUsT0FBM0IsQ0FBb0M4SyxLQUFwQyxDQUEyQyxDQUN6QyxHQUFJWixNQUFPQyxXQUFXMWUsSUFBWCxDQUFYLENBRUEsUUFBUzJlLFFBQVQsRUFBbUIsQ0FDakIsR0FBSWptQyxRQUFTbWdDLFVBQVVuZ0MsTUFBdkIsQ0FDSXduQixLQUFPbGMsTUFBTXRMLE1BQU4sQ0FEWCxDQUVJdUwsTUFBUXZMLE1BRlosQ0FHSWdyQixZQUFjNGIsVUFBVVgsT0FBVixDQUhsQixDQUtBLE1BQU8xNkIsT0FBUCxDQUFnQixDQUNkaWMsS0FBS2pjLEtBQUwsRUFBYzQwQixVQUFVNTBCLEtBQVYsQ0FBZCxDQUNELENBQ0QsR0FBSWc1QixTQUFXdmtDLE9BQVMsQ0FBVCxFQUFjd25CLEtBQUssQ0FBTCxJQUFZd0QsV0FBMUIsRUFBeUN4RCxLQUFLeG5CLE9BQVMsQ0FBZCxJQUFxQmdyQixXQUEvRCxDQUNWLEVBRFUsQ0FFVmtCLGVBQWUxRSxJQUFmLENBQXFCd0QsV0FBckIsQ0FGSixDQUlBaHJCLFFBQVV1a0MsUUFBUXZrQyxNQUFsQixDQUNBLEdBQUlBLE9BQVMybUMsS0FBYixDQUFvQixDQUNsQixNQUFPRSxlQUNMdmYsSUFESyxDQUNDdVUsT0FERCxDQUNVaUwsWUFEVixDQUN3QmIsUUFBUWpiLFdBRGhDLENBQzZDcHFCLFNBRDdDLENBRUw0bUIsSUFGSyxDQUVDK2MsT0FGRCxDQUVVM2pDLFNBRlYsQ0FFcUJBLFNBRnJCLENBRWdDK2xDLE1BQVEzbUMsTUFGeEMsQ0FBUCxDQUdELENBQ0QsR0FBSTJhLElBQU0sTUFBUSxPQUFTZ0wsSUFBakIsRUFBeUIsZUFBZ0JzZ0IsUUFBMUMsQ0FBcURGLElBQXJELENBQTREemUsSUFBckUsQ0FDQSxNQUFPOUwsT0FBTWIsRUFBTixDQUFVLElBQVYsQ0FBZ0I2TSxJQUFoQixDQUFQLENBQ0QsQ0FDRCxNQUFPeWUsUUFBUCxDQUNELENBRUQ7Ozs7OztPQU9BLFFBQVNjLFdBQVQsQ0FBb0JDLGFBQXBCLENBQW1DLENBQ2pDLE1BQU8sVUFBUzVkLFVBQVQsQ0FBcUJuQixTQUFyQixDQUFnQ3NCLFNBQWhDLENBQTJDLENBQ2hELEdBQUlxYyxVQUFXMytCLE9BQU9taUIsVUFBUCxDQUFmLENBQ0EsR0FBSSxDQUFDaVYsWUFBWWpWLFVBQVosQ0FBTCxDQUE4QixDQUM1QixHQUFJeEIsVUFBV3lYLFlBQVlwWCxTQUFaLENBQXVCLENBQXZCLENBQWYsQ0FDQW1CLFdBQWFvRSxLQUFLcEUsVUFBTCxDQUFiLENBQ0FuQixVQUFZLFNBQVN2dEIsR0FBVCxDQUFjLENBQUUsTUFBT2t0QixVQUFTZ2UsU0FBU2xyQyxHQUFULENBQVQsQ0FBd0JBLEdBQXhCLENBQTZCa3JDLFFBQTdCLENBQVAsQ0FBZ0QsQ0FBNUUsQ0FDRCxDQUNELEdBQUlyNkIsT0FBUXk3QixjQUFjNWQsVUFBZCxDQUEwQm5CLFNBQTFCLENBQXFDc0IsU0FBckMsQ0FBWixDQUNBLE1BQU9oZSxPQUFRLENBQUMsQ0FBVCxDQUFhcTZCLFNBQVNoZSxTQUFXd0IsV0FBVzdkLEtBQVgsQ0FBWCxDQUErQkEsS0FBeEMsQ0FBYixDQUE4RDNLLFNBQXJFLENBQ0QsQ0FURCxDQVVELENBRUQ7Ozs7OztPQU9BLFFBQVNxbUMsV0FBVCxDQUFvQnpkLFNBQXBCLENBQStCLENBQzdCLE1BQU8wVyxVQUFTLFNBQVNnSCxLQUFULENBQWdCLENBQzlCQSxNQUFRM04sWUFBWTJOLEtBQVosQ0FBbUIsQ0FBbkIsQ0FBUixDQUVBLEdBQUlsbkMsUUFBU2tuQyxNQUFNbG5DLE1BQW5CLENBQ0l1TCxNQUFRdkwsTUFEWixDQUVJbW5DLE9BQVM1VixjQUFjckUsU0FBZCxDQUF3QmthLElBRnJDLENBSUEsR0FBSTVkLFNBQUosQ0FBZSxDQUNiMGQsTUFBTXJ1QixPQUFOLEdBQ0QsQ0FDRCxNQUFPdE4sT0FBUCxDQUFnQixDQUNkLEdBQUkrYixNQUFPNGYsTUFBTTM3QixLQUFOLENBQVgsQ0FDQSxHQUFJLE1BQU8rYixLQUFQLEVBQWUsVUFBbkIsQ0FBK0IsQ0FDN0IsS0FBTSxJQUFJMEYsVUFBSixDQUFjNVEsZUFBZCxDQUFOLENBQ0QsQ0FDRCxHQUFJK3FCLFFBQVUsQ0FBQ2xCLE9BQVgsRUFBc0JvQixZQUFZL2YsSUFBWixHQUFxQixTQUEvQyxDQUEwRCxDQUN4RCxHQUFJMmUsU0FBVSxHQUFJMVUsY0FBSixDQUFrQixFQUFsQixDQUFzQixJQUF0QixDQUFkLENBQ0QsQ0FDRixDQUNEaG1CLE1BQVEwNkIsUUFBVTE2QixLQUFWLENBQWtCdkwsTUFBMUIsQ0FDQSxNQUFPLEVBQUV1TCxLQUFGLENBQVV2TCxNQUFqQixDQUF5QixDQUN2QnNuQixLQUFPNGYsTUFBTTM3QixLQUFOLENBQVAsQ0FFQSxHQUFJKzdCLFVBQVdELFlBQVkvZixJQUFaLENBQWYsQ0FDSWpxQixLQUFPaXFDLFVBQVksU0FBWixDQUF3QkMsUUFBUWpnQixJQUFSLENBQXhCLENBQXdDMW1CLFNBRG5ELENBR0EsR0FBSXZELE1BQVFtcUMsV0FBV25xQyxLQUFLLENBQUwsQ0FBWCxDQUFSLEVBQ0VBLEtBQUssQ0FBTCxJQUFZeWYsU0FBV0osVUFBWCxDQUF3QkUsWUFBeEIsQ0FBdUNHLFVBQW5ELENBREYsRUFFRSxDQUFDMWYsS0FBSyxDQUFMLEVBQVEyQyxNQUZYLEVBRXFCM0MsS0FBSyxDQUFMLEdBQVcsQ0FGcEMsQ0FHTSxDQUNKNG9DLFFBQVVBLFFBQVFvQixZQUFZaHFDLEtBQUssQ0FBTCxDQUFaLENBQVIsRUFBOEJtZSxLQUE5QixDQUFvQ3lxQixPQUFwQyxDQUE2QzVvQyxLQUFLLENBQUwsQ0FBN0MsQ0FBVixDQUNELENBTEQsSUFLTyxDQUNMNG9DLFFBQVczZSxLQUFLdG5CLE1BQUwsRUFBZSxDQUFmLEVBQW9Cd25DLFdBQVdsZ0IsSUFBWCxDQUFyQixDQUNOMmUsUUFBUXFCLFFBQVIsR0FETSxDQUVOckIsUUFBUW1CLElBQVIsQ0FBYTlmLElBQWIsQ0FGSixDQUdELENBQ0YsQ0FDRCxNQUFPLFdBQVcsQ0FDaEIsR0FBSUUsTUFBTzJZLFNBQVgsQ0FDSXhsQyxNQUFRNnNCLEtBQUssQ0FBTCxDQURaLENBR0EsR0FBSXllLFNBQVd6ZSxLQUFLeG5CLE1BQUwsRUFBZSxDQUExQixFQUNBeVosUUFBUTllLEtBQVIsQ0FEQSxFQUNrQkEsTUFBTXFGLE1BQU4sRUFBZ0JtYyxnQkFEdEMsQ0FDd0QsQ0FDdEQsTUFBTzhwQixTQUFRd0IsS0FBUixDQUFjOXNDLEtBQWQsRUFBcUJBLEtBQXJCLEVBQVAsQ0FDRCxDQUNELEdBQUk0USxPQUFRLENBQVosQ0FDSTZjLE9BQVNwb0IsT0FBU2tuQyxNQUFNMzdCLEtBQU4sRUFBYWlRLEtBQWIsQ0FBbUIsSUFBbkIsQ0FBeUJnTSxJQUF6QixDQUFULENBQTBDN3NCLEtBRHZELENBR0EsTUFBTyxFQUFFNFEsS0FBRixDQUFVdkwsTUFBakIsQ0FBeUIsQ0FDdkJvb0IsT0FBUzhlLE1BQU0zN0IsS0FBTixFQUFhbUssSUFBYixDQUFrQixJQUFsQixDQUF3QjBTLE1BQXhCLENBQVQsQ0FDRCxDQUNELE1BQU9BLE9BQVAsQ0FDRCxDQWZELENBZ0JELENBckRNLENBQVAsQ0FzREQsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BbUJBLFFBQVMwZSxhQUFULENBQXNCeGYsSUFBdEIsQ0FBNEJ1VSxPQUE1QixDQUFxQ3RVLE9BQXJDLENBQThDK2MsUUFBOUMsQ0FBd0RDLE9BQXhELENBQWlFbUQsYUFBakUsQ0FBZ0ZDLFlBQWhGLENBQThGQyxNQUE5RixDQUFzR0MsR0FBdEcsQ0FBMkdsQixLQUEzRyxDQUFrSCxDQUNoSCxHQUFJbUIsT0FBUWpNLFFBQVUvZSxRQUF0QixDQUNJZ3BCLE9BQVNqSyxRQUFVdGYsU0FEdkIsQ0FFSXdyQixVQUFZbE0sUUFBVXJmLGFBRjFCLENBR0lnb0IsVUFBWTNJLFNBQVduZixXQUFhQyxnQkFBeEIsQ0FIaEIsQ0FJSXFyQixPQUFTbk0sUUFBVTdlLFNBSnZCLENBS0krb0IsS0FBT2dDLFVBQVlubkMsU0FBWixDQUF3Qm9sQyxXQUFXMWUsSUFBWCxDQUxuQyxDQU9BLFFBQVMyZSxRQUFULEVBQW1CLENBQ2pCLEdBQUlqbUMsUUFBU21nQyxVQUFVbmdDLE1BQXZCLENBQ0l3bkIsS0FBT2xjLE1BQU10TCxNQUFOLENBRFgsQ0FFSXVMLE1BQVF2TCxNQUZaLENBSUEsTUFBT3VMLE9BQVAsQ0FBZ0IsQ0FDZGljLEtBQUtqYyxLQUFMLEVBQWM0MEIsVUFBVTUwQixLQUFWLENBQWQsQ0FDRCxDQUNELEdBQUlpNUIsU0FBSixDQUFlLENBQ2IsR0FBSXhaLGFBQWM0YixVQUFVWCxPQUFWLENBQWxCLENBQ0lnQyxhQUFlbGQsYUFBYXZELElBQWIsQ0FBbUJ3RCxXQUFuQixDQURuQixDQUVELENBQ0QsR0FBSXNaLFFBQUosQ0FBYyxDQUNaOWMsS0FBTzZjLFlBQVk3YyxJQUFaLENBQWtCOGMsUUFBbEIsQ0FBNEJDLE9BQTVCLENBQXFDQyxTQUFyQyxDQUFQLENBQ0QsQ0FDRCxHQUFJa0QsYUFBSixDQUFtQixDQUNqQmxnQixLQUFPd2QsaUJBQWlCeGQsSUFBakIsQ0FBdUJrZ0IsYUFBdkIsQ0FBc0NDLFlBQXRDLENBQW9EbkQsU0FBcEQsQ0FBUCxDQUNELENBQ0R4a0MsUUFBVWlvQyxZQUFWLENBQ0EsR0FBSXpELFdBQWF4a0MsT0FBUzJtQyxLQUExQixDQUFpQyxDQUMvQixHQUFJdUIsWUFBYWhjLGVBQWUxRSxJQUFmLENBQXFCd0QsV0FBckIsQ0FBakIsQ0FDQSxNQUFPNmIsZUFDTHZmLElBREssQ0FDQ3VVLE9BREQsQ0FDVWlMLFlBRFYsQ0FDd0JiLFFBQVFqYixXQURoQyxDQUM2Q3pELE9BRDdDLENBRUxDLElBRkssQ0FFQzBnQixVQUZELENBRWFOLE1BRmIsQ0FFcUJDLEdBRnJCLENBRTBCbEIsTUFBUTNtQyxNQUZsQyxDQUFQLENBSUQsQ0FDRCxHQUFJeW1DLGFBQWNYLE9BQVN2ZSxPQUFULENBQW1CLElBQXJDLENBQ0k1TSxHQUFLb3RCLFVBQVl0QixZQUFZbmYsSUFBWixDQUFaLENBQWdDQSxJQUR6QyxDQUdBdG5CLE9BQVN3bkIsS0FBS3huQixNQUFkLENBQ0EsR0FBSTRuQyxNQUFKLENBQVksQ0FDVnBnQixLQUFPMmdCLFFBQVEzZ0IsSUFBUixDQUFjb2dCLE1BQWQsQ0FBUCxDQUNELENBRkQsSUFFTyxJQUFJSSxRQUFVaG9DLE9BQVMsQ0FBdkIsQ0FBMEIsQ0FDL0J3bkIsS0FBSzNPLE9BQUwsR0FDRCxDQUNELEdBQUlpdkIsT0FBU0QsSUFBTTduQyxNQUFuQixDQUEyQixDQUN6QnduQixLQUFLeG5CLE1BQUwsQ0FBYzZuQyxHQUFkLENBQ0QsQ0FDRCxHQUFJLE1BQVEsT0FBU2xpQixJQUFqQixFQUF5QixlQUFnQnNnQixRQUE3QyxDQUFzRCxDQUNwRHRyQixHQUFLb3JCLE1BQVFDLFdBQVdyckIsRUFBWCxDQUFiLENBQ0QsQ0FDRCxNQUFPQSxJQUFHYSxLQUFILENBQVNpckIsV0FBVCxDQUFzQmpmLElBQXRCLENBQVAsQ0FDRCxDQUNELE1BQU95ZSxRQUFQLENBQ0QsQ0FFRDs7Ozs7OztPQVFBLFFBQVNtQyxlQUFULENBQXdCemdCLE1BQXhCLENBQWdDMGdCLFVBQWhDLENBQTRDLENBQzFDLE1BQU8sVUFBU3hlLE1BQVQsQ0FBaUJqQyxRQUFqQixDQUEyQixDQUNoQyxNQUFPMFQsY0FBYXpSLE1BQWIsQ0FBcUJsQyxNQUFyQixDQUE2QjBnQixXQUFXemdCLFFBQVgsQ0FBN0IsQ0FBbUQsRUFBbkQsQ0FBUCxDQUNELENBRkQsQ0FHRCxDQUVEOzs7Ozs7O09BUUEsUUFBUzBnQixvQkFBVCxDQUE2QkMsUUFBN0IsQ0FBdUNDLFlBQXZDLENBQXFELENBQ25ELE1BQU8sVUFBUzd0QyxLQUFULENBQWdCKy9CLEtBQWhCLENBQXVCLENBQzVCLEdBQUl0UyxPQUFKLENBQ0EsR0FBSXp0QixRQUFVaUcsU0FBVixFQUF1Qjg1QixRQUFVOTVCLFNBQXJDLENBQWdELENBQzlDLE1BQU80bkMsYUFBUCxDQUNELENBQ0QsR0FBSTd0QyxRQUFVaUcsU0FBZCxDQUF5QixDQUN2QnduQixPQUFTenRCLEtBQVQsQ0FDRCxDQUNELEdBQUkrL0IsUUFBVTk1QixTQUFkLENBQXlCLENBQ3ZCLEdBQUl3bkIsU0FBV3huQixTQUFmLENBQTBCLENBQ3hCLE1BQU84NUIsTUFBUCxDQUNELENBQ0QsR0FBSSxNQUFPLy9CLE1BQVAsRUFBZ0IsUUFBaEIsRUFBNEIsTUFBTysvQixNQUFQLEVBQWdCLFFBQWhELENBQTBELENBQ3hELy9CLE1BQVErbUMsYUFBYS9tQyxLQUFiLENBQVIsQ0FDQSsvQixNQUFRZ0gsYUFBYWhILEtBQWIsQ0FBUixDQUNELENBSEQsSUFHTyxDQUNMLy9CLE1BQVE4bUMsYUFBYTltQyxLQUFiLENBQVIsQ0FDQSsvQixNQUFRK0csYUFBYS9HLEtBQWIsQ0FBUixDQUNELENBQ0R0UyxPQUFTbWdCLFNBQVM1dEMsS0FBVCxDQUFnQisvQixLQUFoQixDQUFULENBQ0QsQ0FDRCxNQUFPdFMsT0FBUCxDQUNELENBdEJELENBdUJELENBRUQ7Ozs7OztPQU9BLFFBQVNxZ0IsV0FBVCxDQUFvQkMsU0FBcEIsQ0FBK0IsQ0FDN0IsTUFBT3hJLFVBQVMsU0FBUzlNLFNBQVQsQ0FBb0IsQ0FDbENBLFVBQWFBLFVBQVVwekIsTUFBVixFQUFvQixDQUFwQixFQUF5QnlaLFFBQVEyWixVQUFVLENBQVYsQ0FBUixDQUExQixDQUNSM0ssU0FBUzJLLFVBQVUsQ0FBVixDQUFULENBQXVCOUksVUFBVStVLGFBQVYsQ0FBdkIsQ0FEUSxDQUVSNVcsU0FBUzhRLFlBQVluRyxTQUFaLENBQXVCLENBQXZCLENBQVQsQ0FBb0M5SSxVQUFVK1UsYUFBVixDQUFwQyxDQUZKLENBSUEsTUFBT2EsVUFBUyxTQUFTMVksSUFBVCxDQUFlLENBQzdCLEdBQUlELFNBQVUsSUFBZCxDQUNBLE1BQU9taEIsV0FBVXRWLFNBQVYsQ0FBcUIsU0FBU3hMLFFBQVQsQ0FBbUIsQ0FDN0MsTUFBT3BNLE9BQU1vTSxRQUFOLENBQWdCTCxPQUFoQixDQUF5QkMsSUFBekIsQ0FBUCxDQUNELENBRk0sQ0FBUCxDQUdELENBTE0sQ0FBUCxDQU1ELENBWE0sQ0FBUCxDQVlELENBRUQ7Ozs7Ozs7O09BU0EsUUFBU21oQixjQUFULENBQXVCM29DLE1BQXZCLENBQStCNG9DLEtBQS9CLENBQXNDLENBQ3BDQSxNQUFRQSxRQUFVaG9DLFNBQVYsQ0FBc0IsR0FBdEIsQ0FBNEI4Z0MsYUFBYWtILEtBQWIsQ0FBcEMsQ0FFQSxHQUFJQyxhQUFjRCxNQUFNNW9DLE1BQXhCLENBQ0EsR0FBSTZvQyxZQUFjLENBQWxCLENBQXFCLENBQ25CLE1BQU9BLGFBQWM1SSxXQUFXMkksS0FBWCxDQUFrQjVvQyxNQUFsQixDQUFkLENBQTBDNG9DLEtBQWpELENBQ0QsQ0FDRCxHQUFJeGdCLFFBQVM2WCxXQUFXMkksS0FBWCxDQUFrQjlaLFdBQVc5dUIsT0FBU3FzQixXQUFXdWMsS0FBWCxDQUFwQixDQUFsQixDQUFiLENBQ0EsTUFBT3RkLFlBQVdzZCxLQUFYLEVBQ0hqRyxVQUFVcFcsY0FBY25FLE1BQWQsQ0FBVixDQUFpQyxDQUFqQyxDQUFvQ3BvQixNQUFwQyxFQUE0Q2lPLElBQTVDLENBQWlELEVBQWpELENBREcsQ0FFSG1hLE9BQU95YSxLQUFQLENBQWEsQ0FBYixDQUFnQjdpQyxNQUFoQixDQUZKLENBR0QsQ0FFRDs7Ozs7Ozs7Ozs7T0FZQSxRQUFTOG9DLGNBQVQsQ0FBdUJ4aEIsSUFBdkIsQ0FBNkJ1VSxPQUE3QixDQUFzQ3RVLE9BQXRDLENBQStDK2MsUUFBL0MsQ0FBeUQsQ0FDdkQsR0FBSXdCLFFBQVNqSyxRQUFVdGYsU0FBdkIsQ0FDSXdwQixLQUFPQyxXQUFXMWUsSUFBWCxDQURYLENBR0EsUUFBUzJlLFFBQVQsRUFBbUIsQ0FDakIsR0FBSXhCLFdBQVksQ0FBQyxDQUFqQixDQUNJQyxXQUFhdkUsVUFBVW5nQyxNQUQzQixDQUVJNGtDLFVBQVksQ0FBQyxDQUZqQixDQUdJQyxXQUFhUCxTQUFTdGtDLE1BSDFCLENBSUl3bkIsS0FBT2xjLE1BQU11NUIsV0FBYUgsVUFBbkIsQ0FKWCxDQUtJL3BCLEdBQU0sTUFBUSxPQUFTZ0wsSUFBakIsRUFBeUIsZUFBZ0JzZ0IsUUFBMUMsQ0FBcURGLElBQXJELENBQTREemUsSUFMckUsQ0FPQSxNQUFPLEVBQUVzZCxTQUFGLENBQWNDLFVBQXJCLENBQWlDLENBQy9CcmQsS0FBS29kLFNBQUwsRUFBa0JOLFNBQVNNLFNBQVQsQ0FBbEIsQ0FDRCxDQUNELE1BQU9GLFlBQVAsQ0FBcUIsQ0FDbkJsZCxLQUFLb2QsV0FBTCxFQUFvQnpFLFVBQVUsRUFBRXNFLFNBQVosQ0FBcEIsQ0FDRCxDQUNELE1BQU9qcEIsT0FBTWIsRUFBTixDQUFVbXJCLE9BQVN2ZSxPQUFULENBQW1CLElBQTdCLENBQW1DQyxJQUFuQyxDQUFQLENBQ0QsQ0FDRCxNQUFPeWUsUUFBUCxDQUNELENBRUQ7Ozs7OztPQU9BLFFBQVM4QyxZQUFULENBQXFCdmYsU0FBckIsQ0FBZ0MsQ0FDOUIsTUFBTyxVQUFTMEosS0FBVCxDQUFnQkMsR0FBaEIsQ0FBcUJ4aEIsSUFBckIsQ0FBMkIsQ0FDaEMsR0FBSUEsTUFBUSxNQUFPQSxLQUFQLEVBQWUsUUFBdkIsRUFBbUNnMEIsZUFBZXpTLEtBQWYsQ0FBc0JDLEdBQXRCLENBQTJCeGhCLElBQTNCLENBQXZDLENBQXlFLENBQ3ZFd2hCLElBQU14aEIsS0FBTy9RLFNBQWIsQ0FDRCxDQUNEO0FBQ0FzeUIsTUFBUThWLFNBQVM5VixLQUFULENBQVIsQ0FDQSxHQUFJQyxNQUFRdnlCLFNBQVosQ0FBdUIsQ0FDckJ1eUIsSUFBTUQsS0FBTixDQUNBQSxNQUFRLENBQVIsQ0FDRCxDQUhELElBR08sQ0FDTEMsSUFBTTZWLFNBQVM3VixHQUFULENBQU4sQ0FDRCxDQUNEeGhCLEtBQU9BLE9BQVMvUSxTQUFULENBQXNCc3lCLE1BQVFDLEdBQVIsQ0FBYyxDQUFkLENBQWtCLENBQUMsQ0FBekMsQ0FBOEM2VixTQUFTcjNCLElBQVQsQ0FBckQsQ0FDQSxNQUFPcXVCLFdBQVU5TSxLQUFWLENBQWlCQyxHQUFqQixDQUFzQnhoQixJQUF0QixDQUE0QjZYLFNBQTVCLENBQVAsQ0FDRCxDQWRELENBZUQsQ0FFRDs7Ozs7O09BT0EsUUFBU3lmLDBCQUFULENBQW1DVixRQUFuQyxDQUE2QyxDQUMzQyxNQUFPLFVBQVM1dEMsS0FBVCxDQUFnQisvQixLQUFoQixDQUF1QixDQUM1QixHQUFJLEVBQUUsTUFBTy8vQixNQUFQLEVBQWdCLFFBQWhCLEVBQTRCLE1BQU8rL0IsTUFBUCxFQUFnQixRQUE5QyxDQUFKLENBQTZELENBQzNELy9CLE1BQVF1dUMsU0FBU3Z1QyxLQUFULENBQVIsQ0FDQSsvQixNQUFRd08sU0FBU3hPLEtBQVQsQ0FBUixDQUNELENBQ0QsTUFBTzZOLFVBQVM1dEMsS0FBVCxDQUFnQisvQixLQUFoQixDQUFQLENBQ0QsQ0FORCxDQU9ELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7T0FpQkEsUUFBU21NLGNBQVQsQ0FBdUJ2ZixJQUF2QixDQUE2QnVVLE9BQTdCLENBQXNDc04sUUFBdEMsQ0FBZ0RuZSxXQUFoRCxDQUE2RHpELE9BQTdELENBQXNFK2MsUUFBdEUsQ0FBZ0ZDLE9BQWhGLENBQXlGcUQsTUFBekYsQ0FBaUdDLEdBQWpHLENBQXNHbEIsS0FBdEcsQ0FBNkcsQ0FDM0csR0FBSXlDLFNBQVV2TixRQUFVbmYsVUFBeEIsQ0FDSXdyQixXQUFha0IsUUFBVTdFLE9BQVYsQ0FBb0IzakMsU0FEckMsQ0FFSXlvQyxnQkFBa0JELFFBQVV4b0MsU0FBVixDQUFzQjJqQyxPQUY1QyxDQUdJK0UsWUFBY0YsUUFBVTlFLFFBQVYsQ0FBcUIxakMsU0FIdkMsQ0FJSTJvQyxpQkFBbUJILFFBQVV4b0MsU0FBVixDQUFzQjBqQyxRQUo3QyxDQU1BekksU0FBWXVOLFFBQVV4c0IsWUFBVixDQUF5QkMsa0JBQXJDLENBQ0FnZixTQUFXLEVBQUV1TixRQUFVdnNCLGtCQUFWLENBQStCRCxZQUFqQyxDQUFYLENBRUEsR0FBSSxFQUFFaWYsUUFBVXBmLGdCQUFaLENBQUosQ0FBbUMsQ0FDakNvZixTQUFXLEVBQUV0ZixVQUFZQyxhQUFkLENBQVgsQ0FDRCxDQUNELEdBQUlndEIsU0FBVSxDQUNabGlCLElBRFksQ0FDTnVVLE9BRE0sQ0FDR3RVLE9BREgsQ0FDWStoQixXQURaLENBQ3lCcEIsVUFEekIsQ0FDcUNxQixnQkFEckMsQ0FFWkYsZUFGWSxDQUVLekIsTUFGTCxDQUVhQyxHQUZiLENBRWtCbEIsS0FGbEIsQ0FBZCxDQUtBLEdBQUl2ZSxRQUFTK2dCLFNBQVMzdEIsS0FBVCxDQUFlNWEsU0FBZixDQUEwQjRvQyxPQUExQixDQUFiLENBQ0EsR0FBSWhDLFdBQVdsZ0IsSUFBWCxDQUFKLENBQXNCLENBQ3BCL2EsUUFBUTZiLE1BQVIsQ0FBZ0JvaEIsT0FBaEIsRUFDRCxDQUNEcGhCLE9BQU80QyxXQUFQLENBQXFCQSxXQUFyQixDQUNBLE1BQU95ZSxpQkFBZ0JyaEIsTUFBaEIsQ0FBd0JkLElBQXhCLENBQThCdVUsT0FBOUIsQ0FBUCxDQUNELENBRUQ7Ozs7OztPQU9BLFFBQVM2TixZQUFULENBQXFCdkQsVUFBckIsQ0FBaUMsQ0FDL0IsR0FBSTdlLE1BQU90cEIsS0FBS21vQyxVQUFMLENBQVgsQ0FDQSxNQUFPLFVBQVNuUCxNQUFULENBQWlCMlMsU0FBakIsQ0FBNEIsQ0FDakMzUyxPQUFTa1MsU0FBU2xTLE1BQVQsQ0FBVCxDQUNBMlMsVUFBWWhhLFVBQVV5SixVQUFVdVEsU0FBVixDQUFWLENBQWdDLEdBQWhDLENBQVosQ0FDQSxHQUFJQSxTQUFKLENBQWUsQ0FDYjtBQUNBO0FBQ0EsR0FBSXhpQixNQUFPLENBQUNzRSxTQUFTdUwsTUFBVCxFQUFtQixHQUFwQixFQUF5Qi85QixLQUF6QixDQUErQixHQUEvQixDQUFYLENBQ0kwQixNQUFRMnNCLEtBQUtILEtBQUssQ0FBTCxFQUFVLEdBQVYsRUFBaUIsQ0FBQ0EsS0FBSyxDQUFMLENBQUQsQ0FBV3dpQixTQUE1QixDQUFMLENBRFosQ0FHQXhpQixLQUFPLENBQUNzRSxTQUFTOXdCLEtBQVQsRUFBa0IsR0FBbkIsRUFBd0IxQixLQUF4QixDQUE4QixHQUE5QixDQUFQLENBQ0EsTUFBTyxFQUFFa3VCLEtBQUssQ0FBTCxFQUFVLEdBQVYsRUFBaUIsQ0FBQ0EsS0FBSyxDQUFMLENBQUQsQ0FBV3dpQixTQUE1QixDQUFGLENBQVAsQ0FDRCxDQUNELE1BQU9yaUIsTUFBSzBQLE1BQUwsQ0FBUCxDQUNELENBYkQsQ0FjRCxDQUVEOzs7Ozs7T0FPQSxHQUFJNEssV0FBWSxFQUFFelIsS0FBUSxFQUFJaEUsV0FBVyxHQUFJZ0UsSUFBSixDQUFRLEVBQUUsQ0FBQyxDQUFILENBQVIsQ0FBWCxFQUEyQixDQUEzQixDQUFMLEVBQXVDelMsUUFBaEQsRUFBNEQzZSxJQUE1RCxDQUFtRSxTQUFTeVcsTUFBVCxDQUFpQixDQUNsRyxNQUFPLElBQUkyYSxJQUFKLENBQVEzYSxNQUFSLENBQVAsQ0FDRCxDQUZELENBSUE7Ozs7OztPQU9BLFFBQVNvMEIsY0FBVCxDQUF1QnRQLFFBQXZCLENBQWlDLENBQy9CLE1BQU8sVUFBU3pRLE1BQVQsQ0FBaUIsQ0FDdEIsR0FBSTlZLEtBQU0wbUIsT0FBTzVOLE1BQVAsQ0FBVixDQUNBLEdBQUk5WSxLQUFPME4sTUFBWCxDQUFtQixDQUNqQixNQUFPb04sWUFBV2hDLE1BQVgsQ0FBUCxDQUNELENBQ0QsR0FBSTlZLEtBQU8rTixNQUFYLENBQW1CLENBQ2pCLE1BQU9zTixZQUFXdkMsTUFBWCxDQUFQLENBQ0QsQ0FDRCxNQUFPTyxhQUFZUCxNQUFaLENBQW9CeVEsU0FBU3pRLE1BQVQsQ0FBcEIsQ0FBUCxDQUNELENBVEQsQ0FVRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMEJBLFFBQVNnZ0IsV0FBVCxDQUFvQnZpQixJQUFwQixDQUEwQnVVLE9BQTFCLENBQW1DdFUsT0FBbkMsQ0FBNEMrYyxRQUE1QyxDQUFzREMsT0FBdEQsQ0FBK0RxRCxNQUEvRCxDQUF1RUMsR0FBdkUsQ0FBNEVsQixLQUE1RSxDQUFtRixDQUNqRixHQUFJb0IsV0FBWWxNLFFBQVVyZixhQUExQixDQUNBLEdBQUksQ0FBQ3VyQixTQUFELEVBQWMsTUFBT3pnQixLQUFQLEVBQWUsVUFBakMsQ0FBNkMsQ0FDM0MsS0FBTSxJQUFJMEYsVUFBSixDQUFjNVEsZUFBZCxDQUFOLENBQ0QsQ0FDRCxHQUFJcGMsUUFBU3NrQyxTQUFXQSxTQUFTdGtDLE1BQXBCLENBQTZCLENBQTFDLENBQ0EsR0FBSSxDQUFDQSxNQUFMLENBQWEsQ0FDWDY3QixTQUFXLEVBQUVqZixhQUFlQyxrQkFBakIsQ0FBWCxDQUNBeW5CLFNBQVdDLFFBQVUzakMsU0FBckIsQ0FDRCxDQUNEaW5DLElBQU1BLE1BQVFqbkMsU0FBUixDQUFvQmluQyxHQUFwQixDQUEwQm5ZLFVBQVUwSixVQUFVeU8sR0FBVixDQUFWLENBQTBCLENBQTFCLENBQWhDLENBQ0FsQixNQUFRQSxRQUFVL2xDLFNBQVYsQ0FBc0IrbEMsS0FBdEIsQ0FBOEJ2TixVQUFVdU4sS0FBVixDQUF0QyxDQUNBM21DLFFBQVV1a0MsUUFBVUEsUUFBUXZrQyxNQUFsQixDQUEyQixDQUFyQyxDQUVBLEdBQUk2N0IsUUFBVWhmLGtCQUFkLENBQWtDLENBQ2hDLEdBQUk2cUIsZUFBZ0JwRCxRQUFwQixDQUNJcUQsYUFBZXBELE9BRG5CLENBR0FELFNBQVdDLFFBQVUzakMsU0FBckIsQ0FDRCxDQUNELEdBQUl2RCxNQUFPMHFDLFVBQVlubkMsU0FBWixDQUF3QjJtQyxRQUFRamdCLElBQVIsQ0FBbkMsQ0FFQSxHQUFJa2lCLFNBQVUsQ0FDWmxpQixJQURZLENBQ051VSxPQURNLENBQ0d0VSxPQURILENBQ1krYyxRQURaLENBQ3NCQyxPQUR0QixDQUMrQm1ELGFBRC9CLENBQzhDQyxZQUQ5QyxDQUVaQyxNQUZZLENBRUpDLEdBRkksQ0FFQ2xCLEtBRkQsQ0FBZCxDQUtBLEdBQUl0cEMsSUFBSixDQUFVLENBQ1J5c0MsVUFBVU4sT0FBVixDQUFtQm5zQyxJQUFuQixFQUNELENBQ0RpcUIsS0FBT2tpQixRQUFRLENBQVIsQ0FBUCxDQUNBM04sUUFBVTJOLFFBQVEsQ0FBUixDQUFWLENBQ0FqaUIsUUFBVWlpQixRQUFRLENBQVIsQ0FBVixDQUNBbEYsU0FBV2tGLFFBQVEsQ0FBUixDQUFYLENBQ0FqRixRQUFVaUYsUUFBUSxDQUFSLENBQVYsQ0FDQTdDLE1BQVE2QyxRQUFRLENBQVIsRUFBYUEsUUFBUSxDQUFSLEdBQWMsSUFBZCxDQUNoQnpCLFVBQVksQ0FBWixDQUFnQnpnQixLQUFLdG5CLE1BREwsQ0FFakIwdkIsVUFBVThaLFFBQVEsQ0FBUixFQUFheHBDLE1BQXZCLENBQStCLENBQS9CLENBRkosQ0FJQSxHQUFJLENBQUMybUMsS0FBRCxFQUFVOUssU0FBV25mLFdBQWFDLGdCQUF4QixDQUFkLENBQXlELENBQ3ZEa2YsU0FBVyxFQUFFbmYsV0FBYUMsZ0JBQWYsQ0FBWCxDQUNELENBQ0QsR0FBSSxDQUFDa2YsT0FBRCxFQUFZQSxTQUFXdGYsU0FBM0IsQ0FBc0MsQ0FDcEMsR0FBSTZMLFFBQVN5ZCxXQUFXdmUsSUFBWCxDQUFpQnVVLE9BQWpCLENBQTBCdFUsT0FBMUIsQ0FBYixDQUNELENBRkQsSUFFTyxJQUFJc1UsU0FBV25mLFVBQVgsRUFBeUJtZixTQUFXbGYsZ0JBQXhDLENBQTBELENBQy9EeUwsT0FBU3NlLFlBQVlwZixJQUFaLENBQWtCdVUsT0FBbEIsQ0FBMkI4SyxLQUEzQixDQUFULENBQ0QsQ0FGTSxJQUVBLElBQUksQ0FBQzlLLFNBQVdqZixZQUFYLEVBQTJCaWYsVUFBWXRmLFVBQVlLLFlBQXhCLENBQTVCLEdBQXNFLENBQUMybkIsUUFBUXZrQyxNQUFuRixDQUEyRixDQUNoR29vQixPQUFTMGdCLGNBQWN4aEIsSUFBZCxDQUFvQnVVLE9BQXBCLENBQTZCdFUsT0FBN0IsQ0FBc0MrYyxRQUF0QyxDQUFULENBQ0QsQ0FGTSxJQUVBLENBQ0xsYyxPQUFTMGUsYUFBYXRyQixLQUFiLENBQW1CNWEsU0FBbkIsQ0FBOEI0b0MsT0FBOUIsQ0FBVCxDQUNELENBQ0QsR0FBSTdoQixRQUFTdHFCLEtBQU9rakMsV0FBUCxDQUFxQmgwQixPQUFsQyxDQUNBLE1BQU9rOUIsaUJBQWdCOWhCLE9BQU9TLE1BQVAsQ0FBZW9oQixPQUFmLENBQWhCLENBQXlDbGlCLElBQXpDLENBQStDdVUsT0FBL0MsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7T0FjQSxRQUFTVSxZQUFULENBQXFCN1UsS0FBckIsQ0FBNEJnVCxLQUE1QixDQUFtQ3FCLFNBQW5DLENBQThDekUsVUFBOUMsQ0FBMER1RSxPQUExRCxDQUFtRXRpQyxLQUFuRSxDQUEwRSxDQUN4RSxHQUFJd3dDLFdBQVlsTyxRQUFVM2Usb0JBQTFCLENBQ0k2VixVQUFZckwsTUFBTTFuQixNQUR0QixDQUVJZzdCLFVBQVlOLE1BQU0xNkIsTUFGdEIsQ0FJQSxHQUFJK3lCLFdBQWFpSSxTQUFiLEVBQTBCLEVBQUUrTyxXQUFhL08sVUFBWWpJLFNBQTNCLENBQTlCLENBQXFFLENBQ25FLE1BQU8sTUFBUCxDQUNELENBQ0Q7QUFDQSxHQUFJZ0YsU0FBVXgrQixNQUFNYyxHQUFOLENBQVVxdEIsS0FBVixDQUFkLENBQ0EsR0FBSXFRLFNBQVd4K0IsTUFBTWMsR0FBTixDQUFVcWdDLEtBQVYsQ0FBZixDQUFpQyxDQUMvQixNQUFPM0MsVUFBVzJDLEtBQWxCLENBQ0QsQ0FDRCxHQUFJbnZCLE9BQVEsQ0FBQyxDQUFiLENBQ0k2YyxPQUFTLElBRGIsQ0FFSWlULEtBQVFRLFFBQVU1ZSxzQkFBWCxDQUFxQyxHQUFJa1ksU0FBSixFQUFyQyxDQUFvRHYwQixTQUYvRCxDQUlBckgsTUFBTWtCLEdBQU4sQ0FBVWl0QixLQUFWLENBQWlCZ1QsS0FBakIsRUFDQW5oQyxNQUFNa0IsR0FBTixDQUFVaWdDLEtBQVYsQ0FBaUJoVCxLQUFqQixFQUVBO0FBQ0EsTUFBTyxFQUFFbmMsS0FBRixDQUFVd25CLFNBQWpCLENBQTRCLENBQzFCLEdBQUlpWCxVQUFXdGlCLE1BQU1uYyxLQUFOLENBQWYsQ0FDSTArQixTQUFXdlAsTUFBTW52QixLQUFOLENBRGYsQ0FHQSxHQUFJK3JCLFVBQUosQ0FBZ0IsQ0FDZCxHQUFJNFMsVUFBV0gsVUFDWHpTLFdBQVcyUyxRQUFYLENBQXFCRCxRQUFyQixDQUErQnorQixLQUEvQixDQUFzQ212QixLQUF0QyxDQUE2Q2hULEtBQTdDLENBQW9EbnVCLEtBQXBELENBRFcsQ0FFWCs5QixXQUFXMFMsUUFBWCxDQUFxQkMsUUFBckIsQ0FBK0IxK0IsS0FBL0IsQ0FBc0NtYyxLQUF0QyxDQUE2Q2dULEtBQTdDLENBQW9EbmhDLEtBQXBELENBRkosQ0FHRCxDQUNELEdBQUkyd0MsV0FBYXRwQyxTQUFqQixDQUE0QixDQUMxQixHQUFJc3BDLFFBQUosQ0FBYyxDQUNaLFNBQ0QsQ0FDRDloQixPQUFTLEtBQVQsQ0FDQSxNQUNELENBQ0Q7QUFDQSxHQUFJaVQsSUFBSixDQUFVLENBQ1IsR0FBSSxDQUFDdlMsVUFBVTRSLEtBQVYsQ0FBaUIsU0FBU3VQLFFBQVQsQ0FBbUJoUCxRQUFuQixDQUE2QixDQUM3QyxHQUFJLENBQUNJLEtBQUszUSxHQUFMLENBQVN1USxRQUFULENBQUQsR0FDQytPLFdBQWFDLFFBQWIsRUFBeUJsTyxVQUFVaU8sUUFBVixDQUFvQkMsUUFBcEIsQ0FBOEIzUyxVQUE5QixDQUEwQ3VFLE9BQTFDLENBQW1EdGlDLEtBQW5ELENBRDFCLENBQUosQ0FDMEYsQ0FDeEYsTUFBTzhoQyxNQUFLaFUsR0FBTCxDQUFTNFQsUUFBVCxDQUFQLENBQ0QsQ0FDRixDQUxBLENBQUwsQ0FLUSxDQUNON1MsT0FBUyxLQUFULENBQ0EsTUFDRCxDQUNGLENBVkQsSUFVTyxJQUFJLEVBQ0w0aEIsV0FBYUMsUUFBYixFQUNFbE8sVUFBVWlPLFFBQVYsQ0FBb0JDLFFBQXBCLENBQThCM1MsVUFBOUIsQ0FBMEN1RSxPQUExQyxDQUFtRHRpQyxLQUFuRCxDQUZHLENBQUosQ0FHQSxDQUNMNnVCLE9BQVMsS0FBVCxDQUNBLE1BQ0QsQ0FDRixDQUNEN3VCLE1BQU0sUUFBTixFQUFnQm11QixLQUFoQixFQUNBbnVCLE1BQU0sUUFBTixFQUFnQm1oQyxLQUFoQixFQUNBLE1BQU90UyxPQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FrQkEsUUFBU29VLFdBQVQsQ0FBb0IzUyxNQUFwQixDQUE0QjZRLEtBQTVCLENBQW1DM3BCLEdBQW5DLENBQXdDZ3JCLFNBQXhDLENBQW1EekUsVUFBbkQsQ0FBK0R1RSxPQUEvRCxDQUF3RXRpQyxLQUF4RSxDQUErRSxDQUM3RSxPQUFRd1gsR0FBUixFQUNFLElBQUtxTyxZQUFMLENBQ0UsR0FBS3lLLE9BQU9vWixVQUFQLEVBQXFCdkksTUFBTXVJLFVBQTVCLEVBQ0NwWixPQUFPdVosVUFBUCxFQUFxQjFJLE1BQU0wSSxVQURoQyxDQUM2QyxDQUMzQyxNQUFPLE1BQVAsQ0FDRCxDQUNEdlosT0FBU0EsT0FBTytZLE1BQWhCLENBQ0FsSSxNQUFRQSxNQUFNa0ksTUFBZCxDQUVGLElBQUt6akIsZUFBTCxDQUNFLEdBQUswSyxPQUFPb1osVUFBUCxFQUFxQnZJLE1BQU11SSxVQUE1QixFQUNBLENBQUNsSCxVQUFVLEdBQUk1TixXQUFKLENBQWV0RSxNQUFmLENBQVYsQ0FBa0MsR0FBSXNFLFdBQUosQ0FBZXVNLEtBQWYsQ0FBbEMsQ0FETCxDQUMrRCxDQUM3RCxNQUFPLE1BQVAsQ0FDRCxDQUNELE1BQU8sS0FBUCxDQUVGLElBQUt0YyxRQUFMLENBQ0EsSUFBS0MsUUFBTCxDQUNBLElBQUtLLFVBQUwsQ0FDRTtBQUNBO0FBQ0EsTUFBTzJYLElBQUcsQ0FBQ3hNLE1BQUosQ0FBWSxDQUFDNlEsS0FBYixDQUFQLENBRUYsSUFBS3BjLFNBQUwsQ0FDRSxNQUFPdUwsUUFBTzNmLElBQVAsRUFBZXd3QixNQUFNeHdCLElBQXJCLEVBQTZCMmYsT0FBT3Z3QixPQUFQLEVBQWtCb2hDLE1BQU1waEMsT0FBNUQsQ0FFRixJQUFLdWxCLFVBQUwsQ0FDQSxJQUFLRSxVQUFMLENBQ0U7QUFDQTtBQUNBO0FBQ0EsTUFBTzhLLFNBQVc2USxNQUFRLEVBQTFCLENBRUYsSUFBS2pjLE9BQUwsQ0FDRSxHQUFJMHJCLFNBQVV0ZSxVQUFkLENBRUYsSUFBSy9NLE9BQUwsQ0FDRSxHQUFJaXJCLFdBQVlsTyxRQUFVM2Usb0JBQTFCLENBQ0FpdEIsVUFBWUEsUUFBVWhlLFVBQXRCLEVBRUEsR0FBSXRDLE9BQU9pQyxJQUFQLEVBQWU0TyxNQUFNNU8sSUFBckIsRUFBNkIsQ0FBQ2llLFNBQWxDLENBQTZDLENBQzNDLE1BQU8sTUFBUCxDQUNELENBQ0Q7QUFDQSxHQUFJaFMsU0FBVXgrQixNQUFNYyxHQUFOLENBQVV3dkIsTUFBVixDQUFkLENBQ0EsR0FBSWtPLE9BQUosQ0FBYSxDQUNYLE1BQU9BLFVBQVcyQyxLQUFsQixDQUNELENBQ0RtQixTQUFXNWUsc0JBQVgsQ0FFQTtBQUNBMWpCLE1BQU1rQixHQUFOLENBQVVvdkIsTUFBVixDQUFrQjZRLEtBQWxCLEVBQ0EsR0FBSXRTLFFBQVNtVSxZQUFZNE4sUUFBUXRnQixNQUFSLENBQVosQ0FBNkJzZ0IsUUFBUXpQLEtBQVIsQ0FBN0IsQ0FBNkNxQixTQUE3QyxDQUF3RHpFLFVBQXhELENBQW9FdUUsT0FBcEUsQ0FBNkV0aUMsS0FBN0UsQ0FBYixDQUNBQSxNQUFNLFFBQU4sRUFBZ0Jzd0IsTUFBaEIsRUFDQSxNQUFPekIsT0FBUCxDQUVGLElBQUtwSixVQUFMLENBQ0UsR0FBSWlTLGFBQUosQ0FBbUIsQ0FDakIsTUFBT0EsZUFBY3ZiLElBQWQsQ0FBbUJtVSxNQUFuQixHQUE4Qm9ILGNBQWN2YixJQUFkLENBQW1CZ2xCLEtBQW5CLENBQXJDLENBQ0QsQ0EzREwsQ0E2REEsTUFBTyxNQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7OztPQWNBLFFBQVNtQyxhQUFULENBQXNCaFQsTUFBdEIsQ0FBOEI2USxLQUE5QixDQUFxQ3FCLFNBQXJDLENBQWdEekUsVUFBaEQsQ0FBNER1RSxPQUE1RCxDQUFxRXRpQyxLQUFyRSxDQUE0RSxDQUMxRSxHQUFJd3dDLFdBQVlsTyxRQUFVM2Usb0JBQTFCLENBQ0lrdEIsU0FBVzVjLEtBQUszRCxNQUFMLENBRGYsQ0FFSXdnQixVQUFZRCxTQUFTcHFDLE1BRnpCLENBR0lzcUMsU0FBVzljLEtBQUtrTixLQUFMLENBSGYsQ0FJSU0sVUFBWXNQLFNBQVN0cUMsTUFKekIsQ0FNQSxHQUFJcXFDLFdBQWFyUCxTQUFiLEVBQTBCLENBQUMrTyxTQUEvQixDQUEwQyxDQUN4QyxNQUFPLE1BQVAsQ0FDRCxDQUNELEdBQUl4K0IsT0FBUTgrQixTQUFaLENBQ0EsTUFBTzkrQixPQUFQLENBQWdCLENBQ2QsR0FBSTdRLEtBQU0wdkMsU0FBUzcrQixLQUFULENBQVYsQ0FDQSxHQUFJLEVBQUV3K0IsVUFBWXJ2QyxNQUFPZ2dDLE1BQW5CLENBQTJCL00sZUFBZWpZLElBQWYsQ0FBb0JnbEIsS0FBcEIsQ0FBMkJoZ0MsR0FBM0IsQ0FBN0IsQ0FBSixDQUFtRSxDQUNqRSxNQUFPLE1BQVAsQ0FDRCxDQUNGLENBQ0Q7QUFDQSxHQUFJcTlCLFNBQVV4K0IsTUFBTWMsR0FBTixDQUFVd3ZCLE1BQVYsQ0FBZCxDQUNBLEdBQUlrTyxTQUFXeCtCLE1BQU1jLEdBQU4sQ0FBVXFnQyxLQUFWLENBQWYsQ0FBaUMsQ0FDL0IsTUFBTzNDLFVBQVcyQyxLQUFsQixDQUNELENBQ0QsR0FBSXRTLFFBQVMsSUFBYixDQUNBN3VCLE1BQU1rQixHQUFOLENBQVVvdkIsTUFBVixDQUFrQjZRLEtBQWxCLEVBQ0FuaEMsTUFBTWtCLEdBQU4sQ0FBVWlnQyxLQUFWLENBQWlCN1EsTUFBakIsRUFFQSxHQUFJMGdCLFVBQVdSLFNBQWYsQ0FDQSxNQUFPLEVBQUV4K0IsS0FBRixDQUFVOCtCLFNBQWpCLENBQTRCLENBQzFCM3ZDLElBQU0wdkMsU0FBUzcrQixLQUFULENBQU4sQ0FDQSxHQUFJNHFCLFVBQVd0TSxPQUFPbnZCLEdBQVAsQ0FBZixDQUNJdXZDLFNBQVd2UCxNQUFNaGdDLEdBQU4sQ0FEZixDQUdBLEdBQUk0OEIsVUFBSixDQUFnQixDQUNkLEdBQUk0UyxVQUFXSCxVQUNYelMsV0FBVzJTLFFBQVgsQ0FBcUI5VCxRQUFyQixDQUErQno3QixHQUEvQixDQUFvQ2dnQyxLQUFwQyxDQUEyQzdRLE1BQTNDLENBQW1EdHdCLEtBQW5ELENBRFcsQ0FFWCs5QixXQUFXbkIsUUFBWCxDQUFxQjhULFFBQXJCLENBQStCdnZDLEdBQS9CLENBQW9DbXZCLE1BQXBDLENBQTRDNlEsS0FBNUMsQ0FBbURuaEMsS0FBbkQsQ0FGSixDQUdELENBQ0Q7QUFDQSxHQUFJLEVBQUUyd0MsV0FBYXRwQyxTQUFiLENBQ0d1MUIsV0FBYThULFFBQWIsRUFBeUJsTyxVQUFVNUYsUUFBVixDQUFvQjhULFFBQXBCLENBQThCM1MsVUFBOUIsQ0FBMEN1RSxPQUExQyxDQUFtRHRpQyxLQUFuRCxDQUQ1QixDQUVFMndDLFFBRkosQ0FBSixDQUdPLENBQ0w5aEIsT0FBUyxLQUFULENBQ0EsTUFDRCxDQUNEbWlCLFdBQWFBLFNBQVc3dkMsS0FBTyxhQUEvQixFQUNELENBQ0QsR0FBSTB0QixRQUFVLENBQUNtaUIsUUFBZixDQUF5QixDQUN2QixHQUFJQyxTQUFVM2dCLE9BQU92dUIsV0FBckIsQ0FDSW12QyxRQUFVL1AsTUFBTXAvQixXQURwQixDQUdBO0FBQ0EsR0FBSWt2QyxTQUFXQyxPQUFYLEVBQ0MsZUFBaUI1Z0IsT0FBakIsRUFBMkIsZUFBaUI2USxNQUQ3QyxFQUVBLEVBQUUsTUFBTzhQLFFBQVAsRUFBa0IsVUFBbEIsRUFBZ0NBLGtCQUFtQkEsUUFBbkQsRUFDQSxNQUFPQyxRQUFQLEVBQWtCLFVBRGxCLEVBQ2dDQSxrQkFBbUJBLFFBRHJELENBRkosQ0FHbUUsQ0FDakVyaUIsT0FBUyxLQUFULENBQ0QsQ0FDRixDQUNEN3VCLE1BQU0sUUFBTixFQUFnQnN3QixNQUFoQixFQUNBdHdCLE1BQU0sUUFBTixFQUFnQm1oQyxLQUFoQixFQUNBLE1BQU90UyxPQUFQLENBQ0QsQ0FFRDs7Ozs7O09BT0EsUUFBUzRQLFdBQVQsQ0FBb0JuTyxNQUFwQixDQUE0QixDQUMxQixNQUFPd1EsZ0JBQWV4USxNQUFmLENBQXVCMkQsSUFBdkIsQ0FBNkI0WCxVQUE3QixDQUFQLENBQ0QsQ0FFRDs7Ozs7OztPQVFBLFFBQVNzRixhQUFULENBQXNCN2dCLE1BQXRCLENBQThCLENBQzVCLE1BQU93USxnQkFBZXhRLE1BQWYsQ0FBdUI4Z0IsTUFBdkIsQ0FBK0JDLFlBQS9CLENBQVAsQ0FDRCxDQUVEOzs7Ozs7T0FPQSxHQUFJckQsU0FBVSxDQUFDaFgsT0FBRCxDQUFXeHhCLElBQVgsQ0FBa0IsU0FBU3VvQixJQUFULENBQWUsQ0FDN0MsTUFBT2lKLFNBQVFsMkIsR0FBUixDQUFZaXRCLElBQVosQ0FBUCxDQUNELENBRkQsQ0FJQTs7Ozs7O09BT0EsUUFBUytmLFlBQVQsQ0FBcUIvZixJQUFyQixDQUEyQixDQUN6QixHQUFJYyxRQUFVZCxLQUFLcGQsSUFBTCxDQUFZLEVBQTFCLENBQ0l3ZCxNQUFRK0ksVUFBVXJJLE1BQVYsQ0FEWixDQUVJcG9CLE9BQVMydEIsZUFBZWpZLElBQWYsQ0FBb0IrYSxTQUFwQixDQUErQnJJLE1BQS9CLEVBQXlDVixNQUFNMW5CLE1BQS9DLENBQXdELENBRnJFLENBSUEsTUFBT0EsUUFBUCxDQUFpQixDQUNmLEdBQUkzQyxNQUFPcXFCLE1BQU0xbkIsTUFBTixDQUFYLENBQ0k2cUMsVUFBWXh0QyxLQUFLaXFCLElBRHJCLENBRUEsR0FBSXVqQixXQUFhLElBQWIsRUFBcUJBLFdBQWF2akIsSUFBdEMsQ0FBNEMsQ0FDMUMsTUFBT2pxQixNQUFLNk0sSUFBWixDQUNELENBQ0YsQ0FDRCxNQUFPa2UsT0FBUCxDQUNELENBRUQ7Ozs7OztPQU9BLFFBQVN3ZSxVQUFULENBQW1CdGYsSUFBbkIsQ0FBeUIsQ0FDdkIsR0FBSXVDLFFBQVM4RCxlQUFlalksSUFBZixDQUFvQjBiLE1BQXBCLENBQTRCLGFBQTVCLEVBQTZDQSxNQUE3QyxDQUFzRDlKLElBQW5FLENBQ0EsTUFBT3VDLFFBQU9tQixXQUFkLENBQ0QsQ0FFRDs7Ozs7Ozs7OztPQVdBLFFBQVNxVSxZQUFULEVBQXVCLENBQ3JCLEdBQUlqWCxRQUFTZ0osT0FBT3hKLFFBQVAsRUFBbUJBLFFBQWhDLENBQ0FRLE9BQVNBLFNBQVdSLFFBQVgsQ0FBc0I2VixZQUF0QixDQUFxQ3JWLE1BQTlDLENBQ0EsTUFBTytYLFdBQVVuZ0MsTUFBVixDQUFtQm9vQixPQUFPK1gsVUFBVSxDQUFWLENBQVAsQ0FBcUJBLFVBQVUsQ0FBVixDQUFyQixDQUFuQixDQUF3RC9YLE1BQS9ELENBQ0QsQ0FFRDs7Ozs7OztPQVFBLFFBQVMyTSxXQUFULENBQW9CL21CLEdBQXBCLENBQXlCdFQsR0FBekIsQ0FBOEIsQ0FDNUIsR0FBSTJDLE1BQU8yUSxJQUFJK2xCLFFBQWYsQ0FDQSxNQUFPK1csV0FBVXB3QyxHQUFWLEVBQ0gyQyxLQUFLLE1BQU8zQyxJQUFQLEVBQWMsUUFBZCxDQUF5QixRQUF6QixDQUFvQyxNQUF6QyxDQURHLENBRUgyQyxLQUFLMlEsR0FGVCxDQUdELENBRUQ7Ozs7OztPQU9BLFFBQVNzd0IsYUFBVCxDQUFzQnpVLE1BQXRCLENBQThCLENBQzVCLEdBQUl6QixRQUFTb0YsS0FBSzNELE1BQUwsQ0FBYixDQUNJN3BCLE9BQVNvb0IsT0FBT3BvQixNQURwQixDQUdBLE1BQU9BLFFBQVAsQ0FBaUIsQ0FDZixHQUFJdEYsS0FBTTB0QixPQUFPcG9CLE1BQVAsQ0FBVixDQUNJckYsTUFBUWt2QixPQUFPbnZCLEdBQVAsQ0FEWixDQUdBMHRCLE9BQU9wb0IsTUFBUCxFQUFpQixDQUFDdEYsR0FBRCxDQUFNQyxLQUFOLENBQWE2akMsbUJBQW1CN2pDLEtBQW5CLENBQWIsQ0FBakIsQ0FDRCxDQUNELE1BQU95dEIsT0FBUCxDQUNELENBRUQ7Ozs7Ozs7T0FRQSxRQUFTNkgsVUFBVCxDQUFtQnBHLE1BQW5CLENBQTJCbnZCLEdBQTNCLENBQWdDLENBQzlCLEdBQUlDLE9BQVEwd0IsU0FBU3hCLE1BQVQsQ0FBaUJudkIsR0FBakIsQ0FBWixDQUNBLE1BQU93aUMsY0FBYXZpQyxLQUFiLEVBQXNCQSxLQUF0QixDQUE4QmlHLFNBQXJDLENBQ0QsQ0FFRDs7Ozs7O09BT0EsR0FBSXdrQyxZQUFhbFcsaUJBQW1CbkQsUUFBUW1ELGdCQUFSLENBQTBCam9CLE1BQTFCLENBQW5CLENBQXVEOGpDLFNBQXhFLENBRUE7Ozs7Ozs7T0FRQSxHQUFJSCxjQUFlLENBQUMxYixnQkFBRCxDQUFvQjZiLFNBQXBCLENBQWdDLFNBQVNsaEIsTUFBVCxDQUFpQixDQUNsRSxHQUFJekIsUUFBUyxFQUFiLENBQ0EsTUFBT3lCLE1BQVAsQ0FBZSxDQUNibkIsVUFBVU4sTUFBVixDQUFrQmdkLFdBQVd2YixNQUFYLENBQWxCLEVBQ0FBLE9BQVN1RSxhQUFhdkUsTUFBYixDQUFULENBQ0QsQ0FDRCxNQUFPekIsT0FBUCxDQUNELENBUEQsQ0FTQTs7Ozs7O09BT0EsR0FBSXFQLFFBQVMrQyxVQUFiLENBRUE7QUFDQTtBQUNBLEdBQUt4SyxVQUFZeUgsT0FBTyxHQUFJekgsU0FBSixDQUFhLEdBQUlnYixZQUFKLENBQWdCLENBQWhCLENBQWIsQ0FBUCxHQUE0QzVyQixXQUF6RCxFQUNDOFEsS0FBT3VILE9BQU8sR0FBSXZILElBQUosRUFBUCxHQUFtQnpSLE1BRDNCLEVBRUM5Z0IsU0FBVzg1QixPQUFPOTVCLFFBQVFDLE9BQVIsRUFBUCxHQUE2QmdoQixVQUZ6QyxFQUdDdVIsS0FBT3NILE9BQU8sR0FBSXRILElBQUosRUFBUCxHQUFtQnJSLE1BSDNCLEVBSUNzUixTQUFXcUgsT0FBTyxHQUFJckgsUUFBSixFQUFQLEdBQXVCblIsVUFKdkMsQ0FJb0QsQ0FDbER3WSxPQUFTLFNBQVM5OEIsS0FBVCxDQUFnQixDQUN2QixHQUFJeXRCLFFBQVMwRixlQUFlcFksSUFBZixDQUFvQi9hLEtBQXBCLENBQWIsQ0FDSW9yQyxLQUFPM2QsUUFBVXpKLFNBQVYsQ0FBc0Joa0IsTUFBTVcsV0FBNUIsQ0FBMENzRixTQURyRCxDQUVJcXFDLFdBQWFsRixLQUFPcFYsU0FBU29WLElBQVQsQ0FBUCxDQUF3Qm5sQyxTQUZ6QyxDQUlBLEdBQUlxcUMsVUFBSixDQUFnQixDQUNkLE9BQVFBLFVBQVIsRUFDRSxJQUFLdmEsbUJBQUwsQ0FBeUIsTUFBT3RSLFlBQVAsQ0FDekIsSUFBS3dSLGNBQUwsQ0FBb0IsTUFBT25TLE9BQVAsQ0FDcEIsSUFBS29TLGtCQUFMLENBQXdCLE1BQU9qUyxXQUFQLENBQ3hCLElBQUtrUyxjQUFMLENBQW9CLE1BQU9oUyxPQUFQLENBQ3BCLElBQUtpUyxrQkFBTCxDQUF3QixNQUFPOVIsV0FBUCxDQUwxQixDQU9ELENBQ0QsTUFBT21KLE9BQVAsQ0FDRCxDQWZELENBZ0JELENBRUQ7Ozs7Ozs7OztPQVVBLFFBQVM2SyxRQUFULENBQWlCQyxLQUFqQixDQUF3QkMsR0FBeEIsQ0FBNkIrWCxVQUE3QixDQUF5QyxDQUN2QyxHQUFJMy9CLE9BQVEsQ0FBQyxDQUFiLENBQ0l2TCxPQUFTa3JDLFdBQVdsckMsTUFEeEIsQ0FHQSxNQUFPLEVBQUV1TCxLQUFGLENBQVV2TCxNQUFqQixDQUF5QixDQUN2QixHQUFJM0MsTUFBTzZ0QyxXQUFXMy9CLEtBQVgsQ0FBWCxDQUNJdWdCLEtBQU96dUIsS0FBS3l1QixJQURoQixDQUdBLE9BQVF6dUIsS0FBS3hELElBQWIsRUFDRSxJQUFLLE1BQUwsQ0FBa0JxNUIsT0FBU3BILElBQVQsQ0FBZSxNQUNqQyxJQUFLLFdBQUwsQ0FBa0JxSCxLQUFPckgsSUFBUCxDQUFhLE1BQy9CLElBQUssTUFBTCxDQUFrQnFILElBQU14RCxVQUFVd0QsR0FBVixDQUFlRCxNQUFRcEgsSUFBdkIsQ0FBTixDQUFvQyxNQUN0RCxJQUFLLFdBQUwsQ0FBa0JvSCxNQUFReEQsVUFBVXdELEtBQVYsQ0FBaUJDLElBQU1ySCxJQUF2QixDQUFSLENBQXNDLE1BSjFELENBTUQsQ0FDRCxNQUFPLENBQUUsUUFBU29ILEtBQVgsQ0FBa0IsTUFBT0MsR0FBekIsQ0FBUCxDQUNELENBRUQ7Ozs7OztPQU9BLFFBQVNnWSxlQUFULENBQXdCOXFCLE1BQXhCLENBQWdDLENBQzlCLEdBQUk5YyxPQUFROGMsT0FBTzljLEtBQVAsQ0FBYTZkLGFBQWIsQ0FBWixDQUNBLE1BQU83ZCxPQUFRQSxNQUFNLENBQU4sRUFBU3RLLEtBQVQsQ0FBZW9vQixjQUFmLENBQVIsQ0FBeUMsRUFBaEQsQ0FDRCxDQUVEOzs7Ozs7OztPQVNBLFFBQVMrcEIsUUFBVCxDQUFpQnZoQixNQUFqQixDQUF5Qm9RLElBQXpCLENBQStCb1IsT0FBL0IsQ0FBd0MsQ0FDdENwUixLQUFPQyxNQUFNRCxJQUFOLENBQVlwUSxNQUFaLEVBQXNCLENBQUNvUSxJQUFELENBQXRCLENBQStCRSxTQUFTRixJQUFULENBQXRDLENBRUEsR0FBSTdSLE9BQUosQ0FDSTdjLE1BQVEsQ0FBQyxDQURiLENBRUl2TCxPQUFTaTZCLEtBQUtqNkIsTUFGbEIsQ0FJQSxNQUFPLEVBQUV1TCxLQUFGLENBQVV2TCxNQUFqQixDQUF5QixDQUN2QixHQUFJdEYsS0FBTTAvQixNQUFNSCxLQUFLMXVCLEtBQUwsQ0FBTixDQUFWLENBQ0EsR0FBSSxFQUFFNmMsT0FBU3lCLFFBQVUsSUFBVixFQUFrQndoQixRQUFReGhCLE1BQVIsQ0FBZ0JudkIsR0FBaEIsQ0FBN0IsQ0FBSixDQUF3RCxDQUN0RCxNQUNELENBQ0RtdkIsT0FBU0EsT0FBT252QixHQUFQLENBQVQsQ0FDRCxDQUNELEdBQUkwdEIsTUFBSixDQUFZLENBQ1YsTUFBT0EsT0FBUCxDQUNELENBQ0QsR0FBSXBvQixRQUFTNnBCLE9BQVNBLE9BQU83cEIsTUFBaEIsQ0FBeUIsQ0FBdEMsQ0FDQSxNQUFPLENBQUMsQ0FBQ0EsTUFBRixFQUFZdzlCLFNBQVN4OUIsTUFBVCxDQUFaLEVBQWdDaTJCLFFBQVF2N0IsR0FBUixDQUFhc0YsTUFBYixDQUFoQyxHQUNKeVosUUFBUW9RLE1BQVIsR0FBbUJrTSxZQUFZbE0sTUFBWixDQURmLENBQVAsQ0FFRCxDQUVEOzs7Ozs7T0FPQSxRQUFTMk4sZUFBVCxDQUF3QjlQLEtBQXhCLENBQStCLENBQzdCLEdBQUkxbkIsUUFBUzBuQixNQUFNMW5CLE1BQW5CLENBQ0lvb0IsT0FBU1YsTUFBTXBzQixXQUFOLENBQWtCMEUsTUFBbEIsQ0FEYixDQUdBO0FBQ0EsR0FBSUEsUUFBVSxNQUFPMG5CLE9BQU0sQ0FBTixDQUFQLEVBQW1CLFFBQTdCLEVBQXlDaUcsZUFBZWpZLElBQWYsQ0FBb0JnUyxLQUFwQixDQUEyQixPQUEzQixDQUE3QyxDQUFrRixDQUNoRlUsT0FBTzdjLEtBQVAsQ0FBZW1jLE1BQU1uYyxLQUFyQixDQUNBNmMsT0FBT2tqQixLQUFQLENBQWU1akIsTUFBTTRqQixLQUFyQixDQUNELENBQ0QsTUFBT2xqQixPQUFQLENBQ0QsQ0FFRDs7Ozs7O09BT0EsUUFBU3dQLGdCQUFULENBQXlCL04sTUFBekIsQ0FBaUMsQ0FDL0IsTUFBUSxPQUFPQSxRQUFPdnVCLFdBQWQsRUFBNkIsVUFBN0IsRUFBMkMsQ0FBQ3lpQyxZQUFZbFUsTUFBWixDQUE3QyxDQUNIb0ksV0FBVzdELGFBQWF2RSxNQUFiLENBQVgsQ0FERyxDQUVILEVBRkosQ0FHRCxDQUVEOzs7Ozs7Ozs7Ozs7T0FhQSxRQUFTaU8sZUFBVCxDQUF3QmpPLE1BQXhCLENBQWdDOVksR0FBaEMsQ0FBcUN1eUIsU0FBckMsQ0FBZ0RsTSxNQUFoRCxDQUF3RCxDQUN0RCxHQUFJMk8sTUFBT2xjLE9BQU92dUIsV0FBbEIsQ0FDQSxPQUFReVYsR0FBUixFQUNFLElBQUtvTyxlQUFMLENBQ0UsTUFBTzRqQixrQkFBaUJsWixNQUFqQixDQUFQLENBRUYsSUFBS3pMLFFBQUwsQ0FDQSxJQUFLQyxRQUFMLENBQ0UsTUFBTyxJQUFJMG5CLEtBQUosQ0FBUyxDQUFDbGMsTUFBVixDQUFQLENBRUYsSUFBS3pLLFlBQUwsQ0FDRSxNQUFPOGpCLGVBQWNyWixNQUFkLENBQXNCdU4sTUFBdEIsQ0FBUCxDQUVGLElBQUsvWCxXQUFMLENBQWlCLElBQUtDLFdBQUwsQ0FDakIsSUFBS0MsUUFBTCxDQUFjLElBQUtDLFNBQUwsQ0FBZSxJQUFLQyxTQUFMLENBQzdCLElBQUtDLFNBQUwsQ0FBZSxJQUFLQyxnQkFBTCxDQUFzQixJQUFLQyxVQUFMLENBQWdCLElBQUtDLFVBQUwsQ0FDbkQsTUFBTytqQixpQkFBZ0IvWixNQUFoQixDQUF3QnVOLE1BQXhCLENBQVAsQ0FFRixJQUFLM1ksT0FBTCxDQUNFLE1BQU80a0IsVUFBU3haLE1BQVQsQ0FBaUJ1TixNQUFqQixDQUF5QmtNLFNBQXpCLENBQVAsQ0FFRixJQUFLNWtCLFVBQUwsQ0FDQSxJQUFLSyxVQUFMLENBQ0UsTUFBTyxJQUFJZ25CLEtBQUosQ0FBU2xjLE1BQVQsQ0FBUCxDQUVGLElBQUtoTCxVQUFMLENBQ0UsTUFBTzBrQixhQUFZMVosTUFBWixDQUFQLENBRUYsSUFBSy9LLE9BQUwsQ0FDRSxNQUFPMmtCLFVBQVM1WixNQUFULENBQWlCdU4sTUFBakIsQ0FBeUJrTSxTQUF6QixDQUFQLENBRUYsSUFBS3RrQixVQUFMLENBQ0UsTUFBTzBrQixhQUFZN1osTUFBWixDQUFQLENBOUJKLENBZ0NELENBRUQ7Ozs7Ozs7T0FRQSxRQUFTMGhCLGtCQUFULENBQTJCbHJCLE1BQTNCLENBQW1DbXJCLE9BQW5DLENBQTRDLENBQzFDLEdBQUl4ckMsUUFBU3dyQyxRQUFReHJDLE1BQXJCLENBQ0kwc0IsVUFBWTFzQixPQUFTLENBRHpCLENBR0F3ckMsUUFBUTllLFNBQVIsRUFBcUIsQ0FBQzFzQixPQUFTLENBQVQsQ0FBYSxJQUFiLENBQW9CLEVBQXJCLEVBQTJCd3JDLFFBQVE5ZSxTQUFSLENBQWhELENBQ0E4ZSxRQUFVQSxRQUFRdjlCLElBQVIsQ0FBYWpPLE9BQVMsQ0FBVCxDQUFhLElBQWIsQ0FBb0IsR0FBakMsQ0FBVixDQUNBLE1BQU9xZ0IsUUFBT3ZiLE9BQVAsQ0FBZXFjLGFBQWYsQ0FBOEIsdUJBQXlCcXFCLE9BQXpCLENBQW1DLFFBQWpFLENBQVAsQ0FDRCxDQUVEOzs7Ozs7T0FPQSxRQUFTOVIsY0FBVCxDQUF1Qi8rQixLQUF2QixDQUE4QixDQUM1QixNQUFPOGUsU0FBUTllLEtBQVIsR0FBa0JvN0IsWUFBWXA3QixLQUFaLENBQWxCLEVBQ0wsQ0FBQyxFQUFFOHpCLGtCQUFvQjl6QixLQUFwQixFQUE2QkEsTUFBTTh6QixnQkFBTixDQUEvQixDQURILENBRUQsQ0FFRDs7Ozs7OztPQVFBLFFBQVN3SCxRQUFULENBQWlCdDdCLEtBQWpCLENBQXdCcUYsTUFBeEIsQ0FBZ0MsQ0FDOUJBLE9BQVNBLFFBQVUsSUFBVixDQUFpQjJkLGdCQUFqQixDQUFvQzNkLE1BQTdDLENBQ0EsTUFBTyxDQUFDLENBQUNBLE1BQUYsR0FDSixNQUFPckYsTUFBUCxFQUFnQixRQUFoQixFQUE0Qm9uQixTQUFTdFMsSUFBVCxDQUFjOVUsS0FBZCxDQUR4QixHQUVKQSxNQUFRLENBQUMsQ0FBVCxFQUFjQSxNQUFRLENBQVIsRUFBYSxDQUEzQixFQUFnQ0EsTUFBUXFGLE1BRjNDLENBR0QsQ0FFRDs7Ozs7Ozs7O09BVUEsUUFBUzJsQyxlQUFULENBQXdCaHJDLEtBQXhCLENBQStCNFEsS0FBL0IsQ0FBc0NzZSxNQUF0QyxDQUE4QyxDQUM1QyxHQUFJLENBQUMwTixTQUFTMU4sTUFBVCxDQUFMLENBQXVCLENBQ3JCLE1BQU8sTUFBUCxDQUNELENBQ0QsR0FBSWh3QixNQUFPLE1BQU8wUixNQUFsQixDQUNBLEdBQUkxUixNQUFRLFFBQVIsQ0FDS3drQyxZQUFZeFUsTUFBWixHQUF1Qm9NLFFBQVExcUIsS0FBUixDQUFlc2UsT0FBTzdwQixNQUF0QixDQUQ1QixDQUVLbkcsTUFBUSxRQUFSLEVBQW9CMFIsUUFBU3NlLE9BRnRDLENBR00sQ0FDSixNQUFPd00sSUFBR3hNLE9BQU90ZSxLQUFQLENBQUgsQ0FBa0I1USxLQUFsQixDQUFQLENBQ0QsQ0FDRCxNQUFPLE1BQVAsQ0FDRCxDQUVEOzs7Ozs7O09BUUEsUUFBU3UvQixNQUFULENBQWV2L0IsS0FBZixDQUFzQmt2QixNQUF0QixDQUE4QixDQUM1QixHQUFJcFEsUUFBUTllLEtBQVIsQ0FBSixDQUFvQixDQUNsQixNQUFPLE1BQVAsQ0FDRCxDQUNELEdBQUlkLE1BQU8sTUFBT2MsTUFBbEIsQ0FDQSxHQUFJZCxNQUFRLFFBQVIsRUFBb0JBLE1BQVEsUUFBNUIsRUFBd0NBLE1BQVEsU0FBaEQsRUFDQWMsT0FBUyxJQURULEVBQ2lCdStCLFNBQVN2K0IsS0FBVCxDQURyQixDQUNzQyxDQUNwQyxNQUFPLEtBQVAsQ0FDRCxDQUNELE1BQU9nbUIsZUFBY2xSLElBQWQsQ0FBbUI5VSxLQUFuQixHQUE2QixDQUFDK2xCLGFBQWFqUixJQUFiLENBQWtCOVUsS0FBbEIsQ0FBOUIsRUFDSmt2QixRQUFVLElBQVYsRUFBa0JsdkIsUUFBU3NNLFFBQU80aUIsTUFBUCxDQUQ5QixDQUVELENBRUQ7Ozs7OztPQU9BLFFBQVNpaEIsVUFBVCxDQUFtQm53QyxLQUFuQixDQUEwQixDQUN4QixHQUFJZCxNQUFPLE1BQU9jLE1BQWxCLENBQ0EsTUFBUWQsT0FBUSxRQUFSLEVBQW9CQSxNQUFRLFFBQTVCLEVBQXdDQSxNQUFRLFFBQWhELEVBQTREQSxNQUFRLFNBQXJFLENBQ0ZjLFFBQVUsV0FEUixDQUVGQSxRQUFVLElBRmYsQ0FHRCxDQUVEOzs7Ozs7O09BUUEsUUFBUzZzQyxXQUFULENBQW9CbGdCLElBQXBCLENBQTBCLENBQ3hCLEdBQUlnZ0IsVUFBV0QsWUFBWS9mLElBQVosQ0FBZixDQUNJb1QsTUFBUXRKLE9BQU9rVyxRQUFQLENBRFosQ0FHQSxHQUFJLE1BQU81TSxNQUFQLEVBQWdCLFVBQWhCLEVBQThCLEVBQUU0TSxXQUFZaFcsYUFBWXBFLFNBQTFCLENBQWxDLENBQXdFLENBQ3RFLE1BQU8sTUFBUCxDQUNELENBQ0QsR0FBSTVGLE9BQVNvVCxLQUFiLENBQW9CLENBQ2xCLE1BQU8sS0FBUCxDQUNELENBQ0QsR0FBSXI5QixNQUFPa3FDLFFBQVE3TSxLQUFSLENBQVgsQ0FDQSxNQUFPLENBQUMsQ0FBQ3I5QixJQUFGLEVBQVVpcUIsT0FBU2pxQixLQUFLLENBQUwsQ0FBMUIsQ0FDRCxDQUVEOzs7Ozs7T0FPQSxRQUFTOC9CLFNBQVQsQ0FBa0I3VixJQUFsQixDQUF3QixDQUN0QixNQUFPLENBQUMsQ0FBQ2dHLFVBQUYsRUFBaUJBLGFBQWNoRyxLQUF0QyxDQUNELENBRUQ7Ozs7OztPQU9BLEdBQUlta0IsWUFBYXBlLFdBQWEwTSxVQUFiLENBQTBCMlIsU0FBM0MsQ0FFQTs7Ozs7O09BT0EsUUFBUzNOLFlBQVQsQ0FBcUJwakMsS0FBckIsQ0FBNEIsQ0FDMUIsR0FBSW9yQyxNQUFPcHJDLE9BQVNBLE1BQU1XLFdBQTFCLENBQ0k4OEIsTUFBUyxNQUFPMk4sS0FBUCxFQUFlLFVBQWYsRUFBNkJBLEtBQUs3WSxTQUFuQyxFQUFpREUsV0FEN0QsQ0FHQSxNQUFPenlCLFNBQVV5OUIsS0FBakIsQ0FDRCxDQUVEOzs7Ozs7O09BUUEsUUFBU29HLG1CQUFULENBQTRCN2pDLEtBQTVCLENBQW1DLENBQ2pDLE1BQU9BLFNBQVVBLEtBQVYsRUFBbUIsQ0FBQzQ4QixTQUFTNThCLEtBQVQsQ0FBM0IsQ0FDRCxDQUVEOzs7Ozs7OztPQVNBLFFBQVM0akMsd0JBQVQsQ0FBaUM3akMsR0FBakMsQ0FBc0MwN0IsUUFBdEMsQ0FBZ0QsQ0FDOUMsTUFBTyxVQUFTdk0sTUFBVCxDQUFpQixDQUN0QixHQUFJQSxRQUFVLElBQWQsQ0FBb0IsQ0FDbEIsTUFBTyxNQUFQLENBQ0QsQ0FDRCxNQUFPQSxRQUFPbnZCLEdBQVAsSUFBZ0IwN0IsUUFBaEIsR0FDSkEsV0FBYXgxQixTQUFiLEVBQTJCbEcsTUFBT3VNLFFBQU80aUIsTUFBUCxDQUQ5QixDQUFQLENBRUQsQ0FORCxDQU9ELENBRUQ7Ozs7Ozs7Ozs7Ozs7OztPQWdCQSxRQUFTaWdCLFVBQVQsQ0FBbUJ6c0MsSUFBbkIsQ0FBeUJnakIsTUFBekIsQ0FBaUMsQ0FDL0IsR0FBSXdiLFNBQVV4K0IsS0FBSyxDQUFMLENBQWQsQ0FDSXN1QyxXQUFhdHJCLE9BQU8sQ0FBUCxDQURqQixDQUVJdXJCLFdBQWEvUCxRQUFVOFAsVUFGM0IsQ0FHSWxULFNBQVdtVCxZQUFjcnZCLFVBQVlDLGFBQVosQ0FBNEJNLFFBQTFDLENBSGYsQ0FLQSxHQUFJK3VCLFNBQ0FGLFlBQWM3dUIsUUFBZixFQUE2QitlLFNBQVduZixVQUF6QyxFQUNFaXZCLFlBQWM3dUIsUUFBZixFQUE2QitlLFNBQVc5ZSxVQUF4QyxFQUF3RDFmLEtBQUssQ0FBTCxFQUFRMkMsTUFBUixFQUFrQnFnQixPQUFPLENBQVAsQ0FEM0UsRUFFRXNyQixhQUFlN3VCLFNBQVdDLFVBQTFCLENBQUQsRUFBNENzRCxPQUFPLENBQVAsRUFBVXJnQixNQUFWLEVBQW9CcWdCLE9BQU8sQ0FBUCxDQUFoRSxFQUErRXdiLFNBQVduZixVQUg3RixDQUtBO0FBQ0EsR0FBSSxFQUFFK2IsVUFBWW9ULE9BQWQsQ0FBSixDQUE0QixDQUMxQixNQUFPeHVDLEtBQVAsQ0FDRCxDQUNEO0FBQ0EsR0FBSXN1QyxXQUFhcHZCLFNBQWpCLENBQTRCLENBQzFCbGYsS0FBSyxDQUFMLEVBQVVnakIsT0FBTyxDQUFQLENBQVYsQ0FDQTtBQUNBdXJCLFlBQWMvUCxRQUFVdGYsU0FBVixDQUFzQixDQUF0QixDQUEwQkUsZ0JBQXhDLENBQ0QsQ0FDRDtBQUNBLEdBQUk5aEIsT0FBUTBsQixPQUFPLENBQVAsQ0FBWixDQUNBLEdBQUkxbEIsS0FBSixDQUFXLENBQ1QsR0FBSTJwQyxVQUFXam5DLEtBQUssQ0FBTCxDQUFmLENBQ0FBLEtBQUssQ0FBTCxFQUFVaW5DLFNBQVdELFlBQVlDLFFBQVosQ0FBc0IzcEMsS0FBdEIsQ0FBNkIwbEIsT0FBTyxDQUFQLENBQTdCLENBQVgsQ0FBcUQxbEIsS0FBL0QsQ0FDQTBDLEtBQUssQ0FBTCxFQUFVaW5DLFNBQVdwWSxlQUFlN3VCLEtBQUssQ0FBTCxDQUFmLENBQXdCaWYsV0FBeEIsQ0FBWCxDQUFrRCtELE9BQU8sQ0FBUCxDQUE1RCxDQUNELENBQ0Q7QUFDQTFsQixNQUFRMGxCLE9BQU8sQ0FBUCxDQUFSLENBQ0EsR0FBSTFsQixLQUFKLENBQVcsQ0FDVDJwQyxTQUFXam5DLEtBQUssQ0FBTCxDQUFYLENBQ0FBLEtBQUssQ0FBTCxFQUFVaW5DLFNBQVdVLGlCQUFpQlYsUUFBakIsQ0FBMkIzcEMsS0FBM0IsQ0FBa0MwbEIsT0FBTyxDQUFQLENBQWxDLENBQVgsQ0FBMEQxbEIsS0FBcEUsQ0FDQTBDLEtBQUssQ0FBTCxFQUFVaW5DLFNBQVdwWSxlQUFlN3VCLEtBQUssQ0FBTCxDQUFmLENBQXdCaWYsV0FBeEIsQ0FBWCxDQUFrRCtELE9BQU8sQ0FBUCxDQUE1RCxDQUNELENBQ0Q7QUFDQTFsQixNQUFRMGxCLE9BQU8sQ0FBUCxDQUFSLENBQ0EsR0FBSTFsQixLQUFKLENBQVcsQ0FDVDBDLEtBQUssQ0FBTCxFQUFVMUMsS0FBVixDQUNELENBQ0Q7QUFDQSxHQUFJZ3hDLFdBQWE3dUIsUUFBakIsQ0FBMkIsQ0FDekJ6ZixLQUFLLENBQUwsRUFBVUEsS0FBSyxDQUFMLEdBQVcsSUFBWCxDQUFrQmdqQixPQUFPLENBQVAsQ0FBbEIsQ0FBOEJzUCxVQUFVdHlCLEtBQUssQ0FBTCxDQUFWLENBQW1CZ2pCLE9BQU8sQ0FBUCxDQUFuQixDQUF4QyxDQUNELENBQ0Q7QUFDQSxHQUFJaGpCLEtBQUssQ0FBTCxHQUFXLElBQWYsQ0FBcUIsQ0FDbkJBLEtBQUssQ0FBTCxFQUFVZ2pCLE9BQU8sQ0FBUCxDQUFWLENBQ0QsQ0FDRDtBQUNBaGpCLEtBQUssQ0FBTCxFQUFVZ2pCLE9BQU8sQ0FBUCxDQUFWLENBQ0FoakIsS0FBSyxDQUFMLEVBQVV1dUMsVUFBVixDQUVBLE1BQU92dUMsS0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7OztPQWFBLFFBQVN5dUMsY0FBVCxDQUF1QjNWLFFBQXZCLENBQWlDQyxRQUFqQyxDQUEyQzE3QixHQUEzQyxDQUFnRG12QixNQUFoRCxDQUF3RHhKLE1BQXhELENBQWdFOW1CLEtBQWhFLENBQXVFLENBQ3JFLEdBQUlnK0IsU0FBU3BCLFFBQVQsR0FBc0JvQixTQUFTbkIsUUFBVCxDQUExQixDQUE4QyxDQUM1QztBQUNBNzhCLE1BQU1rQixHQUFOLENBQVUyN0IsUUFBVixDQUFvQkQsUUFBcEIsRUFDQXVJLFVBQVV2SSxRQUFWLENBQW9CQyxRQUFwQixDQUE4QngxQixTQUE5QixDQUF5Q2tyQyxhQUF6QyxDQUF3RHZ5QyxLQUF4RCxFQUNBQSxNQUFNLFFBQU4sRUFBZ0I2OEIsUUFBaEIsRUFDRCxDQUNELE1BQU9ELFNBQVAsQ0FDRCxDQUVEOzs7Ozs7OztPQVNBLFFBQVM4SCxhQUFULENBQXNCcFUsTUFBdEIsQ0FBOEIsQ0FDNUIsR0FBSXpCLFFBQVMsRUFBYixDQUNBLEdBQUl5QixRQUFVLElBQWQsQ0FBb0IsQ0FDbEIsSUFBSyxHQUFJbnZCLElBQVQsR0FBZ0J1TSxRQUFPNGlCLE1BQVAsQ0FBaEIsQ0FBZ0MsQ0FDOUJ6QixPQUFPM2tCLElBQVAsQ0FBWS9JLEdBQVosRUFDRCxDQUNGLENBQ0QsTUFBTzB0QixPQUFQLENBQ0QsQ0FFRDs7Ozs7OztPQVFBLFFBQVNvVCxPQUFULENBQWdCM1IsTUFBaEIsQ0FBd0JvUSxJQUF4QixDQUE4QixDQUM1QixNQUFPQSxNQUFLajZCLE1BQUwsRUFBZSxDQUFmLENBQW1CNnBCLE1BQW5CLENBQTRCbVEsUUFBUW5RLE1BQVIsQ0FBZ0IyVyxVQUFVdkcsSUFBVixDQUFnQixDQUFoQixDQUFtQixDQUFDLENBQXBCLENBQWhCLENBQW5DLENBQ0QsQ0FFRDs7Ozs7Ozs7O09BVUEsUUFBU2tPLFFBQVQsQ0FBaUJ6Z0IsS0FBakIsQ0FBd0JtWSxPQUF4QixDQUFpQyxDQUMvQixHQUFJOU0sV0FBWXJMLE1BQU0xbkIsTUFBdEIsQ0FDSUEsT0FBUzJ2QixVQUFVa1EsUUFBUTcvQixNQUFsQixDQUEwQit5QixTQUExQixDQURiLENBRUlnWixTQUFXdlosVUFBVTlLLEtBQVYsQ0FGZixDQUlBLE1BQU8xbkIsUUFBUCxDQUFpQixDQUNmLEdBQUl1TCxPQUFRczBCLFFBQVE3L0IsTUFBUixDQUFaLENBQ0EwbkIsTUFBTTFuQixNQUFOLEVBQWdCaTJCLFFBQVExcUIsS0FBUixDQUFld25CLFNBQWYsRUFBNEJnWixTQUFTeGdDLEtBQVQsQ0FBNUIsQ0FBOEMzSyxTQUE5RCxDQUNELENBQ0QsTUFBTzhtQixNQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7OztPQWNBLEdBQUluYixTQUFXLFVBQVcsQ0FDeEIsR0FBSTFCLE9BQVEsQ0FBWixDQUNJbWhDLFdBQWEsQ0FEakIsQ0FHQSxNQUFPLFVBQVN0eEMsR0FBVCxDQUFjQyxLQUFkLENBQXFCLENBQzFCLEdBQUlzeEMsT0FBUXhrQyxLQUFaLENBQ0l5a0MsVUFBWTV1QixVQUFZMnVCLE1BQVFELFVBQXBCLENBRGhCLENBR0FBLFdBQWFDLEtBQWIsQ0FDQSxHQUFJQyxVQUFZLENBQWhCLENBQW1CLENBQ2pCLEdBQUksRUFBRXJoQyxLQUFGLEVBQVd3UyxTQUFmLENBQTBCLENBQ3hCLE1BQU8zaUIsSUFBUCxDQUNELENBQ0YsQ0FKRCxJQUlPLENBQ0xtUSxNQUFRLENBQVIsQ0FDRCxDQUNELE1BQU8wMUIsYUFBWTdsQyxHQUFaLENBQWlCQyxLQUFqQixDQUFQLENBQ0QsQ0FiRCxDQWNELENBbEJjLEVBQWYsQ0FvQkE7Ozs7Ozs7T0FRQSxHQUFJaUUsWUFBYWl3QixlQUFpQixTQUFTdkgsSUFBVCxDQUFlZ1IsSUFBZixDQUFxQixDQUNyRCxNQUFPM1MsTUFBSy9tQixVQUFMLENBQWdCMG9CLElBQWhCLENBQXNCZ1IsSUFBdEIsQ0FBUCxDQUNELENBRkQsQ0FJQTs7Ozs7Ozs7O09BVUEsR0FBSW1SLGlCQUFrQixDQUFDblosY0FBRCxDQUFrQm9OLFFBQWxCLENBQTZCLFNBQVN1SSxPQUFULENBQWtCa0csU0FBbEIsQ0FBNkJ0USxPQUE3QixDQUFzQyxDQUN2RixHQUFJeGIsUUFBVThyQixVQUFZLEVBQTFCLENBQ0EsTUFBTzdiLGdCQUFlMlYsT0FBZixDQUF3QixVQUF4QixDQUFvQyxDQUN6QyxlQUFnQixJQUR5QixDQUV6QyxhQUFjLEtBRjJCLENBR3pDLFFBQVNtRyxTQUFTYixrQkFBa0JsckIsTUFBbEIsQ0FBMEJnc0Isa0JBQWtCbEIsZUFBZTlxQixNQUFmLENBQWxCLENBQTBDd2IsT0FBMUMsQ0FBMUIsQ0FBVCxDQUhnQyxDQUFwQyxDQUFQLENBS0QsQ0FQRCxDQVNBOzs7Ozs7T0FPQSxHQUFJNkcsY0FBZTRKLFFBQVEsU0FBU2xqQyxNQUFULENBQWlCLENBQzFDQSxPQUFTcWlCLFNBQVNyaUIsTUFBVCxDQUFULENBRUEsR0FBSWdmLFFBQVMsRUFBYixDQUNBLEdBQUl4SCxhQUFhblIsSUFBYixDQUFrQnJHLE1BQWxCLENBQUosQ0FBK0IsQ0FDN0JnZixPQUFPM2tCLElBQVAsQ0FBWSxFQUFaLEVBQ0QsQ0FDRDJGLE9BQU90RSxPQUFQLENBQWUrYixVQUFmLENBQTJCLFNBQVN0ZCxLQUFULENBQWdCeXpCLE1BQWhCLENBQXdCdVYsS0FBeEIsQ0FBK0JuakMsTUFBL0IsQ0FBdUMsQ0FDaEVnZixPQUFPM2tCLElBQVAsQ0FBWThvQyxNQUFRbmpDLE9BQU90RSxPQUFQLENBQWV5YyxZQUFmLENBQTZCLElBQTdCLENBQVIsQ0FBOEN5VixRQUFVenpCLEtBQXBFLEVBQ0QsQ0FGRCxFQUdBLE1BQU82a0IsT0FBUCxDQUNELENBWGtCLENBQW5CLENBYUE7Ozs7OztPQU9BLFFBQVNnUyxNQUFULENBQWV6L0IsS0FBZixDQUFzQixDQUNwQixHQUFJLE1BQU9BLE1BQVAsRUFBZ0IsUUFBaEIsRUFBNEJ1K0IsU0FBU3YrQixLQUFULENBQWhDLENBQWlELENBQy9DLE1BQU9BLE1BQVAsQ0FDRCxDQUNELEdBQUl5dEIsUUFBVXp0QixNQUFRLEVBQXRCLENBQ0EsTUFBUXl0QixTQUFVLEdBQVYsRUFBa0IsRUFBSXp0QixLQUFMLEVBQWUsQ0FBQytpQixRQUFsQyxDQUE4QyxJQUE5QyxDQUFxRDBLLE1BQTVELENBQ0QsQ0FFRDs7Ozs7O09BT0EsUUFBU3VJLFNBQVQsQ0FBa0JySixJQUFsQixDQUF3QixDQUN0QixHQUFJQSxNQUFRLElBQVosQ0FBa0IsQ0FDaEIsR0FBSSxDQUNGLE1BQU9vRyxjQUFhaFksSUFBYixDQUFrQjRSLElBQWxCLENBQVAsQ0FDRCxDQUFDLE1BQU9ybUIsQ0FBUCxDQUFVLENBQUUsQ0FDZCxHQUFJLENBQ0YsTUFBUXFtQixNQUFPLEVBQWYsQ0FDRCxDQUFDLE1BQU9ybUIsQ0FBUCxDQUFVLENBQUUsQ0FDZixDQUNELE1BQU8sRUFBUCxDQUNELENBRUQ7Ozs7Ozs7T0FRQSxRQUFTb3JDLGtCQUFULENBQTJCYixPQUEzQixDQUFvQzNQLE9BQXBDLENBQTZDLENBQzNDL1QsVUFBVTdKLFNBQVYsQ0FBcUIsU0FBU2tKLElBQVQsQ0FBZSxDQUNsQyxHQUFJeHNCLE9BQVEsS0FBT3dzQixLQUFLLENBQUwsQ0FBbkIsQ0FDQSxHQUFLMFUsUUFBVTFVLEtBQUssQ0FBTCxDQUFYLEVBQXVCLENBQUNrQixjQUFjbWpCLE9BQWQsQ0FBdUI3d0MsS0FBdkIsQ0FBNUIsQ0FBMkQsQ0FDekQ2d0MsUUFBUS9uQyxJQUFSLENBQWE5SSxLQUFiLEVBQ0QsQ0FDRixDQUxELEVBTUEsTUFBTzZ3QyxTQUFRbnpCLElBQVIsRUFBUCxDQUNELENBRUQ7Ozs7OztPQU9BLFFBQVNtWixhQUFULENBQXNCeVUsT0FBdEIsQ0FBK0IsQ0FDN0IsR0FBSUEsa0JBQW1CM1UsWUFBdkIsQ0FBb0MsQ0FDbEMsTUFBTzJVLFNBQVF2VCxLQUFSLEVBQVAsQ0FDRCxDQUNELEdBQUl0SyxRQUFTLEdBQUltSixjQUFKLENBQWtCMFUsUUFBUXRVLFdBQTFCLENBQXVDc1UsUUFBUXBVLFNBQS9DLENBQWIsQ0FDQXpKLE9BQU93SixXQUFQLENBQXFCWSxVQUFVeVQsUUFBUXJVLFdBQWxCLENBQXJCLENBQ0F4SixPQUFPMEosU0FBUCxDQUFvQm1VLFFBQVFuVSxTQUE1QixDQUNBMUosT0FBTzJKLFVBQVAsQ0FBb0JrVSxRQUFRbFUsVUFBNUIsQ0FDQSxNQUFPM0osT0FBUCxDQUNELENBRUQsNEVBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcUJBLFFBQVNsYSxNQUFULENBQWV3WixLQUFmLENBQXNCb0UsSUFBdEIsQ0FBNEI0WixLQUE1QixDQUFtQyxDQUNqQyxHQUFLQSxNQUFRQyxlQUFlamUsS0FBZixDQUFzQm9FLElBQXRCLENBQTRCNFosS0FBNUIsQ0FBUixDQUE2QzVaLE9BQVNsckIsU0FBM0QsQ0FBdUUsQ0FDckVrckIsS0FBTyxDQUFQLENBQ0QsQ0FGRCxJQUVPLENBQ0xBLEtBQU80RCxVQUFVMEosVUFBVXROLElBQVYsQ0FBVixDQUEyQixDQUEzQixDQUFQLENBQ0QsQ0FDRCxHQUFJOXJCLFFBQVMwbkIsTUFBUUEsTUFBTTFuQixNQUFkLENBQXVCLENBQXBDLENBQ0EsR0FBSSxDQUFDQSxNQUFELEVBQVc4ckIsS0FBTyxDQUF0QixDQUF5QixDQUN2QixNQUFPLEVBQVAsQ0FDRCxDQUNELEdBQUl2Z0IsT0FBUSxDQUFaLENBQ0k0YyxTQUFXLENBRGYsQ0FFSUMsT0FBUzljLE1BQU13akIsV0FBVzl1QixPQUFTOHJCLElBQXBCLENBQU4sQ0FGYixDQUlBLE1BQU92Z0IsTUFBUXZMLE1BQWYsQ0FBdUIsQ0FDckJvb0IsT0FBT0QsVUFBUCxFQUFxQnFZLFVBQVU5WSxLQUFWLENBQWlCbmMsS0FBakIsQ0FBeUJBLE9BQVN1Z0IsSUFBbEMsQ0FBckIsQ0FDRCxDQUNELE1BQU8xRCxPQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7T0FlQSxRQUFTN1EsUUFBVCxDQUFpQm1RLEtBQWpCLENBQXdCLENBQ3RCLEdBQUluYyxPQUFRLENBQUMsQ0FBYixDQUNJdkwsT0FBUzBuQixNQUFRQSxNQUFNMW5CLE1BQWQsQ0FBdUIsQ0FEcEMsQ0FFSW1vQixTQUFXLENBRmYsQ0FHSUMsT0FBUyxFQUhiLENBS0EsTUFBTyxFQUFFN2MsS0FBRixDQUFVdkwsTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSXJGLE9BQVErc0IsTUFBTW5jLEtBQU4sQ0FBWixDQUNBLEdBQUk1USxLQUFKLENBQVcsQ0FDVHl0QixPQUFPRCxVQUFQLEVBQXFCeHRCLEtBQXJCLENBQ0QsQ0FDRixDQUNELE1BQU95dEIsT0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXNCQSxRQUFTMWtCLE9BQVQsRUFBa0IsQ0FDaEIsR0FBSTFELFFBQVNtZ0MsVUFBVW5nQyxNQUF2QixDQUNJd25CLEtBQU9sYyxNQUFNdEwsT0FBU0EsT0FBUyxDQUFsQixDQUFzQixDQUE1QixDQURYLENBRUkwbkIsTUFBUXlZLFVBQVUsQ0FBVixDQUZaLENBR0k1MEIsTUFBUXZMLE1BSFosQ0FLQSxNQUFPdUwsT0FBUCxDQUFnQixDQUNkaWMsS0FBS2pjLE1BQVEsQ0FBYixFQUFrQjQwQixVQUFVNTBCLEtBQVYsQ0FBbEIsQ0FDRCxDQUNELE1BQU92TCxRQUNIMG9CLFVBQVVqUCxRQUFRaU8sS0FBUixFQUFpQjhLLFVBQVU5SyxLQUFWLENBQWpCLENBQW9DLENBQUNBLEtBQUQsQ0FBOUMsQ0FBdUQ2UixZQUFZL1IsSUFBWixDQUFrQixDQUFsQixDQUF2RCxDQURHLENBRUgsRUFGSixDQUdELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcUJBLEdBQUlnbEIsWUFBYXRNLFNBQVMsU0FBU3hZLEtBQVQsQ0FBZ0JsUyxNQUFoQixDQUF3QixDQUNoRCxNQUFPdXBCLG1CQUFrQnJYLEtBQWxCLEVBQ0g2USxlQUFlN1EsS0FBZixDQUFzQjZSLFlBQVkvakIsTUFBWixDQUFvQixDQUFwQixDQUF1QnVwQixpQkFBdkIsQ0FBMEMsSUFBMUMsQ0FBdEIsQ0FERyxDQUVILEVBRkosQ0FHRCxDQUpnQixDQUFqQixDQU1BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F5QkEsR0FBSTBOLGNBQWV2TSxTQUFTLFNBQVN4WSxLQUFULENBQWdCbFMsTUFBaEIsQ0FBd0IsQ0FDbEQsR0FBSW9TLFVBQVc2VCxLQUFLam1CLE1BQUwsQ0FBZixDQUNBLEdBQUl1cEIsa0JBQWtCblgsUUFBbEIsQ0FBSixDQUFpQyxDQUMvQkEsU0FBV2huQixTQUFYLENBQ0QsQ0FDRCxNQUFPbStCLG1CQUFrQnJYLEtBQWxCLEVBQ0g2USxlQUFlN1EsS0FBZixDQUFzQjZSLFlBQVkvakIsTUFBWixDQUFvQixDQUFwQixDQUF1QnVwQixpQkFBdkIsQ0FBMEMsSUFBMUMsQ0FBdEIsQ0FBdUVNLFlBQVl6WCxRQUFaLENBQXNCLENBQXRCLENBQXZFLENBREcsQ0FFSCxFQUZKLENBR0QsQ0FSa0IsQ0FBbkIsQ0FVQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXVCQSxHQUFJOGtCLGdCQUFpQnhNLFNBQVMsU0FBU3hZLEtBQVQsQ0FBZ0JsUyxNQUFoQixDQUF3QixDQUNwRCxHQUFJZ1QsWUFBYWlULEtBQUtqbUIsTUFBTCxDQUFqQixDQUNBLEdBQUl1cEIsa0JBQWtCdlcsVUFBbEIsQ0FBSixDQUFtQyxDQUNqQ0EsV0FBYTVuQixTQUFiLENBQ0QsQ0FDRCxNQUFPbStCLG1CQUFrQnJYLEtBQWxCLEVBQ0g2USxlQUFlN1EsS0FBZixDQUFzQjZSLFlBQVkvakIsTUFBWixDQUFvQixDQUFwQixDQUF1QnVwQixpQkFBdkIsQ0FBMEMsSUFBMUMsQ0FBdEIsQ0FBdUVuK0IsU0FBdkUsQ0FBa0Y0bkIsVUFBbEYsQ0FERyxDQUVILEVBRkosQ0FHRCxDQVJvQixDQUFyQixDQVVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F5QkEsUUFBU3RXLEtBQVQsQ0FBY3dWLEtBQWQsQ0FBcUJ5QyxDQUFyQixDQUF3QnViLEtBQXhCLENBQStCLENBQzdCLEdBQUkxbEMsUUFBUzBuQixNQUFRQSxNQUFNMW5CLE1BQWQsQ0FBdUIsQ0FBcEMsQ0FDQSxHQUFJLENBQUNBLE1BQUwsQ0FBYSxDQUNYLE1BQU8sRUFBUCxDQUNELENBQ0RtcUIsRUFBS3ViLE9BQVN2YixJQUFNdnBCLFNBQWhCLENBQTZCLENBQTdCLENBQWlDdzRCLFVBQVVqUCxDQUFWLENBQXJDLENBQ0EsTUFBT3FXLFdBQVU5WSxLQUFWLENBQWlCeUMsRUFBSSxDQUFKLENBQVEsQ0FBUixDQUFZQSxDQUE3QixDQUFnQ25xQixNQUFoQyxDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BeUJBLFFBQVMyc0MsVUFBVCxDQUFtQmpsQixLQUFuQixDQUEwQnlDLENBQTFCLENBQTZCdWIsS0FBN0IsQ0FBb0MsQ0FDbEMsR0FBSTFsQyxRQUFTMG5CLE1BQVFBLE1BQU0xbkIsTUFBZCxDQUF1QixDQUFwQyxDQUNBLEdBQUksQ0FBQ0EsTUFBTCxDQUFhLENBQ1gsTUFBTyxFQUFQLENBQ0QsQ0FDRG1xQixFQUFLdWIsT0FBU3ZiLElBQU12cEIsU0FBaEIsQ0FBNkIsQ0FBN0IsQ0FBaUN3NEIsVUFBVWpQLENBQVYsQ0FBckMsQ0FDQUEsRUFBSW5xQixPQUFTbXFCLENBQWIsQ0FDQSxNQUFPcVcsV0FBVTlZLEtBQVYsQ0FBaUIsQ0FBakIsQ0FBb0J5QyxFQUFJLENBQUosQ0FBUSxDQUFSLENBQVlBLENBQWhDLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BbUNBLFFBQVN5aUIsZUFBVCxDQUF3QmxsQixLQUF4QixDQUErQk8sU0FBL0IsQ0FBMEMsQ0FDeEMsTUFBUVAsUUFBU0EsTUFBTTFuQixNQUFoQixDQUNIaWlDLFVBQVV2YSxLQUFWLENBQWlCMlgsWUFBWXBYLFNBQVosQ0FBdUIsQ0FBdkIsQ0FBakIsQ0FBNEMsSUFBNUMsQ0FBa0QsSUFBbEQsQ0FERyxDQUVILEVBRkosQ0FHRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQW9DQSxRQUFTNGtCLFVBQVQsQ0FBbUJubEIsS0FBbkIsQ0FBMEJPLFNBQTFCLENBQXFDLENBQ25DLE1BQVFQLFFBQVNBLE1BQU0xbkIsTUFBaEIsQ0FDSGlpQyxVQUFVdmEsS0FBVixDQUFpQjJYLFlBQVlwWCxTQUFaLENBQXVCLENBQXZCLENBQWpCLENBQTRDLElBQTVDLENBREcsQ0FFSCxFQUZKLENBR0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTZCQSxRQUFTNmtCLEtBQVQsQ0FBY3BsQixLQUFkLENBQXFCL3NCLEtBQXJCLENBQTRCdTRCLEtBQTVCLENBQW1DQyxHQUFuQyxDQUF3QyxDQUN0QyxHQUFJbnpCLFFBQVMwbkIsTUFBUUEsTUFBTTFuQixNQUFkLENBQXVCLENBQXBDLENBQ0EsR0FBSSxDQUFDQSxNQUFMLENBQWEsQ0FDWCxNQUFPLEVBQVAsQ0FDRCxDQUNELEdBQUlrekIsT0FBUyxNQUFPQSxNQUFQLEVBQWdCLFFBQXpCLEVBQXFDeVMsZUFBZWplLEtBQWYsQ0FBc0Ivc0IsS0FBdEIsQ0FBNkJ1NEIsS0FBN0IsQ0FBekMsQ0FBOEUsQ0FDNUVBLE1BQVEsQ0FBUixDQUNBQyxJQUFNbnpCLE1BQU4sQ0FDRCxDQUNELE1BQU9tNUIsVUFBU3pSLEtBQVQsQ0FBZ0Ivc0IsS0FBaEIsQ0FBdUJ1NEIsS0FBdkIsQ0FBOEJDLEdBQTlCLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQW9DQSxRQUFTNFosVUFBVCxDQUFtQnJsQixLQUFuQixDQUEwQk8sU0FBMUIsQ0FBcUNzQixTQUFyQyxDQUFnRCxDQUM5QyxHQUFJdnBCLFFBQVMwbkIsTUFBUUEsTUFBTTFuQixNQUFkLENBQXVCLENBQXBDLENBQ0EsR0FBSSxDQUFDQSxNQUFMLENBQWEsQ0FDWCxNQUFPLENBQUMsQ0FBUixDQUNELENBQ0QsR0FBSXVMLE9BQVFnZSxXQUFhLElBQWIsQ0FBb0IsQ0FBcEIsQ0FBd0I2UCxVQUFVN1AsU0FBVixDQUFwQyxDQUNBLEdBQUloZSxNQUFRLENBQVosQ0FBZSxDQUNiQSxNQUFRbWtCLFVBQVUxdkIsT0FBU3VMLEtBQW5CLENBQTBCLENBQTFCLENBQVIsQ0FDRCxDQUNELE1BQU8rZCxlQUFjNUIsS0FBZCxDQUFxQjJYLFlBQVlwWCxTQUFaLENBQXVCLENBQXZCLENBQXJCLENBQWdEMWMsS0FBaEQsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bb0NBLFFBQVN5aEMsY0FBVCxDQUF1QnRsQixLQUF2QixDQUE4Qk8sU0FBOUIsQ0FBeUNzQixTQUF6QyxDQUFvRCxDQUNsRCxHQUFJdnBCLFFBQVMwbkIsTUFBUUEsTUFBTTFuQixNQUFkLENBQXVCLENBQXBDLENBQ0EsR0FBSSxDQUFDQSxNQUFMLENBQWEsQ0FDWCxNQUFPLENBQUMsQ0FBUixDQUNELENBQ0QsR0FBSXVMLE9BQVF2TCxPQUFTLENBQXJCLENBQ0EsR0FBSXVwQixZQUFjM29CLFNBQWxCLENBQTZCLENBQzNCMkssTUFBUTZ0QixVQUFVN1AsU0FBVixDQUFSLENBQ0FoZSxNQUFRZ2UsVUFBWSxDQUFaLENBQ0ptRyxVQUFVMXZCLE9BQVN1TCxLQUFuQixDQUEwQixDQUExQixDQURJLENBRUpva0IsVUFBVXBrQixLQUFWLENBQWlCdkwsT0FBUyxDQUExQixDQUZKLENBR0QsQ0FDRCxNQUFPc3BCLGVBQWM1QixLQUFkLENBQXFCMlgsWUFBWXBYLFNBQVosQ0FBdUIsQ0FBdkIsQ0FBckIsQ0FBZ0QxYyxLQUFoRCxDQUF1RCxJQUF2RCxDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7OztPQWNBLFFBQVMwaEMsUUFBVCxDQUFpQnZsQixLQUFqQixDQUF3QixDQUN0QixHQUFJMW5CLFFBQVMwbkIsTUFBUUEsTUFBTTFuQixNQUFkLENBQXVCLENBQXBDLENBQ0EsTUFBT0EsUUFBU3U1QixZQUFZN1IsS0FBWixDQUFtQixDQUFuQixDQUFULENBQWlDLEVBQXhDLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7OztPQWNBLFFBQVN3bEIsWUFBVCxDQUFxQnhsQixLQUFyQixDQUE0QixDQUMxQixHQUFJMW5CLFFBQVMwbkIsTUFBUUEsTUFBTTFuQixNQUFkLENBQXVCLENBQXBDLENBQ0EsTUFBT0EsUUFBU3U1QixZQUFZN1IsS0FBWixDQUFtQmhLLFFBQW5CLENBQVQsQ0FBd0MsRUFBL0MsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bb0JBLFFBQVN5dkIsYUFBVCxDQUFzQnpsQixLQUF0QixDQUE2QjhSLEtBQTdCLENBQW9DLENBQ2xDLEdBQUl4NUIsUUFBUzBuQixNQUFRQSxNQUFNMW5CLE1BQWQsQ0FBdUIsQ0FBcEMsQ0FDQSxHQUFJLENBQUNBLE1BQUwsQ0FBYSxDQUNYLE1BQU8sRUFBUCxDQUNELENBQ0R3NUIsTUFBUUEsUUFBVTU0QixTQUFWLENBQXNCLENBQXRCLENBQTBCdzRCLFVBQVVJLEtBQVYsQ0FBbEMsQ0FDQSxNQUFPRCxhQUFZN1IsS0FBWixDQUFtQjhSLEtBQW5CLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7OztPQWVBLFFBQVM0VCxVQUFULENBQW1CeFgsS0FBbkIsQ0FBMEIsQ0FDeEIsR0FBSXJxQixPQUFRLENBQUMsQ0FBYixDQUNJdkwsT0FBUzQxQixNQUFRQSxNQUFNNTFCLE1BQWQsQ0FBdUIsQ0FEcEMsQ0FFSW9vQixPQUFTLEVBRmIsQ0FJQSxNQUFPLEVBQUU3YyxLQUFGLENBQVV2TCxNQUFqQixDQUF5QixDQUN2QixHQUFJbW5CLE1BQU95TyxNQUFNcnFCLEtBQU4sQ0FBWCxDQUNBNmMsT0FBT2pCLEtBQUssQ0FBTCxDQUFQLEVBQWtCQSxLQUFLLENBQUwsQ0FBbEIsQ0FDRCxDQUNELE1BQU9pQixPQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FrQkEsUUFBU2lsQixLQUFULENBQWMzbEIsS0FBZCxDQUFxQixDQUNuQixNQUFRQSxRQUFTQSxNQUFNMW5CLE1BQWhCLENBQTBCMG5CLE1BQU0sQ0FBTixDQUExQixDQUFxQzltQixTQUE1QyxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F1QkEsUUFBU21ULFFBQVQsQ0FBaUIyVCxLQUFqQixDQUF3Qi9zQixLQUF4QixDQUErQjR1QixTQUEvQixDQUEwQyxDQUN4QyxHQUFJdnBCLFFBQVMwbkIsTUFBUUEsTUFBTTFuQixNQUFkLENBQXVCLENBQXBDLENBQ0EsR0FBSSxDQUFDQSxNQUFMLENBQWEsQ0FDWCxNQUFPLENBQUMsQ0FBUixDQUNELENBQ0QsR0FBSXVMLE9BQVFnZSxXQUFhLElBQWIsQ0FBb0IsQ0FBcEIsQ0FBd0I2UCxVQUFVN1AsU0FBVixDQUFwQyxDQUNBLEdBQUloZSxNQUFRLENBQVosQ0FBZSxDQUNiQSxNQUFRbWtCLFVBQVUxdkIsT0FBU3VMLEtBQW5CLENBQTBCLENBQTFCLENBQVIsQ0FDRCxDQUNELE1BQU8rYyxhQUFZWixLQUFaLENBQW1CL3NCLEtBQW5CLENBQTBCNFEsS0FBMUIsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7T0FjQSxRQUFTK2hDLFFBQVQsQ0FBaUI1bEIsS0FBakIsQ0FBd0IsQ0FDdEIsR0FBSTFuQixRQUFTMG5CLE1BQVFBLE1BQU0xbkIsTUFBZCxDQUF1QixDQUFwQyxDQUNBLE1BQU9BLFFBQVN3Z0MsVUFBVTlZLEtBQVYsQ0FBaUIsQ0FBakIsQ0FBb0IsQ0FBQyxDQUFyQixDQUFULENBQW1DLEVBQTFDLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7OztPQWlCQSxHQUFJNmxCLGNBQWVyTixTQUFTLFNBQVNuRixNQUFULENBQWlCLENBQzNDLEdBQUl5UyxRQUFTL2tCLFNBQVNzUyxNQUFULENBQWlCeUgsbUJBQWpCLENBQWIsQ0FDQSxNQUFRZ0wsUUFBT3h0QyxNQUFQLEVBQWlCd3RDLE9BQU8sQ0FBUCxJQUFjelMsT0FBTyxDQUFQLENBQWhDLENBQ0hELGlCQUFpQjBTLE1BQWpCLENBREcsQ0FFSCxFQUZKLENBR0QsQ0FMa0IsQ0FBbkIsQ0FPQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bc0JBLEdBQUlDLGdCQUFpQnZOLFNBQVMsU0FBU25GLE1BQVQsQ0FBaUIsQ0FDN0MsR0FBSW5ULFVBQVc2VCxLQUFLVixNQUFMLENBQWYsQ0FDSXlTLE9BQVMva0IsU0FBU3NTLE1BQVQsQ0FBaUJ5SCxtQkFBakIsQ0FEYixDQUdBLEdBQUk1YSxXQUFhNlQsS0FBSytSLE1BQUwsQ0FBakIsQ0FBK0IsQ0FDN0I1bEIsU0FBV2huQixTQUFYLENBQ0QsQ0FGRCxJQUVPLENBQ0w0c0MsT0FBT2haLEdBQVAsR0FDRCxDQUNELE1BQVFnWixRQUFPeHRDLE1BQVAsRUFBaUJ3dEMsT0FBTyxDQUFQLElBQWN6UyxPQUFPLENBQVAsQ0FBaEMsQ0FDSEQsaUJBQWlCMFMsTUFBakIsQ0FBeUJuTyxZQUFZelgsUUFBWixDQUFzQixDQUF0QixDQUF6QixDQURHLENBRUgsRUFGSixDQUdELENBWm9CLENBQXJCLENBY0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcUJBLEdBQUk4bEIsa0JBQW1CeE4sU0FBUyxTQUFTbkYsTUFBVCxDQUFpQixDQUMvQyxHQUFJdlMsWUFBYWlULEtBQUtWLE1BQUwsQ0FBakIsQ0FDSXlTLE9BQVMva0IsU0FBU3NTLE1BQVQsQ0FBaUJ5SCxtQkFBakIsQ0FEYixDQUdBLEdBQUloYSxhQUFlaVQsS0FBSytSLE1BQUwsQ0FBbkIsQ0FBaUMsQ0FDL0JobEIsV0FBYTVuQixTQUFiLENBQ0QsQ0FGRCxJQUVPLENBQ0w0c0MsT0FBT2haLEdBQVAsR0FDRCxDQUNELE1BQVFnWixRQUFPeHRDLE1BQVAsRUFBaUJ3dEMsT0FBTyxDQUFQLElBQWN6UyxPQUFPLENBQVAsQ0FBaEMsQ0FDSEQsaUJBQWlCMFMsTUFBakIsQ0FBeUI1c0MsU0FBekIsQ0FBb0M0bkIsVUFBcEMsQ0FERyxDQUVILEVBRkosQ0FHRCxDQVpzQixDQUF2QixDQWNBOzs7Ozs7Ozs7Ozs7OztPQWVBLFFBQVN2YSxLQUFULENBQWN5WixLQUFkLENBQXFCaW1CLFNBQXJCLENBQWdDLENBQzlCLE1BQU9qbUIsT0FBUThILFdBQVc5WixJQUFYLENBQWdCZ1MsS0FBaEIsQ0FBdUJpbUIsU0FBdkIsQ0FBUixDQUE0QyxFQUFuRCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7T0FjQSxRQUFTbFMsS0FBVCxDQUFjL1QsS0FBZCxDQUFxQixDQUNuQixHQUFJMW5CLFFBQVMwbkIsTUFBUUEsTUFBTTFuQixNQUFkLENBQXVCLENBQXBDLENBQ0EsTUFBT0EsUUFBUzBuQixNQUFNMW5CLE9BQVMsQ0FBZixDQUFULENBQTZCWSxTQUFwQyxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcUJBLFFBQVNndEMsWUFBVCxDQUFxQmxtQixLQUFyQixDQUE0Qi9zQixLQUE1QixDQUFtQzR1QixTQUFuQyxDQUE4QyxDQUM1QyxHQUFJdnBCLFFBQVMwbkIsTUFBUUEsTUFBTTFuQixNQUFkLENBQXVCLENBQXBDLENBQ0EsR0FBSSxDQUFDQSxNQUFMLENBQWEsQ0FDWCxNQUFPLENBQUMsQ0FBUixDQUNELENBQ0QsR0FBSXVMLE9BQVF2TCxNQUFaLENBQ0EsR0FBSXVwQixZQUFjM29CLFNBQWxCLENBQTZCLENBQzNCMkssTUFBUTZ0QixVQUFVN1AsU0FBVixDQUFSLENBQ0FoZSxNQUFRLENBQ05BLE1BQVEsQ0FBUixDQUNJbWtCLFVBQVUxdkIsT0FBU3VMLEtBQW5CLENBQTBCLENBQTFCLENBREosQ0FFSW9rQixVQUFVcGtCLEtBQVYsQ0FBaUJ2TCxPQUFTLENBQTFCLENBSEUsRUFJSixDQUpKLENBS0QsQ0FDRCxHQUFJckYsUUFBVUEsS0FBZCxDQUFxQixDQUNuQixNQUFPMnVCLGVBQWM1QixLQUFkLENBQXFCK0IsU0FBckIsQ0FBZ0NsZSxNQUFRLENBQXhDLENBQTJDLElBQTNDLENBQVAsQ0FDRCxDQUNELE1BQU9BLE9BQVAsQ0FBZ0IsQ0FDZCxHQUFJbWMsTUFBTW5jLEtBQU4sSUFBaUI1USxLQUFyQixDQUE0QixDQUMxQixNQUFPNFEsTUFBUCxDQUNELENBQ0YsQ0FDRCxNQUFPLENBQUMsQ0FBUixDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcUJBLFFBQVNzaUMsSUFBVCxDQUFhbm1CLEtBQWIsQ0FBb0J5QyxDQUFwQixDQUF1QixDQUNyQixNQUFRekMsUUFBU0EsTUFBTTFuQixNQUFoQixDQUEwQmsvQixRQUFReFgsS0FBUixDQUFlMFIsVUFBVWpQLENBQVYsQ0FBZixDQUExQixDQUF5RHZwQixTQUFoRSxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F1QkEsR0FBSWt0QyxNQUFPNU4sU0FBUzZOLE9BQVQsQ0FBWCxDQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bb0JBLFFBQVNBLFFBQVQsQ0FBaUJybUIsS0FBakIsQ0FBd0JsUyxNQUF4QixDQUFnQyxDQUM5QixNQUFRa1MsUUFBU0EsTUFBTTFuQixNQUFmLEVBQXlCd1YsTUFBekIsRUFBbUNBLE9BQU94VixNQUEzQyxDQUNIMi9CLFlBQVlqWSxLQUFaLENBQW1CbFMsTUFBbkIsQ0FERyxDQUVIa1MsS0FGSixDQUdELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bd0JBLFFBQVNzbUIsVUFBVCxDQUFtQnRtQixLQUFuQixDQUEwQmxTLE1BQTFCLENBQWtDb1MsUUFBbEMsQ0FBNEMsQ0FDMUMsTUFBUUYsUUFBU0EsTUFBTTFuQixNQUFmLEVBQXlCd1YsTUFBekIsRUFBbUNBLE9BQU94VixNQUEzQyxDQUNIMi9CLFlBQVlqWSxLQUFaLENBQW1CbFMsTUFBbkIsQ0FBMkI2cEIsWUFBWXpYLFFBQVosQ0FBc0IsQ0FBdEIsQ0FBM0IsQ0FERyxDQUVIRixLQUZKLENBR0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXVCQSxRQUFTdW1CLFlBQVQsQ0FBcUJ2bUIsS0FBckIsQ0FBNEJsUyxNQUE1QixDQUFvQ2dULFVBQXBDLENBQWdELENBQzlDLE1BQVFkLFFBQVNBLE1BQU0xbkIsTUFBZixFQUF5QndWLE1BQXpCLEVBQW1DQSxPQUFPeFYsTUFBM0MsQ0FDSDIvQixZQUFZalksS0FBWixDQUFtQmxTLE1BQW5CLENBQTJCNVUsU0FBM0IsQ0FBc0M0bkIsVUFBdEMsQ0FERyxDQUVIZCxLQUZKLENBR0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F3QkEsR0FBSXdtQixRQUFTaE8sU0FBUyxTQUFTeFksS0FBVCxDQUFnQm1ZLE9BQWhCLENBQXlCLENBQzdDQSxRQUFVdEcsWUFBWXNHLE9BQVosQ0FBcUIsQ0FBckIsQ0FBVixDQUVBLEdBQUk3L0IsUUFBUzBuQixNQUFRQSxNQUFNMW5CLE1BQWQsQ0FBdUIsQ0FBcEMsQ0FDSW9vQixPQUFTd08sT0FBT2xQLEtBQVAsQ0FBY21ZLE9BQWQsQ0FEYixDQUdBRCxXQUFXbFksS0FBWCxDQUFrQmUsU0FBU29YLE9BQVQsQ0FBa0IsU0FBU3QwQixLQUFULENBQWdCLENBQ2xELE1BQU8wcUIsU0FBUTFxQixLQUFSLENBQWV2TCxNQUFmLEVBQXlCLENBQUN1TCxLQUExQixDQUFrQ0EsS0FBekMsQ0FDRCxDQUZpQixFQUVmOE0sSUFGZSxDQUVWeXJCLGdCQUZVLENBQWxCLEVBSUEsTUFBTzFiLE9BQVAsQ0FDRCxDQVhZLENBQWIsQ0FhQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTZCQSxRQUFTenNCLE9BQVQsQ0FBZ0IrckIsS0FBaEIsQ0FBdUJPLFNBQXZCLENBQWtDLENBQ2hDLEdBQUlHLFFBQVMsRUFBYixDQUNBLEdBQUksRUFBRVYsT0FBU0EsTUFBTTFuQixNQUFqQixDQUFKLENBQThCLENBQzVCLE1BQU9vb0IsT0FBUCxDQUNELENBQ0QsR0FBSTdjLE9BQVEsQ0FBQyxDQUFiLENBQ0lzMEIsUUFBVSxFQURkLENBRUk3L0IsT0FBUzBuQixNQUFNMW5CLE1BRm5CLENBSUFpb0IsVUFBWW9YLFlBQVlwWCxTQUFaLENBQXVCLENBQXZCLENBQVosQ0FDQSxNQUFPLEVBQUUxYyxLQUFGLENBQVV2TCxNQUFqQixDQUF5QixDQUN2QixHQUFJckYsT0FBUStzQixNQUFNbmMsS0FBTixDQUFaLENBQ0EsR0FBSTBjLFVBQVV0dEIsS0FBVixDQUFpQjRRLEtBQWpCLENBQXdCbWMsS0FBeEIsQ0FBSixDQUFvQyxDQUNsQ1UsT0FBTzNrQixJQUFQLENBQVk5SSxLQUFaLEVBQ0FrbEMsUUFBUXA4QixJQUFSLENBQWE4SCxLQUFiLEVBQ0QsQ0FDRixDQUNEcTBCLFdBQVdsWSxLQUFYLENBQWtCbVksT0FBbEIsRUFDQSxNQUFPelgsT0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F1QkEsUUFBU3ZQLFFBQVQsQ0FBaUI2TyxLQUFqQixDQUF3QixDQUN0QixNQUFPQSxPQUFRcUksY0FBY3JhLElBQWQsQ0FBbUJnUyxLQUFuQixDQUFSLENBQW9DQSxLQUEzQyxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7OztPQWdCQSxRQUFTbWIsTUFBVCxDQUFlbmIsS0FBZixDQUFzQndMLEtBQXRCLENBQTZCQyxHQUE3QixDQUFrQyxDQUNoQyxHQUFJbnpCLFFBQVMwbkIsTUFBUUEsTUFBTTFuQixNQUFkLENBQXVCLENBQXBDLENBQ0EsR0FBSSxDQUFDQSxNQUFMLENBQWEsQ0FDWCxNQUFPLEVBQVAsQ0FDRCxDQUNELEdBQUltekIsS0FBTyxNQUFPQSxJQUFQLEVBQWMsUUFBckIsRUFBaUN3UyxlQUFlamUsS0FBZixDQUFzQndMLEtBQXRCLENBQTZCQyxHQUE3QixDQUFyQyxDQUF3RSxDQUN0RUQsTUFBUSxDQUFSLENBQ0FDLElBQU1uekIsTUFBTixDQUNELENBSEQsSUFJSyxDQUNIa3pCLE1BQVFBLE9BQVMsSUFBVCxDQUFnQixDQUFoQixDQUFvQmtHLFVBQVVsRyxLQUFWLENBQTVCLENBQ0FDLElBQU1BLE1BQVF2eUIsU0FBUixDQUFvQlosTUFBcEIsQ0FBNkJvNUIsVUFBVWpHLEdBQVYsQ0FBbkMsQ0FDRCxDQUNELE1BQU9xTixXQUFVOVksS0FBVixDQUFpQndMLEtBQWpCLENBQXdCQyxHQUF4QixDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7OztPQWlCQSxRQUFTZ2IsWUFBVCxDQUFxQnptQixLQUFyQixDQUE0Qi9zQixLQUE1QixDQUFtQyxDQUNqQyxNQUFPK2xDLGlCQUFnQmhaLEtBQWhCLENBQXVCL3NCLEtBQXZCLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMEJBLFFBQVN5ekMsY0FBVCxDQUF1QjFtQixLQUF2QixDQUE4Qi9zQixLQUE5QixDQUFxQ2l0QixRQUFyQyxDQUErQyxDQUM3QyxNQUFPa1osbUJBQWtCcFosS0FBbEIsQ0FBeUIvc0IsS0FBekIsQ0FBZ0Mwa0MsWUFBWXpYLFFBQVosQ0FBc0IsQ0FBdEIsQ0FBaEMsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7OztPQWdCQSxRQUFTeW1CLGNBQVQsQ0FBdUIzbUIsS0FBdkIsQ0FBOEIvc0IsS0FBOUIsQ0FBcUMsQ0FDbkMsR0FBSXFGLFFBQVMwbkIsTUFBUUEsTUFBTTFuQixNQUFkLENBQXVCLENBQXBDLENBQ0EsR0FBSUEsTUFBSixDQUFZLENBQ1YsR0FBSXVMLE9BQVFtMUIsZ0JBQWdCaFosS0FBaEIsQ0FBdUIvc0IsS0FBdkIsQ0FBWixDQUNBLEdBQUk0USxNQUFRdkwsTUFBUixFQUFrQnEyQixHQUFHM08sTUFBTW5jLEtBQU4sQ0FBSCxDQUFpQjVRLEtBQWpCLENBQXRCLENBQStDLENBQzdDLE1BQU80USxNQUFQLENBQ0QsQ0FDRixDQUNELE1BQU8sQ0FBQyxDQUFSLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FrQkEsUUFBUytpQyxnQkFBVCxDQUF5QjVtQixLQUF6QixDQUFnQy9zQixLQUFoQyxDQUF1QyxDQUNyQyxNQUFPK2xDLGlCQUFnQmhaLEtBQWhCLENBQXVCL3NCLEtBQXZCLENBQThCLElBQTlCLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMEJBLFFBQVM0ekMsa0JBQVQsQ0FBMkI3bUIsS0FBM0IsQ0FBa0Mvc0IsS0FBbEMsQ0FBeUNpdEIsUUFBekMsQ0FBbUQsQ0FDakQsTUFBT2taLG1CQUFrQnBaLEtBQWxCLENBQXlCL3NCLEtBQXpCLENBQWdDMGtDLFlBQVl6WCxRQUFaLENBQXNCLENBQXRCLENBQWhDLENBQTBELElBQTFELENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7T0FnQkEsUUFBUzRtQixrQkFBVCxDQUEyQjltQixLQUEzQixDQUFrQy9zQixLQUFsQyxDQUF5QyxDQUN2QyxHQUFJcUYsUUFBUzBuQixNQUFRQSxNQUFNMW5CLE1BQWQsQ0FBdUIsQ0FBcEMsQ0FDQSxHQUFJQSxNQUFKLENBQVksQ0FDVixHQUFJdUwsT0FBUW0xQixnQkFBZ0JoWixLQUFoQixDQUF1Qi9zQixLQUF2QixDQUE4QixJQUE5QixFQUFzQyxDQUFsRCxDQUNBLEdBQUkwN0IsR0FBRzNPLE1BQU1uYyxLQUFOLENBQUgsQ0FBaUI1USxLQUFqQixDQUFKLENBQTZCLENBQzNCLE1BQU80USxNQUFQLENBQ0QsQ0FDRixDQUNELE1BQU8sQ0FBQyxDQUFSLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7T0FlQSxRQUFTa2pDLFdBQVQsQ0FBb0IvbUIsS0FBcEIsQ0FBMkIsQ0FDekIsTUFBUUEsUUFBU0EsTUFBTTFuQixNQUFoQixDQUNId2hDLGVBQWU5WixLQUFmLENBREcsQ0FFSCxFQUZKLENBR0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7O09BZ0JBLFFBQVNnbkIsYUFBVCxDQUFzQmhuQixLQUF0QixDQUE2QkUsUUFBN0IsQ0FBdUMsQ0FDckMsTUFBUUYsUUFBU0EsTUFBTTFuQixNQUFoQixDQUNId2hDLGVBQWU5WixLQUFmLENBQXNCMlgsWUFBWXpYLFFBQVosQ0FBc0IsQ0FBdEIsQ0FBdEIsQ0FERyxDQUVILEVBRkosQ0FHRCxDQUVEOzs7Ozs7Ozs7Ozs7O09BY0EsUUFBUyttQixLQUFULENBQWNqbkIsS0FBZCxDQUFxQixDQUNuQixHQUFJMW5CLFFBQVMwbkIsTUFBUUEsTUFBTTFuQixNQUFkLENBQXVCLENBQXBDLENBQ0EsTUFBT0EsUUFBU3dnQyxVQUFVOVksS0FBVixDQUFpQixDQUFqQixDQUFvQjFuQixNQUFwQixDQUFULENBQXVDLEVBQTlDLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BeUJBLFFBQVM0dUMsS0FBVCxDQUFjbG5CLEtBQWQsQ0FBcUJ5QyxDQUFyQixDQUF3QnViLEtBQXhCLENBQStCLENBQzdCLEdBQUksRUFBRWhlLE9BQVNBLE1BQU0xbkIsTUFBakIsQ0FBSixDQUE4QixDQUM1QixNQUFPLEVBQVAsQ0FDRCxDQUNEbXFCLEVBQUt1YixPQUFTdmIsSUFBTXZwQixTQUFoQixDQUE2QixDQUE3QixDQUFpQ3c0QixVQUFValAsQ0FBVixDQUFyQyxDQUNBLE1BQU9xVyxXQUFVOVksS0FBVixDQUFpQixDQUFqQixDQUFvQnlDLEVBQUksQ0FBSixDQUFRLENBQVIsQ0FBWUEsQ0FBaEMsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXlCQSxRQUFTMGtCLFVBQVQsQ0FBbUJubkIsS0FBbkIsQ0FBMEJ5QyxDQUExQixDQUE2QnViLEtBQTdCLENBQW9DLENBQ2xDLEdBQUkxbEMsUUFBUzBuQixNQUFRQSxNQUFNMW5CLE1BQWQsQ0FBdUIsQ0FBcEMsQ0FDQSxHQUFJLENBQUNBLE1BQUwsQ0FBYSxDQUNYLE1BQU8sRUFBUCxDQUNELENBQ0RtcUIsRUFBS3ViLE9BQVN2YixJQUFNdnBCLFNBQWhCLENBQTZCLENBQTdCLENBQWlDdzRCLFVBQVVqUCxDQUFWLENBQXJDLENBQ0FBLEVBQUlucUIsT0FBU21xQixDQUFiLENBQ0EsTUFBT3FXLFdBQVU5WSxLQUFWLENBQWlCeUMsRUFBSSxDQUFKLENBQVEsQ0FBUixDQUFZQSxDQUE3QixDQUFnQ25xQixNQUFoQyxDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FvQ0EsUUFBUzh1QyxlQUFULENBQXdCcG5CLEtBQXhCLENBQStCTyxTQUEvQixDQUEwQyxDQUN4QyxNQUFRUCxRQUFTQSxNQUFNMW5CLE1BQWhCLENBQ0hpaUMsVUFBVXZhLEtBQVYsQ0FBaUIyWCxZQUFZcFgsU0FBWixDQUF1QixDQUF2QixDQUFqQixDQUE0QyxLQUE1QyxDQUFtRCxJQUFuRCxDQURHLENBRUgsRUFGSixDQUdELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bb0NBLFFBQVM4bUIsVUFBVCxDQUFtQnJuQixLQUFuQixDQUEwQk8sU0FBMUIsQ0FBcUMsQ0FDbkMsTUFBUVAsUUFBU0EsTUFBTTFuQixNQUFoQixDQUNIaWlDLFVBQVV2YSxLQUFWLENBQWlCMlgsWUFBWXBYLFNBQVosQ0FBdUIsQ0FBdkIsQ0FBakIsQ0FERyxDQUVILEVBRkosQ0FHRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7T0FnQkEsR0FBSSttQixPQUFROU8sU0FBUyxTQUFTbkYsTUFBVCxDQUFpQixDQUNwQyxNQUFPNEcsVUFBU3BJLFlBQVl3QixNQUFaLENBQW9CLENBQXBCLENBQXVCZ0UsaUJBQXZCLENBQTBDLElBQTFDLENBQVQsQ0FBUCxDQUNELENBRlcsQ0FBWixDQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXdCQSxHQUFJa1EsU0FBVS9PLFNBQVMsU0FBU25GLE1BQVQsQ0FBaUIsQ0FDdEMsR0FBSW5ULFVBQVc2VCxLQUFLVixNQUFMLENBQWYsQ0FDQSxHQUFJZ0Usa0JBQWtCblgsUUFBbEIsQ0FBSixDQUFpQyxDQUMvQkEsU0FBV2huQixTQUFYLENBQ0QsQ0FDRCxNQUFPK2dDLFVBQVNwSSxZQUFZd0IsTUFBWixDQUFvQixDQUFwQixDQUF1QmdFLGlCQUF2QixDQUEwQyxJQUExQyxDQUFULENBQTBETSxZQUFZelgsUUFBWixDQUFzQixDQUF0QixDQUExRCxDQUFQLENBQ0QsQ0FOYSxDQUFkLENBUUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcUJBLEdBQUlzbkIsV0FBWWhQLFNBQVMsU0FBU25GLE1BQVQsQ0FBaUIsQ0FDeEMsR0FBSXZTLFlBQWFpVCxLQUFLVixNQUFMLENBQWpCLENBQ0EsR0FBSWdFLGtCQUFrQnZXLFVBQWxCLENBQUosQ0FBbUMsQ0FDakNBLFdBQWE1bkIsU0FBYixDQUNELENBQ0QsTUFBTytnQyxVQUFTcEksWUFBWXdCLE1BQVosQ0FBb0IsQ0FBcEIsQ0FBdUJnRSxpQkFBdkIsQ0FBMEMsSUFBMUMsQ0FBVCxDQUEwRG4rQixTQUExRCxDQUFxRTRuQixVQUFyRSxDQUFQLENBQ0QsQ0FOZSxDQUFoQixDQVFBOzs7Ozs7Ozs7Ozs7Ozs7O09BaUJBLFFBQVMybUIsS0FBVCxDQUFjem5CLEtBQWQsQ0FBcUIsQ0FDbkIsTUFBUUEsUUFBU0EsTUFBTTFuQixNQUFoQixDQUNIMmhDLFNBQVNqYSxLQUFULENBREcsQ0FFSCxFQUZKLENBR0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bc0JBLFFBQVMwbkIsT0FBVCxDQUFnQjFuQixLQUFoQixDQUF1QkUsUUFBdkIsQ0FBaUMsQ0FDL0IsTUFBUUYsUUFBU0EsTUFBTTFuQixNQUFoQixDQUNIMmhDLFNBQVNqYSxLQUFULENBQWdCMlgsWUFBWXpYLFFBQVosQ0FBc0IsQ0FBdEIsQ0FBaEIsQ0FERyxDQUVILEVBRkosQ0FHRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FtQkEsUUFBU3luQixTQUFULENBQWtCM25CLEtBQWxCLENBQXlCYyxVQUF6QixDQUFxQyxDQUNuQyxNQUFRZCxRQUFTQSxNQUFNMW5CLE1BQWhCLENBQ0gyaEMsU0FBU2phLEtBQVQsQ0FBZ0I5bUIsU0FBaEIsQ0FBMkI0bkIsVUFBM0IsQ0FERyxDQUVILEVBRkosQ0FHRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FtQkEsUUFBUzhtQixNQUFULENBQWU1bkIsS0FBZixDQUFzQixDQUNwQixHQUFJLEVBQUVBLE9BQVNBLE1BQU0xbkIsTUFBakIsQ0FBSixDQUE4QixDQUM1QixNQUFPLEVBQVAsQ0FDRCxDQUNELEdBQUlBLFFBQVMsQ0FBYixDQUNBMG5CLE1BQVFRLFlBQVlSLEtBQVosQ0FBbUIsU0FBUzZuQixLQUFULENBQWdCLENBQ3pDLEdBQUl4USxrQkFBa0J3USxLQUFsQixDQUFKLENBQThCLENBQzVCdnZDLE9BQVMwdkIsVUFBVTZmLE1BQU12dkMsTUFBaEIsQ0FBd0JBLE1BQXhCLENBQVQsQ0FDQSxNQUFPLEtBQVAsQ0FDRCxDQUNGLENBTE8sQ0FBUixDQU1BLE1BQU9rcUIsV0FBVWxxQixNQUFWLENBQWtCLFNBQVN1TCxLQUFULENBQWdCLENBQ3ZDLE1BQU9rZCxVQUFTZixLQUFULENBQWdCc0IsYUFBYXpkLEtBQWIsQ0FBaEIsQ0FBUCxDQUNELENBRk0sQ0FBUCxDQUdELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcUJBLFFBQVNpa0MsVUFBVCxDQUFtQjluQixLQUFuQixDQUEwQkUsUUFBMUIsQ0FBb0MsQ0FDbEMsR0FBSSxFQUFFRixPQUFTQSxNQUFNMW5CLE1BQWpCLENBQUosQ0FBOEIsQ0FDNUIsTUFBTyxFQUFQLENBQ0QsQ0FDRCxHQUFJb29CLFFBQVNrbkIsTUFBTTVuQixLQUFOLENBQWIsQ0FDQSxHQUFJRSxVQUFZLElBQWhCLENBQXNCLENBQ3BCLE1BQU9RLE9BQVAsQ0FDRCxDQUNELE1BQU9LLFVBQVNMLE1BQVQsQ0FBaUIsU0FBU21uQixLQUFULENBQWdCLENBQ3RDLE1BQU8vekIsT0FBTW9NLFFBQU4sQ0FBZ0JobkIsU0FBaEIsQ0FBMkIydUMsS0FBM0IsQ0FBUCxDQUNELENBRk0sQ0FBUCxDQUdELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FvQkEsR0FBSUUsU0FBVXZQLFNBQVMsU0FBU3hZLEtBQVQsQ0FBZ0JsUyxNQUFoQixDQUF3QixDQUM3QyxNQUFPdXBCLG1CQUFrQnJYLEtBQWxCLEVBQ0g2USxlQUFlN1EsS0FBZixDQUFzQmxTLE1BQXRCLENBREcsQ0FFSCxFQUZKLENBR0QsQ0FKYSxDQUFkLENBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7O09Ba0JBLEdBQUlrNkIsS0FBTXhQLFNBQVMsU0FBU25GLE1BQVQsQ0FBaUIsQ0FDbEMsTUFBT3FILFNBQVFsYSxZQUFZNlMsTUFBWixDQUFvQmdFLGlCQUFwQixDQUFSLENBQVAsQ0FDRCxDQUZTLENBQVYsQ0FJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXVCQSxHQUFJNFEsT0FBUXpQLFNBQVMsU0FBU25GLE1BQVQsQ0FBaUIsQ0FDcEMsR0FBSW5ULFVBQVc2VCxLQUFLVixNQUFMLENBQWYsQ0FDQSxHQUFJZ0Usa0JBQWtCblgsUUFBbEIsQ0FBSixDQUFpQyxDQUMvQkEsU0FBV2huQixTQUFYLENBQ0QsQ0FDRCxNQUFPd2hDLFNBQVFsYSxZQUFZNlMsTUFBWixDQUFvQmdFLGlCQUFwQixDQUFSLENBQWdETSxZQUFZelgsUUFBWixDQUFzQixDQUF0QixDQUFoRCxDQUFQLENBQ0QsQ0FOVyxDQUFaLENBUUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FvQkEsR0FBSWdvQixTQUFVMVAsU0FBUyxTQUFTbkYsTUFBVCxDQUFpQixDQUN0QyxHQUFJdlMsWUFBYWlULEtBQUtWLE1BQUwsQ0FBakIsQ0FDQSxHQUFJZ0Usa0JBQWtCdlcsVUFBbEIsQ0FBSixDQUFtQyxDQUNqQ0EsV0FBYTVuQixTQUFiLENBQ0QsQ0FDRCxNQUFPd2hDLFNBQVFsYSxZQUFZNlMsTUFBWixDQUFvQmdFLGlCQUFwQixDQUFSLENBQWdEbitCLFNBQWhELENBQTJENG5CLFVBQTNELENBQVAsQ0FDRCxDQU5hLENBQWQsQ0FRQTs7Ozs7Ozs7Ozs7Ozs7O09BZ0JBLEdBQUlxbkIsS0FBTTNQLFNBQVNvUCxLQUFULENBQVYsQ0FFQTs7Ozs7Ozs7Ozs7Ozs7O09BZ0JBLFFBQVNRLFVBQVQsQ0FBbUJ6bEIsS0FBbkIsQ0FBMEI3VSxNQUExQixDQUFrQyxDQUNoQyxNQUFPNnNCLGVBQWNoWSxPQUFTLEVBQXZCLENBQTJCN1UsUUFBVSxFQUFyQyxDQUF5QytnQixXQUF6QyxDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7T0FlQSxRQUFTd1osY0FBVCxDQUF1QjFsQixLQUF2QixDQUE4QjdVLE1BQTlCLENBQXNDLENBQ3BDLE1BQU82c0IsZUFBY2hZLE9BQVMsRUFBdkIsQ0FBMkI3VSxRQUFVLEVBQXJDLENBQXlDNnFCLE9BQXpDLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FtQkEsR0FBSTJQLFNBQVU5UCxTQUFTLFNBQVNuRixNQUFULENBQWlCLENBQ3RDLEdBQUkvNkIsUUFBUys2QixPQUFPLzZCLE1BQXBCLENBQ0k0bkIsU0FBVzVuQixPQUFTLENBQVQsQ0FBYSs2QixPQUFPLzZCLE9BQVMsQ0FBaEIsQ0FBYixDQUFrQ1ksU0FEakQsQ0FHQWduQixTQUFXLE1BQU9BLFNBQVAsRUFBbUIsVUFBbkIsRUFBaUNtVCxPQUFPdkcsR0FBUCxHQUFjNU0sUUFBL0MsRUFBMkRobkIsU0FBdEUsQ0FDQSxNQUFPNHVDLFdBQVV6VSxNQUFWLENBQWtCblQsUUFBbEIsQ0FBUCxDQUNELENBTmEsQ0FBZCxDQVFBLDRFQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BNkJBLFFBQVNxb0IsTUFBVCxDQUFldDFDLEtBQWYsQ0FBc0IsQ0FDcEIsR0FBSXl0QixRQUFTZ0osT0FBT3oyQixLQUFQLENBQWIsQ0FDQXl0QixPQUFPeUosU0FBUCxDQUFtQixJQUFuQixDQUNBLE1BQU96SixPQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXVCQSxRQUFTOG5CLElBQVQsQ0FBYXYxQyxLQUFiLENBQW9CdzFDLFdBQXBCLENBQWlDLENBQy9CQSxZQUFZeDFDLEtBQVosRUFDQSxNQUFPQSxNQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXVCQSxRQUFTeXNDLEtBQVQsQ0FBY3pzQyxLQUFkLENBQXFCdzFDLFdBQXJCLENBQWtDLENBQ2hDLE1BQU9BLGFBQVl4MUMsS0FBWixDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7O09BZ0JBLEdBQUl5MUMsV0FBWWxRLFNBQVMsU0FBU3JKLEtBQVQsQ0FBZ0IsQ0FDdkNBLE1BQVEwQyxZQUFZMUMsS0FBWixDQUFtQixDQUFuQixDQUFSLENBQ0EsR0FBSTcyQixRQUFTNjJCLE1BQU03MkIsTUFBbkIsQ0FDSWt6QixNQUFRbHpCLE9BQVM2MkIsTUFBTSxDQUFOLENBQVQsQ0FBb0IsQ0FEaEMsQ0FFSWw4QixNQUFRLEtBQUtnM0IsV0FGakIsQ0FHSXdlLFlBQWMsU0FBU3RtQixNQUFULENBQWlCLENBQUUsTUFBTytNLFFBQU8vTSxNQUFQLENBQWVnTixLQUFmLENBQVAsQ0FBK0IsQ0FIcEUsQ0FLQSxHQUFJNzJCLE9BQVMsQ0FBVCxFQUFjLEtBQUs0eEIsV0FBTCxDQUFpQjV4QixNQUEvQixFQUNBLEVBQUVyRixnQkFBaUIyMkIsWUFBbkIsQ0FEQSxFQUNtQyxDQUFDMkUsUUFBUS9DLEtBQVIsQ0FEeEMsQ0FDd0QsQ0FDdEQsTUFBTyxNQUFLa1UsSUFBTCxDQUFVK0ksV0FBVixDQUFQLENBQ0QsQ0FDRHgxQyxNQUFRQSxNQUFNa29DLEtBQU4sQ0FBWTNQLEtBQVosQ0FBbUIsQ0FBQ0EsS0FBRCxFQUFVbHpCLE9BQVMsQ0FBVCxDQUFhLENBQXZCLENBQW5CLENBQVIsQ0FDQXJGLE1BQU1pM0IsV0FBTixDQUFrQm51QixJQUFsQixDQUF1QixDQUNyQixPQUFRMmpDLElBRGEsQ0FFckIsT0FBUSxDQUFDK0ksV0FBRCxDQUZhLENBR3JCLFVBQVd2dkMsU0FIVSxDQUF2QixFQUtBLE1BQU8sSUFBSTJ3QixjQUFKLENBQWtCNTJCLEtBQWxCLENBQXlCLEtBQUtrM0IsU0FBOUIsRUFBeUN1VixJQUF6QyxDQUE4QyxTQUFTMWYsS0FBVCxDQUFnQixDQUNuRSxHQUFJMW5CLFFBQVUsQ0FBQzBuQixNQUFNMW5CLE1BQXJCLENBQTZCLENBQzNCMG5CLE1BQU1qa0IsSUFBTixDQUFXN0MsU0FBWCxFQUNELENBQ0QsTUFBTzhtQixNQUFQLENBQ0QsQ0FMTSxDQUFQLENBTUQsQ0F2QmUsQ0FBaEIsQ0F5QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMkJBLFFBQVMyb0IsYUFBVCxFQUF3QixDQUN0QixNQUFPSixPQUFNLElBQU4sQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0EwQkEsUUFBU0ssY0FBVCxFQUF5QixDQUN2QixNQUFPLElBQUkvZSxjQUFKLENBQWtCLEtBQUs1MkIsS0FBTCxFQUFsQixDQUFnQyxLQUFLazNCLFNBQXJDLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FzQkEsUUFBUzBlLFlBQVQsRUFBdUIsQ0FDckIsR0FBSSxLQUFLeGUsVUFBTCxHQUFvQm54QixTQUF4QixDQUFtQyxDQUNqQyxLQUFLbXhCLFVBQUwsQ0FBa0J5ZSxRQUFRLEtBQUs3MUMsS0FBTCxFQUFSLENBQWxCLENBQ0QsQ0FDRCxHQUFJaXhCLE1BQU8sS0FBS2tHLFNBQUwsRUFBa0IsS0FBS0MsVUFBTCxDQUFnQi94QixNQUE3QyxDQUNJckYsTUFBUWl4QixLQUFPaHJCLFNBQVAsQ0FBbUIsS0FBS214QixVQUFMLENBQWdCLEtBQUtELFNBQUwsRUFBaEIsQ0FEL0IsQ0FHQSxNQUFPLENBQUUsT0FBUWxHLElBQVYsQ0FBZ0IsUUFBU2p4QixLQUF6QixDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FrQkEsUUFBUzgxQyxrQkFBVCxFQUE2QixDQUMzQixNQUFPLEtBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXdCQSxRQUFTQyxhQUFULENBQXNCLzFDLEtBQXRCLENBQTZCLENBQzNCLEdBQUl5dEIsT0FBSixDQUNJb1QsT0FBUyxJQURiLENBR0EsTUFBT0EsaUJBQWtCL0osV0FBekIsQ0FBcUMsQ0FDbkMsR0FBSWlCLE9BQVFsQixhQUFhZ0ssTUFBYixDQUFaLENBQ0E5SSxNQUFNWixTQUFOLENBQWtCLENBQWxCLENBQ0FZLE1BQU1YLFVBQU4sQ0FBbUJueEIsU0FBbkIsQ0FDQSxHQUFJd25CLE1BQUosQ0FBWSxDQUNWMFgsU0FBU25PLFdBQVQsQ0FBdUJlLEtBQXZCLENBQ0QsQ0FGRCxJQUVPLENBQ0x0SyxPQUFTc0ssS0FBVCxDQUNELENBQ0QsR0FBSW9OLFVBQVdwTixLQUFmLENBQ0E4SSxPQUFTQSxPQUFPN0osV0FBaEIsQ0FDRCxDQUNEbU8sU0FBU25PLFdBQVQsQ0FBdUJoM0IsS0FBdkIsQ0FDQSxNQUFPeXRCLE9BQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bb0JBLFFBQVN1b0IsZUFBVCxFQUEwQixDQUN4QixHQUFJaDJDLE9BQVEsS0FBS2czQixXQUFqQixDQUNBLEdBQUloM0IsZ0JBQWlCMjJCLFlBQXJCLENBQWtDLENBQ2hDLEdBQUlzZixTQUFVajJDLEtBQWQsQ0FDQSxHQUFJLEtBQUtpM0IsV0FBTCxDQUFpQjV4QixNQUFyQixDQUE2QixDQUMzQjR3QyxRQUFVLEdBQUl0ZixZQUFKLENBQWdCLElBQWhCLENBQVYsQ0FDRCxDQUNEc2YsUUFBVUEsUUFBUS8zQixPQUFSLEVBQVYsQ0FDQSszQixRQUFRaGYsV0FBUixDQUFvQm51QixJQUFwQixDQUF5QixDQUN2QixPQUFRMmpDLElBRGUsQ0FFdkIsT0FBUSxDQUFDdnVCLE9BQUQsQ0FGZSxDQUd2QixVQUFXalksU0FIWSxDQUF6QixFQUtBLE1BQU8sSUFBSTJ3QixjQUFKLENBQWtCcWYsT0FBbEIsQ0FBMkIsS0FBSy9lLFNBQWhDLENBQVAsQ0FDRCxDQUNELE1BQU8sTUFBS3VWLElBQUwsQ0FBVXZ1QixPQUFWLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7O09BY0EsUUFBU2c0QixhQUFULEVBQXdCLENBQ3RCLE1BQU90ZCxrQkFBaUIsS0FBSzVCLFdBQXRCLENBQW1DLEtBQUtDLFdBQXhDLENBQVAsQ0FDRCxDQUVELDRFQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BdUJBLEdBQUlrZixTQUFVekwsaUJBQWlCLFNBQVNqZCxNQUFULENBQWlCenRCLEtBQWpCLENBQXdCRCxHQUF4QixDQUE2QixDQUMxRGl6QixlQUFlalksSUFBZixDQUFvQjBTLE1BQXBCLENBQTRCMXRCLEdBQTVCLEVBQW1DLEVBQUUwdEIsT0FBTzF0QixHQUFQLENBQXJDLENBQW9EMHRCLE9BQU8xdEIsR0FBUCxFQUFjLENBQWxFLENBQ0QsQ0FGYSxDQUFkLENBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMENBLFFBQVNxMkMsTUFBVCxDQUFlM25CLFVBQWYsQ0FBMkJuQixTQUEzQixDQUFzQ3lkLEtBQXRDLENBQTZDLENBQzNDLEdBQUlwZSxNQUFPN04sUUFBUTJQLFVBQVIsRUFBc0JwQixVQUF0QixDQUFtQ2dSLFNBQTlDLENBQ0EsR0FBSTBNLE9BQVNDLGVBQWV2YyxVQUFmLENBQTJCbkIsU0FBM0IsQ0FBc0N5ZCxLQUF0QyxDQUFiLENBQTJELENBQ3pEemQsVUFBWXJuQixTQUFaLENBQ0QsQ0FDRCxNQUFPMG1CLE1BQUs4QixVQUFMLENBQWlCaVcsWUFBWXBYLFNBQVosQ0FBdUIsQ0FBdkIsQ0FBakIsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FzQ0EsUUFBU2xWLE9BQVQsQ0FBZ0JxVyxVQUFoQixDQUE0Qm5CLFNBQTVCLENBQXVDLENBQ3JDLEdBQUlYLE1BQU83TixRQUFRMlAsVUFBUixFQUFzQmxCLFdBQXRCLENBQW9Db1IsVUFBL0MsQ0FDQSxNQUFPaFMsTUFBSzhCLFVBQUwsQ0FBaUJpVyxZQUFZcFgsU0FBWixDQUF1QixDQUF2QixDQUFqQixDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcUNBLEdBQUkrb0IsTUFBT2pLLFdBQVdnRyxTQUFYLENBQVgsQ0FFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQW9CQSxHQUFJa0UsVUFBV2xLLFdBQVdpRyxhQUFYLENBQWYsQ0FFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bc0JBLFFBQVNrRSxRQUFULENBQWlCOW5CLFVBQWpCLENBQTZCeEIsUUFBN0IsQ0FBdUMsQ0FDckMsTUFBTzJSLGFBQVl2ckIsSUFBSW9iLFVBQUosQ0FBZ0J4QixRQUFoQixDQUFaLENBQXVDLENBQXZDLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXFCQSxRQUFTdXBCLFlBQVQsQ0FBcUIvbkIsVUFBckIsQ0FBaUN4QixRQUFqQyxDQUEyQyxDQUN6QyxNQUFPMlIsYUFBWXZyQixJQUFJb2IsVUFBSixDQUFnQnhCLFFBQWhCLENBQVosQ0FBdUNsSyxRQUF2QyxDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bc0JBLFFBQVMwekIsYUFBVCxDQUFzQmhvQixVQUF0QixDQUFrQ3hCLFFBQWxDLENBQTRDNFIsS0FBNUMsQ0FBbUQsQ0FDakRBLE1BQVFBLFFBQVU1NEIsU0FBVixDQUFzQixDQUF0QixDQUEwQnc0QixVQUFVSSxLQUFWLENBQWxDLENBQ0EsTUFBT0QsYUFBWXZyQixJQUFJb2IsVUFBSixDQUFnQnhCLFFBQWhCLENBQVosQ0FBdUM0UixLQUF2QyxDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E4QkEsUUFBU3A2QixRQUFULENBQWlCZ3FCLFVBQWpCLENBQTZCeEIsUUFBN0IsQ0FBdUMsQ0FDckMsR0FBSU4sTUFBTzdOLFFBQVEyUCxVQUFSLEVBQXNCdEIsU0FBdEIsQ0FBa0MyTyxRQUE3QyxDQUNBLE1BQU9uUCxNQUFLOEIsVUFBTCxDQUFpQmlXLFlBQVl6WCxRQUFaLENBQXNCLENBQXRCLENBQWpCLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bb0JBLFFBQVN5cEIsYUFBVCxDQUFzQmpvQixVQUF0QixDQUFrQ3hCLFFBQWxDLENBQTRDLENBQzFDLEdBQUlOLE1BQU83TixRQUFRMlAsVUFBUixFQUFzQnJCLGNBQXRCLENBQXVDK1EsYUFBbEQsQ0FDQSxNQUFPeFIsTUFBSzhCLFVBQUwsQ0FBaUJpVyxZQUFZelgsUUFBWixDQUFzQixDQUF0QixDQUFqQixDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F3QkEsR0FBSTBwQixTQUFVak0saUJBQWlCLFNBQVNqZCxNQUFULENBQWlCenRCLEtBQWpCLENBQXdCRCxHQUF4QixDQUE2QixDQUMxRCxHQUFJaXpCLGVBQWVqWSxJQUFmLENBQW9CMFMsTUFBcEIsQ0FBNEIxdEIsR0FBNUIsQ0FBSixDQUFzQyxDQUNwQzB0QixPQUFPMXRCLEdBQVAsRUFBWStJLElBQVosQ0FBaUI5SSxLQUFqQixFQUNELENBRkQsSUFFTyxDQUNMeXRCLE9BQU8xdEIsR0FBUCxFQUFjLENBQUNDLEtBQUQsQ0FBZCxDQUNELENBQ0YsQ0FOYSxDQUFkLENBUUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BOEJBLFFBQVM2OUIsU0FBVCxDQUFrQnBQLFVBQWxCLENBQThCenVCLEtBQTlCLENBQXFDNHVCLFNBQXJDLENBQWdEbWMsS0FBaEQsQ0FBdUQsQ0FDckR0YyxXQUFhaVYsWUFBWWpWLFVBQVosRUFBMEJBLFVBQTFCLENBQXVDNVQsT0FBTzRULFVBQVAsQ0FBcEQsQ0FDQUcsVUFBYUEsV0FBYSxDQUFDbWMsS0FBZixDQUF3QnRNLFVBQVU3UCxTQUFWLENBQXhCLENBQStDLENBQTNELENBRUEsR0FBSXZwQixRQUFTb3BCLFdBQVdwcEIsTUFBeEIsQ0FDQSxHQUFJdXBCLFVBQVksQ0FBaEIsQ0FBbUIsQ0FDakJBLFVBQVltRyxVQUFVMXZCLE9BQVN1cEIsU0FBbkIsQ0FBOEIsQ0FBOUIsQ0FBWixDQUNELENBQ0QsTUFBT2dvQixVQUFTbm9CLFVBQVQsRUFDRkcsV0FBYXZwQixNQUFiLEVBQXVCb3BCLFdBQVdyVixPQUFYLENBQW1CcFosS0FBbkIsQ0FBMEI0dUIsU0FBMUIsRUFBdUMsQ0FBQyxDQUQ3RCxDQUVGLENBQUMsQ0FBQ3ZwQixNQUFGLEVBQVlzb0IsWUFBWWMsVUFBWixDQUF3Qnp1QixLQUF4QixDQUErQjR1QixTQUEvQixFQUE0QyxDQUFDLENBRjlELENBR0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXVCQSxHQUFJaW9CLFdBQVl0UixTQUFTLFNBQVM5VyxVQUFULENBQXFCNlEsSUFBckIsQ0FBMkJ6UyxJQUEzQixDQUFpQyxDQUN4RCxHQUFJamMsT0FBUSxDQUFDLENBQWIsQ0FDSW1zQixPQUFTLE1BQU91QyxLQUFQLEVBQWUsVUFENUIsQ0FFSXdYLE9BQVN2WCxNQUFNRCxJQUFOLENBRmIsQ0FHSTdSLE9BQVNpVyxZQUFZalYsVUFBWixFQUEwQjlkLE1BQU04ZCxXQUFXcHBCLE1BQWpCLENBQTFCLENBQXFELEVBSGxFLENBS0F5MkIsU0FBU3JOLFVBQVQsQ0FBcUIsU0FBU3p1QixLQUFULENBQWdCLENBQ25DLEdBQUkyc0IsTUFBT29RLE9BQVN1QyxJQUFULENBQWtCd1gsUUFBVTkyQyxPQUFTLElBQXBCLENBQTRCQSxNQUFNcy9CLElBQU4sQ0FBNUIsQ0FBMENyNUIsU0FBdEUsQ0FDQXduQixPQUFPLEVBQUU3YyxLQUFULEVBQWtCK2IsS0FBTzlMLE1BQU04TCxJQUFOLENBQVkzc0IsS0FBWixDQUFtQjZzQixJQUFuQixDQUFQLENBQWtDK1QsV0FBVzVnQyxLQUFYLENBQWtCcy9CLElBQWxCLENBQXdCelMsSUFBeEIsQ0FBcEQsQ0FDRCxDQUhELEVBSUEsTUFBT1ksT0FBUCxDQUNELENBWGUsQ0FBaEIsQ0FhQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTZCQSxHQUFJc3BCLE9BQVFyTSxpQkFBaUIsU0FBU2pkLE1BQVQsQ0FBaUJ6dEIsS0FBakIsQ0FBd0JELEdBQXhCLENBQTZCLENBQ3hEMHRCLE9BQU8xdEIsR0FBUCxFQUFjQyxLQUFkLENBQ0QsQ0FGVyxDQUFaLENBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMENBLFFBQVNxVCxJQUFULENBQWFvYixVQUFiLENBQXlCeEIsUUFBekIsQ0FBbUMsQ0FDakMsR0FBSU4sTUFBTzdOLFFBQVEyUCxVQUFSLEVBQXNCWCxRQUF0QixDQUFpQzJWLE9BQTVDLENBQ0EsTUFBTzlXLE1BQUs4QixVQUFMLENBQWlCaVcsWUFBWXpYLFFBQVosQ0FBc0IsQ0FBdEIsQ0FBakIsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E2QkEsUUFBUytwQixRQUFULENBQWlCdm9CLFVBQWpCLENBQTZCZ0ssU0FBN0IsQ0FBd0NnTSxNQUF4QyxDQUFnRHNHLEtBQWhELENBQXVELENBQ3JELEdBQUl0YyxZQUFjLElBQWxCLENBQXdCLENBQ3RCLE1BQU8sRUFBUCxDQUNELENBQ0QsR0FBSSxDQUFDM1AsUUFBUTJaLFNBQVIsQ0FBTCxDQUF5QixDQUN2QkEsVUFBWUEsV0FBYSxJQUFiLENBQW9CLEVBQXBCLENBQXlCLENBQUNBLFNBQUQsQ0FBckMsQ0FDRCxDQUNEZ00sT0FBU3NHLE1BQVE5a0MsU0FBUixDQUFvQncrQixNQUE3QixDQUNBLEdBQUksQ0FBQzNsQixRQUFRMmxCLE1BQVIsQ0FBTCxDQUFzQixDQUNwQkEsT0FBU0EsUUFBVSxJQUFWLENBQWlCLEVBQWpCLENBQXNCLENBQUNBLE1BQUQsQ0FBL0IsQ0FDRCxDQUNELE1BQU9ELGFBQVkvVixVQUFaLENBQXdCZ0ssU0FBeEIsQ0FBbUNnTSxNQUFuQyxDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FvQ0EsR0FBSXdTLFdBQVl2TSxpQkFBaUIsU0FBU2pkLE1BQVQsQ0FBaUJ6dEIsS0FBakIsQ0FBd0JELEdBQXhCLENBQTZCLENBQzVEMHRCLE9BQU8xdEIsSUFBTSxDQUFOLENBQVUsQ0FBakIsRUFBb0IrSSxJQUFwQixDQUF5QjlJLEtBQXpCLEVBQ0QsQ0FGZSxDQUViLFVBQVcsQ0FBRSxNQUFPLENBQUMsRUFBRCxDQUFLLEVBQUwsQ0FBUCxDQUFrQixDQUZsQixDQUFoQixDQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FxQ0EsUUFBU2szQyxPQUFULENBQWdCem9CLFVBQWhCLENBQTRCeEIsUUFBNUIsQ0FBc0NDLFdBQXRDLENBQW1ELENBQ2pELEdBQUlQLE1BQU83TixRQUFRMlAsVUFBUixFQUFzQlQsV0FBdEIsQ0FBb0NvQixVQUEvQyxDQUNJbkIsVUFBWXVYLFVBQVVuZ0MsTUFBVixDQUFtQixDQURuQyxDQUdBLE1BQU9zbkIsTUFBSzhCLFVBQUwsQ0FBaUJpVyxZQUFZelgsUUFBWixDQUFzQixDQUF0QixDQUFqQixDQUEyQ0MsV0FBM0MsQ0FBd0RlLFNBQXhELENBQW1FNk4sUUFBbkUsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXNCQSxRQUFTcWIsWUFBVCxDQUFxQjFvQixVQUFyQixDQUFpQ3hCLFFBQWpDLENBQTJDQyxXQUEzQyxDQUF3RCxDQUN0RCxHQUFJUCxNQUFPN04sUUFBUTJQLFVBQVIsRUFBc0JQLGdCQUF0QixDQUF5Q2tCLFVBQXBELENBQ0luQixVQUFZdVgsVUFBVW5nQyxNQUFWLENBQW1CLENBRG5DLENBR0EsTUFBT3NuQixNQUFLOEIsVUFBTCxDQUFpQmlXLFlBQVl6WCxRQUFaLENBQXNCLENBQXRCLENBQWpCLENBQTJDQyxXQUEzQyxDQUF3RGUsU0FBeEQsQ0FBbUVrUSxhQUFuRSxDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Ba0NBLFFBQVNqdkIsT0FBVCxDQUFnQnVmLFVBQWhCLENBQTRCbkIsU0FBNUIsQ0FBdUMsQ0FDckMsR0FBSVgsTUFBTzdOLFFBQVEyUCxVQUFSLEVBQXNCbEIsV0FBdEIsQ0FBb0NvUixVQUEvQyxDQUNBLE1BQU9oUyxNQUFLOEIsVUFBTCxDQUFpQjJvQixPQUFPMVMsWUFBWXBYLFNBQVosQ0FBdUIsQ0FBdkIsQ0FBUCxDQUFqQixDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7OztPQWNBLFFBQVMrcEIsT0FBVCxDQUFnQjVvQixVQUFoQixDQUE0QixDQUMxQixHQUFJMUIsT0FBUTJXLFlBQVlqVixVQUFaLEVBQTBCQSxVQUExQixDQUF1QzVULE9BQU80VCxVQUFQLENBQW5ELENBQ0lwcEIsT0FBUzBuQixNQUFNMW5CLE1BRG5CLENBR0EsTUFBT0EsUUFBUyxDQUFULENBQWEwbkIsTUFBTXFZLFdBQVcsQ0FBWCxDQUFjLy9CLE9BQVMsQ0FBdkIsQ0FBTixDQUFiLENBQWdEWSxTQUF2RCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FvQkEsUUFBU3F4QyxXQUFULENBQW9CN29CLFVBQXBCLENBQWdDZSxDQUFoQyxDQUFtQ3ViLEtBQW5DLENBQTBDLENBQ3hDLEdBQUluNkIsT0FBUSxDQUFDLENBQWIsQ0FDSTZjLE9BQVNvb0IsUUFBUXBuQixVQUFSLENBRGIsQ0FFSXBwQixPQUFTb29CLE9BQU9wb0IsTUFGcEIsQ0FHSTBzQixVQUFZMXNCLE9BQVMsQ0FIekIsQ0FLQSxHQUFLMGxDLE1BQVFDLGVBQWV2YyxVQUFmLENBQTJCZSxDQUEzQixDQUE4QnViLEtBQTlCLENBQVIsQ0FBK0N2YixJQUFNdnBCLFNBQTFELENBQXNFLENBQ3BFdXBCLEVBQUksQ0FBSixDQUNELENBRkQsSUFFTyxDQUNMQSxFQUFJNE0sVUFBVXFDLFVBQVVqUCxDQUFWLENBQVYsQ0FBd0IsQ0FBeEIsQ0FBMkJucUIsTUFBM0IsQ0FBSixDQUNELENBQ0QsTUFBTyxFQUFFdUwsS0FBRixDQUFVNGUsQ0FBakIsQ0FBb0IsQ0FDbEIsR0FBSStuQixNQUFPblMsV0FBV3gwQixLQUFYLENBQWtCbWhCLFNBQWxCLENBQVgsQ0FDSS94QixNQUFReXRCLE9BQU84cEIsSUFBUCxDQURaLENBR0E5cEIsT0FBTzhwQixJQUFQLEVBQWU5cEIsT0FBTzdjLEtBQVAsQ0FBZixDQUNBNmMsT0FBTzdjLEtBQVAsRUFBZ0I1USxLQUFoQixDQUNELENBQ0R5dEIsT0FBT3BvQixNQUFQLENBQWdCbXFCLENBQWhCLENBQ0EsTUFBTy9CLE9BQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7OztPQWVBLFFBQVMrcEIsUUFBVCxDQUFpQi9vQixVQUFqQixDQUE2QixDQUMzQixNQUFPNm9CLFlBQVc3b0IsVUFBWCxDQUF1QnRMLGdCQUF2QixDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FxQkEsUUFBU2dPLEtBQVQsQ0FBYzFDLFVBQWQsQ0FBMEIsQ0FDeEIsR0FBSUEsWUFBYyxJQUFsQixDQUF3QixDQUN0QixNQUFPLEVBQVAsQ0FDRCxDQUNELEdBQUlpVixZQUFZalYsVUFBWixDQUFKLENBQTZCLENBQzNCLE1BQU9tb0IsVUFBU25vQixVQUFULEVBQXVCaUQsV0FBV2pELFVBQVgsQ0FBdkIsQ0FBZ0RBLFdBQVdwcEIsTUFBbEUsQ0FDRCxDQUNELEdBQUkrUSxLQUFNMG1CLE9BQU9yTyxVQUFQLENBQVYsQ0FDQSxHQUFJclksS0FBTzBOLE1BQVAsRUFBaUIxTixLQUFPK04sTUFBNUIsQ0FBb0MsQ0FDbEMsTUFBT3NLLFlBQVcwQyxJQUFsQixDQUNELENBQ0QsTUFBT2dTLFVBQVMxVSxVQUFULEVBQXFCcHBCLE1BQTVCLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FvQ0EsUUFBU295QyxLQUFULENBQWNocEIsVUFBZCxDQUEwQm5CLFNBQTFCLENBQXFDeWQsS0FBckMsQ0FBNEMsQ0FDMUMsR0FBSXBlLE1BQU83TixRQUFRMlAsVUFBUixFQUFzQk4sU0FBdEIsQ0FBa0MyWCxRQUE3QyxDQUNBLEdBQUlpRixPQUFTQyxlQUFldmMsVUFBZixDQUEyQm5CLFNBQTNCLENBQXNDeWQsS0FBdEMsQ0FBYixDQUEyRCxDQUN6RHpkLFVBQVlybkIsU0FBWixDQUNELENBQ0QsTUFBTzBtQixNQUFLOEIsVUFBTCxDQUFpQmlXLFlBQVlwWCxTQUFaLENBQXVCLENBQXZCLENBQWpCLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FrQ0EsR0FBSW9xQixRQUFTblMsU0FBUyxTQUFTOVcsVUFBVCxDQUFxQmdLLFNBQXJCLENBQWdDLENBQ3BELEdBQUloSyxZQUFjLElBQWxCLENBQXdCLENBQ3RCLE1BQU8sRUFBUCxDQUNELENBQ0QsR0FBSXBwQixRQUFTb3pCLFVBQVVwekIsTUFBdkIsQ0FDQSxHQUFJQSxPQUFTLENBQVQsRUFBYzJsQyxlQUFldmMsVUFBZixDQUEyQmdLLFVBQVUsQ0FBVixDQUEzQixDQUF5Q0EsVUFBVSxDQUFWLENBQXpDLENBQWxCLENBQTBFLENBQ3hFQSxVQUFZLEVBQVosQ0FDRCxDQUZELElBRU8sSUFBSXB6QixPQUFTLENBQVQsRUFBYzJsQyxlQUFldlMsVUFBVSxDQUFWLENBQWYsQ0FBNkJBLFVBQVUsQ0FBVixDQUE3QixDQUEyQ0EsVUFBVSxDQUFWLENBQTNDLENBQWxCLENBQTRFLENBQ2pGQSxVQUFZLENBQUNBLFVBQVUsQ0FBVixDQUFELENBQVosQ0FDRCxDQUNELE1BQU8rTCxhQUFZL1YsVUFBWixDQUF3Qm1RLFlBQVluRyxTQUFaLENBQXVCLENBQXZCLENBQXhCLENBQW1ELEVBQW5ELENBQVAsQ0FDRCxDQVhZLENBQWIsQ0FhQSw0RUFFQTs7Ozs7Ozs7Ozs7Ozs7O09BZ0JBLEdBQUkzckIsS0FBTW1uQixRQUFVLFVBQVcsQ0FDN0IsTUFBT2pKLE1BQUtuZSxJQUFMLENBQVVDLEdBQVYsRUFBUCxDQUNELENBRkQsQ0FJQSw0RUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F3QkEsUUFBUzZxQyxNQUFULENBQWVub0IsQ0FBZixDQUFrQjdDLElBQWxCLENBQXdCLENBQ3RCLEdBQUksTUFBT0EsS0FBUCxFQUFlLFVBQW5CLENBQStCLENBQzdCLEtBQU0sSUFBSTBGLFVBQUosQ0FBYzVRLGVBQWQsQ0FBTixDQUNELENBQ0QrTixFQUFJaVAsVUFBVWpQLENBQVYsQ0FBSixDQUNBLE1BQU8sV0FBVyxDQUNoQixHQUFJLEVBQUVBLENBQUYsQ0FBTSxDQUFWLENBQWEsQ0FDWCxNQUFPN0MsTUFBSzlMLEtBQUwsQ0FBVyxJQUFYLENBQWlCMmtCLFNBQWpCLENBQVAsQ0FDRCxDQUNGLENBSkQsQ0FLRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7O09BaUJBLFFBQVMwSCxJQUFULENBQWF2Z0IsSUFBYixDQUFtQjZDLENBQW5CLENBQXNCdWIsS0FBdEIsQ0FBNkIsQ0FDM0J2YixFQUFJdWIsTUFBUTlrQyxTQUFSLENBQW9CdXBCLENBQXhCLENBQ0FBLEVBQUs3QyxNQUFRNkMsR0FBSyxJQUFkLENBQXNCN0MsS0FBS3RuQixNQUEzQixDQUFvQ21xQixDQUF4QyxDQUNBLE1BQU8wZixZQUFXdmlCLElBQVgsQ0FBaUJ4SyxRQUFqQixDQUEyQmxjLFNBQTNCLENBQXNDQSxTQUF0QyxDQUFpREEsU0FBakQsQ0FBNERBLFNBQTVELENBQXVFdXBCLENBQXZFLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7O09BaUJBLFFBQVNvb0IsT0FBVCxDQUFnQnBvQixDQUFoQixDQUFtQjdDLElBQW5CLENBQXlCLENBQ3ZCLEdBQUljLE9BQUosQ0FDQSxHQUFJLE1BQU9kLEtBQVAsRUFBZSxVQUFuQixDQUErQixDQUM3QixLQUFNLElBQUkwRixVQUFKLENBQWM1USxlQUFkLENBQU4sQ0FDRCxDQUNEK04sRUFBSWlQLFVBQVVqUCxDQUFWLENBQUosQ0FDQSxNQUFPLFdBQVcsQ0FDaEIsR0FBSSxFQUFFQSxDQUFGLENBQU0sQ0FBVixDQUFhLENBQ1gvQixPQUFTZCxLQUFLOUwsS0FBTCxDQUFXLElBQVgsQ0FBaUIya0IsU0FBakIsQ0FBVCxDQUNELENBQ0QsR0FBSWhXLEdBQUssQ0FBVCxDQUFZLENBQ1Y3QyxLQUFPMW1CLFNBQVAsQ0FDRCxDQUNELE1BQU93bkIsT0FBUCxDQUNELENBUkQsQ0FTRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BbUNBLEdBQUlyaUIsTUFBT202QixTQUFTLFNBQVM1WSxJQUFULENBQWVDLE9BQWYsQ0FBd0IrYyxRQUF4QixDQUFrQyxDQUNwRCxHQUFJekksU0FBVXRmLFNBQWQsQ0FDQSxHQUFJK25CLFNBQVN0a0MsTUFBYixDQUFxQixDQUNuQixHQUFJdWtDLFNBQVVyWSxlQUFlb1ksUUFBZixDQUF5QnNDLFVBQVU3Z0MsSUFBVixDQUF6QixDQUFkLENBQ0E4MUIsU0FBV2pmLFlBQVgsQ0FDRCxDQUNELE1BQU9pdEIsWUFBV3ZpQixJQUFYLENBQWlCdVUsT0FBakIsQ0FBMEJ0VSxPQUExQixDQUFtQytjLFFBQW5DLENBQTZDQyxPQUE3QyxDQUFQLENBQ0QsQ0FQVSxDQUFYLENBU0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BNkNBLEdBQUlpTyxTQUFVdFMsU0FBUyxTQUFTclcsTUFBVCxDQUFpQm52QixHQUFqQixDQUFzQjRwQyxRQUF0QixDQUFnQyxDQUNyRCxHQUFJekksU0FBVXRmLFVBQVlDLGFBQTFCLENBQ0EsR0FBSThuQixTQUFTdGtDLE1BQWIsQ0FBcUIsQ0FDbkIsR0FBSXVrQyxTQUFVclksZUFBZW9ZLFFBQWYsQ0FBeUJzQyxVQUFVNEwsT0FBVixDQUF6QixDQUFkLENBQ0EzVyxTQUFXamYsWUFBWCxDQUNELENBQ0QsTUFBT2l0QixZQUFXbnZDLEdBQVgsQ0FBZ0JtaEMsT0FBaEIsQ0FBeUJoUyxNQUF6QixDQUFpQ3lhLFFBQWpDLENBQTJDQyxPQUEzQyxDQUFQLENBQ0QsQ0FQYSxDQUFkLENBU0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F5Q0EsUUFBU2tPLE1BQVQsQ0FBZW5yQixJQUFmLENBQXFCcWYsS0FBckIsQ0FBNEJqQixLQUE1QixDQUFtQyxDQUNqQ2lCLE1BQVFqQixNQUFROWtDLFNBQVIsQ0FBb0IrbEMsS0FBNUIsQ0FDQSxHQUFJdmUsUUFBU3loQixXQUFXdmlCLElBQVgsQ0FBaUI1SyxVQUFqQixDQUE2QjliLFNBQTdCLENBQXdDQSxTQUF4QyxDQUFtREEsU0FBbkQsQ0FBOERBLFNBQTlELENBQXlFQSxTQUF6RSxDQUFvRitsQyxLQUFwRixDQUFiLENBQ0F2ZSxPQUFPNEMsV0FBUCxDQUFxQnluQixNQUFNem5CLFdBQTNCLENBQ0EsTUFBTzVDLE9BQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bc0NBLFFBQVNzcUIsV0FBVCxDQUFvQnByQixJQUFwQixDQUEwQnFmLEtBQTFCLENBQWlDakIsS0FBakMsQ0FBd0MsQ0FDdENpQixNQUFRakIsTUFBUTlrQyxTQUFSLENBQW9CK2xDLEtBQTVCLENBQ0EsR0FBSXZlLFFBQVN5aEIsV0FBV3ZpQixJQUFYLENBQWlCM0ssZ0JBQWpCLENBQW1DL2IsU0FBbkMsQ0FBOENBLFNBQTlDLENBQXlEQSxTQUF6RCxDQUFvRUEsU0FBcEUsQ0FBK0VBLFNBQS9FLENBQTBGK2xDLEtBQTFGLENBQWIsQ0FDQXZlLE9BQU80QyxXQUFQLENBQXFCMG5CLFdBQVcxbkIsV0FBaEMsQ0FDQSxNQUFPNUMsT0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bc0RBLFFBQVN1cUIsU0FBVCxDQUFrQnJyQixJQUFsQixDQUF3QmdSLElBQXhCLENBQThCc2EsT0FBOUIsQ0FBdUMsQ0FDckMsR0FBSUMsU0FBSixDQUNJQyxRQURKLENBRUlDLE9BRkosQ0FHSTNxQixNQUhKLENBSUk0cUIsT0FKSixDQUtJQyxZQUxKLENBTUlDLGVBQWlCLENBTnJCLENBT0lDLFFBQVUsS0FQZCxDQVFJQyxPQUFTLEtBUmIsQ0FTSS9NLFNBQVcsSUFUZixDQVdBLEdBQUksTUFBTy9lLEtBQVAsRUFBZSxVQUFuQixDQUErQixDQUM3QixLQUFNLElBQUkwRixVQUFKLENBQWM1USxlQUFkLENBQU4sQ0FDRCxDQUNEa2MsS0FBTzRRLFNBQVM1USxJQUFULEdBQWtCLENBQXpCLENBQ0EsR0FBSWYsU0FBU3FiLE9BQVQsQ0FBSixDQUF1QixDQUNyQk8sUUFBVSxDQUFDLENBQUNQLFFBQVFPLE9BQXBCLENBQ0FDLE9BQVMsV0FBYVIsUUFBdEIsQ0FDQUcsUUFBVUssT0FBUzFqQixVQUFVd1osU0FBUzBKLFFBQVFHLE9BQWpCLEdBQTZCLENBQXZDLENBQTBDemEsSUFBMUMsQ0FBVCxDQUEyRHlhLE9BQXJFLENBQ0ExTSxTQUFXLFlBQWN1TSxRQUFkLENBQXdCLENBQUMsQ0FBQ0EsUUFBUXZNLFFBQWxDLENBQTZDQSxRQUF4RCxDQUNELENBRUQsUUFBU2dOLFdBQVQsQ0FBb0JDLElBQXBCLENBQTBCLENBQ3hCLEdBQUk5ckIsTUFBT3FyQixRQUFYLENBQ0l0ckIsUUFBVXVyQixRQURkLENBR0FELFNBQVdDLFNBQVdseUMsU0FBdEIsQ0FDQXN5QyxlQUFpQkksSUFBakIsQ0FDQWxyQixPQUFTZCxLQUFLOUwsS0FBTCxDQUFXK0wsT0FBWCxDQUFvQkMsSUFBcEIsQ0FBVCxDQUNBLE1BQU9ZLE9BQVAsQ0FDRCxDQUVELFFBQVNtckIsWUFBVCxDQUFxQkQsSUFBckIsQ0FBMkIsQ0FDekI7QUFDQUosZUFBaUJJLElBQWpCLENBQ0E7QUFDQU4sUUFBVXAwQyxXQUFXNDBDLFlBQVgsQ0FBeUJsYixJQUF6QixDQUFWLENBQ0E7QUFDQSxNQUFPNmEsU0FBVUUsV0FBV0MsSUFBWCxDQUFWLENBQTZCbHJCLE1BQXBDLENBQ0QsQ0FFRCxRQUFTcXJCLGNBQVQsQ0FBdUJILElBQXZCLENBQTZCLENBQzNCLEdBQUlJLG1CQUFvQkosS0FBT0wsWUFBL0IsQ0FDSVUsb0JBQXNCTCxLQUFPSixjQURqQyxDQUVJOXFCLE9BQVNrUSxLQUFPb2IsaUJBRnBCLENBSUEsTUFBT04sUUFBU3pqQixVQUFVdkgsTUFBVixDQUFrQjJxQixRQUFVWSxtQkFBNUIsQ0FBVCxDQUE0RHZyQixNQUFuRSxDQUNELENBRUQsUUFBU3dyQixhQUFULENBQXNCTixJQUF0QixDQUE0QixDQUMxQixHQUFJSSxtQkFBb0JKLEtBQU9MLFlBQS9CLENBQ0lVLG9CQUFzQkwsS0FBT0osY0FEakMsQ0FHQTtBQUNBO0FBQ0E7QUFDQSxNQUFRRCxnQkFBaUJyeUMsU0FBakIsRUFBK0I4eUMsbUJBQXFCcGIsSUFBcEQsRUFDTG9iLGtCQUFvQixDQURmLEVBQ3NCTixRQUFVTyxxQkFBdUJaLE9BRC9ELENBRUQsQ0FFRCxRQUFTUyxhQUFULEVBQXdCLENBQ3RCLEdBQUlGLE1BQU83ckMsS0FBWCxDQUNBLEdBQUltc0MsYUFBYU4sSUFBYixDQUFKLENBQXdCLENBQ3RCLE1BQU9PLGNBQWFQLElBQWIsQ0FBUCxDQUNELENBQ0Q7QUFDQU4sUUFBVXAwQyxXQUFXNDBDLFlBQVgsQ0FBeUJDLGNBQWNILElBQWQsQ0FBekIsQ0FBVixDQUNELENBRUQsUUFBU08sYUFBVCxDQUFzQlAsSUFBdEIsQ0FBNEIsQ0FDMUJOLFFBQVVweUMsU0FBVixDQUVBO0FBQ0E7QUFDQSxHQUFJeWxDLFVBQVl3TSxRQUFoQixDQUEwQixDQUN4QixNQUFPUSxZQUFXQyxJQUFYLENBQVAsQ0FDRCxDQUNEVCxTQUFXQyxTQUFXbHlDLFNBQXRCLENBQ0EsTUFBT3duQixPQUFQLENBQ0QsQ0FFRCxRQUFTMHJCLE9BQVQsRUFBa0IsQ0FDaEIsR0FBSWQsVUFBWXB5QyxTQUFoQixDQUEyQixDQUN6QjhOLGFBQWFza0MsT0FBYixFQUNELENBQ0RFLGVBQWlCLENBQWpCLENBQ0FMLFNBQVdJLGFBQWVILFNBQVdFLFFBQVVweUMsU0FBL0MsQ0FDRCxDQUVELFFBQVNtekMsTUFBVCxFQUFpQixDQUNmLE1BQU9mLFdBQVlweUMsU0FBWixDQUF3QnduQixNQUF4QixDQUFpQ3lyQixhQUFhcHNDLEtBQWIsQ0FBeEMsQ0FDRCxDQUVELFFBQVN1c0MsVUFBVCxFQUFxQixDQUNuQixHQUFJVixNQUFPN3JDLEtBQVgsQ0FDSXdzQyxXQUFhTCxhQUFhTixJQUFiLENBRGpCLENBR0FULFNBQVcxUyxTQUFYLENBQ0EyUyxTQUFXLElBQVgsQ0FDQUcsYUFBZUssSUFBZixDQUVBLEdBQUlXLFVBQUosQ0FBZ0IsQ0FDZCxHQUFJakIsVUFBWXB5QyxTQUFoQixDQUEyQixDQUN6QixNQUFPMnlDLGFBQVlOLFlBQVosQ0FBUCxDQUNELENBQ0QsR0FBSUcsTUFBSixDQUFZLENBQ1Y7QUFDQUosUUFBVXAwQyxXQUFXNDBDLFlBQVgsQ0FBeUJsYixJQUF6QixDQUFWLENBQ0EsTUFBTythLFlBQVdKLFlBQVgsQ0FBUCxDQUNELENBQ0YsQ0FDRCxHQUFJRCxVQUFZcHlDLFNBQWhCLENBQTJCLENBQ3pCb3lDLFFBQVVwMEMsV0FBVzQwQyxZQUFYLENBQXlCbGIsSUFBekIsQ0FBVixDQUNELENBQ0QsTUFBT2xRLE9BQVAsQ0FDRCxDQUNENHJCLFVBQVVGLE1BQVYsQ0FBbUJBLE1BQW5CLENBQ0FFLFVBQVVELEtBQVYsQ0FBa0JBLEtBQWxCLENBQ0EsTUFBT0MsVUFBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7O09Ba0JBLEdBQUlFLE9BQVFoVSxTQUFTLFNBQVM1WSxJQUFULENBQWVFLElBQWYsQ0FBcUIsQ0FDeEMsTUFBTzZRLFdBQVUvUSxJQUFWLENBQWdCLENBQWhCLENBQW1CRSxJQUFuQixDQUFQLENBQ0QsQ0FGVyxDQUFaLENBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQW1CQSxHQUFJMnNCLE9BQVFqVSxTQUFTLFNBQVM1WSxJQUFULENBQWVnUixJQUFmLENBQXFCOVEsSUFBckIsQ0FBMkIsQ0FDOUMsTUFBTzZRLFdBQVUvUSxJQUFWLENBQWdCNGhCLFNBQVM1USxJQUFULEdBQWtCLENBQWxDLENBQXFDOVEsSUFBckMsQ0FBUCxDQUNELENBRlcsQ0FBWixDQUlBOzs7Ozs7Ozs7Ozs7Ozs7OztPQWtCQSxRQUFTNHNCLEtBQVQsQ0FBYzlzQixJQUFkLENBQW9CLENBQ2xCLE1BQU91aUIsWUFBV3ZpQixJQUFYLENBQWlCdEssU0FBakIsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E0Q0EsUUFBU3N2QixRQUFULENBQWlCaGxCLElBQWpCLENBQXVCK3NCLFFBQXZCLENBQWlDLENBQy9CLEdBQUksTUFBTy9zQixLQUFQLEVBQWUsVUFBZixFQUE4QitzQixVQUFZLE1BQU9BLFNBQVAsRUFBbUIsVUFBakUsQ0FBOEUsQ0FDNUUsS0FBTSxJQUFJcm5CLFVBQUosQ0FBYzVRLGVBQWQsQ0FBTixDQUNELENBQ0QsR0FBSWs0QixVQUFXLFVBQVcsQ0FDeEIsR0FBSTlzQixNQUFPMlksU0FBWCxDQUNJemxDLElBQU0yNUMsU0FBV0EsU0FBUzc0QixLQUFULENBQWUsSUFBZixDQUFxQmdNLElBQXJCLENBQVgsQ0FBd0NBLEtBQUssQ0FBTCxDQURsRCxDQUVJaUQsTUFBUTZwQixTQUFTN3BCLEtBRnJCLENBSUEsR0FBSUEsTUFBTUMsR0FBTixDQUFVaHdCLEdBQVYsQ0FBSixDQUFvQixDQUNsQixNQUFPK3ZCLE9BQU1wd0IsR0FBTixDQUFVSyxHQUFWLENBQVAsQ0FDRCxDQUNELEdBQUkwdEIsUUFBU2QsS0FBSzlMLEtBQUwsQ0FBVyxJQUFYLENBQWlCZ00sSUFBakIsQ0FBYixDQUNBOHNCLFNBQVM3cEIsS0FBVCxDQUFpQkEsTUFBTWh3QixHQUFOLENBQVVDLEdBQVYsQ0FBZTB0QixNQUFmLENBQWpCLENBQ0EsTUFBT0EsT0FBUCxDQUNELENBWEQsQ0FZQWtzQixTQUFTN3BCLEtBQVQsQ0FBaUIsSUFBSzZoQixRQUFRaUksS0FBUixFQUFpQjNmLFFBQXRCLEdBQWpCLENBQ0EsTUFBTzBmLFNBQVAsQ0FDRCxDQUVEO0FBQ0FoSSxRQUFRaUksS0FBUixDQUFnQjNmLFFBQWhCLENBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FvQkEsUUFBU21kLE9BQVQsQ0FBZ0I5cEIsU0FBaEIsQ0FBMkIsQ0FDekIsR0FBSSxNQUFPQSxVQUFQLEVBQW9CLFVBQXhCLENBQW9DLENBQ2xDLEtBQU0sSUFBSStFLFVBQUosQ0FBYzVRLGVBQWQsQ0FBTixDQUNELENBQ0QsTUFBTyxXQUFXLENBQ2hCLEdBQUlvTCxNQUFPMlksU0FBWCxDQUNBLE9BQVEzWSxLQUFLeG5CLE1BQWIsRUFDRSxJQUFLLEVBQUwsQ0FBUSxNQUFPLENBQUNpb0IsVUFBVXZTLElBQVYsQ0FBZSxJQUFmLENBQVIsQ0FDUixJQUFLLEVBQUwsQ0FBUSxNQUFPLENBQUN1UyxVQUFVdlMsSUFBVixDQUFlLElBQWYsQ0FBcUI4UixLQUFLLENBQUwsQ0FBckIsQ0FBUixDQUNSLElBQUssRUFBTCxDQUFRLE1BQU8sQ0FBQ1MsVUFBVXZTLElBQVYsQ0FBZSxJQUFmLENBQXFCOFIsS0FBSyxDQUFMLENBQXJCLENBQThCQSxLQUFLLENBQUwsQ0FBOUIsQ0FBUixDQUNSLElBQUssRUFBTCxDQUFRLE1BQU8sQ0FBQ1MsVUFBVXZTLElBQVYsQ0FBZSxJQUFmLENBQXFCOFIsS0FBSyxDQUFMLENBQXJCLENBQThCQSxLQUFLLENBQUwsQ0FBOUIsQ0FBdUNBLEtBQUssQ0FBTCxDQUF2QyxDQUFSLENBSlYsQ0FNQSxNQUFPLENBQUNTLFVBQVV6TSxLQUFWLENBQWdCLElBQWhCLENBQXNCZ00sSUFBdEIsQ0FBUixDQUNELENBVEQsQ0FVRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7OztPQWtCQSxRQUFTZ3RCLEtBQVQsQ0FBY2x0QixJQUFkLENBQW9CLENBQ2xCLE1BQU9pckIsUUFBTyxDQUFQLENBQVVqckIsSUFBVixDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BK0JBLEdBQUltdEIsVUFBV3ZVLFNBQVMsU0FBUzVZLElBQVQsQ0FBZTRqQixVQUFmLENBQTJCLENBQ2pEQSxXQUFjQSxXQUFXbHJDLE1BQVgsRUFBcUIsQ0FBckIsRUFBMEJ5WixRQUFReXhCLFdBQVcsQ0FBWCxDQUFSLENBQTNCLENBQ1R6aUIsU0FBU3lpQixXQUFXLENBQVgsQ0FBVCxDQUF3QjVnQixVQUFVK1UsYUFBVixDQUF4QixDQURTLENBRVQ1VyxTQUFTOFEsWUFBWTJSLFVBQVosQ0FBd0IsQ0FBeEIsQ0FBVCxDQUFxQzVnQixVQUFVK1UsYUFBVixDQUFyQyxDQUZKLENBSUEsR0FBSXFWLGFBQWN4SixXQUFXbHJDLE1BQTdCLENBQ0EsTUFBT2tnQyxVQUFTLFNBQVMxWSxJQUFULENBQWUsQ0FDN0IsR0FBSWpjLE9BQVEsQ0FBQyxDQUFiLENBQ0l2TCxPQUFTMnZCLFVBQVVuSSxLQUFLeG5CLE1BQWYsQ0FBdUIwMEMsV0FBdkIsQ0FEYixDQUdBLE1BQU8sRUFBRW5wQyxLQUFGLENBQVV2TCxNQUFqQixDQUF5QixDQUN2QnduQixLQUFLamMsS0FBTCxFQUFjMi9CLFdBQVczL0IsS0FBWCxFQUFrQm1LLElBQWxCLENBQXVCLElBQXZCLENBQTZCOFIsS0FBS2pjLEtBQUwsQ0FBN0IsQ0FBZCxDQUNELENBQ0QsTUFBT2lRLE9BQU04TCxJQUFOLENBQVksSUFBWixDQUFrQkUsSUFBbEIsQ0FBUCxDQUNELENBUk0sQ0FBUCxDQVNELENBZmMsQ0FBZixDQWlCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FpQ0EsR0FBSW10QixTQUFVelUsU0FBUyxTQUFTNVksSUFBVCxDQUFlZ2QsUUFBZixDQUF5QixDQUM5QyxHQUFJQyxTQUFVclksZUFBZW9ZLFFBQWYsQ0FBeUJzQyxVQUFVK04sT0FBVixDQUF6QixDQUFkLENBQ0EsTUFBTzlLLFlBQVd2aUIsSUFBWCxDQUFpQjFLLFlBQWpCLENBQStCaGMsU0FBL0IsQ0FBMEMwakMsUUFBMUMsQ0FBb0RDLE9BQXBELENBQVAsQ0FDRCxDQUhhLENBQWQsQ0FLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWdDQSxHQUFJcVEsY0FBZTFVLFNBQVMsU0FBUzVZLElBQVQsQ0FBZWdkLFFBQWYsQ0FBeUIsQ0FDbkQsR0FBSUMsU0FBVXJZLGVBQWVvWSxRQUFmLENBQXlCc0MsVUFBVWdPLFlBQVYsQ0FBekIsQ0FBZCxDQUNBLE1BQU8vSyxZQUFXdmlCLElBQVgsQ0FBaUJ6SyxrQkFBakIsQ0FBcUNqYyxTQUFyQyxDQUFnRDBqQyxRQUFoRCxDQUEwREMsT0FBMUQsQ0FBUCxDQUNELENBSGtCLENBQW5CLENBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXNCQSxHQUFJc1EsT0FBUTNVLFNBQVMsU0FBUzVZLElBQVQsQ0FBZXVZLE9BQWYsQ0FBd0IsQ0FDM0MsTUFBT2dLLFlBQVd2aUIsSUFBWCxDQUFpQnZLLFVBQWpCLENBQTZCbmMsU0FBN0IsQ0FBd0NBLFNBQXhDLENBQW1EQSxTQUFuRCxDQUE4RDI0QixZQUFZc0csT0FBWixDQUFxQixDQUFyQixDQUE5RCxDQUFQLENBQ0QsQ0FGVyxDQUFaLENBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXlCQSxRQUFTaVYsS0FBVCxDQUFjeHRCLElBQWQsQ0FBb0I0TCxLQUFwQixDQUEyQixDQUN6QixHQUFJLE1BQU81TCxLQUFQLEVBQWUsVUFBbkIsQ0FBK0IsQ0FDN0IsS0FBTSxJQUFJMEYsVUFBSixDQUFjNVEsZUFBZCxDQUFOLENBQ0QsQ0FDRDhXLE1BQVFBLFFBQVV0eUIsU0FBVixDQUFzQnN5QixLQUF0QixDQUE4QmtHLFVBQVVsRyxLQUFWLENBQXRDLENBQ0EsTUFBT2dOLFVBQVM1WSxJQUFULENBQWU0TCxLQUFmLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FrQ0EsUUFBUzZoQixPQUFULENBQWdCenRCLElBQWhCLENBQXNCNEwsS0FBdEIsQ0FBNkIsQ0FDM0IsR0FBSSxNQUFPNUwsS0FBUCxFQUFlLFVBQW5CLENBQStCLENBQzdCLEtBQU0sSUFBSTBGLFVBQUosQ0FBYzVRLGVBQWQsQ0FBTixDQUNELENBQ0Q4VyxNQUFRQSxRQUFVdHlCLFNBQVYsQ0FBc0IsQ0FBdEIsQ0FBMEI4dUIsVUFBVTBKLFVBQVVsRyxLQUFWLENBQVYsQ0FBNEIsQ0FBNUIsQ0FBbEMsQ0FDQSxNQUFPZ04sVUFBUyxTQUFTMVksSUFBVCxDQUFlLENBQzdCLEdBQUlFLE9BQVFGLEtBQUswTCxLQUFMLENBQVosQ0FDSWtOLFVBQVl1QyxVQUFVbmIsSUFBVixDQUFnQixDQUFoQixDQUFtQjBMLEtBQW5CLENBRGhCLENBR0EsR0FBSXhMLEtBQUosQ0FBVyxDQUNUZ0IsVUFBVTBYLFNBQVYsQ0FBcUIxWSxLQUFyQixFQUNELENBQ0QsTUFBT2xNLE9BQU04TCxJQUFOLENBQVksSUFBWixDQUFrQjhZLFNBQWxCLENBQVAsQ0FDRCxDQVJNLENBQVAsQ0FTRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BNENBLFFBQVM0VSxTQUFULENBQWtCMXRCLElBQWxCLENBQXdCZ1IsSUFBeEIsQ0FBOEJzYSxPQUE5QixDQUF1QyxDQUNyQyxHQUFJTyxTQUFVLElBQWQsQ0FDSTlNLFNBQVcsSUFEZixDQUdBLEdBQUksTUFBTy9lLEtBQVAsRUFBZSxVQUFuQixDQUErQixDQUM3QixLQUFNLElBQUkwRixVQUFKLENBQWM1USxlQUFkLENBQU4sQ0FDRCxDQUNELEdBQUltYixTQUFTcWIsT0FBVCxDQUFKLENBQXVCLENBQ3JCTyxRQUFVLFdBQWFQLFFBQWIsQ0FBdUIsQ0FBQyxDQUFDQSxRQUFRTyxPQUFqQyxDQUEyQ0EsT0FBckQsQ0FDQTlNLFNBQVcsWUFBY3VNLFFBQWQsQ0FBd0IsQ0FBQyxDQUFDQSxRQUFRdk0sUUFBbEMsQ0FBNkNBLFFBQXhELENBQ0QsQ0FDRCxNQUFPc00sVUFBU3JyQixJQUFULENBQWVnUixJQUFmLENBQXFCLENBQzFCLFVBQVc2YSxPQURlLENBRTFCLFVBQVc3YSxJQUZlLENBRzFCLFdBQVkrTixRQUhjLENBQXJCLENBQVAsQ0FLRCxDQUVEOzs7Ozs7Ozs7Ozs7OztPQWVBLFFBQVM0TyxNQUFULENBQWUzdEIsSUFBZixDQUFxQixDQUNuQixNQUFPdWdCLEtBQUl2Z0IsSUFBSixDQUFVLENBQVYsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXNCQSxRQUFTNHRCLEtBQVQsQ0FBY3Y2QyxLQUFkLENBQXFCc3JDLE9BQXJCLENBQThCLENBQzVCQSxRQUFVQSxTQUFXLElBQVgsQ0FBa0J2SSxRQUFsQixDQUE2QnVJLE9BQXZDLENBQ0EsTUFBTzBPLFNBQVExTyxPQUFSLENBQWlCdHJDLEtBQWpCLENBQVAsQ0FDRCxDQUVELDRFQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWlDQSxRQUFTdzZDLFVBQVQsRUFBcUIsQ0FDbkIsR0FBSSxDQUFDaFYsVUFBVW5nQyxNQUFmLENBQXVCLENBQ3JCLE1BQU8sRUFBUCxDQUNELENBQ0QsR0FBSXJGLE9BQVF3bEMsVUFBVSxDQUFWLENBQVosQ0FDQSxNQUFPMW1CLFNBQVE5ZSxLQUFSLEVBQWlCQSxLQUFqQixDQUF5QixDQUFDQSxLQUFELENBQWhDLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTBCQSxRQUFTKzNCLE1BQVQsQ0FBZS8zQixLQUFmLENBQXNCLENBQ3BCLE1BQU93OEIsV0FBVXg4QixLQUFWLENBQWlCLEtBQWpCLENBQXdCLElBQXhCLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0ErQkEsUUFBU3k2QyxVQUFULENBQW1CejZDLEtBQW5CLENBQTBCMjhCLFVBQTFCLENBQXNDLENBQ3BDLE1BQU9ILFdBQVV4OEIsS0FBVixDQUFpQixLQUFqQixDQUF3QixJQUF4QixDQUE4QjI4QixVQUE5QixDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FrQkEsUUFBUytkLFVBQVQsQ0FBbUIxNkMsS0FBbkIsQ0FBMEIsQ0FDeEIsTUFBT3c4QixXQUFVeDhCLEtBQVYsQ0FBaUIsSUFBakIsQ0FBdUIsSUFBdkIsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTRCQSxRQUFTMjZDLGNBQVQsQ0FBdUIzNkMsS0FBdkIsQ0FBOEIyOEIsVUFBOUIsQ0FBMEMsQ0FDeEMsTUFBT0gsV0FBVXg4QixLQUFWLENBQWlCLElBQWpCLENBQXVCLElBQXZCLENBQTZCMjhCLFVBQTdCLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXdCQSxRQUFTaWUsV0FBVCxDQUFvQjFyQixNQUFwQixDQUE0QnhKLE1BQTVCLENBQW9DLENBQ2xDLE1BQU9BLFNBQVUsSUFBVixFQUFrQjhYLGVBQWV0TyxNQUFmLENBQXVCeEosTUFBdkIsQ0FBK0JtTixLQUFLbk4sTUFBTCxDQUEvQixDQUF6QixDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FnQ0EsUUFBU2dXLEdBQVQsQ0FBWTE3QixLQUFaLENBQW1CKy9CLEtBQW5CLENBQTBCLENBQ3hCLE1BQU8vL0IsU0FBVSsvQixLQUFWLEVBQW9CLy9CLFFBQVVBLEtBQVYsRUFBbUIrL0IsUUFBVUEsS0FBeEQsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BdUJBLEdBQUk4YSxJQUFLdk0sMEJBQTBCeE8sTUFBMUIsQ0FBVCxDQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BdUJBLEdBQUlnYixLQUFNeE0sMEJBQTBCLFNBQVN0dUMsS0FBVCxDQUFnQisvQixLQUFoQixDQUF1QixDQUN6RCxNQUFPLy9CLFFBQVMrL0IsS0FBaEIsQ0FDRCxDQUZTLENBQVYsQ0FJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FrQkEsUUFBUzNFLFlBQVQsQ0FBcUJwN0IsS0FBckIsQ0FBNEIsQ0FDMUI7QUFDQSxNQUFPb2tDLG1CQUFrQnBrQyxLQUFsQixHQUE0Qmd6QixlQUFlalksSUFBZixDQUFvQi9hLEtBQXBCLENBQTJCLFFBQTNCLENBQTVCLEdBQ0osQ0FBQzZ6QixxQkFBcUI5WSxJQUFyQixDQUEwQi9hLEtBQTFCLENBQWlDLFFBQWpDLENBQUQsRUFBK0NtekIsZUFBZXBZLElBQWYsQ0FBb0IvYSxLQUFwQixHQUE4QnVqQixPQUR6RSxDQUFQLENBRUQsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXVCQSxHQUFJekUsU0FBVW5PLE1BQU1tTyxPQUFwQixDQUVBOzs7Ozs7Ozs7Ozs7Ozs7O09BaUJBLEdBQUk4TSxlQUFnQkQsa0JBQW9CZ0UsVUFBVWhFLGlCQUFWLENBQXBCLENBQW1Eb1YsaUJBQXZFLENBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXlCQSxRQUFTMkMsWUFBVCxDQUFxQjFqQyxLQUFyQixDQUE0QixDQUMxQixNQUFPQSxRQUFTLElBQVQsRUFBaUI2aUMsU0FBUzdpQyxNQUFNcUYsTUFBZixDQUFqQixFQUEyQyxDQUFDKzVCLFdBQVdwL0IsS0FBWCxDQUFuRCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXlCQSxRQUFTb2tDLGtCQUFULENBQTJCcGtDLEtBQTNCLENBQWtDLENBQ2hDLE1BQU8wMkIsY0FBYTEyQixLQUFiLEdBQXVCMGpDLFlBQVkxakMsS0FBWixDQUE5QixDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7T0FpQkEsUUFBUys2QyxVQUFULENBQW1CLzZDLEtBQW5CLENBQTBCLENBQ3hCLE1BQU9BLFNBQVUsSUFBVixFQUFrQkEsUUFBVSxLQUE1QixFQUNKMDJCLGFBQWExMkIsS0FBYixHQUF1Qm16QixlQUFlcFksSUFBZixDQUFvQi9hLEtBQXBCLEdBQThCeWpCLE9BRHhELENBRUQsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7OztPQWlCQSxHQUFJaVIsVUFBV0QsZ0JBQWtCc2MsU0FBakMsQ0FFQTs7Ozs7Ozs7Ozs7Ozs7OztPQWlCQSxHQUFJamxCLFFBQVNELFdBQWE4RCxVQUFVOUQsVUFBVixDQUFiLENBQXFDbVYsVUFBbEQsQ0FFQTs7Ozs7Ozs7Ozs7Ozs7OztPQWlCQSxRQUFTZ2EsVUFBVCxDQUFtQmg3QyxLQUFuQixDQUEwQixDQUN4QixNQUFPLENBQUMsQ0FBQ0EsS0FBRixFQUFXQSxNQUFNb3JCLFFBQU4sR0FBbUIsQ0FBOUIsRUFBbUNzTCxhQUFhMTJCLEtBQWIsQ0FBbkMsRUFBMEQsQ0FBQ3FrQyxjQUFjcmtDLEtBQWQsQ0FBbEUsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWlDQSxRQUFTaTdDLFFBQVQsQ0FBaUJqN0MsS0FBakIsQ0FBd0IsQ0FDdEIsR0FBSTBqQyxZQUFZMWpDLEtBQVosSUFDQzhlLFFBQVE5ZSxLQUFSLEdBQWtCLE1BQU9BLE1BQVAsRUFBZ0IsUUFBbEMsRUFDQyxNQUFPQSxPQUFNOGYsTUFBYixFQUF1QixVQUR4QixFQUNzQzRVLFNBQVMxMEIsS0FBVCxDQUR0QyxFQUN5RG83QixZQUFZcDdCLEtBQVosQ0FGMUQsQ0FBSixDQUVtRixDQUNqRixNQUFPLENBQUNBLE1BQU1xRixNQUFkLENBQ0QsQ0FDRCxHQUFJK1EsS0FBTTBtQixPQUFPOThCLEtBQVAsQ0FBVixDQUNBLEdBQUlvVyxLQUFPME4sTUFBUCxFQUFpQjFOLEtBQU8rTixNQUE1QixDQUFvQyxDQUNsQyxNQUFPLENBQUNua0IsTUFBTW14QixJQUFkLENBQ0QsQ0FDRCxHQUFJMEUsZ0JBQWtCdU4sWUFBWXBqQyxLQUFaLENBQXRCLENBQTBDLENBQ3hDLE1BQU8sQ0FBQzgwQixXQUFXOTBCLEtBQVgsRUFBa0JxRixNQUExQixDQUNELENBQ0QsSUFBSyxHQUFJdEYsSUFBVCxHQUFnQkMsTUFBaEIsQ0FBdUIsQ0FDckIsR0FBSWd6QixlQUFlalksSUFBZixDQUFvQi9hLEtBQXBCLENBQTJCRCxHQUEzQixDQUFKLENBQXFDLENBQ25DLE1BQU8sTUFBUCxDQUNELENBQ0YsQ0FDRCxNQUFPLEtBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E0QkEsUUFBU203QyxRQUFULENBQWlCbDdDLEtBQWpCLENBQXdCKy9CLEtBQXhCLENBQStCLENBQzdCLE1BQU9rQixhQUFZamhDLEtBQVosQ0FBbUIrL0IsS0FBbkIsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FnQ0EsUUFBU29iLFlBQVQsQ0FBcUJuN0MsS0FBckIsQ0FBNEIrL0IsS0FBNUIsQ0FBbUNwRCxVQUFuQyxDQUErQyxDQUM3Q0EsV0FBYSxNQUFPQSxXQUFQLEVBQXFCLFVBQXJCLENBQWtDQSxVQUFsQyxDQUErQzEyQixTQUE1RCxDQUNBLEdBQUl3bkIsUUFBU2tQLFdBQWFBLFdBQVczOEIsS0FBWCxDQUFrQisvQixLQUFsQixDQUFiLENBQXdDOTVCLFNBQXJELENBQ0EsTUFBT3duQixVQUFXeG5CLFNBQVgsQ0FBdUJnN0IsWUFBWWpoQyxLQUFaLENBQW1CKy9CLEtBQW5CLENBQTBCcEQsVUFBMUIsQ0FBdkIsQ0FBK0QsQ0FBQyxDQUFDbFAsTUFBeEUsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7OztPQWtCQSxRQUFTMnRCLFFBQVQsQ0FBaUJwN0MsS0FBakIsQ0FBd0IsQ0FDdEIsR0FBSSxDQUFDMDJCLGFBQWExMkIsS0FBYixDQUFMLENBQTBCLENBQ3hCLE1BQU8sTUFBUCxDQUNELENBQ0QsTUFBUW16QixnQkFBZXBZLElBQWYsQ0FBb0IvYSxLQUFwQixHQUE4QjJqQixRQUEvQixFQUNKLE1BQU8zakIsT0FBTXJCLE9BQWIsRUFBd0IsUUFBeEIsRUFBb0MsTUFBT3FCLE9BQU11UCxJQUFiLEVBQXFCLFFBRDVELENBRUQsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTBCQSxRQUFTcWxCLFNBQVQsQ0FBa0I1MEIsS0FBbEIsQ0FBeUIsQ0FDdkIsTUFBTyxPQUFPQSxNQUFQLEVBQWdCLFFBQWhCLEVBQTRCMjBCLGVBQWUzMEIsS0FBZixDQUFuQyxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7T0FpQkEsUUFBU28vQixXQUFULENBQW9CcC9CLEtBQXBCLENBQTJCLENBQ3pCO0FBQ0E7QUFDQSxHQUFJb1csS0FBTXdtQixTQUFTNThCLEtBQVQsRUFBa0JtekIsZUFBZXBZLElBQWYsQ0FBb0IvYSxLQUFwQixDQUFsQixDQUErQyxFQUF6RCxDQUNBLE1BQU9vVyxNQUFPd04sT0FBUCxFQUFrQnhOLEtBQU95TixNQUFoQyxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0EwQkEsUUFBU3czQixVQUFULENBQW1CcjdDLEtBQW5CLENBQTBCLENBQ3hCLE1BQU8sT0FBT0EsTUFBUCxFQUFnQixRQUFoQixFQUE0QkEsT0FBU3krQixVQUFVeitCLEtBQVYsQ0FBNUMsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMEJBLFFBQVM2aUMsU0FBVCxDQUFrQjdpQyxLQUFsQixDQUF5QixDQUN2QixNQUFPLE9BQU9BLE1BQVAsRUFBZ0IsUUFBaEIsRUFDTEEsTUFBUSxDQUFDLENBREosRUFDU0EsTUFBUSxDQUFSLEVBQWEsQ0FEdEIsRUFDMkJBLE9BQVNnakIsZ0JBRDNDLENBRUQsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BeUJBLFFBQVM0WixTQUFULENBQWtCNThCLEtBQWxCLENBQXlCLENBQ3ZCLEdBQUlkLE1BQU8sTUFBT2MsTUFBbEIsQ0FDQSxNQUFPLENBQUMsQ0FBQ0EsS0FBRixHQUFZZCxNQUFRLFFBQVIsRUFBb0JBLE1BQVEsVUFBeEMsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bd0JBLFFBQVN3M0IsYUFBVCxDQUFzQjEyQixLQUF0QixDQUE2QixDQUMzQixNQUFPLENBQUMsQ0FBQ0EsS0FBRixFQUFXLE1BQU9BLE1BQVAsRUFBZ0IsUUFBbEMsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7O09BaUJBLEdBQUlnc0IsT0FBUUQsVUFBWTRELFVBQVU1RCxTQUFWLENBQVosQ0FBbUNvVyxTQUEvQyxDQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E0QkEsUUFBU21aLFFBQVQsQ0FBaUJwc0IsTUFBakIsQ0FBeUJ4SixNQUF6QixDQUFpQyxDQUMvQixNQUFPd0osVUFBV3hKLE1BQVgsRUFBcUIwYyxZQUFZbFQsTUFBWixDQUFvQnhKLE1BQXBCLENBQTRCaWUsYUFBYWplLE1BQWIsQ0FBNUIsQ0FBNUIsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BZ0NBLFFBQVM2MUIsWUFBVCxDQUFxQnJzQixNQUFyQixDQUE2QnhKLE1BQTdCLENBQXFDaVgsVUFBckMsQ0FBaUQsQ0FDL0NBLFdBQWEsTUFBT0EsV0FBUCxFQUFxQixVQUFyQixDQUFrQ0EsVUFBbEMsQ0FBK0MxMkIsU0FBNUQsQ0FDQSxNQUFPbThCLGFBQVlsVCxNQUFaLENBQW9CeEosTUFBcEIsQ0FBNEJpZSxhQUFhamUsTUFBYixDQUE1QixDQUFrRGlYLFVBQWxELENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E0QkEsUUFBUzZlLE1BQVQsQ0FBZXg3QyxLQUFmLENBQXNCLENBQ3BCO0FBQ0E7QUFDQTtBQUNBLE1BQU95N0MsVUFBU3o3QyxLQUFULEdBQW1CQSxPQUFTLENBQUNBLEtBQXBDLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTBCQSxRQUFTMDdDLFNBQVQsQ0FBa0IxN0MsS0FBbEIsQ0FBeUIsQ0FDdkIsR0FBSTh3QyxXQUFXOXdDLEtBQVgsQ0FBSixDQUF1QixDQUNyQixLQUFNLElBQUl0QixNQUFKLENBQVUsNkVBQVYsQ0FBTixDQUNELENBQ0QsTUFBTzZqQyxjQUFhdmlDLEtBQWIsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7T0FpQkEsUUFBUzI3QyxPQUFULENBQWdCMzdDLEtBQWhCLENBQXVCLENBQ3JCLE1BQU9BLFNBQVUsSUFBakIsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bb0JBLFFBQVNtOEIsTUFBVCxDQUFlbjhCLEtBQWYsQ0FBc0IsQ0FDcEIsTUFBT0EsUUFBUyxJQUFoQixDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0EwQkEsUUFBU3k3QyxTQUFULENBQWtCejdDLEtBQWxCLENBQXlCLENBQ3ZCLE1BQU8sT0FBT0EsTUFBUCxFQUFnQixRQUFoQixFQUNKMDJCLGFBQWExMkIsS0FBYixHQUF1Qm16QixlQUFlcFksSUFBZixDQUFvQi9hLEtBQXBCLEdBQThCK2pCLFNBRHhELENBRUQsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BNEJBLFFBQVNzZ0IsY0FBVCxDQUF1QnJrQyxLQUF2QixDQUE4QixDQUM1QixHQUFJLENBQUMwMkIsYUFBYTEyQixLQUFiLENBQUQsRUFDQW16QixlQUFlcFksSUFBZixDQUFvQi9hLEtBQXBCLEdBQThCZ2tCLFNBRDlCLEVBQzJDNk0sYUFBYTd3QixLQUFiLENBRC9DLENBQ29FLENBQ2xFLE1BQU8sTUFBUCxDQUNELENBQ0QsR0FBSXk5QixPQUFRaEssYUFBYXp6QixLQUFiLENBQVosQ0FDQSxHQUFJeTlCLFFBQVUsSUFBZCxDQUFvQixDQUNsQixNQUFPLEtBQVAsQ0FDRCxDQUNELEdBQUkyTixNQUFPcFksZUFBZWpZLElBQWYsQ0FBb0IwaUIsS0FBcEIsQ0FBMkIsYUFBM0IsR0FBNkNBLE1BQU05OEIsV0FBOUQsQ0FDQSxNQUFRLE9BQU95cUMsS0FBUCxFQUFlLFVBQWYsRUFDTkEsZUFBZ0JBLEtBRFYsRUFDa0JyWSxhQUFhaFksSUFBYixDQUFrQnF3QixJQUFsQixHQUEyQmxZLGdCQURyRCxDQUVELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7T0FpQkEsR0FBSWhILFVBQVdELGFBQWUwRCxVQUFVMUQsWUFBVixDQUFmLENBQXlDeVcsWUFBeEQsQ0FFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0EyQkEsUUFBU2taLGNBQVQsQ0FBdUI1N0MsS0FBdkIsQ0FBOEIsQ0FDNUIsTUFBT3E3QyxXQUFVcjdDLEtBQVYsR0FBb0JBLE9BQVMsQ0FBQ2dqQixnQkFBOUIsRUFBa0RoakIsT0FBU2dqQixnQkFBbEUsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7O09BaUJBLEdBQUlvSixPQUFRRCxVQUFZd0QsVUFBVXhELFNBQVYsQ0FBWixDQUFtQ3dXLFNBQS9DLENBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7T0FpQkEsUUFBU2lVLFNBQVQsQ0FBa0I1MkMsS0FBbEIsQ0FBeUIsQ0FDdkIsTUFBTyxPQUFPQSxNQUFQLEVBQWdCLFFBQWhCLEVBQ0osQ0FBQzhlLFFBQVE5ZSxLQUFSLENBQUQsRUFBbUIwMkIsYUFBYTEyQixLQUFiLENBQW5CLEVBQTBDbXpCLGVBQWVwWSxJQUFmLENBQW9CL2EsS0FBcEIsR0FBOEJva0IsU0FEM0UsQ0FFRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7O09BaUJBLFFBQVNtYSxTQUFULENBQWtCditCLEtBQWxCLENBQXlCLENBQ3ZCLE1BQU8sT0FBT0EsTUFBUCxFQUFnQixRQUFoQixFQUNKMDJCLGFBQWExMkIsS0FBYixHQUF1Qm16QixlQUFlcFksSUFBZixDQUFvQi9hLEtBQXBCLEdBQThCcWtCLFNBRHhELENBRUQsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7OztPQWlCQSxHQUFJaUksY0FBZUQsaUJBQW1Cc0QsVUFBVXRELGdCQUFWLENBQW5CLENBQWlEdVcsZ0JBQXBFLENBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7T0FpQkEsUUFBU2laLFlBQVQsQ0FBcUI3N0MsS0FBckIsQ0FBNEIsQ0FDMUIsTUFBT0EsU0FBVWlHLFNBQWpCLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7OztPQWlCQSxRQUFTNjFDLFVBQVQsQ0FBbUI5N0MsS0FBbkIsQ0FBMEIsQ0FDeEIsTUFBTzAyQixjQUFhMTJCLEtBQWIsR0FBdUI4OEIsT0FBTzk4QixLQUFQLEdBQWlCc2tCLFVBQS9DLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7OztPQWlCQSxRQUFTeTNCLFVBQVQsQ0FBbUIvN0MsS0FBbkIsQ0FBMEIsQ0FDeEIsTUFBTzAyQixjQUFhMTJCLEtBQWIsR0FBdUJtekIsZUFBZXBZLElBQWYsQ0FBb0IvYSxLQUFwQixHQUE4QnVrQixVQUE1RCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F1QkEsR0FBSXkzQixJQUFLMU4sMEJBQTBCOUssTUFBMUIsQ0FBVCxDQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BdUJBLEdBQUl5WSxLQUFNM04sMEJBQTBCLFNBQVN0dUMsS0FBVCxDQUFnQisvQixLQUFoQixDQUF1QixDQUN6RCxNQUFPLy9CLFFBQVMrL0IsS0FBaEIsQ0FDRCxDQUZTLENBQVYsQ0FJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXVCQSxRQUFTOFYsUUFBVCxDQUFpQjcxQyxLQUFqQixDQUF3QixDQUN0QixHQUFJLENBQUNBLEtBQUwsQ0FBWSxDQUNWLE1BQU8sRUFBUCxDQUNELENBQ0QsR0FBSTBqQyxZQUFZMWpDLEtBQVosQ0FBSixDQUF3QixDQUN0QixNQUFPNDJDLFVBQVM1MkMsS0FBVCxFQUFrQjR4QixjQUFjNXhCLEtBQWQsQ0FBbEIsQ0FBeUM2M0IsVUFBVTczQixLQUFWLENBQWhELENBQ0QsQ0FDRCxHQUFJMnpCLGdCQUFrQjN6QixNQUFNMnpCLGNBQU4sQ0FBdEIsQ0FBNkMsQ0FDM0MsTUFBTzVDLGlCQUFnQi93QixNQUFNMnpCLGNBQU4sR0FBaEIsQ0FBUCxDQUNELENBQ0QsR0FBSXZkLEtBQU0wbUIsT0FBTzk4QixLQUFQLENBQVYsQ0FDSTJzQixLQUFPdlcsS0FBTzBOLE1BQVAsQ0FBZ0JvTixVQUFoQixDQUE4QjlhLEtBQU8rTixNQUFQLENBQWdCcU4sVUFBaEIsQ0FBNkIzVyxNQUR0RSxDQUdBLE1BQU84UixNQUFLM3NCLEtBQUwsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F1QkEsUUFBU3F1QyxTQUFULENBQWtCcnVDLEtBQWxCLENBQXlCLENBQ3ZCLEdBQUksQ0FBQ0EsS0FBTCxDQUFZLENBQ1YsTUFBT0EsU0FBVSxDQUFWLENBQWNBLEtBQWQsQ0FBc0IsQ0FBN0IsQ0FDRCxDQUNEQSxNQUFRdXVDLFNBQVN2dUMsS0FBVCxDQUFSLENBQ0EsR0FBSUEsUUFBVStpQixRQUFWLEVBQXNCL2lCLFFBQVUsQ0FBQytpQixRQUFyQyxDQUErQyxDQUM3QyxHQUFJbTVCLE1BQVFsOEMsTUFBUSxDQUFSLENBQVksQ0FBQyxDQUFiLENBQWlCLENBQTdCLENBQ0EsTUFBT2s4QyxNQUFPajVCLFdBQWQsQ0FDRCxDQUNELE1BQU9qakIsU0FBVUEsS0FBVixDQUFrQkEsS0FBbEIsQ0FBMEIsQ0FBakMsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMEJBLFFBQVN5K0IsVUFBVCxDQUFtQnorQixLQUFuQixDQUEwQixDQUN4QixHQUFJeXRCLFFBQVM0Z0IsU0FBU3J1QyxLQUFULENBQWIsQ0FDSW04QyxVQUFZMXVCLE9BQVMsQ0FEekIsQ0FHQSxNQUFPQSxVQUFXQSxNQUFYLENBQXFCMHVCLFVBQVkxdUIsT0FBUzB1QixTQUFyQixDQUFpQzF1QixNQUF0RCxDQUFnRSxDQUF2RSxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMkJBLFFBQVNpUixTQUFULENBQWtCMStCLEtBQWxCLENBQXlCLENBQ3ZCLE1BQU9BLE9BQVFvOEIsVUFBVXFDLFVBQVV6K0IsS0FBVixDQUFWLENBQTRCLENBQTVCLENBQStCbWpCLGdCQUEvQixDQUFSLENBQTJELENBQWxFLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXVCQSxRQUFTb3JCLFNBQVQsQ0FBa0J2dUMsS0FBbEIsQ0FBeUIsQ0FDdkIsR0FBSSxNQUFPQSxNQUFQLEVBQWdCLFFBQXBCLENBQThCLENBQzVCLE1BQU9BLE1BQVAsQ0FDRCxDQUNELEdBQUl1K0IsU0FBU3YrQixLQUFULENBQUosQ0FBcUIsQ0FDbkIsTUFBT2tqQixJQUFQLENBQ0QsQ0FDRCxHQUFJMFosU0FBUzU4QixLQUFULENBQUosQ0FBcUIsQ0FDbkIsR0FBSSsvQixPQUFRLE1BQU8vL0IsT0FBTXUyQixPQUFiLEVBQXdCLFVBQXhCLENBQXFDdjJCLE1BQU11MkIsT0FBTixFQUFyQyxDQUF1RHYyQixLQUFuRSxDQUNBQSxNQUFRNDhCLFNBQVNtRCxLQUFULEVBQW1CQSxNQUFRLEVBQTNCLENBQWlDQSxLQUF6QyxDQUNELENBQ0QsR0FBSSxNQUFPLy9CLE1BQVAsRUFBZ0IsUUFBcEIsQ0FBOEIsQ0FDNUIsTUFBT0EsU0FBVSxDQUFWLENBQWNBLEtBQWQsQ0FBc0IsQ0FBQ0EsS0FBOUIsQ0FDRCxDQUNEQSxNQUFRQSxNQUFNbUssT0FBTixDQUFja2MsTUFBZCxDQUFzQixFQUF0QixDQUFSLENBQ0EsR0FBSSsxQixVQUFXbjFCLFdBQVduUyxJQUFYLENBQWdCOVUsS0FBaEIsQ0FBZixDQUNBLE1BQVFvOEMsV0FBWWoxQixVQUFVclMsSUFBVixDQUFlOVUsS0FBZixDQUFiLENBQ0g2cUIsYUFBYTdxQixNQUFNa29DLEtBQU4sQ0FBWSxDQUFaLENBQWIsQ0FBNkJrVSxTQUFXLENBQVgsQ0FBZSxDQUE1QyxDQURHLENBRUZwMUIsV0FBV2xTLElBQVgsQ0FBZ0I5VSxLQUFoQixFQUF5QmtqQixHQUF6QixDQUErQixDQUFDbGpCLEtBRnJDLENBR0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F3QkEsUUFBU3NrQyxjQUFULENBQXVCdGtDLEtBQXZCLENBQThCLENBQzVCLE1BQU9nOEIsWUFBV2g4QixLQUFYLENBQWtCZ3dDLE9BQU9od0MsS0FBUCxDQUFsQixDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F3QkEsUUFBU3E4QyxjQUFULENBQXVCcjhDLEtBQXZCLENBQThCLENBQzVCLE1BQU9vOEIsV0FBVXFDLFVBQVV6K0IsS0FBVixDQUFWLENBQTRCLENBQUNnakIsZ0JBQTdCLENBQStDQSxnQkFBL0MsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcUJBLFFBQVM4TixTQUFULENBQWtCOXdCLEtBQWxCLENBQXlCLENBQ3ZCLE1BQU9BLFFBQVMsSUFBVCxDQUFnQixFQUFoQixDQUFxQittQyxhQUFhL21DLEtBQWIsQ0FBNUIsQ0FDRCxDQUVELDRFQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BZ0NBLEdBQUl1ZCxRQUFTcXRCLGVBQWUsU0FBUzFiLE1BQVQsQ0FBaUJ4SixNQUFqQixDQUF5QixDQUNuRCxHQUFJbVEsZ0JBQWtCdU4sWUFBWTFkLE1BQVosQ0FBbEIsRUFBeUNnZSxZQUFZaGUsTUFBWixDQUE3QyxDQUFrRSxDQUNoRXNXLFdBQVd0VyxNQUFYLENBQW1CbU4sS0FBS25OLE1BQUwsQ0FBbkIsQ0FBaUN3SixNQUFqQyxFQUNBLE9BQ0QsQ0FDRCxJQUFLLEdBQUludkIsSUFBVCxHQUFnQjJsQixPQUFoQixDQUF3QixDQUN0QixHQUFJc04sZUFBZWpZLElBQWYsQ0FBb0IySyxNQUFwQixDQUE0QjNsQixHQUE1QixDQUFKLENBQXNDLENBQ3BDNjdCLFlBQVkxTSxNQUFaLENBQW9CbnZCLEdBQXBCLENBQXlCMmxCLE9BQU8zbEIsR0FBUCxDQUF6QixFQUNELENBQ0YsQ0FDRixDQVZZLENBQWIsQ0FZQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BK0JBLEdBQUl1OEMsVUFBVzFSLGVBQWUsU0FBUzFiLE1BQVQsQ0FBaUJ4SixNQUFqQixDQUF5QixDQUNyRHNXLFdBQVd0VyxNQUFYLENBQW1Cc3FCLE9BQU90cUIsTUFBUCxDQUFuQixDQUFtQ3dKLE1BQW5DLEVBQ0QsQ0FGYyxDQUFmLENBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E2QkEsR0FBSXF0QixjQUFlM1IsZUFBZSxTQUFTMWIsTUFBVCxDQUFpQnhKLE1BQWpCLENBQXlCc2UsUUFBekIsQ0FBbUNySCxVQUFuQyxDQUErQyxDQUMvRVgsV0FBV3RXLE1BQVgsQ0FBbUJzcUIsT0FBT3RxQixNQUFQLENBQW5CLENBQW1Dd0osTUFBbkMsQ0FBMkN5TixVQUEzQyxFQUNELENBRmtCLENBQW5CLENBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTRCQSxHQUFJNmYsWUFBYTVSLGVBQWUsU0FBUzFiLE1BQVQsQ0FBaUJ4SixNQUFqQixDQUF5QnNlLFFBQXpCLENBQW1DckgsVUFBbkMsQ0FBK0MsQ0FDN0VYLFdBQVd0VyxNQUFYLENBQW1CbU4sS0FBS25OLE1BQUwsQ0FBbkIsQ0FBaUN3SixNQUFqQyxDQUF5Q3lOLFVBQXpDLEVBQ0QsQ0FGZ0IsQ0FBakIsQ0FJQTs7Ozs7Ozs7Ozs7Ozs7OztPQWlCQSxHQUFJOGYsSUFBS2xYLFNBQVMsU0FBU3JXLE1BQVQsQ0FBaUJnTixLQUFqQixDQUF3QixDQUN4QyxNQUFPRCxRQUFPL00sTUFBUCxDQUFlMFAsWUFBWTFDLEtBQVosQ0FBbUIsQ0FBbkIsQ0FBZixDQUFQLENBQ0QsQ0FGUSxDQUFULENBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWtDQSxRQUFTcDdCLE9BQVQsQ0FBZ0J5eEIsU0FBaEIsQ0FBMkJtcUIsVUFBM0IsQ0FBdUMsQ0FDckMsR0FBSWp2QixRQUFTNkosV0FBVy9FLFNBQVgsQ0FBYixDQUNBLE1BQU9tcUIsWUFBYTNnQixXQUFXdE8sTUFBWCxDQUFtQml2QixVQUFuQixDQUFiLENBQThDanZCLE1BQXJELENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FxQkEsR0FBSTBFLFVBQVdvVCxTQUFTLFNBQVMxWSxJQUFULENBQWUsQ0FDckNBLEtBQUsvakIsSUFBTCxDQUFVN0MsU0FBVixDQUFxQnMxQixnQkFBckIsRUFDQSxNQUFPMWEsT0FBTTA3QixZQUFOLENBQW9CdDJDLFNBQXBCLENBQStCNG1CLElBQS9CLENBQVAsQ0FDRCxDQUhjLENBQWYsQ0FLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BbUJBLEdBQUk4dkIsY0FBZXBYLFNBQVMsU0FBUzFZLElBQVQsQ0FBZSxDQUN6Q0EsS0FBSy9qQixJQUFMLENBQVU3QyxTQUFWLENBQXFCa3JDLGFBQXJCLEVBQ0EsTUFBT3R3QixPQUFNKzdCLFNBQU4sQ0FBaUIzMkMsU0FBakIsQ0FBNEI0bUIsSUFBNUIsQ0FBUCxDQUNELENBSGtCLENBQW5CLENBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FtQ0EsUUFBU2d3QixRQUFULENBQWlCM3RCLE1BQWpCLENBQXlCNUIsU0FBekIsQ0FBb0MsQ0FDbEMsTUFBT2tCLGFBQVlVLE1BQVosQ0FBb0J3VixZQUFZcFgsU0FBWixDQUF1QixDQUF2QixDQUFwQixDQUErQzRRLFVBQS9DLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BbUNBLFFBQVM0ZSxZQUFULENBQXFCNXRCLE1BQXJCLENBQTZCNUIsU0FBN0IsQ0FBd0MsQ0FDdEMsTUFBT2tCLGFBQVlVLE1BQVosQ0FBb0J3VixZQUFZcFgsU0FBWixDQUF1QixDQUF2QixDQUFwQixDQUErQzhRLGVBQS9DLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E0QkEsUUFBUzdyQixNQUFULENBQWUyYyxNQUFmLENBQXVCakMsUUFBdkIsQ0FBaUMsQ0FDL0IsTUFBT2lDLFNBQVUsSUFBVixDQUNIQSxNQURHLENBRUg4UCxRQUFROVAsTUFBUixDQUFnQndWLFlBQVl6WCxRQUFaLENBQXNCLENBQXRCLENBQWhCLENBQTBDK2lCLE1BQTFDLENBRkosQ0FHRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMEJBLFFBQVMrTSxXQUFULENBQW9CN3RCLE1BQXBCLENBQTRCakMsUUFBNUIsQ0FBc0MsQ0FDcEMsTUFBT2lDLFNBQVUsSUFBVixDQUNIQSxNQURHLENBRUhnUSxhQUFhaFEsTUFBYixDQUFxQndWLFlBQVl6WCxRQUFaLENBQXNCLENBQXRCLENBQXJCLENBQStDK2lCLE1BQS9DLENBRkosQ0FHRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E0QkEsUUFBU2dOLE9BQVQsQ0FBZ0I5dEIsTUFBaEIsQ0FBd0JqQyxRQUF4QixDQUFrQyxDQUNoQyxNQUFPaUMsU0FBVWdQLFdBQVdoUCxNQUFYLENBQW1Cd1YsWUFBWXpYLFFBQVosQ0FBc0IsQ0FBdEIsQ0FBbkIsQ0FBakIsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMEJBLFFBQVNnd0IsWUFBVCxDQUFxQi90QixNQUFyQixDQUE2QmpDLFFBQTdCLENBQXVDLENBQ3JDLE1BQU9pQyxTQUFVa1AsZ0JBQWdCbFAsTUFBaEIsQ0FBd0J3VixZQUFZelgsUUFBWixDQUFzQixDQUF0QixDQUF4QixDQUFqQixDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F1QkEsUUFBU2l3QixVQUFULENBQW1CaHVCLE1BQW5CLENBQTJCLENBQ3pCLE1BQU9BLFNBQVUsSUFBVixDQUFpQixFQUFqQixDQUFzQmlRLGNBQWNqUSxNQUFkLENBQXNCMkQsS0FBSzNELE1BQUwsQ0FBdEIsQ0FBN0IsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BdUJBLFFBQVNpdUIsWUFBVCxDQUFxQmp1QixNQUFyQixDQUE2QixDQUMzQixNQUFPQSxTQUFVLElBQVYsQ0FBaUIsRUFBakIsQ0FBc0JpUSxjQUFjalEsTUFBZCxDQUFzQjhnQixPQUFPOWdCLE1BQVAsQ0FBdEIsQ0FBN0IsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F5QkEsUUFBU3h2QixJQUFULENBQWF3dkIsTUFBYixDQUFxQm9RLElBQXJCLENBQTJCdU8sWUFBM0IsQ0FBeUMsQ0FDdkMsR0FBSXBnQixRQUFTeUIsUUFBVSxJQUFWLENBQWlCanBCLFNBQWpCLENBQTZCbzVCLFFBQVFuUSxNQUFSLENBQWdCb1EsSUFBaEIsQ0FBMUMsQ0FDQSxNQUFPN1IsVUFBV3huQixTQUFYLENBQXVCNG5DLFlBQXZCLENBQXNDcGdCLE1BQTdDLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0EyQkEsUUFBU3NDLElBQVQsQ0FBYWIsTUFBYixDQUFxQm9RLElBQXJCLENBQTJCLENBQ3pCLE1BQU9wUSxTQUFVLElBQVYsRUFBa0J1aEIsUUFBUXZoQixNQUFSLENBQWdCb1EsSUFBaEIsQ0FBc0JVLE9BQXRCLENBQXpCLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTBCQSxRQUFTOEQsTUFBVCxDQUFlNVUsTUFBZixDQUF1Qm9RLElBQXZCLENBQTZCLENBQzNCLE1BQU9wUSxTQUFVLElBQVYsRUFBa0J1aEIsUUFBUXZoQixNQUFSLENBQWdCb1EsSUFBaEIsQ0FBc0JXLFNBQXRCLENBQXpCLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FrQkEsR0FBSW1kLFFBQVMzUCxlQUFlLFNBQVNoZ0IsTUFBVCxDQUFpQnp0QixLQUFqQixDQUF3QkQsR0FBeEIsQ0FBNkIsQ0FDdkQwdEIsT0FBT3p0QixLQUFQLEVBQWdCRCxHQUFoQixDQUNELENBRlksQ0FFVjB4QyxTQUFTMU8sUUFBVCxDQUZVLENBQWIsQ0FJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTBCQSxHQUFJc2EsVUFBVzVQLGVBQWUsU0FBU2hnQixNQUFULENBQWlCenRCLEtBQWpCLENBQXdCRCxHQUF4QixDQUE2QixDQUN6RCxHQUFJaXpCLGVBQWVqWSxJQUFmLENBQW9CMFMsTUFBcEIsQ0FBNEJ6dEIsS0FBNUIsQ0FBSixDQUF3QyxDQUN0Q3l0QixPQUFPenRCLEtBQVAsRUFBYzhJLElBQWQsQ0FBbUIvSSxHQUFuQixFQUNELENBRkQsSUFFTyxDQUNMMHRCLE9BQU96dEIsS0FBUCxFQUFnQixDQUFDRCxHQUFELENBQWhCLENBQ0QsQ0FDRixDQU5jLENBTVoya0MsV0FOWSxDQUFmLENBUUE7Ozs7Ozs7Ozs7Ozs7Ozs7O09Ba0JBLEdBQUk0WSxRQUFTL1gsU0FBUzNFLFVBQVQsQ0FBYixDQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E0QkEsUUFBUy9OLEtBQVQsQ0FBYzNELE1BQWQsQ0FBc0IsQ0FDcEIsTUFBT3dVLGFBQVl4VSxNQUFaLEVBQXNCZ00sY0FBY2hNLE1BQWQsQ0FBdEIsQ0FBOENpVSxTQUFTalUsTUFBVCxDQUFyRCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F1QkEsUUFBUzhnQixPQUFULENBQWdCOWdCLE1BQWhCLENBQXdCLENBQ3RCLE1BQU93VSxhQUFZeFUsTUFBWixFQUFzQmdNLGNBQWNoTSxNQUFkLENBQXNCLElBQXRCLENBQXRCLENBQW9EbVUsV0FBV25VLE1BQVgsQ0FBM0QsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXFCQSxRQUFTcXVCLFFBQVQsQ0FBaUJydUIsTUFBakIsQ0FBeUJqQyxRQUF6QixDQUFtQyxDQUNqQyxHQUFJUSxRQUFTLEVBQWIsQ0FDQVIsU0FBV3lYLFlBQVl6WCxRQUFaLENBQXNCLENBQXRCLENBQVgsQ0FFQWlSLFdBQVdoUCxNQUFYLENBQW1CLFNBQVNsdkIsS0FBVCxDQUFnQkQsR0FBaEIsQ0FBcUJtdkIsTUFBckIsQ0FBNkIsQ0FDOUN6QixPQUFPUixTQUFTanRCLEtBQVQsQ0FBZ0JELEdBQWhCLENBQXFCbXZCLE1BQXJCLENBQVAsRUFBdUNsdkIsS0FBdkMsQ0FDRCxDQUZELEVBR0EsTUFBT3l0QixPQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BNEJBLFFBQVMrdkIsVUFBVCxDQUFtQnR1QixNQUFuQixDQUEyQmpDLFFBQTNCLENBQXFDLENBQ25DLEdBQUlRLFFBQVMsRUFBYixDQUNBUixTQUFXeVgsWUFBWXpYLFFBQVosQ0FBc0IsQ0FBdEIsQ0FBWCxDQUVBaVIsV0FBV2hQLE1BQVgsQ0FBbUIsU0FBU2x2QixLQUFULENBQWdCRCxHQUFoQixDQUFxQm12QixNQUFyQixDQUE2QixDQUM5Q3pCLE9BQU8xdEIsR0FBUCxFQUFja3RCLFNBQVNqdEIsS0FBVCxDQUFnQkQsR0FBaEIsQ0FBcUJtdkIsTUFBckIsQ0FBZCxDQUNELENBRkQsRUFHQSxNQUFPekIsT0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQStCQSxHQUFJZ3dCLE9BQVE3UyxlQUFlLFNBQVMxYixNQUFULENBQWlCeEosTUFBakIsQ0FBeUJzZSxRQUF6QixDQUFtQyxDQUM1REQsVUFBVTdVLE1BQVYsQ0FBa0J4SixNQUFsQixDQUEwQnNlLFFBQTFCLEVBQ0QsQ0FGVyxDQUFaLENBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQStCQSxHQUFJNFksV0FBWWhTLGVBQWUsU0FBUzFiLE1BQVQsQ0FBaUJ4SixNQUFqQixDQUF5QnNlLFFBQXpCLENBQW1DckgsVUFBbkMsQ0FBK0MsQ0FDNUVvSCxVQUFVN1UsTUFBVixDQUFrQnhKLE1BQWxCLENBQTBCc2UsUUFBMUIsQ0FBb0NySCxVQUFwQyxFQUNELENBRmUsQ0FBaEIsQ0FJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BbUJBLEdBQUkrZ0IsTUFBT25ZLFNBQVMsU0FBU3JXLE1BQVQsQ0FBaUJRLEtBQWpCLENBQXdCLENBQzFDLEdBQUlSLFFBQVUsSUFBZCxDQUFvQixDQUNsQixNQUFPLEVBQVAsQ0FDRCxDQUNEUSxNQUFRNUIsU0FBUzhRLFlBQVlsUCxLQUFaLENBQW1CLENBQW5CLENBQVQsQ0FBZ0MrUCxLQUFoQyxDQUFSLENBQ0EsTUFBT29GLFVBQVMzVixNQUFULENBQWlCME8sZUFBZW1TLGFBQWE3Z0IsTUFBYixDQUFmLENBQXFDUSxLQUFyQyxDQUFqQixDQUFQLENBQ0QsQ0FOVSxDQUFYLENBUUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FvQkEsUUFBU2l1QixPQUFULENBQWdCenVCLE1BQWhCLENBQXdCNUIsU0FBeEIsQ0FBbUMsQ0FDakMsTUFBT3N3QixRQUFPMXVCLE1BQVAsQ0FBZWtvQixPQUFPMVMsWUFBWXBYLFNBQVosQ0FBUCxDQUFmLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7O09BaUJBLEdBQUk4RSxNQUFPbVQsU0FBUyxTQUFTclcsTUFBVCxDQUFpQlEsS0FBakIsQ0FBd0IsQ0FDMUMsTUFBT1IsU0FBVSxJQUFWLENBQWlCLEVBQWpCLENBQXNCMlYsU0FBUzNWLE1BQVQsQ0FBaUJwQixTQUFTOFEsWUFBWWxQLEtBQVosQ0FBbUIsQ0FBbkIsQ0FBVCxDQUFnQytQLEtBQWhDLENBQWpCLENBQTdCLENBQ0QsQ0FGVSxDQUFYLENBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7O09Ba0JBLFFBQVNtZSxPQUFULENBQWdCMXVCLE1BQWhCLENBQXdCNUIsU0FBeEIsQ0FBbUMsQ0FDakMsTUFBTzRCLFNBQVUsSUFBVixDQUFpQixFQUFqQixDQUFzQjRWLFdBQVc1VixNQUFYLENBQW1CNmdCLGFBQWE3Z0IsTUFBYixDQUFuQixDQUF5Q3dWLFlBQVlwWCxTQUFaLENBQXpDLENBQTdCLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTZCQSxRQUFTRyxPQUFULENBQWdCeUIsTUFBaEIsQ0FBd0JvUSxJQUF4QixDQUE4QnVPLFlBQTlCLENBQTRDLENBQzFDdk8sS0FBT0MsTUFBTUQsSUFBTixDQUFZcFEsTUFBWixFQUFzQixDQUFDb1EsSUFBRCxDQUF0QixDQUErQkUsU0FBU0YsSUFBVCxDQUF0QyxDQUVBLEdBQUkxdUIsT0FBUSxDQUFDLENBQWIsQ0FDSXZMLE9BQVNpNkIsS0FBS2o2QixNQURsQixDQUdBO0FBQ0EsR0FBSSxDQUFDQSxNQUFMLENBQWEsQ0FDWDZwQixPQUFTanBCLFNBQVQsQ0FDQVosT0FBUyxDQUFULENBQ0QsQ0FDRCxNQUFPLEVBQUV1TCxLQUFGLENBQVV2TCxNQUFqQixDQUF5QixDQUN2QixHQUFJckYsT0FBUWt2QixRQUFVLElBQVYsQ0FBaUJqcEIsU0FBakIsQ0FBNkJpcEIsT0FBT3VRLE1BQU1ILEtBQUsxdUIsS0FBTCxDQUFOLENBQVAsQ0FBekMsQ0FDQSxHQUFJNVEsUUFBVWlHLFNBQWQsQ0FBeUIsQ0FDdkIySyxNQUFRdkwsTUFBUixDQUNBckYsTUFBUTZ0QyxZQUFSLENBQ0QsQ0FDRDNlLE9BQVNrUSxXQUFXcC9CLEtBQVgsRUFBb0JBLE1BQU0rYSxJQUFOLENBQVdtVSxNQUFYLENBQXBCLENBQXlDbHZCLEtBQWxELENBQ0QsQ0FDRCxNQUFPa3ZCLE9BQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E0QkEsUUFBU3B2QixJQUFULENBQWFvdkIsTUFBYixDQUFxQm9RLElBQXJCLENBQTJCdC9CLEtBQTNCLENBQWtDLENBQ2hDLE1BQU9rdkIsU0FBVSxJQUFWLENBQWlCQSxNQUFqQixDQUEwQndXLFFBQVF4VyxNQUFSLENBQWdCb1EsSUFBaEIsQ0FBc0J0L0IsS0FBdEIsQ0FBakMsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXdCQSxRQUFTNjlDLFFBQVQsQ0FBaUIzdUIsTUFBakIsQ0FBeUJvUSxJQUF6QixDQUErQnQvQixLQUEvQixDQUFzQzI4QixVQUF0QyxDQUFrRCxDQUNoREEsV0FBYSxNQUFPQSxXQUFQLEVBQXFCLFVBQXJCLENBQWtDQSxVQUFsQyxDQUErQzEyQixTQUE1RCxDQUNBLE1BQU9pcEIsU0FBVSxJQUFWLENBQWlCQSxNQUFqQixDQUEwQndXLFFBQVF4VyxNQUFSLENBQWdCb1EsSUFBaEIsQ0FBc0J0L0IsS0FBdEIsQ0FBNkIyOEIsVUFBN0IsQ0FBakMsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXdCQSxHQUFJbWhCLFNBQVU3TyxjQUFjcGMsSUFBZCxDQUFkLENBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bd0JBLEdBQUlrckIsV0FBWTlPLGNBQWNlLE1BQWQsQ0FBaEIsQ0FFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E4QkEsUUFBUzNlLFVBQVQsQ0FBbUJuQyxNQUFuQixDQUEyQmpDLFFBQTNCLENBQXFDQyxXQUFyQyxDQUFrRCxDQUNoRCxHQUFJZ0wsT0FBUXBaLFFBQVFvUSxNQUFSLEdBQW1CNUMsYUFBYTRDLE1BQWIsQ0FBL0IsQ0FDQWpDLFNBQVd5WCxZQUFZelgsUUFBWixDQUFzQixDQUF0QixDQUFYLENBRUEsR0FBSUMsYUFBZSxJQUFuQixDQUF5QixDQUN2QixHQUFJZ0wsT0FBUzBFLFNBQVMxTixNQUFULENBQWIsQ0FBK0IsQ0FDN0IsR0FBSWtjLE1BQU9sYyxPQUFPdnVCLFdBQWxCLENBQ0EsR0FBSXUzQixLQUFKLENBQVcsQ0FDVGhMLFlBQWNwTyxRQUFRb1EsTUFBUixFQUFrQixHQUFJa2MsS0FBSixFQUFsQixDQUE2QixFQUEzQyxDQUNELENBRkQsSUFFTyxDQUNMbGUsWUFBY2tTLFdBQVdnTSxJQUFYLEVBQW1COVQsV0FBVzdELGFBQWF2RSxNQUFiLENBQVgsQ0FBbkIsQ0FBc0QsRUFBcEUsQ0FDRCxDQUNGLENBUEQsSUFPTyxDQUNMaEMsWUFBYyxFQUFkLENBQ0QsQ0FDRixDQUNELENBQUNnTCxNQUFRL0ssU0FBUixDQUFvQitRLFVBQXJCLEVBQWlDaFAsTUFBakMsQ0FBeUMsU0FBU2x2QixLQUFULENBQWdCNFEsS0FBaEIsQ0FBdUJzZSxNQUF2QixDQUErQixDQUN0RSxNQUFPakMsVUFBU0MsV0FBVCxDQUFzQmx0QixLQUF0QixDQUE2QjRRLEtBQTdCLENBQW9Dc2UsTUFBcEMsQ0FBUCxDQUNELENBRkQsRUFHQSxNQUFPaEMsWUFBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMkJBLFFBQVM4d0IsTUFBVCxDQUFlOXVCLE1BQWYsQ0FBdUJvUSxJQUF2QixDQUE2QixDQUMzQixNQUFPcFEsU0FBVSxJQUFWLENBQWlCLElBQWpCLENBQXdCaVksVUFBVWpZLE1BQVYsQ0FBa0JvUSxJQUFsQixDQUEvQixDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMkJBLFFBQVMyZSxPQUFULENBQWdCL3VCLE1BQWhCLENBQXdCb1EsSUFBeEIsQ0FBOEIrSCxPQUE5QixDQUF1QyxDQUNyQyxNQUFPblksU0FBVSxJQUFWLENBQWlCQSxNQUFqQixDQUEwQmtZLFdBQVdsWSxNQUFYLENBQW1Cb1EsSUFBbkIsQ0FBeUJ3SSxhQUFhVCxPQUFiLENBQXpCLENBQWpDLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F3QkEsUUFBUzZXLFdBQVQsQ0FBb0JodkIsTUFBcEIsQ0FBNEJvUSxJQUE1QixDQUFrQytILE9BQWxDLENBQTJDMUssVUFBM0MsQ0FBdUQsQ0FDckRBLFdBQWEsTUFBT0EsV0FBUCxFQUFxQixVQUFyQixDQUFrQ0EsVUFBbEMsQ0FBK0MxMkIsU0FBNUQsQ0FDQSxNQUFPaXBCLFNBQVUsSUFBVixDQUFpQkEsTUFBakIsQ0FBMEJrWSxXQUFXbFksTUFBWCxDQUFtQm9RLElBQW5CLENBQXlCd0ksYUFBYVQsT0FBYixDQUF6QixDQUFnRDFLLFVBQWhELENBQWpDLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTBCQSxRQUFTOWhCLE9BQVQsQ0FBZ0JxVSxNQUFoQixDQUF3QixDQUN0QixNQUFPQSxRQUFTVSxXQUFXVixNQUFYLENBQW1CMkQsS0FBSzNELE1BQUwsQ0FBbkIsQ0FBVCxDQUE0QyxFQUFuRCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bd0JBLFFBQVNpdkIsU0FBVCxDQUFrQmp2QixNQUFsQixDQUEwQixDQUN4QixNQUFPQSxTQUFVLElBQVYsQ0FBaUIsRUFBakIsQ0FBc0JVLFdBQVdWLE1BQVgsQ0FBbUI4Z0IsT0FBTzlnQixNQUFQLENBQW5CLENBQTdCLENBQ0QsQ0FFRCw0RUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BbUJBLFFBQVNrdkIsTUFBVCxDQUFlL2hCLE1BQWYsQ0FBdUJDLEtBQXZCLENBQThCQyxLQUE5QixDQUFxQyxDQUNuQyxHQUFJQSxRQUFVdDJCLFNBQWQsQ0FBeUIsQ0FDdkJzMkIsTUFBUUQsS0FBUixDQUNBQSxNQUFRcjJCLFNBQVIsQ0FDRCxDQUNELEdBQUlzMkIsUUFBVXQyQixTQUFkLENBQXlCLENBQ3ZCczJCLE1BQVFnUyxTQUFTaFMsS0FBVCxDQUFSLENBQ0FBLE1BQVFBLFFBQVVBLEtBQVYsQ0FBa0JBLEtBQWxCLENBQTBCLENBQWxDLENBQ0QsQ0FDRCxHQUFJRCxRQUFVcjJCLFNBQWQsQ0FBeUIsQ0FDdkJxMkIsTUFBUWlTLFNBQVNqUyxLQUFULENBQVIsQ0FDQUEsTUFBUUEsUUFBVUEsS0FBVixDQUFrQkEsS0FBbEIsQ0FBMEIsQ0FBbEMsQ0FDRCxDQUNELE1BQU9GLFdBQVVtUyxTQUFTbFMsTUFBVCxDQUFWLENBQTRCQyxLQUE1QixDQUFtQ0MsS0FBbkMsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FzQ0EsUUFBUzhoQixRQUFULENBQWlCaGlCLE1BQWpCLENBQXlCOUQsS0FBekIsQ0FBZ0NDLEdBQWhDLENBQXFDLENBQ25DRCxNQUFROFYsU0FBUzlWLEtBQVQsQ0FBUixDQUNBLEdBQUlDLE1BQVF2eUIsU0FBWixDQUF1QixDQUNyQnV5QixJQUFNRCxLQUFOLENBQ0FBLE1BQVEsQ0FBUixDQUNELENBSEQsSUFHTyxDQUNMQyxJQUFNNlYsU0FBUzdWLEdBQVQsQ0FBTixDQUNELENBQ0Q2RCxPQUFTa1MsU0FBU2xTLE1BQVQsQ0FBVCxDQUNBLE1BQU82RCxhQUFZN0QsTUFBWixDQUFvQjlELEtBQXBCLENBQTJCQyxHQUEzQixDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BK0JBLFFBQVNsMUIsT0FBVCxDQUFnQmc1QixLQUFoQixDQUF1QkMsS0FBdkIsQ0FBOEIraEIsUUFBOUIsQ0FBd0MsQ0FDdEMsR0FBSUEsVUFBWSxNQUFPQSxTQUFQLEVBQW1CLFNBQS9CLEVBQTRDdFQsZUFBZTFPLEtBQWYsQ0FBc0JDLEtBQXRCLENBQTZCK2hCLFFBQTdCLENBQWhELENBQXdGLENBQ3RGL2hCLE1BQVEraEIsU0FBV3I0QyxTQUFuQixDQUNELENBQ0QsR0FBSXE0QyxXQUFhcjRDLFNBQWpCLENBQTRCLENBQzFCLEdBQUksTUFBT3MyQixNQUFQLEVBQWdCLFNBQXBCLENBQStCLENBQzdCK2hCLFNBQVcvaEIsS0FBWCxDQUNBQSxNQUFRdDJCLFNBQVIsQ0FDRCxDQUhELElBSUssSUFBSSxNQUFPcTJCLE1BQVAsRUFBZ0IsU0FBcEIsQ0FBK0IsQ0FDbENnaUIsU0FBV2hpQixLQUFYLENBQ0FBLE1BQVFyMkIsU0FBUixDQUNELENBQ0YsQ0FDRCxHQUFJcTJCLFFBQVVyMkIsU0FBVixFQUF1QnMyQixRQUFVdDJCLFNBQXJDLENBQWdELENBQzlDcTJCLE1BQVEsQ0FBUixDQUNBQyxNQUFRLENBQVIsQ0FDRCxDQUhELElBSUssQ0FDSEQsTUFBUStSLFNBQVMvUixLQUFULENBQVIsQ0FDQSxHQUFJQyxRQUFVdDJCLFNBQWQsQ0FBeUIsQ0FDdkJzMkIsTUFBUUQsS0FBUixDQUNBQSxNQUFRLENBQVIsQ0FDRCxDQUhELElBR08sQ0FDTEMsTUFBUThSLFNBQVM5UixLQUFULENBQVIsQ0FDRCxDQUNGLENBQ0QsR0FBSUQsTUFBUUMsS0FBWixDQUFtQixDQUNqQixHQUFJZ2lCLE1BQU9qaUIsS0FBWCxDQUNBQSxNQUFRQyxLQUFSLENBQ0FBLE1BQVFnaUIsSUFBUixDQUNELENBQ0QsR0FBSUQsVUFBWWhpQixNQUFRLENBQXBCLEVBQXlCQyxNQUFRLENBQXJDLENBQXdDLENBQ3RDLEdBQUlnYixNQUFPcGlCLGNBQVgsQ0FDQSxNQUFPSCxXQUFVc0gsTUFBU2liLE1BQVFoYixNQUFRRCxLQUFSLENBQWdCM1IsZUFBZSxPQUFTLENBQUM0c0IsS0FBTyxFQUFSLEVBQVlseUMsTUFBWixDQUFxQixDQUE5QixDQUFmLENBQXhCLENBQW5CLENBQStGazNCLEtBQS9GLENBQVAsQ0FDRCxDQUNELE1BQU82SSxZQUFXOUksS0FBWCxDQUFrQkMsS0FBbEIsQ0FBUCxDQUNELENBRUQsNEVBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FvQkEsR0FBSWlpQixXQUFZN1MsaUJBQWlCLFNBQVNsZSxNQUFULENBQWlCcFYsSUFBakIsQ0FBdUJ6SCxLQUF2QixDQUE4QixDQUM3RHlILEtBQU9BLEtBQUtGLFdBQUwsRUFBUCxDQUNBLE1BQU9zVixTQUFVN2MsTUFBUTZ0QyxXQUFXcG1DLElBQVgsQ0FBUixDQUEyQkEsSUFBckMsQ0FBUCxDQUNELENBSGUsQ0FBaEIsQ0FLQTs7Ozs7Ozs7Ozs7Ozs7T0FlQSxRQUFTb21DLFdBQVQsQ0FBb0Jod0MsTUFBcEIsQ0FBNEIsQ0FDMUIsTUFBT2l3QyxZQUFXNXRCLFNBQVNyaUIsTUFBVCxFQUFpQjBKLFdBQWpCLEVBQVgsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7O09Ba0JBLFFBQVMwekIsT0FBVCxDQUFnQnA5QixNQUFoQixDQUF3QixDQUN0QkEsT0FBU3FpQixTQUFTcmlCLE1BQVQsQ0FBVCxDQUNBLE1BQU9BLFNBQVVBLE9BQU90RSxPQUFQLENBQWVrZCxPQUFmLENBQXdCaUosWUFBeEIsRUFBc0NubUIsT0FBdEMsQ0FBOEMyZixXQUE5QyxDQUEyRCxFQUEzRCxDQUFqQixDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F1QkEsUUFBUzYwQixTQUFULENBQWtCbHdDLE1BQWxCLENBQTBCbXdDLE1BQTFCLENBQWtDQyxRQUFsQyxDQUE0QyxDQUMxQ3B3QyxPQUFTcWlCLFNBQVNyaUIsTUFBVCxDQUFULENBQ0Ftd0MsT0FBUzdYLGFBQWE2WCxNQUFiLENBQVQsQ0FFQSxHQUFJdjVDLFFBQVNvSixPQUFPcEosTUFBcEIsQ0FDQXc1QyxTQUFXQSxXQUFhNTRDLFNBQWIsQ0FDUFosTUFETyxDQUVQKzJCLFVBQVVxQyxVQUFVb2dCLFFBQVYsQ0FBVixDQUErQixDQUEvQixDQUFrQ3g1QyxNQUFsQyxDQUZKLENBSUEsR0FBSW16QixLQUFNcW1CLFFBQVYsQ0FDQUEsVUFBWUQsT0FBT3Y1QyxNQUFuQixDQUNBLE1BQU93NUMsV0FBWSxDQUFaLEVBQWlCcHdDLE9BQU95NUIsS0FBUCxDQUFhMlcsUUFBYixDQUF1QnJtQixHQUF2QixHQUErQm9tQixNQUF2RCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWtDQSxRQUFTRSxPQUFULENBQWdCcndDLE1BQWhCLENBQXdCLENBQ3RCQSxPQUFTcWlCLFNBQVNyaUIsTUFBVCxDQUFULENBQ0EsTUFBUUEsU0FBVWtYLG1CQUFtQjdRLElBQW5CLENBQXdCckcsTUFBeEIsQ0FBWCxDQUNIQSxPQUFPdEUsT0FBUCxDQUFlb2IsZUFBZixDQUFnQ2dMLGNBQWhDLENBREcsQ0FFSDloQixNQUZKLENBR0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7T0FlQSxRQUFTc3dDLGFBQVQsQ0FBc0J0d0MsTUFBdEIsQ0FBOEIsQ0FDNUJBLE9BQVNxaUIsU0FBU3JpQixNQUFULENBQVQsQ0FDQSxNQUFRQSxTQUFVMlgsZ0JBQWdCdFIsSUFBaEIsQ0FBcUJyRyxNQUFyQixDQUFYLENBQ0hBLE9BQU90RSxPQUFQLENBQWVnYyxZQUFmLENBQTZCLE1BQTdCLENBREcsQ0FFSDFYLE1BRkosQ0FHRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXFCQSxHQUFJdXdDLFdBQVlyVCxpQkFBaUIsU0FBU2xlLE1BQVQsQ0FBaUJwVixJQUFqQixDQUF1QnpILEtBQXZCLENBQThCLENBQzdELE1BQU82YyxTQUFVN2MsTUFBUSxHQUFSLENBQWMsRUFBeEIsRUFBOEJ5SCxLQUFLRixXQUFMLEVBQXJDLENBQ0QsQ0FGZSxDQUFoQixDQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bb0JBLEdBQUk4bUMsV0FBWXRULGlCQUFpQixTQUFTbGUsTUFBVCxDQUFpQnBWLElBQWpCLENBQXVCekgsS0FBdkIsQ0FBOEIsQ0FDN0QsTUFBTzZjLFNBQVU3YyxNQUFRLEdBQVIsQ0FBYyxFQUF4QixFQUE4QnlILEtBQUtGLFdBQUwsRUFBckMsQ0FDRCxDQUZlLENBQWhCLENBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7T0FpQkEsR0FBSSttQyxZQUFhM1QsZ0JBQWdCLGFBQWhCLENBQWpCLENBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F1QkEsUUFBUzRULElBQVQsQ0FBYTF3QyxNQUFiLENBQXFCcEosTUFBckIsQ0FBNkI0b0MsS0FBN0IsQ0FBb0MsQ0FDbEN4L0IsT0FBU3FpQixTQUFTcmlCLE1BQVQsQ0FBVCxDQUNBcEosT0FBU281QixVQUFVcDVCLE1BQVYsQ0FBVCxDQUVBLEdBQUkrNUMsV0FBWS81QyxPQUFTcXNCLFdBQVdqakIsTUFBWCxDQUFULENBQThCLENBQTlDLENBQ0EsR0FBSSxDQUFDcEosTUFBRCxFQUFXKzVDLFdBQWEvNUMsTUFBNUIsQ0FBb0MsQ0FDbEMsTUFBT29KLE9BQVAsQ0FDRCxDQUNELEdBQUl4RixLQUFNLENBQUM1RCxPQUFTKzVDLFNBQVYsRUFBdUIsQ0FBakMsQ0FDQSxNQUNFcFIsZUFBYzNaLFlBQVlwckIsR0FBWixDQUFkLENBQWdDZ2xDLEtBQWhDLEVBQ0F4L0IsTUFEQSxDQUVBdS9CLGNBQWM3WixXQUFXbHJCLEdBQVgsQ0FBZCxDQUErQmdsQyxLQUEvQixDQUhGLENBS0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXVCQSxRQUFTb1IsT0FBVCxDQUFnQjV3QyxNQUFoQixDQUF3QnBKLE1BQXhCLENBQWdDNG9DLEtBQWhDLENBQXVDLENBQ3JDeC9CLE9BQVNxaUIsU0FBU3JpQixNQUFULENBQVQsQ0FDQXBKLE9BQVNvNUIsVUFBVXA1QixNQUFWLENBQVQsQ0FFQSxHQUFJKzVDLFdBQVkvNUMsT0FBU3FzQixXQUFXampCLE1BQVgsQ0FBVCxDQUE4QixDQUE5QyxDQUNBLE1BQVFwSixTQUFVKzVDLFVBQVkvNUMsTUFBdkIsQ0FDRm9KLE9BQVN1L0IsY0FBYzNvQyxPQUFTKzVDLFNBQXZCLENBQWtDblIsS0FBbEMsQ0FEUCxDQUVIeC9CLE1BRkosQ0FHRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BdUJBLFFBQVM2d0MsU0FBVCxDQUFrQjd3QyxNQUFsQixDQUEwQnBKLE1BQTFCLENBQWtDNG9DLEtBQWxDLENBQXlDLENBQ3ZDeC9CLE9BQVNxaUIsU0FBU3JpQixNQUFULENBQVQsQ0FDQXBKLE9BQVNvNUIsVUFBVXA1QixNQUFWLENBQVQsQ0FFQSxHQUFJKzVDLFdBQVkvNUMsT0FBU3FzQixXQUFXampCLE1BQVgsQ0FBVCxDQUE4QixDQUE5QyxDQUNBLE1BQVFwSixTQUFVKzVDLFVBQVkvNUMsTUFBdkIsQ0FDRjJvQyxjQUFjM29DLE9BQVMrNUMsU0FBdkIsQ0FBa0NuUixLQUFsQyxFQUEyQ3gvQixNQUR6QyxDQUVIQSxNQUZKLENBR0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F3QkEsUUFBU25FLFNBQVQsQ0FBa0JtRSxNQUFsQixDQUEwQjh3QyxLQUExQixDQUFpQ3hVLEtBQWpDLENBQXdDLENBQ3RDO0FBQ0E7QUFDQSxHQUFJQSxPQUFTd1UsT0FBUyxJQUF0QixDQUE0QixDQUMxQkEsTUFBUSxDQUFSLENBQ0QsQ0FGRCxJQUVPLElBQUlBLEtBQUosQ0FBVyxDQUNoQkEsTUFBUSxDQUFDQSxLQUFULENBQ0QsQ0FDRDl3QyxPQUFTcWlCLFNBQVNyaUIsTUFBVCxFQUFpQnRFLE9BQWpCLENBQXlCa2MsTUFBekIsQ0FBaUMsRUFBakMsQ0FBVCxDQUNBLE1BQU82TyxnQkFBZXptQixNQUFmLENBQXVCOHdDLFFBQVV4NEIsZUFBZWpTLElBQWYsQ0FBb0JyRyxNQUFwQixFQUE4QixFQUE5QixDQUFtQyxFQUE3QyxDQUF2QixDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bc0JBLFFBQVMrd0MsT0FBVCxDQUFnQi93QyxNQUFoQixDQUF3QitnQixDQUF4QixDQUEyQnViLEtBQTNCLENBQWtDLENBQ2hDLEdBQUtBLE1BQVFDLGVBQWV2OEIsTUFBZixDQUF1QitnQixDQUF2QixDQUEwQnViLEtBQTFCLENBQVIsQ0FBMkN2YixJQUFNdnBCLFNBQXRELENBQWtFLENBQ2hFdXBCLEVBQUksQ0FBSixDQUNELENBRkQsSUFFTyxDQUNMQSxFQUFJaVAsVUFBVWpQLENBQVYsQ0FBSixDQUNELENBQ0QsTUFBTzhWLFlBQVd4VSxTQUFTcmlCLE1BQVQsQ0FBWCxDQUE2QitnQixDQUE3QixDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BbUJBLFFBQVNybEIsUUFBVCxFQUFtQixDQUNqQixHQUFJMGlCLE1BQU8yWSxTQUFYLENBQ0kvMkIsT0FBU3FpQixTQUFTakUsS0FBSyxDQUFMLENBQVQsQ0FEYixDQUdBLE1BQU9BLE1BQUt4bkIsTUFBTCxDQUFjLENBQWQsQ0FBa0JvSixNQUFsQixDQUEyQkEsT0FBT3RFLE9BQVAsQ0FBZTBpQixLQUFLLENBQUwsQ0FBZixDQUF3QkEsS0FBSyxDQUFMLENBQXhCLENBQWxDLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FxQkEsR0FBSTR5QixXQUFZOVQsaUJBQWlCLFNBQVNsZSxNQUFULENBQWlCcFYsSUFBakIsQ0FBdUJ6SCxLQUF2QixDQUE4QixDQUM3RCxNQUFPNmMsU0FBVTdjLE1BQVEsR0FBUixDQUFjLEVBQXhCLEVBQThCeUgsS0FBS0YsV0FBTCxFQUFyQyxDQUNELENBRmUsQ0FBaEIsQ0FJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BbUJBLFFBQVM3WixNQUFULENBQWVtUSxNQUFmLENBQXVCdWtDLFNBQXZCLENBQWtDbDNCLEtBQWxDLENBQXlDLENBQ3ZDLEdBQUlBLE9BQVMsTUFBT0EsTUFBUCxFQUFnQixRQUF6QixFQUFxQ2t2QixlQUFldjhCLE1BQWYsQ0FBdUJ1a0MsU0FBdkIsQ0FBa0NsM0IsS0FBbEMsQ0FBekMsQ0FBbUYsQ0FDakZrM0IsVUFBWWwzQixNQUFRN1YsU0FBcEIsQ0FDRCxDQUNENlYsTUFBUUEsUUFBVTdWLFNBQVYsQ0FBc0JrZCxnQkFBdEIsQ0FBeUNySCxRQUFVLENBQTNELENBQ0EsR0FBSSxDQUFDQSxLQUFMLENBQVksQ0FDVixNQUFPLEVBQVAsQ0FDRCxDQUNEck4sT0FBU3FpQixTQUFTcmlCLE1BQVQsQ0FBVCxDQUNBLEdBQUlBLFNBQ0UsTUFBT3VrQyxVQUFQLEVBQW9CLFFBQXBCLEVBQ0NBLFdBQWEsSUFBYixFQUFxQixDQUFDOW1CLFNBQVM4bUIsU0FBVCxDQUZ6QixDQUFKLENBR08sQ0FDTEEsVUFBWWpNLGFBQWFpTSxTQUFiLENBQVosQ0FDQSxHQUFJLENBQUNBLFNBQUQsRUFBY3JpQixXQUFXbGlCLE1BQVgsQ0FBbEIsQ0FBc0MsQ0FDcEMsTUFBT3U1QixXQUFVcFcsY0FBY25qQixNQUFkLENBQVYsQ0FBaUMsQ0FBakMsQ0FBb0NxTixLQUFwQyxDQUFQLENBQ0QsQ0FDRixDQUNELE1BQU9yTixRQUFPblEsS0FBUCxDQUFhMDBDLFNBQWIsQ0FBd0JsM0IsS0FBeEIsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcUJBLEdBQUk0akMsV0FBWS9ULGlCQUFpQixTQUFTbGUsTUFBVCxDQUFpQnBWLElBQWpCLENBQXVCekgsS0FBdkIsQ0FBOEIsQ0FDN0QsTUFBTzZjLFNBQVU3YyxNQUFRLEdBQVIsQ0FBYyxFQUF4QixFQUE4Qjh0QyxXQUFXcm1DLElBQVgsQ0FBckMsQ0FDRCxDQUZlLENBQWhCLENBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F1QkEsUUFBU3NuQyxXQUFULENBQW9CbHhDLE1BQXBCLENBQTRCbXdDLE1BQTVCLENBQW9DQyxRQUFwQyxDQUE4QyxDQUM1Q3B3QyxPQUFTcWlCLFNBQVNyaUIsTUFBVCxDQUFULENBQ0Fvd0MsU0FBV3ppQixVQUFVcUMsVUFBVW9nQixRQUFWLENBQVYsQ0FBK0IsQ0FBL0IsQ0FBa0Nwd0MsT0FBT3BKLE1BQXpDLENBQVgsQ0FDQXU1QyxPQUFTN1gsYUFBYTZYLE1BQWIsQ0FBVCxDQUNBLE1BQU9ud0MsUUFBT3k1QixLQUFQLENBQWEyVyxRQUFiLENBQXVCQSxTQUFXRCxPQUFPdjVDLE1BQXpDLEdBQW9EdTVDLE1BQTNELENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BdUdBLFFBQVNnQixTQUFULENBQWtCbnhDLE1BQWxCLENBQTBCd3BDLE9BQTFCLENBQW1DbE4sS0FBbkMsQ0FBMEMsQ0FDeEM7QUFDQTtBQUNBO0FBQ0EsR0FBSXY0QixVQUFXaWtCLE9BQU9ZLGdCQUF0QixDQUVBLEdBQUkwVCxPQUFTQyxlQUFldjhCLE1BQWYsQ0FBdUJ3cEMsT0FBdkIsQ0FBZ0NsTixLQUFoQyxDQUFiLENBQXFELENBQ25Ea04sUUFBVWh5QyxTQUFWLENBQ0QsQ0FDRHdJLE9BQVNxaUIsU0FBU3JpQixNQUFULENBQVQsQ0FDQXdwQyxRQUFVc0UsYUFBYSxFQUFiLENBQWlCdEUsT0FBakIsQ0FBMEJ6bEMsUUFBMUIsQ0FBb0Mrb0IsZ0JBQXBDLENBQVYsQ0FFQSxHQUFJc2tCLFNBQVV0RCxhQUFhLEVBQWIsQ0FBaUJ0RSxRQUFRNEgsT0FBekIsQ0FBa0NydEMsU0FBU3F0QyxPQUEzQyxDQUFvRHRrQixnQkFBcEQsQ0FBZCxDQUNJdWtCLFlBQWNqdEIsS0FBS2d0QixPQUFMLENBRGxCLENBRUlFLGNBQWdCbndCLFdBQVdpd0IsT0FBWCxDQUFvQkMsV0FBcEIsQ0FGcEIsQ0FJQSxHQUFJRSxXQUFKLENBQ0lDLFlBREosQ0FFSXJ2QyxNQUFRLENBRlosQ0FHSXN2QyxZQUFjakksUUFBUWlJLFdBQVIsRUFBdUI1NEIsU0FIekMsQ0FJSTVCLE9BQVMsVUFKYixDQU1BO0FBQ0EsR0FBSXk2QixjQUFlMTZCLE9BQ2pCLENBQUN3eUIsUUFBUTZHLE1BQVIsRUFBa0J4M0IsU0FBbkIsRUFBOEI1QixNQUE5QixDQUF1QyxHQUF2QyxDQUNBdzZCLFlBQVl4NkIsTUFEWixDQUNxQixHQURyQixDQUVBLENBQUN3NkIsY0FBZ0JwNkIsYUFBaEIsQ0FBZ0NlLFlBQWhDLENBQStDUyxTQUFoRCxFQUEyRDVCLE1BRjNELENBRW9FLEdBRnBFLENBR0EsQ0FBQ3V5QixRQUFRbUksUUFBUixFQUFvQjk0QixTQUFyQixFQUFnQzVCLE1BSGhDLENBR3lDLElBSnhCLENBS2pCLEdBTGlCLENBQW5CLENBT0E7QUFDQSxHQUFJMjZCLFdBQVksa0JBQ2IsYUFBZXBJLFFBQWYsQ0FDR0EsUUFBUW9JLFNBRFgsQ0FFSSwwQkFBNkIsR0FBRWoyQixlQUEvQixDQUFrRCxHQUh6QyxFQUlWLElBSk4sQ0FNQTNiLE9BQU90RSxPQUFQLENBQWVnMkMsWUFBZixDQUE2QixTQUFTdjNDLEtBQVQsQ0FBZ0IwM0MsV0FBaEIsQ0FBNkJDLGdCQUE3QixDQUErQ0MsZUFBL0MsQ0FBZ0VDLGFBQWhFLENBQStFaHhDLE1BQS9FLENBQXVGLENBQ2xIOHdDLG1CQUFxQkEsaUJBQW1CQyxlQUF4QyxFQUVBO0FBQ0E5NkIsUUFBVWpYLE9BQU95NUIsS0FBUCxDQUFhdDNCLEtBQWIsQ0FBb0JuQixNQUFwQixFQUE0QnRGLE9BQTVCLENBQW9Db2QsaUJBQXBDLENBQXVEaUosZ0JBQXZELENBQVYsQ0FFQTtBQUNBLEdBQUk4dkIsV0FBSixDQUFpQixDQUNmTixXQUFhLElBQWIsQ0FDQXQ2QixRQUFVLFlBQWM0NkIsV0FBZCxDQUE0QixRQUF0QyxDQUNELENBQ0QsR0FBSUcsYUFBSixDQUFtQixDQUNqQlIsYUFBZSxJQUFmLENBQ0F2NkIsUUFBVSxPQUFTKzZCLGFBQVQsQ0FBeUIsYUFBbkMsQ0FDRCxDQUNELEdBQUlGLGdCQUFKLENBQXNCLENBQ3BCNzZCLFFBQVUsaUJBQW1CNjZCLGdCQUFuQixDQUFzQyw2QkFBaEQsQ0FDRCxDQUNEM3ZDLE1BQVFuQixPQUFTN0csTUFBTXZELE1BQXZCLENBRUE7QUFDQTtBQUNBLE1BQU91RCxNQUFQLENBQ0QsQ0F2QkQsRUF5QkE4YyxRQUFVLE1BQVYsQ0FFQTtBQUNBO0FBQ0EsR0FBSWc3QixVQUFXekksUUFBUXlJLFFBQXZCLENBQ0EsR0FBSSxDQUFDQSxRQUFMLENBQWUsQ0FDYmg3QixPQUFTLGlCQUFtQkEsTUFBbkIsQ0FBNEIsT0FBckMsQ0FDRCxDQUNEO0FBQ0FBLE9BQVMsQ0FBQ3U2QixhQUFldjZCLE9BQU92YixPQUFQLENBQWVnYixvQkFBZixDQUFxQyxFQUFyQyxDQUFmLENBQTBETyxNQUEzRCxFQUNOdmIsT0FETSxDQUNFaWIsbUJBREYsQ0FDdUIsSUFEdkIsRUFFTmpiLE9BRk0sQ0FFRWtiLHFCQUZGLENBRXlCLEtBRnpCLENBQVQsQ0FJQTtBQUNBSyxPQUFTLGFBQWVnN0IsVUFBWSxLQUEzQixFQUFvQyxPQUFwQyxFQUNOQSxTQUNHLEVBREgsQ0FFRyxzQkFIRyxFQUtQLG1CQUxPLEVBTU5WLFdBQ0ksa0JBREosQ0FFSSxFQVJFLEdBVU5DLGFBQ0csa0NBQ0EsdURBRkgsQ0FHRyxLQWJHLEVBZVB2NkIsTUFmTyxDQWdCUCxlQWhCRixDQWtCQSxHQUFJK0gsUUFBU2t6QixRQUFRLFVBQVcsQ0FDOUIsTUFBTzExQixVQUFTNjBCLFdBQVQsQ0FBc0JPLFVBQVksU0FBWixDQUF3QjM2QixNQUE5QyxFQUNKN0UsS0FESSxDQUNFNWEsU0FERixDQUNhODVDLGFBRGIsQ0FBUCxDQUVELENBSFksQ0FBYixDQUtBO0FBQ0E7QUFDQXR5QixPQUFPL0gsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQSxHQUFJMDFCLFFBQVEzdEIsTUFBUixDQUFKLENBQXFCLENBQ25CLEtBQU1BLE9BQU4sQ0FDRCxDQUNELE1BQU9BLE9BQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXFCQSxRQUFTbXpCLFFBQVQsQ0FBaUI1Z0QsS0FBakIsQ0FBd0IsQ0FDdEIsTUFBTzh3QixVQUFTOXdCLEtBQVQsRUFBZ0JtWSxXQUFoQixFQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FxQkEsUUFBUzBvQyxRQUFULENBQWlCN2dELEtBQWpCLENBQXdCLENBQ3RCLE1BQU84d0IsVUFBUzl3QixLQUFULEVBQWdCOGdELFdBQWhCLEVBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FzQkEsUUFBU0MsS0FBVCxDQUFjdHlDLE1BQWQsQ0FBc0J3L0IsS0FBdEIsQ0FBNkJsRCxLQUE3QixDQUFvQyxDQUNsQ3Q4QixPQUFTcWlCLFNBQVNyaUIsTUFBVCxDQUFULENBQ0EsR0FBSUEsU0FBV3M4QixPQUFTa0QsUUFBVWhvQyxTQUE5QixDQUFKLENBQThDLENBQzVDLE1BQU93SSxRQUFPdEUsT0FBUCxDQUFla2MsTUFBZixDQUF1QixFQUF2QixDQUFQLENBQ0QsQ0FDRCxHQUFJLENBQUM1WCxNQUFELEVBQVcsRUFBRXcvQixNQUFRbEgsYUFBYWtILEtBQWIsQ0FBVixDQUFmLENBQStDLENBQzdDLE1BQU94L0IsT0FBUCxDQUNELENBQ0QsR0FBSXdoQixZQUFhMkIsY0FBY25qQixNQUFkLENBQWpCLENBQ0l5aEIsV0FBYTBCLGNBQWNxYyxLQUFkLENBRGpCLENBRUkxVixNQUFRdkksZ0JBQWdCQyxVQUFoQixDQUE0QkMsVUFBNUIsQ0FGWixDQUdJc0ksSUFBTXJJLGNBQWNGLFVBQWQsQ0FBMEJDLFVBQTFCLEVBQXdDLENBSGxELENBS0EsTUFBTzhYLFdBQVUvWCxVQUFWLENBQXNCc0ksS0FBdEIsQ0FBNkJDLEdBQTdCLEVBQWtDbGxCLElBQWxDLENBQXVDLEVBQXZDLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FtQkEsUUFBUzB0QyxRQUFULENBQWlCdnlDLE1BQWpCLENBQXlCdy9CLEtBQXpCLENBQWdDbEQsS0FBaEMsQ0FBdUMsQ0FDckN0OEIsT0FBU3FpQixTQUFTcmlCLE1BQVQsQ0FBVCxDQUNBLEdBQUlBLFNBQVdzOEIsT0FBU2tELFFBQVVob0MsU0FBOUIsQ0FBSixDQUE4QyxDQUM1QyxNQUFPd0ksUUFBT3RFLE9BQVAsQ0FBZW9jLFNBQWYsQ0FBMEIsRUFBMUIsQ0FBUCxDQUNELENBQ0QsR0FBSSxDQUFDOVgsTUFBRCxFQUFXLEVBQUV3L0IsTUFBUWxILGFBQWFrSCxLQUFiLENBQVYsQ0FBZixDQUErQyxDQUM3QyxNQUFPeC9CLE9BQVAsQ0FDRCxDQUNELEdBQUl3aEIsWUFBYTJCLGNBQWNuakIsTUFBZCxDQUFqQixDQUNJK3BCLElBQU1ySSxjQUFjRixVQUFkLENBQTBCMkIsY0FBY3FjLEtBQWQsQ0FBMUIsRUFBa0QsQ0FENUQsQ0FHQSxNQUFPakcsV0FBVS9YLFVBQVYsQ0FBc0IsQ0FBdEIsQ0FBeUJ1SSxHQUF6QixFQUE4QmxsQixJQUE5QixDQUFtQyxFQUFuQyxDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BbUJBLFFBQVMydEMsVUFBVCxDQUFtQnh5QyxNQUFuQixDQUEyQncvQixLQUEzQixDQUFrQ2xELEtBQWxDLENBQXlDLENBQ3ZDdDhCLE9BQVNxaUIsU0FBU3JpQixNQUFULENBQVQsQ0FDQSxHQUFJQSxTQUFXczhCLE9BQVNrRCxRQUFVaG9DLFNBQTlCLENBQUosQ0FBOEMsQ0FDNUMsTUFBT3dJLFFBQU90RSxPQUFQLENBQWVtYyxXQUFmLENBQTRCLEVBQTVCLENBQVAsQ0FDRCxDQUNELEdBQUksQ0FBQzdYLE1BQUQsRUFBVyxFQUFFdy9CLE1BQVFsSCxhQUFha0gsS0FBYixDQUFWLENBQWYsQ0FBK0MsQ0FDN0MsTUFBT3gvQixPQUFQLENBQ0QsQ0FDRCxHQUFJd2hCLFlBQWEyQixjQUFjbmpCLE1BQWQsQ0FBakIsQ0FDSThwQixNQUFRdkksZ0JBQWdCQyxVQUFoQixDQUE0QjJCLGNBQWNxYyxLQUFkLENBQTVCLENBRFosQ0FHQSxNQUFPakcsV0FBVS9YLFVBQVYsQ0FBc0JzSSxLQUF0QixFQUE2QmpsQixJQUE3QixDQUFrQyxFQUFsQyxDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcUNBLFFBQVM0dEMsU0FBVCxDQUFrQnp5QyxNQUFsQixDQUEwQndwQyxPQUExQixDQUFtQyxDQUNqQyxHQUFJNXlDLFFBQVNtZCxvQkFBYixDQUNJMitCLFNBQVcxK0Isc0JBRGYsQ0FHQSxHQUFJbWEsU0FBU3FiLE9BQVQsQ0FBSixDQUF1QixDQUNyQixHQUFJakYsV0FBWSxhQUFlaUYsUUFBZixDQUF5QkEsUUFBUWpGLFNBQWpDLENBQTZDQSxTQUE3RCxDQUNBM3RDLE9BQVMsVUFBWTR5QyxRQUFaLENBQXNCeFosVUFBVXdaLFFBQVE1eUMsTUFBbEIsQ0FBdEIsQ0FBa0RBLE1BQTNELENBQ0E4N0MsU0FBVyxZQUFjbEosUUFBZCxDQUF3QmxSLGFBQWFrUixRQUFRa0osUUFBckIsQ0FBeEIsQ0FBeURBLFFBQXBFLENBQ0QsQ0FDRDF5QyxPQUFTcWlCLFNBQVNyaUIsTUFBVCxDQUFULENBRUEsR0FBSTJ3QyxXQUFZM3dDLE9BQU9wSixNQUF2QixDQUNBLEdBQUlzckIsV0FBV2xpQixNQUFYLENBQUosQ0FBd0IsQ0FDdEIsR0FBSXdoQixZQUFhMkIsY0FBY25qQixNQUFkLENBQWpCLENBQ0Eyd0MsVUFBWW52QixXQUFXNXFCLE1BQXZCLENBQ0QsQ0FDRCxHQUFJQSxRQUFVKzVDLFNBQWQsQ0FBeUIsQ0FDdkIsTUFBTzN3QyxPQUFQLENBQ0QsQ0FDRCxHQUFJK3BCLEtBQU1uekIsT0FBU3FzQixXQUFXeXZCLFFBQVgsQ0FBbkIsQ0FDQSxHQUFJM29CLElBQU0sQ0FBVixDQUFhLENBQ1gsTUFBTzJvQixTQUFQLENBQ0QsQ0FDRCxHQUFJMXpCLFFBQVN3QyxXQUNUK1gsVUFBVS9YLFVBQVYsQ0FBc0IsQ0FBdEIsQ0FBeUJ1SSxHQUF6QixFQUE4QmxsQixJQUE5QixDQUFtQyxFQUFuQyxDQURTLENBRVQ3RSxPQUFPeTVCLEtBQVAsQ0FBYSxDQUFiLENBQWdCMVAsR0FBaEIsQ0FGSixDQUlBLEdBQUl3YSxZQUFjL3NDLFNBQWxCLENBQTZCLENBQzNCLE1BQU93bkIsUUFBUzB6QixRQUFoQixDQUNELENBQ0QsR0FBSWx4QixVQUFKLENBQWdCLENBQ2R1SSxLQUFRL0ssT0FBT3BvQixNQUFQLENBQWdCbXpCLEdBQXhCLENBQ0QsQ0FDRCxHQUFJdE0sU0FBUzhtQixTQUFULENBQUosQ0FBeUIsQ0FDdkIsR0FBSXZrQyxPQUFPeTVCLEtBQVAsQ0FBYTFQLEdBQWIsRUFBa0I0b0IsTUFBbEIsQ0FBeUJwTyxTQUF6QixDQUFKLENBQXlDLENBQ3ZDLEdBQUlwcUMsTUFBSixDQUNJeTRDLFVBQVk1ekIsTUFEaEIsQ0FHQSxHQUFJLENBQUN1bEIsVUFBVTF3QyxNQUFmLENBQXVCLENBQ3JCMHdDLFVBQVl2dEIsT0FBT3V0QixVQUFVdHRCLE1BQWpCLENBQXlCb0wsU0FBU2hLLFFBQVE4TCxJQUFSLENBQWFvZ0IsU0FBYixDQUFULEVBQW9DLEdBQTdELENBQVosQ0FDRCxDQUNEQSxVQUFVamhCLFNBQVYsQ0FBc0IsQ0FBdEIsQ0FDQSxNQUFRbnBCLE1BQVFvcUMsVUFBVXBnQixJQUFWLENBQWV5dUIsU0FBZixDQUFoQixDQUE0QyxDQUMxQyxHQUFJQyxRQUFTMTRDLE1BQU1nSSxLQUFuQixDQUNELENBQ0Q2YyxPQUFTQSxPQUFPeWEsS0FBUCxDQUFhLENBQWIsQ0FBZ0JvWixTQUFXcjdDLFNBQVgsQ0FBdUJ1eUIsR0FBdkIsQ0FBNkI4b0IsTUFBN0MsQ0FBVCxDQUNELENBQ0YsQ0FkRCxJQWNPLElBQUk3eUMsT0FBTzJLLE9BQVAsQ0FBZTJ0QixhQUFhaU0sU0FBYixDQUFmLENBQXdDeGEsR0FBeEMsR0FBZ0RBLEdBQXBELENBQXlELENBQzlELEdBQUk1bkIsT0FBUTZjLE9BQU93bEIsV0FBUCxDQUFtQkQsU0FBbkIsQ0FBWixDQUNBLEdBQUlwaUMsTUFBUSxDQUFDLENBQWIsQ0FBZ0IsQ0FDZDZjLE9BQVNBLE9BQU95YSxLQUFQLENBQWEsQ0FBYixDQUFnQnQzQixLQUFoQixDQUFULENBQ0QsQ0FDRixDQUNELE1BQU82YyxRQUFTMHpCLFFBQWhCLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BbUJBLFFBQVNJLFNBQVQsQ0FBa0I5eUMsTUFBbEIsQ0FBMEIsQ0FDeEJBLE9BQVNxaUIsU0FBU3JpQixNQUFULENBQVQsQ0FDQSxNQUFRQSxTQUFVK1csaUJBQWlCMVEsSUFBakIsQ0FBc0JyRyxNQUF0QixDQUFYLENBQ0hBLE9BQU90RSxPQUFQLENBQWVtYixhQUFmLENBQThCd00sZ0JBQTlCLENBREcsQ0FFSHJqQixNQUZKLENBR0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQW9CQSxHQUFJK3lDLFdBQVk3VixpQkFBaUIsU0FBU2xlLE1BQVQsQ0FBaUJwVixJQUFqQixDQUF1QnpILEtBQXZCLENBQThCLENBQzdELE1BQU82YyxTQUFVN2MsTUFBUSxHQUFSLENBQWMsRUFBeEIsRUFBOEJ5SCxLQUFLeW9DLFdBQUwsRUFBckMsQ0FDRCxDQUZlLENBQWhCLENBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7T0FpQkEsR0FBSXBDLFlBQWFuVCxnQkFBZ0IsYUFBaEIsQ0FBakIsQ0FFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BbUJBLFFBQVNLLE1BQVQsQ0FBZW45QixNQUFmLENBQXVCZzBCLE9BQXZCLENBQWdDc0ksS0FBaEMsQ0FBdUMsQ0FDckN0OEIsT0FBU3FpQixTQUFTcmlCLE1BQVQsQ0FBVCxDQUNBZzBCLFFBQVVzSSxNQUFROWtDLFNBQVIsQ0FBb0J3OEIsT0FBOUIsQ0FFQSxHQUFJQSxVQUFZeDhCLFNBQWhCLENBQTJCLENBQ3pCLE1BQU8ycUIsZ0JBQWVuaUIsTUFBZixFQUF5QnVqQixhQUFhdmpCLE1BQWIsQ0FBekIsQ0FBZ0Q4ZixXQUFXOWYsTUFBWCxDQUF2RCxDQUNELENBQ0QsTUFBT0EsUUFBTzdGLEtBQVAsQ0FBYTY1QixPQUFiLEdBQXlCLEVBQWhDLENBQ0QsQ0FFRCw0RUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bc0JBLEdBQUlrZSxTQUFVcGIsU0FBUyxTQUFTNVksSUFBVCxDQUFlRSxJQUFmLENBQXFCLENBQzFDLEdBQUksQ0FDRixNQUFPaE0sT0FBTThMLElBQU4sQ0FBWTFtQixTQUFaLENBQXVCNG1CLElBQXZCLENBQVAsQ0FDRCxDQUFDLE1BQU92bUIsQ0FBUCxDQUFVLENBQ1YsTUFBTzgwQyxTQUFROTBDLENBQVIsRUFBYUEsQ0FBYixDQUFpQixHQUFJNUgsTUFBSixDQUFVNEgsQ0FBVixDQUF4QixDQUNELENBQ0YsQ0FOYSxDQUFkLENBUUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0EwQkEsR0FBSW03QyxTQUFVbGMsU0FBUyxTQUFTclcsTUFBVCxDQUFpQnd5QixXQUFqQixDQUE4QixDQUNuRHYwQixVQUFVeVIsWUFBWThpQixXQUFaLENBQXlCLENBQXpCLENBQVYsQ0FBdUMsU0FBUzNoRCxHQUFULENBQWMsQ0FDbkRBLElBQU0wL0IsTUFBTTEvQixHQUFOLENBQU4sQ0FDQW12QixPQUFPbnZCLEdBQVAsRUFBY3FMLEtBQUs4akIsT0FBT252QixHQUFQLENBQUwsQ0FBa0JtdkIsTUFBbEIsQ0FBZCxDQUNELENBSEQsRUFJQSxNQUFPQSxPQUFQLENBQ0QsQ0FOYSxDQUFkLENBUUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E2QkEsUUFBU3l5QixLQUFULENBQWMxbUIsS0FBZCxDQUFxQixDQUNuQixHQUFJNTFCLFFBQVM0MUIsTUFBUUEsTUFBTTUxQixNQUFkLENBQXVCLENBQXBDLENBQ0lxb0MsV0FBYWhKLGFBRGpCLENBR0F6SixNQUFRLENBQUM1MUIsTUFBRCxDQUFVLEVBQVYsQ0FBZXlvQixTQUFTbU4sS0FBVCxDQUFnQixTQUFTek8sSUFBVCxDQUFlLENBQ3BELEdBQUksTUFBT0EsTUFBSyxDQUFMLENBQVAsRUFBa0IsVUFBdEIsQ0FBa0MsQ0FDaEMsS0FBTSxJQUFJNkYsVUFBSixDQUFjNVEsZUFBZCxDQUFOLENBQ0QsQ0FDRCxNQUFPLENBQUNpc0IsV0FBV2xoQixLQUFLLENBQUwsQ0FBWCxDQUFELENBQXNCQSxLQUFLLENBQUwsQ0FBdEIsQ0FBUCxDQUNELENBTHNCLENBQXZCLENBT0EsTUFBTytZLFVBQVMsU0FBUzFZLElBQVQsQ0FBZSxDQUM3QixHQUFJamMsT0FBUSxDQUFDLENBQWIsQ0FDQSxNQUFPLEVBQUVBLEtBQUYsQ0FBVXZMLE1BQWpCLENBQXlCLENBQ3ZCLEdBQUltbkIsTUFBT3lPLE1BQU1ycUIsS0FBTixDQUFYLENBQ0EsR0FBSWlRLE1BQU0yTCxLQUFLLENBQUwsQ0FBTixDQUFlLElBQWYsQ0FBcUJLLElBQXJCLENBQUosQ0FBZ0MsQ0FDOUIsTUFBT2hNLE9BQU0yTCxLQUFLLENBQUwsQ0FBTixDQUFlLElBQWYsQ0FBcUJLLElBQXJCLENBQVAsQ0FDRCxDQUNGLENBQ0YsQ0FSTSxDQUFQLENBU0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F3QkEsUUFBUyswQixTQUFULENBQWtCbDhCLE1BQWxCLENBQTBCLENBQ3hCLE1BQU82WCxjQUFhZixVQUFVOVcsTUFBVixDQUFrQixJQUFsQixDQUFiLENBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FtQkEsUUFBUytyQixTQUFULENBQWtCenhDLEtBQWxCLENBQXlCLENBQ3ZCLE1BQU8sV0FBVyxDQUNoQixNQUFPQSxNQUFQLENBQ0QsQ0FGRCxDQUdELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FvQkEsUUFBUzZoRCxVQUFULENBQW1CN2hELEtBQW5CLENBQTBCNnRDLFlBQTFCLENBQXdDLENBQ3RDLE1BQVE3dEMsUUFBUyxJQUFULEVBQWlCQSxRQUFVQSxLQUE1QixDQUFxQzZ0QyxZQUFyQyxDQUFvRDd0QyxLQUEzRCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXNCQSxHQUFJOGhELE1BQU94VixZQUFYLENBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcUJBLEdBQUl5VixXQUFZelYsV0FBVyxJQUFYLENBQWhCLENBRUE7Ozs7Ozs7Ozs7Ozs7OztPQWdCQSxRQUFTdkosU0FBVCxDQUFrQi9pQyxLQUFsQixDQUF5QixDQUN2QixNQUFPQSxNQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0EwQ0EsUUFBU2l0QixTQUFULENBQWtCTixJQUFsQixDQUF3QixDQUN0QixNQUFPbVcsY0FBYSxNQUFPblcsS0FBUCxFQUFlLFVBQWYsQ0FBNEJBLElBQTVCLENBQW1DNlAsVUFBVTdQLElBQVYsQ0FBZ0IsSUFBaEIsQ0FBaEQsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTRCQSxRQUFTaGtCLFFBQVQsQ0FBaUIrYyxNQUFqQixDQUF5QixDQUN2QixNQUFPdWQsYUFBWXpHLFVBQVU5VyxNQUFWLENBQWtCLElBQWxCLENBQVosQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0EwQkEsUUFBU3M4QixnQkFBVCxDQUF5QjFpQixJQUF6QixDQUErQjdELFFBQS9CLENBQXlDLENBQ3ZDLE1BQU91SCxxQkFBb0IxRCxJQUFwQixDQUEwQjlDLFVBQVVmLFFBQVYsQ0FBb0IsSUFBcEIsQ0FBMUIsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bd0JBLEdBQUl3bUIsUUFBUzFjLFNBQVMsU0FBU2pHLElBQVQsQ0FBZXpTLElBQWYsQ0FBcUIsQ0FDekMsTUFBTyxVQUFTcUMsTUFBVCxDQUFpQixDQUN0QixNQUFPMFIsWUFBVzFSLE1BQVgsQ0FBbUJvUSxJQUFuQixDQUF5QnpTLElBQXpCLENBQVAsQ0FDRCxDQUZELENBR0QsQ0FKWSxDQUFiLENBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F1QkEsR0FBSXExQixVQUFXM2MsU0FBUyxTQUFTclcsTUFBVCxDQUFpQnJDLElBQWpCLENBQXVCLENBQzdDLE1BQU8sVUFBU3lTLElBQVQsQ0FBZSxDQUNwQixNQUFPc0IsWUFBVzFSLE1BQVgsQ0FBbUJvUSxJQUFuQixDQUF5QnpTLElBQXpCLENBQVAsQ0FDRCxDQUZELENBR0QsQ0FKYyxDQUFmLENBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bb0NBLFFBQVNzMUIsTUFBVCxDQUFlanpCLE1BQWYsQ0FBdUJ4SixNQUF2QixDQUErQnV5QixPQUEvQixDQUF3QyxDQUN0QyxHQUFJdm9CLE9BQVFtRCxLQUFLbk4sTUFBTCxDQUFaLENBQ0lnOEIsWUFBY3ZpQixjQUFjelosTUFBZCxDQUFzQmdLLEtBQXRCLENBRGxCLENBR0EsR0FBSXVvQixTQUFXLElBQVgsRUFDQSxFQUFFcmIsU0FBU2xYLE1BQVQsSUFBcUJnOEIsWUFBWXI4QyxNQUFaLEVBQXNCLENBQUNxcUIsTUFBTXJxQixNQUFsRCxDQUFGLENBREosQ0FDa0UsQ0FDaEU0eUMsUUFBVXZ5QixNQUFWLENBQ0FBLE9BQVN3SixNQUFULENBQ0FBLE9BQVMsSUFBVCxDQUNBd3lCLFlBQWN2aUIsY0FBY3paLE1BQWQsQ0FBc0JtTixLQUFLbk4sTUFBTCxDQUF0QixDQUFkLENBQ0QsQ0FDRCxHQUFJNHZCLE9BQVEsRUFBRTFZLFNBQVNxYixPQUFULEdBQXFCLFNBQVdBLFFBQWxDLEdBQThDLENBQUMsQ0FBQ0EsUUFBUTNDLEtBQXBFLENBQ0l2WSxPQUFTcUMsV0FBV2xRLE1BQVgsQ0FEYixDQUdBL0IsVUFBVXUwQixXQUFWLENBQXVCLFNBQVNsVyxVQUFULENBQXFCLENBQzFDLEdBQUk3ZSxNQUFPakgsT0FBTzhsQixVQUFQLENBQVgsQ0FDQXRjLE9BQU9zYyxVQUFQLEVBQXFCN2UsSUFBckIsQ0FDQSxHQUFJb1EsTUFBSixDQUFZLENBQ1Y3TixPQUFPcUQsU0FBUCxDQUFpQmlaLFVBQWpCLEVBQStCLFVBQVcsQ0FDeEMsR0FBSXpVLFVBQVcsS0FBS0csU0FBcEIsQ0FDQSxHQUFJb2UsT0FBU3ZlLFFBQWIsQ0FBdUIsQ0FDckIsR0FBSXRKLFFBQVN5QixPQUFPLEtBQUs4SCxXQUFaLENBQWIsQ0FDSXdRLFFBQVUvWixPQUFPd0osV0FBUCxDQUFxQlksVUFBVSxLQUFLWixXQUFmLENBRG5DLENBR0F1USxRQUFRMStCLElBQVIsQ0FBYSxDQUFFLE9BQVE2akIsSUFBVixDQUFnQixPQUFRNlksU0FBeEIsQ0FBbUMsVUFBV3RXLE1BQTlDLENBQWIsRUFDQXpCLE9BQU95SixTQUFQLENBQW1CSCxRQUFuQixDQUNBLE1BQU90SixPQUFQLENBQ0QsQ0FDRCxNQUFPZCxNQUFLOUwsS0FBTCxDQUFXcU8sTUFBWCxDQUFtQm5CLFVBQVUsQ0FBQyxLQUFLL3RCLEtBQUwsRUFBRCxDQUFWLENBQTBCd2xDLFNBQTFCLENBQW5CLENBQVAsQ0FDRCxDQVhELENBWUQsQ0FDRixDQWpCRCxFQW1CQSxNQUFPdFcsT0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7OztPQWFBLFFBQVNrekIsV0FBVCxFQUFzQixDQUNwQixHQUFJcDNCLEtBQUs3bUIsQ0FBTCxHQUFXLElBQWYsQ0FBcUIsQ0FDbkI2bUIsS0FBSzdtQixDQUFMLENBQVNpdkIsT0FBVCxDQUNELENBQ0QsTUFBTyxLQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7T0FZQSxRQUFTaHZCLEtBQVQsRUFBZ0IsQ0FFZixDQURDO0FBR0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FvQkEsUUFBU2krQyxPQUFULENBQWdCN3lCLENBQWhCLENBQW1CLENBQ2pCQSxFQUFJaVAsVUFBVWpQLENBQVYsQ0FBSixDQUNBLE1BQU8rVixVQUFTLFNBQVMxWSxJQUFULENBQWUsQ0FDN0IsTUFBTzBYLFNBQVExWCxJQUFSLENBQWMyQyxDQUFkLENBQVAsQ0FDRCxDQUZNLENBQVAsQ0FHRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7OztPQWtCQSxHQUFJOHlCLE1BQU94VSxXQUFXaGdCLFFBQVgsQ0FBWCxDQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXdCQSxHQUFJeTBCLFdBQVl6VSxXQUFXemdCLFVBQVgsQ0FBaEIsQ0FFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F3QkEsR0FBSW0xQixVQUFXMVUsV0FBVzNmLFNBQVgsQ0FBZixDQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FzQkEsUUFBUytVLFNBQVQsQ0FBa0I1RCxJQUFsQixDQUF3QixDQUN0QixNQUFPQyxPQUFNRCxJQUFOLEVBQWNqUixhQUFhb1IsTUFBTUgsSUFBTixDQUFiLENBQWQsQ0FBMEN5RixpQkFBaUJ6RixJQUFqQixDQUFqRCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcUJBLFFBQVNtakIsV0FBVCxDQUFvQnZ6QixNQUFwQixDQUE0QixDQUMxQixNQUFPLFVBQVNvUSxJQUFULENBQWUsQ0FDcEIsTUFBT3BRLFNBQVUsSUFBVixDQUFpQmpwQixTQUFqQixDQUE2Qm81QixRQUFRblEsTUFBUixDQUFnQm9RLElBQWhCLENBQXBDLENBQ0QsQ0FGRCxDQUdELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F5Q0EsR0FBSXJqQixPQUFRbXlCLGFBQVosQ0FFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FvQ0EsR0FBSXNVLFlBQWF0VSxZQUFZLElBQVosQ0FBakIsQ0FFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FrQkEsUUFBU2dDLFVBQVQsRUFBcUIsQ0FDbkIsTUFBTyxFQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7O09BYUEsUUFBU1csVUFBVCxFQUFxQixDQUNuQixNQUFPLE1BQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7OztPQWtCQSxRQUFTNFIsV0FBVCxFQUFzQixDQUNwQixNQUFPLEVBQVAsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7T0FhQSxRQUFTQyxXQUFULEVBQXNCLENBQ3BCLE1BQU8sRUFBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7OztPQWFBLFFBQVNDLFNBQVQsRUFBb0IsQ0FDbEIsTUFBTyxLQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BbUJBLFFBQVNDLE1BQVQsQ0FBZXR6QixDQUFmLENBQWtCdkMsUUFBbEIsQ0FBNEIsQ0FDMUJ1QyxFQUFJaVAsVUFBVWpQLENBQVYsQ0FBSixDQUNBLEdBQUlBLEVBQUksQ0FBSixFQUFTQSxFQUFJeE0sZ0JBQWpCLENBQW1DLENBQ2pDLE1BQU8sRUFBUCxDQUNELENBQ0QsR0FBSXBTLE9BQVF1UyxnQkFBWixDQUNJOWQsT0FBUzJ2QixVQUFVeEYsQ0FBVixDQUFhck0sZ0JBQWIsQ0FEYixDQUdBOEosU0FBV3lYLFlBQVl6WCxRQUFaLENBQVgsQ0FDQXVDLEdBQUtyTSxnQkFBTCxDQUVBLEdBQUlzSyxRQUFTOEIsVUFBVWxxQixNQUFWLENBQWtCNG5CLFFBQWxCLENBQWIsQ0FDQSxNQUFPLEVBQUVyYyxLQUFGLENBQVU0ZSxDQUFqQixDQUFvQixDQUNsQnZDLFNBQVNyYyxLQUFULEVBQ0QsQ0FDRCxNQUFPNmMsT0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7T0FpQkEsUUFBU3MxQixPQUFULENBQWdCL2lELEtBQWhCLENBQXVCLENBQ3JCLEdBQUk4ZSxRQUFROWUsS0FBUixDQUFKLENBQW9CLENBQ2xCLE1BQU84dEIsVUFBUzl0QixLQUFULENBQWdCeS9CLEtBQWhCLENBQVAsQ0FDRCxDQUNELE1BQU9sQixVQUFTditCLEtBQVQsRUFBa0IsQ0FBQ0EsS0FBRCxDQUFsQixDQUE0QjYzQixVQUFVa1EsYUFBYS9uQyxLQUFiLENBQVYsQ0FBbkMsQ0FDRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7O09BaUJBLFFBQVNnakQsU0FBVCxDQUFrQkMsTUFBbEIsQ0FBMEIsQ0FDeEIsR0FBSTcvQyxJQUFLLEVBQUU2dkIsU0FBWCxDQUNBLE1BQU9uQyxVQUFTbXlCLE1BQVQsRUFBbUI3L0MsRUFBMUIsQ0FDRCxDQUVELDRFQUVBOzs7Ozs7Ozs7Ozs7OztPQWVBLEdBQUlzcEIsS0FBTWloQixvQkFBb0IsU0FBU3VWLE1BQVQsQ0FBaUJDLE1BQWpCLENBQXlCLENBQ3JELE1BQU9ELFFBQVNDLE1BQWhCLENBQ0QsQ0FGUyxDQUVQLENBRk8sQ0FBVixDQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXFCQSxHQUFJL3VCLE1BQU8yYSxZQUFZLE1BQVosQ0FBWCxDQUVBOzs7Ozs7Ozs7Ozs7OztPQWVBLEdBQUlxVSxRQUFTelYsb0JBQW9CLFNBQVMwVixRQUFULENBQW1CQyxPQUFuQixDQUE0QixDQUMzRCxNQUFPRCxVQUFXQyxPQUFsQixDQUNELENBRlksQ0FFVixDQUZVLENBQWIsQ0FJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FxQkEsR0FBSWh2QixPQUFReWEsWUFBWSxPQUFaLENBQVosQ0FFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FrQkEsUUFBU3BpQyxJQUFULENBQWFvZ0IsS0FBYixDQUFvQixDQUNsQixNQUFRQSxRQUFTQSxNQUFNMW5CLE1BQWhCLENBQ0hpNUIsYUFBYXZSLEtBQWIsQ0FBb0JnVyxRQUFwQixDQUE4QmpELE1BQTlCLENBREcsQ0FFSDc1QixTQUZKLENBR0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXVCQSxRQUFTczlDLE1BQVQsQ0FBZXgyQixLQUFmLENBQXNCRSxRQUF0QixDQUFnQyxDQUM5QixNQUFRRixRQUFTQSxNQUFNMW5CLE1BQWhCLENBQ0hpNUIsYUFBYXZSLEtBQWIsQ0FBb0IyWCxZQUFZelgsUUFBWixDQUFzQixDQUF0QixDQUFwQixDQUE4QzZTLE1BQTlDLENBREcsQ0FFSDc1QixTQUZKLENBR0QsQ0FFRDs7Ozs7Ozs7Ozs7OztPQWNBLFFBQVN1OUMsS0FBVCxDQUFjejJCLEtBQWQsQ0FBcUIsQ0FDbkIsTUFBT2lDLFVBQVNqQyxLQUFULENBQWdCZ1csUUFBaEIsQ0FBUCxDQUNELENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F1QkEsUUFBUzBnQixPQUFULENBQWdCMTJCLEtBQWhCLENBQXVCRSxRQUF2QixDQUFpQyxDQUMvQixNQUFPK0IsVUFBU2pDLEtBQVQsQ0FBZ0IyWCxZQUFZelgsUUFBWixDQUFzQixDQUF0QixDQUFoQixDQUFQLENBQ0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FrQkEsUUFBU2dJLElBQVQsQ0FBYWxJLEtBQWIsQ0FBb0IsQ0FDbEIsTUFBUUEsUUFBU0EsTUFBTTFuQixNQUFoQixDQUNIaTVCLGFBQWF2UixLQUFiLENBQW9CZ1csUUFBcEIsQ0FBOEJTLE1BQTlCLENBREcsQ0FFSHY5QixTQUZKLENBR0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXVCQSxRQUFTeTlDLE1BQVQsQ0FBZTMyQixLQUFmLENBQXNCRSxRQUF0QixDQUFnQyxDQUM5QixNQUFRRixRQUFTQSxNQUFNMW5CLE1BQWhCLENBQ0hpNUIsYUFBYXZSLEtBQWIsQ0FBb0IyWCxZQUFZelgsUUFBWixDQUFzQixDQUF0QixDQUFwQixDQUE4Q3VXLE1BQTlDLENBREcsQ0FFSHY5QixTQUZKLENBR0QsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7T0FlQSxHQUFJMDlDLFVBQVdoVyxvQkFBb0IsU0FBU2lXLFVBQVQsQ0FBcUJDLFlBQXJCLENBQW1DLENBQ3BFLE1BQU9ELFlBQWFDLFlBQXBCLENBQ0QsQ0FGYyxDQUVaLENBRlksQ0FBZixDQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXFCQSxHQUFJQyxPQUFRL1UsWUFBWSxPQUFaLENBQVosQ0FFQTs7Ozs7Ozs7Ozs7Ozs7T0FlQSxHQUFJZ1YsVUFBV3BXLG9CQUFvQixTQUFTcVcsT0FBVCxDQUFrQkMsVUFBbEIsQ0FBOEIsQ0FDL0QsTUFBT0QsU0FBVUMsVUFBakIsQ0FDRCxDQUZjLENBRVosQ0FGWSxDQUFmLENBSUE7Ozs7Ozs7Ozs7Ozs7T0FjQSxRQUFTQyxJQUFULENBQWFuM0IsS0FBYixDQUFvQixDQUNsQixNQUFRQSxRQUFTQSxNQUFNMW5CLE1BQWhCLENBQ0g0cEIsUUFBUWxDLEtBQVIsQ0FBZWdXLFFBQWYsQ0FERyxDQUVILENBRkosQ0FHRCxDQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BdUJBLFFBQVNvaEIsTUFBVCxDQUFlcDNCLEtBQWYsQ0FBc0JFLFFBQXRCLENBQWdDLENBQzlCLE1BQVFGLFFBQVNBLE1BQU0xbkIsTUFBaEIsQ0FDSDRwQixRQUFRbEMsS0FBUixDQUFlMlgsWUFBWXpYLFFBQVosQ0FBc0IsQ0FBdEIsQ0FBZixDQURHLENBRUgsQ0FGSixDQUdELENBRUQsNEVBRUE7QUFDQXdKLE9BQU9raEIsS0FBUCxDQUFlQSxLQUFmLENBQ0FsaEIsT0FBT3lXLEdBQVAsQ0FBYUEsR0FBYixDQUNBelcsT0FBT2xaLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0FrWixPQUFPNmxCLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0E3bEIsT0FBTzhsQixZQUFQLENBQXNCQSxZQUF0QixDQUNBOWxCLE9BQU8rbEIsVUFBUCxDQUFvQkEsVUFBcEIsQ0FDQS9sQixPQUFPZ21CLEVBQVAsQ0FBWUEsRUFBWixDQUNBaG1CLE9BQU9taEIsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQW5oQixPQUFPcnJCLElBQVAsQ0FBY0EsSUFBZCxDQUNBcXJCLE9BQU9nckIsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQWhyQixPQUFPb2hCLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0FwaEIsT0FBTytqQixTQUFQLENBQW1CQSxTQUFuQixDQUNBL2pCLE9BQU82ZSxLQUFQLENBQWVBLEtBQWYsQ0FDQTdlLE9BQU9sakIsS0FBUCxDQUFlQSxLQUFmLENBQ0FrakIsT0FBTzdaLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0E2WixPQUFPMXRCLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0EwdEIsT0FBT2tyQixJQUFQLENBQWNBLElBQWQsQ0FDQWxyQixPQUFPbXJCLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0FuckIsT0FBT2diLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0FoYixPQUFPMGYsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQTFmLE9BQU8zMUIsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQTIxQixPQUFPcWhCLEtBQVAsQ0FBZUEsS0FBZixDQUNBcmhCLE9BQU9zaEIsVUFBUCxDQUFvQkEsVUFBcEIsQ0FDQXRoQixPQUFPdWhCLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0F2aEIsT0FBT3RFLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0FzRSxPQUFPa21CLFlBQVAsQ0FBc0JBLFlBQXRCLENBQ0FsbUIsT0FBTzhpQixLQUFQLENBQWVBLEtBQWYsQ0FDQTlpQixPQUFPK2lCLEtBQVAsQ0FBZUEsS0FBZixDQUNBL2lCLE9BQU9vYixVQUFQLENBQW9CQSxVQUFwQixDQUNBcGIsT0FBT3FiLFlBQVAsQ0FBc0JBLFlBQXRCLENBQ0FyYixPQUFPc2IsY0FBUCxDQUF3QkEsY0FBeEIsQ0FDQXRiLE9BQU9sZixJQUFQLENBQWNBLElBQWQsQ0FDQWtmLE9BQU91YixTQUFQLENBQW1CQSxTQUFuQixDQUNBdmIsT0FBT3diLGNBQVAsQ0FBd0JBLGNBQXhCLENBQ0F4YixPQUFPeWIsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQXpiLE9BQU8wYixJQUFQLENBQWNBLElBQWQsQ0FDQTFiLE9BQU9yZSxNQUFQLENBQWdCQSxNQUFoQixDQUNBcWUsT0FBTzhmLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0E5ZixPQUFPK2YsV0FBUCxDQUFxQkEsV0FBckIsQ0FDQS9mLE9BQU9nZ0IsWUFBUCxDQUFzQkEsWUFBdEIsQ0FDQWhnQixPQUFPNmIsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQTdiLE9BQU84YixXQUFQLENBQXFCQSxXQUFyQixDQUNBOWIsT0FBTytiLFlBQVAsQ0FBc0JBLFlBQXRCLENBQ0EvYixPQUFPZ2pCLElBQVAsQ0FBY0EsSUFBZCxDQUNBaGpCLE9BQU9xckIsSUFBUCxDQUFjQSxJQUFkLENBQ0FyckIsT0FBT3NyQixTQUFQLENBQW1CQSxTQUFuQixDQUNBdHJCLE9BQU9nYyxTQUFQLENBQW1CQSxTQUFuQixDQUNBaGMsT0FBT3ltQixTQUFQLENBQW1CQSxTQUFuQixDQUNBem1CLE9BQU8wbUIsV0FBUCxDQUFxQkEsV0FBckIsQ0FDQTFtQixPQUFPa2dCLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0FsZ0IsT0FBT2tjLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0FsYyxPQUFPbWMsWUFBUCxDQUFzQkEsWUFBdEIsQ0FDQW5jLE9BQU9xYyxjQUFQLENBQXdCQSxjQUF4QixDQUNBcmMsT0FBT3NjLGdCQUFQLENBQTBCQSxnQkFBMUIsQ0FDQXRjLE9BQU8ybUIsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQTNtQixPQUFPNG1CLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0E1bUIsT0FBT29nQixTQUFQLENBQW1CQSxTQUFuQixDQUNBcGdCLE9BQU94SixRQUFQLENBQWtCQSxRQUFsQixDQUNBd0osT0FBT3NnQixLQUFQLENBQWVBLEtBQWYsQ0FDQXRnQixPQUFPNUQsSUFBUCxDQUFjQSxJQUFkLENBQ0E0RCxPQUFPdVosTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQXZaLE9BQU9wakIsR0FBUCxDQUFhQSxHQUFiLENBQ0FvakIsT0FBTzhtQixPQUFQLENBQWlCQSxPQUFqQixDQUNBOW1CLE9BQU8rbUIsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQS9tQixPQUFPOXRCLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0E4dEIsT0FBT3VyQixlQUFQLENBQXlCQSxlQUF6QixDQUNBdnJCLE9BQU9rYixPQUFQLENBQWlCQSxPQUFqQixDQUNBbGIsT0FBT2duQixLQUFQLENBQWVBLEtBQWYsQ0FDQWhuQixPQUFPbW1CLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0FubUIsT0FBT3dyQixNQUFQLENBQWdCQSxNQUFoQixDQUNBeHJCLE9BQU95ckIsUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQXpyQixPQUFPMHJCLEtBQVAsQ0FBZUEsS0FBZixDQUNBMXJCLE9BQU8yZ0IsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQTNnQixPQUFPNHJCLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0E1ckIsT0FBT2luQixJQUFQLENBQWNBLElBQWQsQ0FDQWpuQixPQUFPa25CLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0FsbkIsT0FBT29qQixJQUFQLENBQWNBLElBQWQsQ0FDQXBqQixPQUFPdWdCLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0F2Z0IsT0FBTzZyQixJQUFQLENBQWNBLElBQWQsQ0FDQTdyQixPQUFPcWpCLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0FyakIsT0FBTzhyQixTQUFQLENBQW1CQSxTQUFuQixDQUNBOXJCLE9BQU8rckIsUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQS9yQixPQUFPdWpCLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0F2akIsT0FBT3dqQixZQUFQLENBQXNCQSxZQUF0QixDQUNBeGpCLE9BQU93Z0IsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQXhnQixPQUFPckUsSUFBUCxDQUFjQSxJQUFkLENBQ0FxRSxPQUFPbW5CLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0FubkIsT0FBT3lNLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0F6TSxPQUFPZ3NCLFVBQVAsQ0FBb0JBLFVBQXBCLENBQ0Foc0IsT0FBTzBjLElBQVAsQ0FBY0EsSUFBZCxDQUNBMWMsT0FBTzJjLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0EzYyxPQUFPNGMsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQTVjLE9BQU82YyxXQUFQLENBQXFCQSxXQUFyQixDQUNBN2MsT0FBTzhjLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0E5YyxPQUFPeGEsS0FBUCxDQUFlQSxLQUFmLENBQ0F3YSxPQUFPaXNCLFVBQVAsQ0FBb0JBLFVBQXBCLENBQ0Fqc0IsT0FBT3lqQixLQUFQLENBQWVBLEtBQWYsQ0FDQXpqQixPQUFPdm5CLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0F1bkIsT0FBT3oxQixNQUFQLENBQWdCQSxNQUFoQixDQUNBeTFCLE9BQU8wakIsSUFBUCxDQUFjQSxJQUFkLENBQ0ExakIsT0FBT3ZZLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0F1WSxPQUFPNmdCLFVBQVAsQ0FBb0JBLFVBQXBCLENBQ0E3Z0IsT0FBTzMyQixHQUFQLENBQWFBLEdBQWIsQ0FDQTIyQixPQUFPb25CLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0FwbkIsT0FBTytnQixPQUFQLENBQWlCQSxPQUFqQixDQUNBL2dCLE9BQU95UixLQUFQLENBQWVBLEtBQWYsQ0FDQXpSLE9BQU9paEIsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQWpoQixPQUFPcWQsVUFBUCxDQUFvQkEsVUFBcEIsQ0FDQXJkLE9BQU9zZCxZQUFQLENBQXNCQSxZQUF0QixDQUNBdGQsT0FBT240QixLQUFQLENBQWVBLEtBQWYsQ0FDQW00QixPQUFPMmpCLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0EzakIsT0FBT3VkLElBQVAsQ0FBY0EsSUFBZCxDQUNBdmQsT0FBT3dkLElBQVAsQ0FBY0EsSUFBZCxDQUNBeGQsT0FBT3lkLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0F6ZCxPQUFPMGQsY0FBUCxDQUF3QkEsY0FBeEIsQ0FDQTFkLE9BQU8yZCxTQUFQLENBQW1CQSxTQUFuQixDQUNBM2QsT0FBTzhlLEdBQVAsQ0FBYUEsR0FBYixDQUNBOWUsT0FBTzRqQixRQUFQLENBQWtCQSxRQUFsQixDQUNBNWpCLE9BQU9nVyxJQUFQLENBQWNBLElBQWQsQ0FDQWhXLE9BQU9vZixPQUFQLENBQWlCQSxPQUFqQixDQUNBcGYsT0FBT3FuQixPQUFQLENBQWlCQSxPQUFqQixDQUNBcm5CLE9BQU9zbkIsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQXRuQixPQUFPc3NCLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0F0c0IsT0FBTzZOLGFBQVAsQ0FBdUJBLGFBQXZCLENBQ0E3TixPQUFPcEYsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQW9GLE9BQU82akIsS0FBUCxDQUFlQSxLQUFmLENBQ0E3akIsT0FBTzRkLEtBQVAsQ0FBZUEsS0FBZixDQUNBNWQsT0FBTzZkLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0E3ZCxPQUFPOGQsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQTlkLE9BQU8rZCxJQUFQLENBQWNBLElBQWQsQ0FDQS9kLE9BQU9nZSxNQUFQLENBQWdCQSxNQUFoQixDQUNBaGUsT0FBT2llLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0FqZSxPQUFPdW5CLEtBQVAsQ0FBZUEsS0FBZixDQUNBdm5CLE9BQU9rZSxLQUFQLENBQWVBLEtBQWYsQ0FDQWxlLE9BQU9vZSxTQUFQLENBQW1CQSxTQUFuQixDQUNBcGUsT0FBT3duQixNQUFQLENBQWdCQSxNQUFoQixDQUNBeG5CLE9BQU95bkIsVUFBUCxDQUFvQkEsVUFBcEIsQ0FDQXpuQixPQUFPNWIsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQTRiLE9BQU8wbkIsUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQTFuQixPQUFPcWUsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQXJlLE9BQU9tVixLQUFQLENBQWVBLEtBQWYsQ0FDQW5WLE9BQU84akIsSUFBUCxDQUFjQSxJQUFkLENBQ0E5akIsT0FBT3NlLEdBQVAsQ0FBYUEsR0FBYixDQUNBdGUsT0FBT3VlLEtBQVAsQ0FBZUEsS0FBZixDQUNBdmUsT0FBT3dlLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0F4ZSxPQUFPeWUsR0FBUCxDQUFhQSxHQUFiLENBQ0F6ZSxPQUFPMGUsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQTFlLE9BQU8yZSxhQUFQLENBQXVCQSxhQUF2QixDQUNBM2UsT0FBTzRlLE9BQVAsQ0FBaUJBLE9BQWpCLENBRUE7QUFDQTVlLE9BQU93QyxPQUFQLENBQWlCNmtCLE9BQWpCLENBQ0FybkIsT0FBTzJ0QixTQUFQLENBQW1CckcsU0FBbkIsQ0FDQXRuQixPQUFPNHRCLE1BQVAsQ0FBZ0IvSCxRQUFoQixDQUNBN2xCLE9BQU82dEIsVUFBUCxDQUFvQi9ILFlBQXBCLENBRUE7QUFDQTRGLE1BQU0xckIsTUFBTixDQUFjQSxNQUFkLEVBRUEsNEVBRUE7QUFDQUEsT0FBTy9KLEdBQVAsQ0FBYUEsR0FBYixDQUNBK0osT0FBT2txQixPQUFQLENBQWlCQSxPQUFqQixDQUNBbHFCLE9BQU8rbkIsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQS9uQixPQUFPZ29CLFVBQVAsQ0FBb0JBLFVBQXBCLENBQ0Fob0IsT0FBT3JDLElBQVAsQ0FBY0EsSUFBZCxDQUNBcUMsT0FBTzJuQixLQUFQLENBQWVBLEtBQWYsQ0FDQTNuQixPQUFPc0IsS0FBUCxDQUFlQSxLQUFmLENBQ0F0QixPQUFPaWtCLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0Fqa0IsT0FBT2trQixhQUFQLENBQXVCQSxhQUF2QixDQUNBbGtCLE9BQU9na0IsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQWhrQixPQUFPbWtCLFVBQVAsQ0FBb0JBLFVBQXBCLENBQ0Fua0IsT0FBT29WLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0FwVixPQUFPb3JCLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0FwckIsT0FBTzJzQixNQUFQLENBQWdCQSxNQUFoQixDQUNBM3NCLE9BQU9rb0IsUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQWxvQixPQUFPaUYsRUFBUCxDQUFZQSxFQUFaLENBQ0FqRixPQUFPcW9CLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0Fyb0IsT0FBT3NvQixZQUFQLENBQXNCQSxZQUF0QixDQUNBdG9CLE9BQU8yZixLQUFQLENBQWVBLEtBQWYsQ0FDQTNmLE9BQU80ZixJQUFQLENBQWNBLElBQWQsQ0FDQTVmLE9BQU8yYixTQUFQLENBQW1CQSxTQUFuQixDQUNBM2IsT0FBT29tQixPQUFQLENBQWlCQSxPQUFqQixDQUNBcG1CLE9BQU82ZixRQUFQLENBQWtCQSxRQUFsQixDQUNBN2YsT0FBTzRiLGFBQVAsQ0FBdUJBLGFBQXZCLENBQ0E1YixPQUFPcW1CLFdBQVAsQ0FBcUJBLFdBQXJCLENBQ0FybUIsT0FBT25DLEtBQVAsQ0FBZUEsS0FBZixDQUNBbUMsT0FBT2h5QixPQUFQLENBQWlCQSxPQUFqQixDQUNBZ3lCLE9BQU9pZ0IsWUFBUCxDQUFzQkEsWUFBdEIsQ0FDQWpnQixPQUFPbGtCLEtBQVAsQ0FBZUEsS0FBZixDQUNBa2tCLE9BQU9zbUIsVUFBUCxDQUFvQkEsVUFBcEIsQ0FDQXRtQixPQUFPdW1CLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0F2bUIsT0FBT3dtQixXQUFQLENBQXFCQSxXQUFyQixDQUNBeG1CLE9BQU8vMkIsR0FBUCxDQUFhQSxHQUFiLENBQ0ErMkIsT0FBT29rQixFQUFQLENBQVlBLEVBQVosQ0FDQXBrQixPQUFPcWtCLEdBQVAsQ0FBYUEsR0FBYixDQUNBcmtCLE9BQU8xRyxHQUFQLENBQWFBLEdBQWIsQ0FDQTBHLE9BQU9xTixLQUFQLENBQWVBLEtBQWYsQ0FDQXJOLE9BQU9pYyxJQUFQLENBQWNBLElBQWQsQ0FDQWpjLE9BQU9zTSxRQUFQLENBQWtCQSxRQUFsQixDQUNBdE0sT0FBT29ILFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0FwSCxPQUFPcmQsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQXFkLE9BQU80bkIsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQTVuQixPQUFPNm1CLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0E3bUIsT0FBTzJFLFdBQVAsQ0FBcUJBLFdBQXJCLENBQ0EzRSxPQUFPM1gsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQTJYLE9BQU83SyxhQUFQLENBQXVCQSxhQUF2QixDQUNBNkssT0FBT2lOLFdBQVAsQ0FBcUJBLFdBQXJCLENBQ0FqTixPQUFPMk4saUJBQVAsQ0FBMkJBLGlCQUEzQixDQUNBM04sT0FBT3NrQixTQUFQLENBQW1CQSxTQUFuQixDQUNBdGtCLE9BQU8vQixRQUFQLENBQWtCQSxRQUFsQixDQUNBK0IsT0FBTzNLLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0EySyxPQUFPdWtCLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0F2a0IsT0FBT3drQixPQUFQLENBQWlCQSxPQUFqQixDQUNBeGtCLE9BQU95a0IsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQXprQixPQUFPMGtCLFdBQVAsQ0FBcUJBLFdBQXJCLENBQ0Exa0IsT0FBTzJrQixPQUFQLENBQWlCQSxPQUFqQixDQUNBM2tCLE9BQU83QixRQUFQLENBQWtCQSxRQUFsQixDQUNBNkIsT0FBTzJJLFVBQVAsQ0FBb0JBLFVBQXBCLENBQ0EzSSxPQUFPNGtCLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0E1a0IsT0FBT29NLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0FwTSxPQUFPekssS0FBUCxDQUFlQSxLQUFmLENBQ0F5SyxPQUFPNmtCLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0E3a0IsT0FBTzhrQixXQUFQLENBQXFCQSxXQUFyQixDQUNBOWtCLE9BQU8ra0IsS0FBUCxDQUFlQSxLQUFmLENBQ0Eva0IsT0FBT2lsQixRQUFQLENBQWtCQSxRQUFsQixDQUNBamxCLE9BQU8wRixLQUFQLENBQWVBLEtBQWYsQ0FDQTFGLE9BQU9rbEIsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQWxsQixPQUFPZ2xCLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0FobEIsT0FBT21HLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0FuRyxPQUFPQyxZQUFQLENBQXNCQSxZQUF0QixDQUNBRCxPQUFPNE4sYUFBUCxDQUF1QkEsYUFBdkIsQ0FDQTVOLE9BQU92SyxRQUFQLENBQWtCQSxRQUFsQixDQUNBdUssT0FBT21sQixhQUFQLENBQXVCQSxhQUF2QixDQUNBbmxCLE9BQU9ySyxLQUFQLENBQWVBLEtBQWYsQ0FDQXFLLE9BQU9tZ0IsUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQW5nQixPQUFPOEgsUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQTlILE9BQU9uSyxZQUFQLENBQXNCQSxZQUF0QixDQUNBbUssT0FBT29sQixXQUFQLENBQXFCQSxXQUFyQixDQUNBcGxCLE9BQU9xbEIsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQXJsQixPQUFPc2xCLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0F0bEIsT0FBT25qQixJQUFQLENBQWNBLElBQWQsQ0FDQW1qQixPQUFPdW9CLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0F2b0IsT0FBT3FLLElBQVAsQ0FBY0EsSUFBZCxDQUNBckssT0FBT3djLFdBQVAsQ0FBcUJBLFdBQXJCLENBQ0F4YyxPQUFPd29CLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0F4b0IsT0FBT3lvQixVQUFQLENBQW9CQSxVQUFwQixDQUNBem9CLE9BQU91bEIsRUFBUCxDQUFZQSxFQUFaLENBQ0F2bEIsT0FBT3dsQixHQUFQLENBQWFBLEdBQWIsQ0FDQXhsQixPQUFPOXBCLEdBQVAsQ0FBYUEsR0FBYixDQUNBOHBCLE9BQU84c0IsS0FBUCxDQUFlQSxLQUFmLENBQ0E5c0IsT0FBTytzQixJQUFQLENBQWNBLElBQWQsQ0FDQS9zQixPQUFPZ3RCLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0FodEIsT0FBT3hCLEdBQVAsQ0FBYUEsR0FBYixDQUNBd0IsT0FBT2l0QixLQUFQLENBQWVBLEtBQWYsQ0FDQWp0QixPQUFPMlosU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQTNaLE9BQU9zYSxTQUFQLENBQW1CQSxTQUFuQixDQUNBdGEsT0FBT2tzQixVQUFQLENBQW9CQSxVQUFwQixDQUNBbHNCLE9BQU9tc0IsVUFBUCxDQUFvQkEsVUFBcEIsQ0FDQW5zQixPQUFPb3NCLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0Fwc0IsT0FBT2t0QixRQUFQLENBQWtCQSxRQUFsQixDQUNBbHRCLE9BQU95YyxHQUFQLENBQWFBLEdBQWIsQ0FDQXpjLE9BQU8yckIsVUFBUCxDQUFvQkEsVUFBcEIsQ0FDQTNyQixPQUFPcnlCLElBQVAsQ0FBY0EsSUFBZCxDQUNBcXlCLE9BQU8zcEIsR0FBUCxDQUFhQSxHQUFiLENBQ0EycEIsT0FBTzBvQixHQUFQLENBQWFBLEdBQWIsQ0FDQTFvQixPQUFPNG9CLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0E1b0IsT0FBTzZvQixRQUFQLENBQWtCQSxRQUFsQixDQUNBN29CLE9BQU9uc0IsUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQW1zQixPQUFPbnpCLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0FtekIsT0FBT3lnQixNQUFQLENBQWdCQSxNQUFoQixDQUNBemdCLE9BQU8wZ0IsV0FBUCxDQUFxQkEsV0FBckIsQ0FDQTFnQixPQUFPK29CLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0Evb0IsT0FBT3RzQixPQUFQLENBQWlCQSxPQUFqQixDQUNBc3NCLE9BQU9oSixNQUFQLENBQWdCQSxNQUFoQixDQUNBZ0osT0FBT3F0QixLQUFQLENBQWVBLEtBQWYsQ0FDQXJ0QixPQUFPeEUsWUFBUCxDQUFzQkEsWUFBdEIsQ0FDQXdFLE9BQU80Z0IsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQTVnQixPQUFPdEYsSUFBUCxDQUFjQSxJQUFkLENBQ0FzRixPQUFPZ3BCLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0FocEIsT0FBT2doQixJQUFQLENBQWNBLElBQWQsQ0FDQWhoQixPQUFPK2MsV0FBUCxDQUFxQkEsV0FBckIsQ0FDQS9jLE9BQU9nZCxhQUFQLENBQXVCQSxhQUF2QixDQUNBaGQsT0FBT2lkLGFBQVAsQ0FBdUJBLGFBQXZCLENBQ0FqZCxPQUFPa2QsZUFBUCxDQUF5QkEsZUFBekIsQ0FDQWxkLE9BQU9tZCxpQkFBUCxDQUEyQkEsaUJBQTNCLENBQ0FuZCxPQUFPb2QsaUJBQVAsQ0FBMkJBLGlCQUEzQixDQUNBcGQsT0FBT2lwQixTQUFQLENBQW1CQSxTQUFuQixDQUNBanBCLE9BQU9rcEIsVUFBUCxDQUFvQkEsVUFBcEIsQ0FDQWxwQixPQUFPc3RCLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0F0dEIsT0FBT3l0QixHQUFQLENBQWFBLEdBQWIsQ0FDQXp0QixPQUFPMHRCLEtBQVAsQ0FBZUEsS0FBZixDQUNBMXRCLE9BQU9tcEIsUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQW5wQixPQUFPcXNCLEtBQVAsQ0FBZUEsS0FBZixDQUNBcnNCLE9BQU80WCxRQUFQLENBQWtCQSxRQUFsQixDQUNBNVgsT0FBT2dJLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0FoSSxPQUFPaUksUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQWpJLE9BQU9tcUIsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQW5xQixPQUFPOFgsUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQTlYLE9BQU80bEIsYUFBUCxDQUF1QkEsYUFBdkIsQ0FDQTVsQixPQUFPM0YsUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQTJGLE9BQU9vcUIsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQXBxQixPQUFPc3FCLElBQVAsQ0FBY0EsSUFBZCxDQUNBdHFCLE9BQU91cUIsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQXZxQixPQUFPd3FCLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0F4cUIsT0FBT3lxQixRQUFQLENBQWtCQSxRQUFsQixDQUNBenFCLE9BQU84cUIsUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQTlxQixPQUFPdXNCLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0F2c0IsT0FBTytxQixTQUFQLENBQW1CQSxTQUFuQixDQUNBL3FCLE9BQU9pb0IsVUFBUCxDQUFvQkEsVUFBcEIsQ0FFQTtBQUNBam9CLE9BQU84dEIsSUFBUCxDQUFjOS9DLE9BQWQsQ0FDQWd5QixPQUFPK3RCLFNBQVAsQ0FBbUI5TixZQUFuQixDQUNBamdCLE9BQU9ndUIsS0FBUCxDQUFlL1IsSUFBZixDQUVBeVAsTUFBTTFyQixNQUFOLENBQWUsVUFBVyxDQUN4QixHQUFJL1EsUUFBUyxFQUFiLENBQ0F3WSxXQUFXekgsTUFBWCxDQUFtQixTQUFTOUosSUFBVCxDQUFlNmUsVUFBZixDQUEyQixDQUM1QyxHQUFJLENBQUN4WSxlQUFlalksSUFBZixDQUFvQjBiLE9BQU9sRSxTQUEzQixDQUFzQ2laLFVBQXRDLENBQUwsQ0FBd0QsQ0FDdEQ5bEIsT0FBTzhsQixVQUFQLEVBQXFCN2UsSUFBckIsQ0FDRCxDQUNGLENBSkQsRUFLQSxNQUFPakgsT0FBUCxDQUNELENBUmMsRUFBZixDQVFNLENBQUUsUUFBUyxLQUFYLENBUk4sRUFVQSw0RUFFQTs7Ozs7O09BT0ErUSxPQUFPNWYsT0FBUCxDQUFpQkEsT0FBakIsQ0FFQTtBQUNBc1csVUFBVSxDQUFDLE1BQUQsQ0FBUyxTQUFULENBQW9CLE9BQXBCLENBQTZCLFlBQTdCLENBQTJDLFNBQTNDLENBQXNELGNBQXRELENBQVYsQ0FBaUYsU0FBU3FlLFVBQVQsQ0FBcUIsQ0FDcEcvVSxPQUFPK1UsVUFBUCxFQUFtQm5iLFdBQW5CLENBQWlDb0csTUFBakMsQ0FDRCxDQUZELEVBSUE7QUFDQXRKLFVBQVUsQ0FBQyxNQUFELENBQVMsTUFBVCxDQUFWLENBQTRCLFNBQVNxZSxVQUFULENBQXFCNTZCLEtBQXJCLENBQTRCLENBQ3REK2xCLFlBQVlwRSxTQUFaLENBQXNCaVosVUFBdEIsRUFBb0MsU0FBU2hjLENBQVQsQ0FBWSxDQUM5QyxHQUFJazFCLFVBQVcsS0FBS2x0QixZQUFwQixDQUNBLEdBQUlrdEIsVUFBWSxDQUFDOXpDLEtBQWpCLENBQXdCLENBQ3RCLE1BQU8sSUFBSStsQixZQUFKLENBQWdCLElBQWhCLENBQVAsQ0FDRCxDQUNEbkgsRUFBSUEsSUFBTXZwQixTQUFOLENBQWtCLENBQWxCLENBQXNCOHVCLFVBQVUwSixVQUFValAsQ0FBVixDQUFWLENBQXdCLENBQXhCLENBQTFCLENBRUEsR0FBSS9CLFFBQVMsS0FBS3NLLEtBQUwsRUFBYixDQUNBLEdBQUkyc0IsUUFBSixDQUFjLENBQ1pqM0IsT0FBT2lLLGFBQVAsQ0FBdUIxQyxVQUFVeEYsQ0FBVixDQUFhL0IsT0FBT2lLLGFBQXBCLENBQXZCLENBQ0QsQ0FGRCxJQUVPLENBQ0xqSyxPQUFPa0ssU0FBUCxDQUFpQjd1QixJQUFqQixDQUFzQixDQUNwQixPQUFRa3NCLFVBQVV4RixDQUFWLENBQWFyTSxnQkFBYixDQURZLENBRXBCLE9BQVFxb0IsWUFBYy9kLE9BQU84SixPQUFQLENBQWlCLENBQWpCLENBQXFCLE9BQXJCLENBQStCLEVBQTdDLENBRlksQ0FBdEIsRUFJRCxDQUNELE1BQU85SixPQUFQLENBQ0QsQ0FqQkQsQ0FtQkFrSixZQUFZcEUsU0FBWixDQUFzQmlaLFdBQWEsT0FBbkMsRUFBOEMsU0FBU2hjLENBQVQsQ0FBWSxDQUN4RCxNQUFPLE1BQUt0UixPQUFMLEdBQWVzdEIsVUFBZixFQUEyQmhjLENBQTNCLEVBQThCdFIsT0FBOUIsRUFBUCxDQUNELENBRkQsQ0FHRCxDQXZCRCxFQXlCQTtBQUNBaVAsVUFBVSxDQUFDLFFBQUQsQ0FBVyxLQUFYLENBQWtCLFdBQWxCLENBQVYsQ0FBMEMsU0FBU3FlLFVBQVQsQ0FBcUI1NkIsS0FBckIsQ0FBNEIsQ0FDcEUsR0FBSTFSLE1BQU8wUixNQUFRLENBQW5CLENBQ0krekMsU0FBV3psRCxNQUFRMGpCLGdCQUFSLEVBQTRCMWpCLE1BQVE0akIsZUFEbkQsQ0FHQTZULFlBQVlwRSxTQUFaLENBQXNCaVosVUFBdEIsRUFBb0MsU0FBU3ZlLFFBQVQsQ0FBbUIsQ0FDckQsR0FBSVEsUUFBUyxLQUFLc0ssS0FBTCxFQUFiLENBQ0F0SyxPQUFPZ0ssYUFBUCxDQUFxQjN1QixJQUFyQixDQUEwQixDQUN4QixXQUFZNDdCLFlBQVl6WCxRQUFaLENBQXNCLENBQXRCLENBRFksQ0FFeEIsT0FBUS90QixJQUZnQixDQUExQixFQUlBdXVCLE9BQU8rSixZQUFQLENBQXNCL0osT0FBTytKLFlBQVAsRUFBdUJtdEIsUUFBN0MsQ0FDQSxNQUFPbDNCLE9BQVAsQ0FDRCxDQVJELENBU0QsQ0FiRCxFQWVBO0FBQ0FOLFVBQVUsQ0FBQyxNQUFELENBQVMsTUFBVCxDQUFWLENBQTRCLFNBQVNxZSxVQUFULENBQXFCNTZCLEtBQXJCLENBQTRCLENBQ3RELEdBQUlnMEMsVUFBVyxRQUFVaDBDLE1BQVEsT0FBUixDQUFrQixFQUE1QixDQUFmLENBRUErbEIsWUFBWXBFLFNBQVosQ0FBc0JpWixVQUF0QixFQUFvQyxVQUFXLENBQzdDLE1BQU8sTUFBS29aLFFBQUwsRUFBZSxDQUFmLEVBQWtCNWtELEtBQWxCLEdBQTBCLENBQTFCLENBQVAsQ0FDRCxDQUZELENBR0QsQ0FORCxFQVFBO0FBQ0FtdEIsVUFBVSxDQUFDLFNBQUQsQ0FBWSxNQUFaLENBQVYsQ0FBK0IsU0FBU3FlLFVBQVQsQ0FBcUI1NkIsS0FBckIsQ0FBNEIsQ0FDekQsR0FBSWkwQyxVQUFXLFFBQVVqMEMsTUFBUSxFQUFSLENBQWEsT0FBdkIsQ0FBZixDQUVBK2xCLFlBQVlwRSxTQUFaLENBQXNCaVosVUFBdEIsRUFBb0MsVUFBVyxDQUM3QyxNQUFPLE1BQUtoVSxZQUFMLENBQW9CLEdBQUliLFlBQUosQ0FBZ0IsSUFBaEIsQ0FBcEIsQ0FBNEMsS0FBS2t1QixRQUFMLEVBQWUsQ0FBZixDQUFuRCxDQUNELENBRkQsQ0FHRCxDQU5ELEVBUUFsdUIsWUFBWXBFLFNBQVosQ0FBc0IzVixPQUF0QixDQUFnQyxVQUFXLENBQ3pDLE1BQU8sTUFBS3hFLE1BQUwsQ0FBWTJxQixRQUFaLENBQVAsQ0FDRCxDQUZELENBSUFwTSxZQUFZcEUsU0FBWixDQUFzQjhqQixJQUF0QixDQUE2QixTQUFTL29CLFNBQVQsQ0FBb0IsQ0FDL0MsTUFBTyxNQUFLbFYsTUFBTCxDQUFZa1YsU0FBWixFQUF1Qm9sQixJQUF2QixFQUFQLENBQ0QsQ0FGRCxDQUlBL2IsWUFBWXBFLFNBQVosQ0FBc0IrakIsUUFBdEIsQ0FBaUMsU0FBU2hwQixTQUFULENBQW9CLENBQ25ELE1BQU8sTUFBS3BQLE9BQUwsR0FBZW00QixJQUFmLENBQW9CL29CLFNBQXBCLENBQVAsQ0FDRCxDQUZELENBSUFxSixZQUFZcEUsU0FBWixDQUFzQnNrQixTQUF0QixDQUFrQ3RSLFNBQVMsU0FBU2pHLElBQVQsQ0FBZXpTLElBQWYsQ0FBcUIsQ0FDOUQsR0FBSSxNQUFPeVMsS0FBUCxFQUFlLFVBQW5CLENBQStCLENBQzdCLE1BQU8sSUFBSTNJLFlBQUosQ0FBZ0IsSUFBaEIsQ0FBUCxDQUNELENBQ0QsTUFBTyxNQUFLdGpCLEdBQUwsQ0FBUyxTQUFTclQsS0FBVCxDQUFnQixDQUM5QixNQUFPNGdDLFlBQVc1Z0MsS0FBWCxDQUFrQnMvQixJQUFsQixDQUF3QnpTLElBQXhCLENBQVAsQ0FDRCxDQUZNLENBQVAsQ0FHRCxDQVBpQyxDQUFsQyxDQVNBOEosWUFBWXBFLFNBQVosQ0FBc0JyakIsTUFBdEIsQ0FBK0IsU0FBU29lLFNBQVQsQ0FBb0IsQ0FDakQsTUFBTyxNQUFLbFYsTUFBTCxDQUFZZy9CLE9BQU8xUyxZQUFZcFgsU0FBWixDQUFQLENBQVosQ0FBUCxDQUNELENBRkQsQ0FJQXFKLFlBQVlwRSxTQUFaLENBQXNCMlYsS0FBdEIsQ0FBOEIsU0FBUzNQLEtBQVQsQ0FBZ0JDLEdBQWhCLENBQXFCLENBQ2pERCxNQUFRa0csVUFBVWxHLEtBQVYsQ0FBUixDQUVBLEdBQUk5SyxRQUFTLElBQWIsQ0FDQSxHQUFJQSxPQUFPK0osWUFBUCxHQUF3QmUsTUFBUSxDQUFSLEVBQWFDLElBQU0sQ0FBM0MsQ0FBSixDQUFtRCxDQUNqRCxNQUFPLElBQUk3QixZQUFKLENBQWdCbEosTUFBaEIsQ0FBUCxDQUNELENBQ0QsR0FBSThLLE1BQVEsQ0FBWixDQUFlLENBQ2I5SyxPQUFTQSxPQUFPeW1CLFNBQVAsQ0FBaUIsQ0FBQzNiLEtBQWxCLENBQVQsQ0FDRCxDQUZELElBRU8sSUFBSUEsS0FBSixDQUFXLENBQ2hCOUssT0FBU0EsT0FBT2xXLElBQVAsQ0FBWWdoQixLQUFaLENBQVQsQ0FDRCxDQUNELEdBQUlDLE1BQVF2eUIsU0FBWixDQUF1QixDQUNyQnV5QixJQUFNaUcsVUFBVWpHLEdBQVYsQ0FBTixDQUNBL0ssT0FBUytLLElBQU0sQ0FBTixDQUFVL0ssT0FBT3VrQixTQUFQLENBQWlCLENBQUN4WixHQUFsQixDQUFWLENBQW1DL0ssT0FBT3dtQixJQUFQLENBQVl6YixJQUFNRCxLQUFsQixDQUE1QyxDQUNELENBQ0QsTUFBTzlLLE9BQVAsQ0FDRCxDQWpCRCxDQW1CQWtKLFlBQVlwRSxTQUFaLENBQXNCNGhCLGNBQXRCLENBQXVDLFNBQVM3bUIsU0FBVCxDQUFvQixDQUN6RCxNQUFPLE1BQUtwUCxPQUFMLEdBQWVrMkIsU0FBZixDQUF5QjltQixTQUF6QixFQUFvQ3BQLE9BQXBDLEVBQVAsQ0FDRCxDQUZELENBSUF5WSxZQUFZcEUsU0FBWixDQUFzQnNqQixPQUF0QixDQUFnQyxVQUFXLENBQ3pDLE1BQU8sTUFBSzVCLElBQUwsQ0FBVTl3QixnQkFBVixDQUFQLENBQ0QsQ0FGRCxDQUlBO0FBQ0ErYSxXQUFXdkgsWUFBWXBFLFNBQXZCLENBQWtDLFNBQVM1RixJQUFULENBQWU2ZSxVQUFmLENBQTJCLENBQzNELEdBQUlzWixlQUFnQixxQ0FBcUNod0MsSUFBckMsQ0FBMEMwMkIsVUFBMUMsQ0FBcEIsQ0FDSXVaLFFBQVUsa0JBQWtCandDLElBQWxCLENBQXVCMDJCLFVBQXZCLENBRGQsQ0FFSXdaLFdBQWF2dUIsT0FBT3N1QixRQUFXLFFBQVV2WixZQUFjLE1BQWQsQ0FBdUIsT0FBdkIsQ0FBaUMsRUFBM0MsQ0FBWCxDQUE2REEsVUFBcEUsQ0FGakIsQ0FHSXlaLGFBQWVGLFNBQVcsUUFBUWp3QyxJQUFSLENBQWEwMkIsVUFBYixDQUg5QixDQUtBLEdBQUksQ0FBQ3daLFVBQUwsQ0FBaUIsQ0FDZixPQUNELENBQ0R2dUIsT0FBT2xFLFNBQVAsQ0FBaUJpWixVQUFqQixFQUErQixVQUFXLENBQ3hDLEdBQUl4ckMsT0FBUSxLQUFLZzNCLFdBQWpCLENBQ0luSyxLQUFPazRCLFFBQVUsQ0FBQyxDQUFELENBQVYsQ0FBZ0J2ZixTQUQzQixDQUVJMGYsT0FBU2xsRCxnQkFBaUIyMkIsWUFGOUIsQ0FHSTFKLFNBQVdKLEtBQUssQ0FBTCxDQUhmLENBSUlzNEIsUUFBVUQsUUFBVXBtQyxRQUFROWUsS0FBUixDQUp4QixDQU1BLEdBQUl3MUMsYUFBYyxTQUFTeDFDLEtBQVQsQ0FBZ0IsQ0FDaEMsR0FBSXl0QixRQUFTdTNCLFdBQVdua0MsS0FBWCxDQUFpQjRWLE1BQWpCLENBQXlCMUksVUFBVSxDQUFDL3RCLEtBQUQsQ0FBVixDQUFtQjZzQixJQUFuQixDQUF6QixDQUFiLENBQ0EsTUFBUWs0QixVQUFXaHVCLFFBQVosQ0FBd0J0SixPQUFPLENBQVAsQ0FBeEIsQ0FBb0NBLE1BQTNDLENBQ0QsQ0FIRCxDQUtBLEdBQUkwM0IsU0FBV0wsYUFBWCxFQUE0QixNQUFPNzNCLFNBQVAsRUFBbUIsVUFBL0MsRUFBNkRBLFNBQVM1bkIsTUFBVCxFQUFtQixDQUFwRixDQUF1RixDQUNyRjtBQUNBNi9DLE9BQVNDLFFBQVUsS0FBbkIsQ0FDRCxDQUNELEdBQUlwdUIsVUFBVyxLQUFLRyxTQUFwQixDQUNJa3VCLFNBQVcsQ0FBQyxDQUFDLEtBQUtudUIsV0FBTCxDQUFpQjV4QixNQURsQyxDQUVJZ2dELFlBQWNKLGNBQWdCLENBQUNsdUIsUUFGbkMsQ0FHSXV1QixTQUFXSixRQUFVLENBQUNFLFFBSDFCLENBS0EsR0FBSSxDQUFDSCxZQUFELEVBQWlCRSxPQUFyQixDQUE4QixDQUM1Qm5sRCxNQUFRc2xELFNBQVd0bEQsS0FBWCxDQUFtQixHQUFJMjJCLFlBQUosQ0FBZ0IsSUFBaEIsQ0FBM0IsQ0FDQSxHQUFJbEosUUFBU2QsS0FBSzlMLEtBQUwsQ0FBVzdnQixLQUFYLENBQWtCNnNCLElBQWxCLENBQWIsQ0FDQVksT0FBT3dKLFdBQVAsQ0FBbUJudUIsSUFBbkIsQ0FBd0IsQ0FBRSxPQUFRMmpDLElBQVYsQ0FBZ0IsT0FBUSxDQUFDK0ksV0FBRCxDQUF4QixDQUF1QyxVQUFXdnZDLFNBQWxELENBQXhCLEVBQ0EsTUFBTyxJQUFJMndCLGNBQUosQ0FBa0JuSixNQUFsQixDQUEwQnNKLFFBQTFCLENBQVAsQ0FDRCxDQUNELEdBQUlzdUIsYUFBZUMsUUFBbkIsQ0FBNkIsQ0FDM0IsTUFBTzM0QixNQUFLOUwsS0FBTCxDQUFXLElBQVgsQ0FBaUJnTSxJQUFqQixDQUFQLENBQ0QsQ0FDRFksT0FBUyxLQUFLZ2YsSUFBTCxDQUFVK0ksV0FBVixDQUFULENBQ0EsTUFBTzZQLGFBQWVOLFFBQVV0M0IsT0FBT3p0QixLQUFQLEdBQWUsQ0FBZixDQUFWLENBQThCeXRCLE9BQU96dEIsS0FBUCxFQUE3QyxDQUErRHl0QixNQUF0RSxDQUNELENBaENELENBaUNELENBMUNELEVBNENBO0FBQ0FOLFVBQVUsQ0FBQyxLQUFELENBQVEsTUFBUixDQUFnQixPQUFoQixDQUF5QixNQUF6QixDQUFpQyxRQUFqQyxDQUEyQyxTQUEzQyxDQUFWLENBQWlFLFNBQVNxZSxVQUFULENBQXFCLENBQ3BGLEdBQUk3ZSxNQUFPMkYsV0FBV2taLFVBQVgsQ0FBWCxDQUNJK1osVUFBWSwwQkFBMEJ6d0MsSUFBMUIsQ0FBK0IwMkIsVUFBL0IsRUFBNkMsS0FBN0MsQ0FBcUQsTUFEckUsQ0FFSXlaLGFBQWUsa0JBQWtCbndDLElBQWxCLENBQXVCMDJCLFVBQXZCLENBRm5CLENBSUEvVSxPQUFPbEUsU0FBUCxDQUFpQmlaLFVBQWpCLEVBQStCLFVBQVcsQ0FDeEMsR0FBSTNlLE1BQU8yWSxTQUFYLENBQ0EsR0FBSXlmLGNBQWdCLENBQUMsS0FBSy90QixTQUExQixDQUFxQyxDQUNuQyxHQUFJbDNCLE9BQVEsS0FBS0EsS0FBTCxFQUFaLENBQ0EsTUFBTzJzQixNQUFLOUwsS0FBTCxDQUFXL0IsUUFBUTllLEtBQVIsRUFBaUJBLEtBQWpCLENBQXlCLEVBQXBDLENBQXdDNnNCLElBQXhDLENBQVAsQ0FDRCxDQUNELE1BQU8sTUFBSzA0QixTQUFMLEVBQWdCLFNBQVN2bEQsS0FBVCxDQUFnQixDQUNyQyxNQUFPMnNCLE1BQUs5TCxLQUFMLENBQVcvQixRQUFROWUsS0FBUixFQUFpQkEsS0FBakIsQ0FBeUIsRUFBcEMsQ0FBd0M2c0IsSUFBeEMsQ0FBUCxDQUNELENBRk0sQ0FBUCxDQUdELENBVEQsQ0FVRCxDQWZELEVBaUJBO0FBQ0FxUixXQUFXdkgsWUFBWXBFLFNBQXZCLENBQWtDLFNBQVM1RixJQUFULENBQWU2ZSxVQUFmLENBQTJCLENBQzNELEdBQUl3WixZQUFhdnVCLE9BQU8rVSxVQUFQLENBQWpCLENBQ0EsR0FBSXdaLFVBQUosQ0FBZ0IsQ0FDZCxHQUFJamxELEtBQU9pbEQsV0FBV3oxQyxJQUFYLENBQWtCLEVBQTdCLENBQ0lpMkMsTUFBUTF2QixVQUFVLzFCLEdBQVYsSUFBbUIrMUIsVUFBVS8xQixHQUFWLEVBQWlCLEVBQXBDLENBRFosQ0FHQXlsRCxNQUFNMThDLElBQU4sQ0FBVyxDQUFFLE9BQVEwaUMsVUFBVixDQUFzQixPQUFRd1osVUFBOUIsQ0FBWCxFQUNELENBQ0YsQ0FSRCxFQVVBbHZCLFVBQVVxVyxhQUFhbG1DLFNBQWIsQ0FBd0I0YixhQUF4QixFQUF1Q3RTLElBQWpELEVBQXlELENBQUMsQ0FDeEQsT0FBUSxTQURnRCxDQUV4RCxPQUFRdEosU0FGZ0QsQ0FBRCxDQUF6RCxDQUtBO0FBQ0Ewd0IsWUFBWXBFLFNBQVosQ0FBc0J3RixLQUF0QixDQUE4QkgsU0FBOUIsQ0FDQWpCLFlBQVlwRSxTQUFaLENBQXNCclUsT0FBdEIsQ0FBZ0M0WixXQUFoQyxDQUNBbkIsWUFBWXBFLFNBQVosQ0FBc0J2eUIsS0FBdEIsQ0FBOEJnNEIsU0FBOUIsQ0FFQTtBQUNBdkIsT0FBT2xFLFNBQVAsQ0FBaUJrcUIsRUFBakIsQ0FBc0JoSCxTQUF0QixDQUNBaGYsT0FBT2xFLFNBQVAsQ0FBaUIraUIsS0FBakIsQ0FBeUJJLFlBQXpCLENBQ0FqZixPQUFPbEUsU0FBUCxDQUFpQmt6QixNQUFqQixDQUEwQjlQLGFBQTFCLENBQ0FsZixPQUFPbEUsU0FBUCxDQUFpQjlhLElBQWpCLENBQXdCbStCLFdBQXhCLENBQ0FuZixPQUFPbEUsU0FBUCxDQUFpQnVhLEtBQWpCLENBQXlCaUosWUFBekIsQ0FDQXRmLE9BQU9sRSxTQUFQLENBQWlCclUsT0FBakIsQ0FBMkI4M0IsY0FBM0IsQ0FDQXZmLE9BQU9sRSxTQUFQLENBQWlCbXpCLE1BQWpCLENBQTBCanZCLE9BQU9sRSxTQUFQLENBQWlCZ0UsT0FBakIsQ0FBMkJFLE9BQU9sRSxTQUFQLENBQWlCdnlCLEtBQWpCLENBQXlCazJDLFlBQTlFLENBRUE7QUFDQXpmLE9BQU9sRSxTQUFQLENBQWlCa3lCLEtBQWpCLENBQXlCaHVCLE9BQU9sRSxTQUFQLENBQWlCbWdCLElBQTFDLENBRUEsR0FBSS9lLGNBQUosQ0FBb0IsQ0FDbEI4QyxPQUFPbEUsU0FBUCxDQUFpQm9CLGNBQWpCLEVBQW1DbWlCLGlCQUFuQyxDQUNELENBQ0QsTUFBT3JmLE9BQVAsQ0FDRCxDQUVELDhFQUVBO0FBQ0EsR0FBSXR5QixHQUFJOHRCLGNBQVIsQ0FFQTtBQUNBLEdBQUksSUFBSixDQUFnRixDQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBakgsS0FBSzdtQixDQUFMLENBQVNBLENBQVQsQ0FFQTtBQUNBO0FBQ0Esa0NBQU8sVUFBVyxDQUNoQixNQUFPQSxFQUFQLENBQ0QsQ0FGRCx1SkFHRCxDQUNEO0FBYkEsSUFjSyxJQUFJa25CLFVBQUosQ0FBZ0IsQ0FDbkI7QUFDQSxDQUFDQSxXQUFXRixPQUFYLENBQXFCaG5CLENBQXRCLEVBQXlCQSxDQUF6QixDQUE2QkEsQ0FBN0IsQ0FDQTtBQUNBK21CLFlBQVkvbUIsQ0FBWixDQUFnQkEsQ0FBaEIsQ0FDRCxDQUxJLElBTUEsQ0FDSDtBQUNBNm1CLEtBQUs3bUIsQ0FBTCxDQUFTQSxDQUFULENBQ0QsQ0FDRixDQXAxZ0JDLEVBbzFnQkE0VyxJQXAxZ0JBLENBbzFnQkssSUFwMWdCTCxDQUFELEM7Ozs7Ozs7QUNSRHVRLE9BQU9ILE9BQVAsR0FBaUIsVUFBU0csTUFBVCxFQUFpQjtBQUNqQyxLQUFHLENBQUNBLE9BQU9xNkIsZUFBWCxFQUE0QjtBQUMzQnI2QixTQUFPczZCLFNBQVAsR0FBbUIsWUFBVyxDQUFFLENBQWhDO0FBQ0F0NkIsU0FBTzRRLEtBQVAsR0FBZSxFQUFmO0FBQ0E7QUFDQSxNQUFHLENBQUM1USxPQUFPdTZCLFFBQVgsRUFBcUJ2NkIsT0FBT3U2QixRQUFQLEdBQWtCLEVBQWxCO0FBQ3JCdjVDLFNBQU9xcEIsY0FBUCxDQUFzQnJLLE1BQXRCLEVBQThCLFFBQTlCLEVBQXdDO0FBQ3ZDdzZCLGVBQVksSUFEMkI7QUFFdkNDLGlCQUFjLEtBRnlCO0FBR3ZDcm1ELFFBQUssWUFBVztBQUFFLFdBQU80ckIsT0FBTzA2QixDQUFkO0FBQWtCO0FBSEcsR0FBeEM7QUFLQTE1QyxTQUFPcXBCLGNBQVAsQ0FBc0JySyxNQUF0QixFQUE4QixJQUE5QixFQUFvQztBQUNuQ3c2QixlQUFZLElBRHVCO0FBRW5DQyxpQkFBYyxLQUZxQjtBQUduQ3JtRCxRQUFLLFlBQVc7QUFBRSxXQUFPNHJCLE9BQU85ZCxDQUFkO0FBQWtCO0FBSEQsR0FBcEM7QUFLQThkLFNBQU9xNkIsZUFBUCxHQUF5QixDQUF6QjtBQUNBO0FBQ0QsUUFBT3I2QixNQUFQO0FBQ0EsQ0FuQkQsQyIsImZpbGUiOiJlbnRyeXBvaW50LnN5bmMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9yeSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb3J5IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHR9KTtcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gOCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgMWE4NGZjZmU5Y2M0YmYwOWQ4MjIiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7aXBjUmVuZGVyZXJ9IGZyb20gJ2VsZWN0cm9uJztcblxuY29uc3QgcHJlcGFyZVN0YWNrVGV4dCA9IChlcnJTdGFjaykgPT4ge1xuXHRyZXR1cm4gZXJyU3RhY2suc3BsaXQoJ1xcbiAgICAnKTtcbn07XG5cbmNvbnN0IGZsYXR0ZW5FcnJvciA9IChlcnIpID0+IHtcblx0Y29uc3QgaXNFcnJvckluc3RhbmNlID0gZXJyIGluc3RhbmNlb2YgRXJyb3I7IFxuXHRjb25zdCBtZXNzYWdlID0gaXNFcnJvckluc3RhbmNlID8gZXJyLm1lc3NhZ2UgOiBlcnI7XG5cdGNvbnN0IHN0YWNrID0gaXNFcnJvckluc3RhbmNlID8gcHJlcGFyZVN0YWNrVGV4dChlcnIuc3RhY2spIDogbnVsbDtcblxuXHRyZXR1cm4ge21lc3NhZ2UsIHN0YWNrfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IChmaWxlKSA9PiB7XG5cdC8vIGxpc3RlbiB0byBub2RlLXJlbGF0ZWQgZXJyb3JzXG5cdHByb2Nlc3Mub24oJ3VuY2F1Z2h0RXhjZXB0aW9uJywgZXJyID0+IHtcblx0XHQvLyBUT0RPIGxvZyBlcnJvcnMgdG8gSW5kZXhlZERCXG5cdFx0Ly8gTG9nTWFuYWdlci5lcnJvcihtc2dFcnJvcik7XG5cblx0XHRpcGNSZW5kZXJlci5zZW5kKCdyZW5kZXJlckVycm9yJywge1xuXHRcdFx0ZmlsZSxcblx0XHRcdGVycjogZmxhdHRlbkVycm9yKGVyciksXG5cdFx0XHR0eXBlOiAndW5jYXVnaHRFeGNlcHRpb24nXG5cdFx0fSk7XG5cdH0pO1xuXG5cdC8vIGxpc3RlbiB0byB1bmhhbmRsZWQgcHJvbWlzZXMgYmVpbmcgcmVqZWN0ZWRcblx0cHJvY2Vzcy5vbigndW5oYW5kbGVkUmVqZWN0aW9uJywgcmVhc29uID0+IHtcblx0XHQvLyBUT0RPIGxvZyBlcnJvcnMgdG8gSW5kZXhlZERCXG5cdFx0Ly8gTG9nTWFuYWdlci5lcnJvcihtc2dFcnJvcik7XG5cdFx0Ly8gcmVhc29uIGlzIG1vc3RseSBhbiBFcnJvciBpbnN0YW5jZVxuXG5cdFx0aXBjUmVuZGVyZXIuc2VuZCgncmVuZGVyZXJFcnJvcicsIHtcblx0XHRcdGZpbGUsXG5cdFx0XHRlcnI6IGZsYXR0ZW5FcnJvcihlcnIpLFxuXHRcdFx0dHlwZTogJ3VuaGFuZGxlZFJlamVjdGlvbidcblx0XHR9KTtcblx0fSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmNfZWxlY3Ryb24vdWkvanMvZXJyb3JoYW5kbGVyLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZWxlY3Ryb25cIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJlbGVjdHJvblwiXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQge29wZW5NZXRhfSBmcm9tICcuL2lkYic7XG5cbmNvbnN0IE9CSl9TVE9SRV9OQU1FID0gJ2tleXZhbHVlcyc7XG5cbmNsYXNzIFN0b3JhZ2Uge1xuICAgIC8vIGl0J3Mga2luZGEgbGlrZSBjb25zdHJ1Y3RvciBidXQgb3RoZXIgbW9kdWxlcyBuZWVkIHRvIGtub3cgdGhlIG1vbWVudFxuICAgIC8vIHdoZW4gc3RvcmFnZSBpcyBpbml0aWFsaXplZFxuICAgIGFzeW5jIGxvYWQoKSB7XG4gICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBvcGVuTWV0YSgpO1xuICAgICAgICBjb25zdCByZWNvcmRzID0gYXdhaXQgY29ubi5nZXQoT0JKX1NUT1JFX05BTUUpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKHJlY29yZHMpO1xuICAgICAgICB0aGlzLl9kYXRhID0gcmVjb3JkcztcbiAgICB9XG5cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jaGVja0lzSW5pdGlhbGl6ZWQoKTtcblxuXG5cbiAgICAgICAgdmFyIHN0b3JhZ2VEYXRhID0ge307XG4gICAgICAgIHN0b3JhZ2VEYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgY2hyb21lLnN0b3JhZ2UubG9jYWwuc2V0KHN0b3JhZ2VEYXRhKTtcblxuICAgICAgICB0aGlzLl9kYXRhW2tleV0gPSB2YWx1ZTtcblxuICAgICAgICAvLyB0aGlzIG9wIHNob3VsZCBub3QgYmxvY2sgb3RoZXJzIHNvIHRoZSBmdW5jdGlvbiBpcyBzdGlsbCBzeW5jXG4gICAgICAgIG9wZW5Db25uKCkudGhlbihjb25uID0+IGNvbm4udXBzZXJ0KE9CSl9TVE9SRV9OQU1FLCB7a2V5LCB2YWx1ZX0pKTtcbiAgICB9XG5cbiAgICBnZXQoa2V5LCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tJc0luaXRpYWxpemVkKCk7XG5cbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5fZGF0YVtrZXldIHx8IG51bGw7XG4gICAgICAgIGxldCB2YWx1ZUNyZWF0ZWQgPSBmYWxzZTtcblxuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgIHBhcmFtcy5jb25zdHJ1Y3RvciA9IHBhcmFtcy5jb25zdHJ1Y3RvciB8fCBTdHJpbmc7XG4gICAgICAgIHBhcmFtcy5zdHJpY3QgPSBwYXJhbXMuc3RyaWN0IHx8IGZhbHNlO1xuICAgICAgICBwYXJhbXMuY3JlYXRlID0gcGFyYW1zLmNyZWF0ZSB8fCBmYWxzZTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgJiYgcGFyYW1zLmNyZWF0ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSAocGFyYW1zLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpID8gJycgOiBuZXcgcGFyYW1zLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgICB2YWx1ZUNyZWF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy5zdHJpY3QgJiYgcGFyYW1zLmNvbnN0cnVjdG9yICE9PSBTdHJpbmcgJiYgdmFsdWVDcmVhdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8g0L/RgNC+0LLQtdGA0LrQsCDQvdCwINGC0LjQvyDQtNCw0L3QvdGL0YVcbiAgICAgICAgICAgIGFzc2VydCh2YWx1ZSBpbnN0YW5jZW9mIHBhcmFtcy5jb25zdHJ1Y3RvciwgYFdyb25nIHN0b3JhZ2UgZGF0YSB0eXBlIG9mIGtleSBcIiR7a2V5fVwiYCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmVtb3ZlKGtleSkge1xuICAgICAgICB0aGlzLl9jaGVja0lzSW5pdGlhbGl6ZWQoKTtcblxuICAgICAgICBkZWxldGUgdGhpcy5fZGF0YVtrZXldO1xuXG4gICAgICAgIC8vIHRoaXMgb3Agc2hvdWxkIG5vdCBibG9jayBvdGhlcnMgc28gdGhlIGZ1bmN0aW9uIGlzIHN0aWxsIHN5bmNcbiAgICAgICAgb3BlbkNvbm4oKS50aGVuKGNvbm4gPT4gY29ubi5kZWxldGUoT0JKX1NUT1JFX05BTUUsIGtleSkpO1xuICAgIH1cblxuICAgIF9jaGVja0lzSW5pdGlhbGl6ZWQoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLl9pbml0aWFsaXplZCwgJ1N0b3JhZ2UgaGFzblxcJ3QgeWV0IGJlZW4gaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN0b3JhZ2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmNfZWxlY3Ryb24vdWkvanMvc3RvcmFnZS5qcyIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInNrbGFkXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInNrbGFkXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uXG4gKiovXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCA4NWNmNGNlNjdhMDJkYjJhMjNiM1xuICoqL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi93ZWJwYWNrL2Jvb3RzdHJhcCA4NWNmNGNlNjdhMDJkYjJhMjNiMyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTYgRG1pdHJ5IFNvcmluIDxpbmZvQHN0YXlwb3NpdGl2ZS5ydT5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS8xOTk5L3NrbGFkXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKiBAYXV0aG9yIERtaXRyeSBTb3JpbiA8aW5mb0BzdGF5cG9zaXRpdmUucnU+XG4gKiBAbGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLmh0bWwgTUlUIExpY2Vuc2VcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgS2lub1Byb21pc2UgZnJvbSAna2lub3Byb21pc2UnO1xuaW1wb3J0IHV1aWQgZnJvbSAnLi91dWlkJztcbmltcG9ydCB7Y3JlYXRlRXJyb3IsIGVuc3VyZUVycm9yfSBmcm9tICcuL2Vycm9yJztcblxuaW1wb3J0IHtcbiAgICBpbmRleGVkRGJSZWYsXG4gICAgSURCS2V5UmFuZ2VSZWYsXG4gICAgVFJBTlNBQ1RJT05fUkVBRE9OTFksXG4gICAgVFJBTlNBQ1RJT05fUkVBRFdSSVRFLFxuICAgIFNPUlRfQVNDLFxuICAgIFNPUlRfQVNDX1VOSVFVRSxcbiAgICBTT1JUX0RFU0MsXG4gICAgU09SVF9ERVNDX1VOSVFVRVxufSBmcm9tICcuL2Vudic7XG5cbmNvbnN0IHNrbGFkQVBJID0ge307XG5za2xhZEFQSS5BU0MgPSBTT1JUX0FTQztcbnNrbGFkQVBJLkFTQ19VTklRVUUgPSBTT1JUX0FTQ19VTklRVUU7XG5za2xhZEFQSS5ERVNDID0gU09SVF9ERVNDO1xuc2tsYWRBUEkuREVTQ19VTklRVUUgPSBTT1JUX0RFU0NfVU5JUVVFO1xuXG4vLyB1bmZvcnR1bmF0ZWx5IGBiYWJlbC1wbHVnaW4tYXJyYXktaW5jbHVkZXNgIGNhbid0IGNvbnZlcnQgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4vLyBpbnRvIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIHdpdGggaXRzIGNvZGVcbmNvbnN0IGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbmNvbnN0IHN1cHBvcnRzT2JqU3RvcmVHZXRBbGwgPSB0eXBlb2YgSURCT2JqZWN0U3RvcmUucHJvdG90eXBlLmdldEFsbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSURCT2JqZWN0U3RvcmUucHJvdG90eXBlLmdldEFsbEtleXMgPT09ICdmdW5jdGlvbic7XG5jb25zdCBvYmpTdG9yZXNNZXRhID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIENvbW1vbiBhbmNlc3RvciBmb3Igb2JqZWN0cyBjcmVhdGVkIHdpdGggc2tsYWQua2V5VmFsdWUoKSBtZXRob2RcbiAqIFVzZWQgdG8gZGlzdGluZ3Vpc2ggc3RhbmRhcmQgb2JqZWN0cyB3aXRoIFwia2V5XCIgYW5kIFwidmFsdWVcIiBmaWVsZHMgZnJvbSBzcGVjaWFsIG9uZXNcbiAqL1xuY29uc3Qgc2tsYWRLZXlWYWx1ZUNvbnRhaW5lciA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbi8qKlxuICogQ2hlY2tzIGRhdGEgYmVmb3JlIHNhdmluZyBpdCBpbiB0aGUgb2JqZWN0IHN0b3JlXG4gKiBAcmV0dXJuIHtCb29sZWFufSBmYWxzZSBpZiBzYXZlZCBkYXRhIHR5cGUgaXMgaW5jb3JyZWN0LCBvdGhlcndpc2Uge0FycmF5fSBvYmplY3Qgc3RvcmUgZnVuY3Rpb24gYXJndW1lbnRzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrU2F2ZWREYXRhKGRiTmFtZSwgb2JqU3RvcmUsIGRhdGEpIHtcbiAgICBjb25zdCBrZXlWYWx1ZUNvbnRhaW5lciA9IE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKHNrbGFkS2V5VmFsdWVDb250YWluZXIsIGRhdGEpO1xuICAgIGNvbnN0IHZhbHVlID0ga2V5VmFsdWVDb250YWluZXIgPyBkYXRhLnZhbHVlIDogZGF0YTtcbiAgICBjb25zdCBvYmpTdG9yZU1ldGEgPSBvYmpTdG9yZXNNZXRhLmdldChkYk5hbWUpLmdldChvYmpTdG9yZS5uYW1lKTtcbiAgICBsZXQga2V5ID0ga2V5VmFsdWVDb250YWluZXIgPyBkYXRhLmtleSA6IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IGtleVBhdGggPSBvYmpTdG9yZS5rZXlQYXRoIHx8IG9ialN0b3JlTWV0YS5rZXlQYXRoO1xuICAgIGNvbnN0IGF1dG9JbmNyZW1lbnQgPSBvYmpTdG9yZS5hdXRvSW5jcmVtZW50IHx8IG9ialN0b3JlTWV0YS5hdXRvSW5jcmVtZW50O1xuXG4gICAgaWYgKGtleVBhdGggPT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFhdXRvSW5jcmVtZW50ICYmIGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBrZXkgPSB1dWlkKCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGRvdC1zZXBhcmF0ZWQgYW5kIGFycmF5IGtleVBhdGhzXG4gICAgICAgIGlmICghYXV0b0luY3JlbWVudCAmJiBkYXRhW2tleVBhdGhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGFba2V5UGF0aF0gPSB1dWlkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ga2V5ID8gW3ZhbHVlLCBrZXldIDogW3ZhbHVlXTtcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGRhdGFiYXNlIGNvbnRhaW5zIGFsbCBuZWVkZWQgc3RvcmVzXG4gKlxuICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBvYmpTdG9yZU5hbWVzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBjaGVja0NvbnRhaW5pbmdTdG9yZXMob2JqU3RvcmVOYW1lcykge1xuICAgIHJldHVybiBvYmpTdG9yZU5hbWVzLmV2ZXJ5KGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIChpbmRleE9mLmNhbGwodGhpcy5kYXRhYmFzZS5vYmplY3RTdG9yZU5hbWVzLCBzdG9yZU5hbWUpICE9PSAtMSk7XG4gICAgfSwgdGhpcyk7XG59XG5cbi8qKlxuICogYXV0b0luY3JlbWVudCBpcyBicm9rZW4gaW4gSUUgZmFtaWx5LiBSdW4gdGhpcyB0cmFuc2FjdGlvbiB0byBnZXQgaXRzIHZhbHVlXG4gKiBvbiBldmVyeSBvYmplY3Qgc3RvcmVcbiAqXG4gKiBAcGFyYW0ge0lEQkRhdGFiYXNlfSBkYlxuICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBvYmpTdG9yZU5hbWVzXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICpcbiAqIEBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTY4MjE2NS9pbmRleGVkZGItaW4taWUxMS1lZGdlLXdoeS1pcy1vYmpzdG9yZS1hdXRvaW5jcmVtZW50LXVuZGVmaW5lZFxuICogQHNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9GZWVkYmFjay9EZXRhaWxzLzc3MjcyNlxuICovXG5mdW5jdGlvbiBnZXRPYmpTdG9yZXNNZXRhKGRiLCBvYmpTdG9yZU5hbWVzKSB7XG4gICAgY29uc3QgZGJNZXRhID0gb2JqU3RvcmVzTWV0YS5nZXQoZGIubmFtZSk7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcblxuICAgIG9ialN0b3JlTmFtZXMuZm9yRWFjaChvYmpTdG9yZU5hbWUgPT4ge1xuICAgICAgICBpZiAoZGJNZXRhLmhhcyhvYmpTdG9yZU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFtvYmpTdG9yZU5hbWVdLCBUUkFOU0FDVElPTl9SRUFEV1JJVEUpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmFib3J0ID0gcmVzb2x2ZTtcblxuICAgICAgICAgICAgY29uc3Qgb2JqU3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShvYmpTdG9yZU5hbWUpO1xuXG4gICAgICAgICAgICBpZiAob2JqU3RvcmUuYXV0b0luY3JlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGJNZXRhLnNldChvYmpTdG9yZU5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgYXV0b0luY3JlbWVudDogb2JqU3RvcmUuYXV0b0luY3JlbWVudCxcbiAgICAgICAgICAgICAgICAgICAga2V5UGF0aDogb2JqU3RvcmUua2V5UGF0aFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgYXV0b0luY3JlbWVudDtcblxuICAgICAgICAgICAgaWYgKG9ialN0b3JlLmtleVBhdGggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBrZXkgcGF0aCBpcyBkZWZpbmVkIGl0J3MgcG9zc2libGUgdG8gaW5zZXJ0IG9ubHkgb2JqZWN0c1xuICAgICAgICAgICAgICAgIC8vIGJ1dCBpZiBrZXkgZ2VuZXJhdG9yIChhdXRvSW5jcmVtZW50KSBpcyBub3QgZGVmaW5lZCB0aGUgaW5zZXJ0ZWQgb2JqZWN0c1xuICAgICAgICAgICAgICAgIC8vIG11c3QgY29udGFpbiBmaWVsZChzKSBkZXNjcmliZWQgaW4ga2V5UGF0aCB2YWx1ZSBvdGhlcndpc2UgSURCT2JqZWN0U3RvcmUuYWRkIG9wIGZhaWxzXG4gICAgICAgICAgICAgICAgLy8gc28gaWYgd2UgcnVuIE9EQk9iamVjdFN0b3JlLmFkZCB3aXRoIGFuIGVtcHR5IG9iamVjdCBhbmQgaXQgZmFpbHMsIHRoaXMgbWVhbnMgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGF1dG9JbmNyZW1lbnQgcHJvcGVydHkgd2FzIGZhbHNlLiBPdGhlcndpc2UgLSB0cnVlXG4gICAgICAgICAgICAgICAgLy8gaWYga2V5IHBhdGggaXMgYXJyYXkgYXV0b0luY3JlbWVudCBwcm9wZXJ0eSBjYW4ndCBiZSB0cnVlXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqU3RvcmUua2V5UGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXV0b0luY3JlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpTdG9yZS5hZGQoe30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b0luY3JlbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvSW5jcmVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIGtleSBwYXRoIGlzIG5vdCBkZWZpbmVkIGl0J3MgcG9zc2libGUgdG8gaW5zZXJ0IGFueSBraW5kIG9mIGRhdGFcbiAgICAgICAgICAgICAgICAvLyBidXQgaWYga2V5IGdlbmVyYXRvciAoYXV0b0luY3JlbWVudCkgaXMgbm90IGRlZmluZWQgeW91IHNob3VsZCBzZXQgaXQgZXhwbGljaXRseVxuICAgICAgICAgICAgICAgIC8vIHNvIGlmIHdlIHJ1biBPREJPYmplY3RTdG9yZS5hZGQgd2l0aCBvbmUgYXJndW1lbnQgYW5kIGl0IGZhaWxzLCB0aGlzIG1lYW5zIHRoYXRcbiAgICAgICAgICAgICAgICAvLyBhdXRvSW5jcmVtZW50IHByb3BlcnR5IHdhcyBmYWxzZS4gT3RoZXJ3aXNlIC0gdHJ1ZVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialN0b3JlLmFkZCgnc29tZSB2YWx1ZScpO1xuICAgICAgICAgICAgICAgICAgICBhdXRvSW5jcmVtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICBhdXRvSW5jcmVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzYXZlIG1ldGEgcHJvcGVydGllc1xuICAgICAgICAgICAgZGJNZXRhLnNldChvYmpTdG9yZU5hbWUsIHtcbiAgICAgICAgICAgICAgICBhdXRvSW5jcmVtZW50OiBhdXRvSW5jcmVtZW50LFxuICAgICAgICAgICAgICAgIGtleVBhdGg6IG9ialN0b3JlLmtleVBhdGhcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBhbmQgYWJvcnQgdHJhbnNhY3Rpb24gc28gdGhhdCBuZXcgcmVjb3JkIGlzIGZvcmdvdHRlblxuICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWJvcnQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59XG5cbmNvbnN0IHNrbGFkQ29ubmVjdGlvbiA9IHtcbiAgICAvKipcbiAgICAgKiAxKSBJbnNlcnQgb25lIHJlY29yZCBpbnRvIHRoZSBvYmplY3Qgc3RvcmVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqU3RvcmVOYW1lIG5hbWUgb2Ygb2JqZWN0IHN0b3JlXG4gICAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiAgIEBwYXJhbSB7RXJyb3J9IFtlcnJdIGlmIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAgICAgKiAgIEBwYXJhbSB7Kn0gaW5zZXJ0ZWQgb2JqZWN0IGtleVxuICAgICAqXG4gICAgICogMikgSW5zZXJ0IG11bHRpcGxlIHJlY29yZHMgaW50byB0aGUgb2JqZWN0IHN0b3JlcyAoZHVyaW5nIG9uZSB0cmFuc2FjdGlvbilcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICogICBAcGFyYW0ge0Vycm9yfSBbZXJyXSBpZiBwcm9taXNlIGlzIHJlamVjdGVkXG4gICAgICogICBAcGFyYW0ge09iamVjdH0gaW5zZXJ0ZWQgb2JqZWN0cycga2V5c1xuICAgICAqL1xuICAgIGluc2VydDogZnVuY3Rpb24gc2tsYWRDb25uZWN0aW9uX2luc2VydCgpIHtcbiAgICAgICAgY29uc3QgaXNNdWx0aSA9IChhcmd1bWVudHMubGVuZ3RoID09PSAxKTtcbiAgICAgICAgY29uc3Qgb2JqU3RvcmVOYW1lcyA9IGlzTXVsdGkgPyBPYmplY3Qua2V5cyhhcmd1bWVudHNbMF0pIDogW2FyZ3VtZW50c1swXV07XG5cbiAgICAgICAgY29uc3QgYWxsT2JqU3RvcmVzRXhpc3QgPSBjaGVja0NvbnRhaW5pbmdTdG9yZXMuY2FsbCh0aGlzLCBvYmpTdG9yZU5hbWVzKTtcbiAgICAgICAgaWYgKCFhbGxPYmpTdG9yZXNFeGlzdCkge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gY3JlYXRlRXJyb3IoJ05vdEZvdW5kRXJyb3InLCBgRGF0YWJhc2UgJHt0aGlzLmRhdGFiYXNlLm5hbWV9ICh2ZXJzaW9uICR7dGhpcy5kYXRhYmFzZS52ZXJzaW9ufSkgZG9lc24ndCBjb250YWluIGFsbCBuZWVkZWQgc3RvcmVzYCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBpZiAoaXNNdWx0aSkge1xuICAgICAgICAgICAgZGF0YSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSB7fTtcbiAgICAgICAgICAgIGRhdGFbYXJndW1lbnRzWzBdXSA9IFthcmd1bWVudHNbMV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldE9ialN0b3Jlc01ldGEodGhpcy5kYXRhYmFzZSwgb2JqU3RvcmVOYW1lcykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgICAgIGxldCB0cmFuc2FjdGlvbjtcbiAgICAgICAgICAgICAgICBsZXQgYWJvcnRFcnI7XG5cbiAgICAgICAgICAgICAgICAvLyBTYWZhcmk5IGNhbid0IHJ1biBtdWx0aS1vYmplY3RzdG9yZSB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgICAgICAvLyBkaXZpZGUgb25lIHRyYW5zYWN0aW9uIGludG8gbWFueSB3aXRoIG9uZSBvYmplY3Qgc3RvcmUgdG8gZml4IHRoaXNcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiA9IHRoaXMuZGF0YWJhc2UudHJhbnNhY3Rpb24ob2JqU3RvcmVOYW1lcywgVFJBTlNBQ1RJT05fUkVBRFdSSVRFKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXgubmFtZSA9PT0gJ05vdEZvdW5kRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpTdG9yZU5hbWVzLmZvckVhY2gob2JqU3RvcmVOYW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5pbnNlcnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb2JqU3RvcmVOYW1lXTogQXJyYXkuaXNBcnJheShkYXRhW29ialN0b3JlTmFtZV0pID8gZGF0YVtvYmpTdG9yZU5hbWVdIDogW2RhdGFbb2JqU3RvcmVOYW1lXV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKHJlcyA9PiByZXNbb2JqU3RvcmVOYW1lXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlc1tvYmpTdG9yZU5hbWVdID0gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBLaW5vUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IHRyYW5zYWN0aW9uLm9uZXJyb3IgPSB0cmFuc2FjdGlvbi5vbmFib3J0ID0gZnVuY3Rpb24gc2tsYWRDb25uZWN0aW9uX2luc2VydF9vbkZpbmlzaChldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gYWJvcnRFcnIgfHwgZXZ0LnRhcmdldC5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNTdWNjZXNzID0gIWVyciAmJiBldnQudHlwZSA9PT0gJ2NvbXBsZXRlJztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGlzTXVsdGkgPyByZXN1bHQgOiByZXN1bHRbb2JqU3RvcmVOYW1lc1swXV1bMF0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVuc3VyZUVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2dC50eXBlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvYmpTdG9yZU5hbWUgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvYmpTdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKG9ialN0b3JlTmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhW29ialN0b3JlTmFtZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrZWREYXRhID0gY2hlY2tTYXZlZERhdGEodGhpcy5kYXRhYmFzZS5uYW1lLCBvYmpTdG9yZSwgZGF0YVtvYmpTdG9yZU5hbWVdW2ldKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja2VkRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0RXJyID0gY3JlYXRlRXJyb3IoJ0ludmFsaWRTdGF0ZUVycm9yJywgJ1lvdSBtdXN0IHN1cHBseSBvYmplY3RzIHRvIGJlIHNhdmVkIGluIHRoZSBvYmplY3Qgc3RvcmUgd2l0aCBzZXQga2V5UGF0aCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlcTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gb2JqU3RvcmUuYWRkLmFwcGx5KG9ialN0b3JlLCBjaGVja2VkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0RXJyID0gZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W29ialN0b3JlTmFtZV0gPSByZXN1bHRbb2JqU3RvcmVOYW1lXSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbb2JqU3RvcmVOYW1lXVtpXSA9IGV2dC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogMSkgSW5zZXJ0IG9yIHVwZGF0ZSBvbmUgcmVjb3JkIGluIHRoZSBvYmplY3Qgc3RvcmVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqU3RvcmVOYW1lIG5hbWUgb2Ygb2JqZWN0IHN0b3JlXG4gICAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiAgIEBwYXJhbSB7RXJyb3J9IFtlcnJdIGlmIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAgICAgKiAgIEBwYXJhbSB7Kn0gaW5zZXJ0ZWQvdXBkYXRlZCBvYmplY3Qga2V5IG90aGVyd2lzZVxuICAgICAqXG4gICAgICogMikgSW5zZXJ0IG9yIHVwZGF0ZSBtdWx0aXBsZSByZWNvcmRzIGluIHRoZSBvYmplY3Qgc3RvcmVzIChkdXJpbmcgb25lIHRyYW5zYWN0aW9uKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiAgIEBwYXJhbSB7RXJyb3J9IFtlcnJdIGlmIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAgICAgKiAgIEBwYXJhbSB7T2JqZWN0fSBpbnNlcnRlZC91cGRhdGVkIG9iamVjdHMnIGtleXMgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgdXBzZXJ0OiBmdW5jdGlvbiBza2xhZENvbm5lY3Rpb25fdXBzZXJ0KCkge1xuICAgICAgICBjb25zdCBpc011bHRpID0gKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpO1xuICAgICAgICBjb25zdCBvYmpTdG9yZU5hbWVzID0gaXNNdWx0aSA/IE9iamVjdC5rZXlzKGFyZ3VtZW50c1swXSkgOiBbYXJndW1lbnRzWzBdXTtcblxuICAgICAgICBjb25zdCBhbGxPYmpTdG9yZXNFeGlzdCA9IGNoZWNrQ29udGFpbmluZ1N0b3Jlcy5jYWxsKHRoaXMsIG9ialN0b3JlTmFtZXMpO1xuICAgICAgICBpZiAoIWFsbE9ialN0b3Jlc0V4aXN0KSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBjcmVhdGVFcnJvcignTm90Rm91bmRFcnJvcicsIGBEYXRhYmFzZSAke3RoaXMuZGF0YWJhc2UubmFtZX0gKHZlcnNpb24gJHt0aGlzLmRhdGFiYXNlLnZlcnNpb259KSBkb2Vzbid0IGNvbnRhaW4gYWxsIG5lZWRlZCBzdG9yZXNgKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIGlmIChpc011bHRpKSB7XG4gICAgICAgICAgICBkYXRhID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICAgICAgZGF0YVthcmd1bWVudHNbMF1dID0gW2FyZ3VtZW50c1sxXV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0T2JqU3RvcmVzTWV0YSh0aGlzLmRhdGFiYXNlLCBvYmpTdG9yZU5hbWVzKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgICAgICAgICAgbGV0IHRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgICAgIGxldCBhYm9ydEVycjtcblxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaTkgY2FuJ3QgcnVuIG11bHRpLW9iamVjdHN0b3JlIHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgICAgIC8vIGRpdmlkZSBvbmUgdHJhbnNhY3Rpb24gaW50byBtYW55IHdpdGggb25lIG9iamVjdCBzdG9yZSB0byBmaXggdGhpc1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gdGhpcy5kYXRhYmFzZS50cmFuc2FjdGlvbihvYmpTdG9yZU5hbWVzLCBUUkFOU0FDVElPTl9SRUFEV1JJVEUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleC5uYW1lID09PSAnTm90Rm91bmRFcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialN0b3JlTmFtZXMuZm9yRWFjaChvYmpTdG9yZU5hbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLnVwc2VydCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvYmpTdG9yZU5hbWVdOiBBcnJheS5pc0FycmF5KGRhdGFbb2JqU3RvcmVOYW1lXSkgPyBkYXRhW29ialN0b3JlTmFtZV0gOiBbZGF0YVtvYmpTdG9yZU5hbWVdXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4ocmVzID0+IHJlc1tvYmpTdG9yZU5hbWVdKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzW29ialN0b3JlTmFtZV0gPSBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIEtpbm9Qcm9taXNlLmFsbChwcm9taXNlcykudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmNvbXBsZXRlID0gdHJhbnNhY3Rpb24ub25lcnJvciA9IHRyYW5zYWN0aW9uLm9uYWJvcnQgPSBmdW5jdGlvbiBza2xhZENvbm5lY3Rpb25fdXBzZXJ0X29uRmluaXNoKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBhYm9ydEVyciB8fCBldnQudGFyZ2V0LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1N1Y2Nlc3MgPSAhZXJyICYmIGV2dC50eXBlID09PSAnY29tcGxldGUnO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaXNNdWx0aSA/IHJlc3VsdCA6IHJlc3VsdFtvYmpTdG9yZU5hbWVzWzBdXVswXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZW5zdXJlRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZ0LnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IG9ialN0b3JlTmFtZSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9ialN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUob2JqU3RvcmVOYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFbb2JqU3RvcmVOYW1lXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hlY2tlZERhdGEgPSBjaGVja1NhdmVkRGF0YSh0aGlzLmRhdGFiYXNlLm5hbWUsIG9ialN0b3JlLCBkYXRhW29ialN0b3JlTmFtZV1baV0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrZWREYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRFcnIgPSBjcmVhdGVFcnJvcignSW52YWxpZFN0YXRlRXJyb3InLCAnWW91IG11c3Qgc3VwcGx5IG9iamVjdHMgdG8gYmUgc2F2ZWQgaW4gdGhlIG9iamVjdCBzdG9yZSB3aXRoIHNldCBrZXlQYXRoJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEgPSBvYmpTdG9yZS5wdXQuYXBwbHkob2JqU3RvcmUsIGNoZWNrZWREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRFcnIgPSBleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbb2JqU3RvcmVOYW1lXSA9IHJlc3VsdFtvYmpTdG9yZU5hbWVdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtvYmpTdG9yZU5hbWVdW2ldID0gZXZ0LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiAxKSBEZWxldGUgb25lIHJlY29yZCBmcm9tIHRoZSBvYmplY3Qgc3RvcmVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqU3RvcmVOYW1lIG5hbWUgb2Ygb2JqZWN0IHN0b3JlXG4gICAgICogQHBhcmFtIHtNaXhlZH0ga2V5XG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiAgIEBwYXJhbSB7RXJyb3J9IFtlcnJdIGlmIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAgICAgKlxuICAgICAqIDIpIERlbGV0ZSBtdWx0aXBsZSByZWNvcmRzIGZyb20gdGhlIG9iamVjdCBzdG9yZXMgKGR1cmluZyBvbmUgdHJhbnNhY3Rpb24pXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqICAgQHBhcmFtIHtFcnJvcn0gW2Vycl0gaWYgcHJvbWlzZSBpcyByZWplY3RlZFxuICAgICAqXG4gICAgICogQVRURU5USU9OOiB5b3UgY2FuIHBhc3Mgb25seSBWQUxJRCBLRVlTIE9SIEtFWSBSQU5HRVMgdG8gZGVsZXRlIHJlY29yZHNcbiAgICAgKiBAc2VlIGh0dHBzOi8vZHZjcy53My5vcmcvaGcvSW5kZXhlZERCL3Jhdy1maWxlL3RpcC9PdmVydmlldy5odG1sI2Rmbi12YWxpZC1rZXlcbiAgICAgKiBAc2VlIGh0dHBzOi8vZHZjcy53My5vcmcvaGcvSW5kZXhlZERCL3Jhdy1maWxlL3RpcC9PdmVydmlldy5odG1sI2Rmbi1rZXktcmFuZ2VcbiAgICAgKi9cbiAgICBkZWxldGU6IGZ1bmN0aW9uIHNrbGFkQ29ubmVjdGlvbl9kZWxldGUoKSB7XG4gICAgICAgIGNvbnN0IGlzTXVsdGkgPSAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSk7XG4gICAgICAgIGNvbnN0IG9ialN0b3JlTmFtZXMgPSBpc011bHRpID8gT2JqZWN0LmtleXMoYXJndW1lbnRzWzBdKSA6IFthcmd1bWVudHNbMF1dO1xuXG4gICAgICAgIGNvbnN0IGFsbE9ialN0b3Jlc0V4aXN0ID0gY2hlY2tDb250YWluaW5nU3RvcmVzLmNhbGwodGhpcywgb2JqU3RvcmVOYW1lcyk7XG4gICAgICAgIGlmICghYWxsT2JqU3RvcmVzRXhpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IGNyZWF0ZUVycm9yKCdOb3RGb3VuZEVycm9yJywgYERhdGFiYXNlICR7dGhpcy5kYXRhYmFzZS5uYW1lfSAodmVyc2lvbiAke3RoaXMuZGF0YWJhc2UudmVyc2lvbn0pIGRvZXNuJ3QgY29udGFpbiBhbGwgbmVlZGVkIHN0b3Jlc2ApO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgaWYgKGlzTXVsdGkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0ge307XG4gICAgICAgICAgICBkYXRhW2FyZ3VtZW50c1swXV0gPSBbYXJndW1lbnRzWzFdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHJhbnNhY3Rpb247XG4gICAgICAgICAgICBsZXQgYWJvcnRFcnI7XG5cbiAgICAgICAgICAgIC8vIFNhZmFyaTkgY2FuJ3QgcnVuIG11bHRpLW9iamVjdHN0b3JlIHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgLy8gZGl2aWRlIG9uZSB0cmFuc2FjdGlvbiBpbnRvIG1hbnkgd2l0aCBvbmUgb2JqZWN0IHN0b3JlIHRvIGZpeCB0aGlzXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gdGhpcy5kYXRhYmFzZS50cmFuc2FjdGlvbihvYmpTdG9yZU5hbWVzLCBUUkFOU0FDVElPTl9SRUFEV1JJVEUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXgubmFtZSA9PT0gJ05vdEZvdW5kRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gb2JqU3RvcmVOYW1lcy5tYXAob2JqU3RvcmVOYW1lID0+IHRoaXMuZGVsZXRlKG9ialN0b3JlTmFtZSwgZGF0YVtvYmpTdG9yZU5hbWVdKSk7XG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHJlc29sdmUoKSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IHRyYW5zYWN0aW9uLm9uZXJyb3IgPSB0cmFuc2FjdGlvbi5vbmFib3J0ID0gZnVuY3Rpb24gc2tsYWRDb25uZWN0aW9uX2RlbGV0ZV9vbkZpbmlzaChldnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBhYm9ydEVyciB8fCBldnQudGFyZ2V0LmVycm9yO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZW5zdXJlRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChldnQudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKGxldCBvYmpTdG9yZU5hbWUgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9ialN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUob2JqU3RvcmVOYW1lKTtcblxuICAgICAgICAgICAgICAgIGRhdGFbb2JqU3RvcmVOYW1lXS5mb3JFYWNoKHJlY29yZEtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhYm9ydEVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialN0b3JlLmRlbGV0ZShyZWNvcmRLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRFcnIgPSBleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgb2JqZWN0IHN0b3JlKHMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gb2JqU3RvcmVOYW1lcyBhcnJheSBvZiBvYmplY3Qgc3RvcmVzIG9yIGEgc2luZ2xlIG9iamVjdCBzdG9yZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICogICBAcGFyYW0ge0Vycm9yfSBlcnJcbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24gc2tsYWRDb25uZWN0aW9uX2NsZWFyKG9ialN0b3JlTmFtZXMpIHtcbiAgICAgICAgb2JqU3RvcmVOYW1lcyA9IEFycmF5LmlzQXJyYXkob2JqU3RvcmVOYW1lcykgPyBvYmpTdG9yZU5hbWVzIDogW29ialN0b3JlTmFtZXNdO1xuXG4gICAgICAgIGNvbnN0IGFsbE9ialN0b3Jlc0V4aXN0ID0gY2hlY2tDb250YWluaW5nU3RvcmVzLmNhbGwodGhpcywgb2JqU3RvcmVOYW1lcyk7XG4gICAgICAgIGlmICghYWxsT2JqU3RvcmVzRXhpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IGNyZWF0ZUVycm9yKCdOb3RGb3VuZEVycm9yJywgYERhdGFiYXNlICR7dGhpcy5kYXRhYmFzZS5uYW1lfSAodmVyc2lvbiAke3RoaXMuZGF0YWJhc2UudmVyc2lvbn0pIGRvZXNuJ3QgY29udGFpbiBhbGwgbmVlZGVkIHN0b3Jlc2ApO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IHRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgbGV0IGFib3J0RXJyO1xuXG4gICAgICAgICAgICAvLyBTYWZhcmk5IGNhbid0IHJ1biBtdWx0aS1vYmplY3RzdG9yZSB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgIC8vIGRpdmlkZSBvbmUgdHJhbnNhY3Rpb24gaW50byBtYW55IHdpdGggb25lIG9iamVjdCBzdG9yZSB0byBmaXggdGhpc1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiA9IHRoaXMuZGF0YWJhc2UudHJhbnNhY3Rpb24ob2JqU3RvcmVOYW1lcywgVFJBTlNBQ1RJT05fUkVBRFdSSVRFKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4Lm5hbWUgPT09ICdOb3RGb3VuZEVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IG9ialN0b3JlTmFtZXMubWFwKG9ialN0b3JlTmFtZSA9PiB0aGlzLmNsZWFyKFtvYmpTdG9yZU5hbWVdKSk7XG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHJlc29sdmUoKSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IHRyYW5zYWN0aW9uLm9uZXJyb3IgPSB0cmFuc2FjdGlvbi5vbmFib3J0ID0gZnVuY3Rpb24gc2tsYWRDb25uZWN0aW9uX2NsZWFyX29uRmluaXNoKGV2dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IGFib3J0RXJyIHx8IGV2dC50YXJnZXQuZXJyb3I7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlbnN1cmVFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGV2dC50eXBlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9ialN0b3JlTmFtZXMuZm9yRWFjaChvYmpTdG9yZU5hbWUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9ialN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUob2JqU3RvcmVOYW1lKTtcblxuICAgICAgICAgICAgICAgIGlmIChhYm9ydEVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgb2JqU3RvcmUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICBhYm9ydEVyciA9IGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogMSkgR2V0IG9iamVjdHMgZnJvbSBvbmUgb2JqZWN0IHN0b3JlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9ialN0b3JlTmFtZSBuYW1lIG9mIG9iamVjdCBzdG9yZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIChvcHRpb25hbCkgb2JqZWN0IHdpdGgga2V5cyAnaW5kZXgnLCAncmFuZ2UnLCAnb2Zmc2V0JywgJ2xpbWl0JyBhbmQgJ2RpcmVjdGlvbidcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqICAgQHBhcmFtIHtFcnJvcn0gW2Vycl0gaWYgcHJvbWlzZSBpcyByZWplY3RlZFxuICAgICAqICAgQHBhcmFtIHtBcnJheX0gc3RvcmVkIG9iamVjdHMgb3RoZXJ3aXNlXG4gICAgICpcbiAgICAgKiAyKSBHZXQgb2JqZWN0cyBmcm9tIG11bHRpcGxlIG9iamVjdCBzdG9yZXMgKGR1cmluZyBvbmUgdHJhbnNhY3Rpb24pXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqICAgQHBhcmFtIHtFcnJvcn0gW2Vycl0gaWYgcHJvbWlzZSBpcyByZWplY3RlZFxuICAgICAqICAgQHBhcmFtIHtPYmplY3R9IHN0b3JlZCBvYmplY3RzIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gc2tsYWRDb25uZWN0aW9uX2dldCgpIHtcbiAgICAgICAgY29uc3QgaXNNdWx0aSA9IChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKTtcbiAgICAgICAgY29uc3Qgb2JqU3RvcmVOYW1lcyA9IGlzTXVsdGkgPyBPYmplY3Qua2V5cyhhcmd1bWVudHNbMF0pIDogW2FyZ3VtZW50c1swXV07XG5cbiAgICAgICAgY29uc3QgYWxsT2JqU3RvcmVzRXhpc3QgPSBjaGVja0NvbnRhaW5pbmdTdG9yZXMuY2FsbCh0aGlzLCBvYmpTdG9yZU5hbWVzKTtcbiAgICAgICAgaWYgKCFhbGxPYmpTdG9yZXNFeGlzdCkge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gY3JlYXRlRXJyb3IoJ05vdEZvdW5kRXJyb3InLCBgRGF0YWJhc2UgJHt0aGlzLmRhdGFiYXNlLm5hbWV9ICh2ZXJzaW9uICR7dGhpcy5kYXRhYmFzZS52ZXJzaW9ufSkgZG9lc24ndCBjb250YWluIGFsbCBuZWVkZWQgc3RvcmVzYCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgbGV0IGRhdGEsIGFib3J0RXJyO1xuXG4gICAgICAgIGlmIChpc011bHRpKSB7XG4gICAgICAgICAgICBkYXRhID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICAgICAgZGF0YVthcmd1bWVudHNbMF1dID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqU3RvcmVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChvYmpTdG9yZU5hbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdFtvYmpTdG9yZU5hbWVdID0gW107XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHJhbnNhY3Rpb247XG5cbiAgICAgICAgICAgIC8vIFNhZmFyaTkgY2FuJ3QgcnVuIG11bHRpLW9iamVjdHN0b3JlIHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgLy8gZGl2aWRlIG9uZSB0cmFuc2FjdGlvbiBpbnRvIG1hbnkgd2l0aCBvbmUgb2JqZWN0IHN0b3JlIHRvIGZpeCB0aGlzXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gdGhpcy5kYXRhYmFzZS50cmFuc2FjdGlvbihvYmpTdG9yZU5hbWVzLCBUUkFOU0FDVElPTl9SRUFET05MWSk7XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIGlmIChleC5uYW1lID09PSAnTm90Rm91bmRFcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICBvYmpTdG9yZU5hbWVzLmZvckVhY2gob2JqU3RvcmVOYW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLmdldChvYmpTdG9yZU5hbWUsIGRhdGFbb2JqU3RvcmVOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlc1tvYmpTdG9yZU5hbWVdID0gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgS2lub1Byb21pc2UuYWxsKHByb21pc2VzKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGV4KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSB0cmFuc2FjdGlvbi5vbmVycm9yID0gdHJhbnNhY3Rpb24ub25hYm9ydCA9IGZ1bmN0aW9uIHNrbGFkQ29ubmVjdGlvbl9nZXRfb25GaW5pc2goZXZ0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gYWJvcnRFcnIgfHwgZXZ0LnRhcmdldC5lcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1N1Y2Nlc3MgPSAhZXJyICYmIGV2dC50eXBlID09PSAnY29tcGxldGUnO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzU3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGlzTXVsdGkgPyByZXN1bHQgOiByZXN1bHRbb2JqU3RvcmVOYW1lc1swXV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlbnN1cmVFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZXZ0LnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yIChsZXQgb2JqU3RvcmVOYW1lIGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmpTdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKG9ialN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGRhdGFbb2JqU3RvcmVOYW1lXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbiB8fCBza2xhZEFQSS5BU0M7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBvcHRpb25zLnJhbmdlIGluc3RhbmNlb2YgSURCS2V5UmFuZ2VSZWYgPyBvcHRpb25zLnJhbmdlIDogbnVsbDtcblxuICAgICAgICAgICAgICAgIGxldCB1c2VHZXRBbGwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgaXRlcmF0ZVJlcXVlc3Q7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNPYmpTdG9yZUdldEFsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXRBbGwgZG9lc24ndCB3b3JrIGZvciBpbmRleCByYW5nZXMgKyBpdCBkb2Vzbid0IHN1cHBvcnQgc3BlY2lhbCBkaXJlY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0lEQk9iamVjdFN0b3JlL2dldEFsbFxuICAgICAgICAgICAgICAgICAgICB1c2VHZXRBbGwgPSBPYmplY3Qua2V5cyhvcHRpb25zKS5ldmVyeShrZXkgPT4gKGtleSAhPT0gJ2luZGV4JyAmJiBrZXkgIT09ICdkaXJlY3Rpb24nKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvYmpTdG9yZS5pbmRleE5hbWVzLmNvbnRhaW5zKG9wdGlvbnMuaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydEVyciA9IGNyZWF0ZUVycm9yKCdOb3RGb3VuZEVycm9yJywgYE9iamVjdCBzdG9yZSAke29ialN0b3JlLm5hbWV9IGRvZXNuJ3QgY29udGFpbiBcIiR7b3B0aW9ucy5pbmRleH1cIiBpbmRleGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGVSZXF1ZXN0ID0gb2JqU3RvcmUuaW5kZXgob3B0aW9ucy5pbmRleCkub3BlbkN1cnNvcihyYW5nZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0RXJyID0gZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHVzZUdldEFsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBicm93c2VyIHN1cHBvcnRzIGdldEFsbC9nZXRBbGxLZXlzIG1ldGhvZHMgaXQgY291bGQgYmUgZmFzdGVyIHRvIHJ1biB0aGVzZSBtZXRob2RzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGdldCBhbGwgcmVjb3JkcyBpZiB0aGVyZSdzIG5vIGBpbmRleGAgb3IgYGRpcmVjdGlvbmAgb3B0aW9ucyBzZXRcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSBnZXRBbGwgZG9lc24ndCBleHBvc2UgcmVzdWx0IGtleXMgc28gd2UgaGF2ZSB0byBydW4gYm90aCB0aGVzZSBtZXRob2RzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGdldCBhbGwga2V5cyBhbmQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIC8vIEFueXdheSBpdCBzZWVtcyBsaWtlIDIgZ2V0QWxsKiBvcHMgYXJlIGZhc3RlciBpbiBtb2Rlcm4gYnJvd3NlcnMgdGhhbiB0aGF0IG9uZVxuICAgICAgICAgICAgICAgICAgICAvLyB3b3JraW5nIHdpdGggVURCQ3Vyc29yXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0lEQk9iamVjdFN0b3JlL2dldEFsbFxuICAgICAgICAgICAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JREJPYmplY3RTdG9yZS9nZXRBbGxLZXlzXG4gICAgICAgICAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vaWRiLWlkYmN1cnNvci12cy1pZGJvYmplY3RzdG9yZS1nZXRhbGwtb3BzLzNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IFtyYW5nZV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2gob3B0aW9ucy5saW1pdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbMV0gKz0gb3B0aW9ucy5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGFsbCB2YWx1ZXMgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqU3RvcmUuZ2V0QWxsKC4uLmFyZ3MpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBldnQudGFyZ2V0LnJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRJbmRleCA9IGluZGV4IC0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbb2JqU3RvcmVOYW1lXVtyZXN1bHRJbmRleF0gPSByZXN1bHRbb2JqU3RvcmVOYW1lXVtyZXN1bHRJbmRleF0gfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtvYmpTdG9yZU5hbWVdW3Jlc3VsdEluZGV4XS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGFsbCBrZXlzIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialN0b3JlLmdldEFsbEtleXMoLi4uYXJncykub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBldnQudGFyZ2V0LnJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXMuZm9yRWFjaCgoa2V5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdEluZGV4ID0gaW5kZXggLSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtvYmpTdG9yZU5hbWVdW3Jlc3VsdEluZGV4XSA9IHJlc3VsdFtvYmpTdG9yZU5hbWVdW3Jlc3VsdEluZGV4XSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W29ialN0b3JlTmFtZV1bcmVzdWx0SW5kZXhdLmtleSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydEVyciA9IGV4O1xuICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlcmUgYXJlIDIgc2VwYXJhdGUgSURCUmVxdWVzdHMgcnVubmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gdGhlcmUncyBubyBuZWVkIHRvIGJpbmQgbGlzdGVuZXIgdG8gc3VjY2VzcyBldmVudCBvZiBhbnkgb2YgdGhlbVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZVJlcXVlc3QgPSBvYmpTdG9yZS5vcGVuQ3Vyc29yKHJhbmdlLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRFcnIgPSBleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBjdXJzb3JQb3NpdGlvbk1vdmVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpdGVyYXRlUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IGV2dC50YXJnZXQucmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIG1vcmUgcmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0ICYmICFjdXJzb3JQb3NpdGlvbk1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3JQb3NpdGlvbk1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5hZHZhbmNlKG9wdGlvbnMub2Zmc2V0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W29ialN0b3JlTmFtZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGN1cnNvci5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY3Vyc29yLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmxpbWl0ICYmIG9wdGlvbnMubGltaXQgPT09IHJlc3VsdFtvYmpTdG9yZU5hbWVdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIDEpIENvdW50IG9iamVjdHMgaW4gb25lIG9iamVjdCBzdG9yZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvYmpTdG9yZU5hbWUgbmFtZSBvZiBvYmplY3Qgc3RvcmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAob3B0aW9uYWwpIG9iamVjdCB3aXRoIGtleXMgJ2luZGV4JyBvci9hbmQgJ3JhbmdlJ1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICogICBAcGFyYW0ge0Vycm9yfSBbZXJyXSBpZiBwcm9taXNlIGlzIHJlamVjdGVkXG4gICAgICogICBAcGFyYW0ge051bWJlcn0gbnVtYmVyIG9mIHN0b3JlZCBvYmplY3RzIG90aGVyd2lzZVxuICAgICAqXG4gICAgICogMikgQ291bnQgb2JqZWN0cyBpbiBtdWx0aXBsZSBvYmplY3Qgc3RvcmVzIChkdXJpbmcgb25lIHRyYW5zYWN0aW9uKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiAgIEBwYXJhbSB7RXJyb3J9IFtlcnJdIGlmIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAgICAgKiAgIEBwYXJhbSB7T2JqZWN0fSBudW1iZXIgb2Ygc3RvcmVkIG9iamVjdHMgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgY291bnQ6IGZ1bmN0aW9uIHNrbGFkQ29ubmVjdGlvbl9jb3VudCgpIHtcbiAgICAgICAgY29uc3QgaXNNdWx0aSA9IChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKTtcbiAgICAgICAgY29uc3Qgb2JqU3RvcmVOYW1lcyA9IGlzTXVsdGkgPyBPYmplY3Qua2V5cyhhcmd1bWVudHNbMF0pIDogW2FyZ3VtZW50c1swXV07XG4gICAgICAgIGxldCBkYXRhO1xuXG4gICAgICAgIGlmIChpc011bHRpKSB7XG4gICAgICAgICAgICBkYXRhID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICAgICAgZGF0YVthcmd1bWVudHNbMF1dID0gKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpID8gbnVsbCA6IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFsbE9ialN0b3Jlc0V4aXN0ID0gY2hlY2tDb250YWluaW5nU3RvcmVzLmNhbGwodGhpcywgb2JqU3RvcmVOYW1lcyk7XG4gICAgICAgIGlmICghYWxsT2JqU3RvcmVzRXhpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IGNyZWF0ZUVycm9yKCdOb3RGb3VuZEVycm9yJywgYERhdGFiYXNlICR7dGhpcy5kYXRhYmFzZS5uYW1lfSAodmVyc2lvbiAke3RoaXMuZGF0YWJhc2UudmVyc2lvbn0pIGRvZXNuJ3QgY29udGFpbiBhbGwgbmVlZGVkIHN0b3Jlc2ApO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBsZXQgdHJhbnNhY3Rpb247XG4gICAgICAgICAgICBsZXQgY291bnRSZXF1ZXN0O1xuICAgICAgICAgICAgbGV0IGFib3J0RXJyO1xuXG4gICAgICAgICAgICAvLyBTYWZhcmk5IGNhbid0IHJ1biBtdWx0aS1vYmplY3RzdG9yZSB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgIC8vIGRpdmlkZSBvbmUgdHJhbnNhY3Rpb24gaW50byBtYW55IHdpdGggb25lIG9iamVjdCBzdG9yZSB0byBmaXggdGhpc1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiA9IHRoaXMuZGF0YWJhc2UudHJhbnNhY3Rpb24ob2JqU3RvcmVOYW1lcywgVFJBTlNBQ1RJT05fUkVBRE9OTFkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXgubmFtZSA9PT0gJ05vdEZvdW5kRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqU3RvcmVOYW1lcy5mb3JFYWNoKG9ialN0b3JlTmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5jb3VudChvYmpTdG9yZU5hbWUsIGRhdGFbb2JqU3RvcmVOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlc1tvYmpTdG9yZU5hbWVdID0gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgS2lub1Byb21pc2UuYWxsKHByb21pc2VzKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGV4KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSB0cmFuc2FjdGlvbi5vbmVycm9yID0gdHJhbnNhY3Rpb24ub25hYm9ydCA9IGZ1bmN0aW9uIHNrbGFkQ29ubmVjdGlvbl9jb3VudF9vbkZpbmlzaChldnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBhYm9ydEVyciB8fCBldnQudGFyZ2V0LmVycm9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzU3VjY2VzcyA9ICFlcnIgJiYgZXZ0LnR5cGUgPT09ICdjb21wbGV0ZSc7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNTdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaXNNdWx0aSA/IHJlc3VsdCA6IHJlc3VsdFtvYmpTdG9yZU5hbWVzWzBdXSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZW5zdXJlRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGV2dC50eXBlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAobGV0IG9ialN0b3JlTmFtZSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqU3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShvYmpTdG9yZU5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBkYXRhW29ialN0b3JlTmFtZV0gfHwge307XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2VBcmdzID0gKG9wdGlvbnMucmFuZ2UgaW5zdGFuY2VvZiBJREJLZXlSYW5nZVJlZikgPyBbb3B0aW9ucy5yYW5nZV0gOiBbXTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb2JqU3RvcmUuaW5kZXhOYW1lcy5jb250YWlucyhvcHRpb25zLmluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRFcnIgPSBjcmVhdGVFcnJvcignTm90Rm91bmRFcnJvcicsIGBPYmplY3Qgc3RvcmUgJHtvYmpTdG9yZS5uYW1lfSBkb2Vzbid0IGNvbnRhaW4gXCIke29wdGlvbnMuaW5kZXh9XCIgaW5kZXhgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG9ialN0b3JlLmluZGV4KG9wdGlvbnMuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRSZXF1ZXN0ID0gaW5kZXguY291bnQoLi4ucmFuZ2VBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0RXJyID0gZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRSZXF1ZXN0ID0gb2JqU3RvcmUuY291bnQoLi4ucmFuZ2VBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0RXJyID0gZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb3VudFJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbb2JqU3RvcmVOYW1lXSA9IGV2dC50YXJnZXQucmVzdWx0IHx8IDA7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsb3NlIEluZGV4ZWREQiBjb25uZWN0aW9uXG4gICAgICovXG4gICAgY2xvc2U6IGZ1bmN0aW9uIHNrbGFkQ29ubmVjdGlvbl9jbG9zZSgpIHtcbiAgICAgICAgdGhpcy5kYXRhYmFzZS5jbG9zZSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5kYXRhYmFzZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE9wZW5zIGNvbm5lY3Rpb24gdG8gYSBkYXRhYmFzZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYk5hbWUgZGF0YWJhc2UgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zID0ge31dIGNvbm5lY3Rpb24gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZlcnNpb25dIGRhdGFiYXNlIHZlcnNpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5taWdyYXRpb25dIG1pZ3JhdGlvbiBzY3JpcHRzXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBAcGFyYW0ge09iamVjdH0gW2Nvbm5dIGlmIC0gcHJvbWlzZSBpcyByZXNvbHZlZFxuICogICBAcGFyYW0ge0Vycm9yfSBbZXJyXSAtIGlmIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAqL1xuc2tsYWRBUEkub3BlbiA9IGZ1bmN0aW9uIHNrbGFkX29wZW4oZGJOYW1lLCBvcHRpb25zID0ge3ZlcnNpb246IDF9KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKCFpbmRleGVkRGJSZWYpIHtcbiAgICAgICAgICAgIHJlamVjdChjcmVhdGVFcnJvcignTm90U3VwcG9ydGVkRXJyb3InLCAnWW91ciBicm93c2VyIGRvZXNuXFwndCBzdXBwb3J0IEluZGV4ZWREQicpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9wZW5Db25uUmVxdWVzdCA9IGluZGV4ZWREYlJlZi5vcGVuKGRiTmFtZSwgb3B0aW9ucy52ZXJzaW9uKTtcbiAgICAgICAgbGV0IGlzUmVzb2x2ZWRPclJlamVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgb3BlbkNvbm5SZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgIGlmIChpc1Jlc29sdmVkT3JSZWplY3RlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3B0aW9ucy5taWdyYXRpb24gPSBvcHRpb25zLm1pZ3JhdGlvbiB8fCB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBldnQub2xkVmVyc2lvbiArIDE7IGkgPD0gZXZ0Lm5ld1ZlcnNpb247IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5taWdyYXRpb25baV0pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5taWdyYXRpb25baV0uY2FsbCh0aGlzLCB0aGlzLnJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgb3BlbkNvbm5SZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICBpZiAoaXNSZXNvbHZlZE9yUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmVqZWN0KGVuc3VyZUVycm9yKGV2dC50YXJnZXQuZXJyb3IpKTtcblxuICAgICAgICAgICAgaXNSZXNvbHZlZE9yUmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIG9wZW5Db25uUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICBpZiAoaXNSZXNvbHZlZE9yUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRhdGFiYXNlID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgICAgICBjb25zdCBvbGRWZXJzaW9uID0gcGFyc2VJbnQoZGF0YWJhc2UudmVyc2lvbiB8fCAwLCAxMCk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2Uuc2V0VmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBvbGRWZXJzaW9uIDwgb3B0aW9ucy52ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlVmVyUmVxdWVzdCA9IGRhdGFiYXNlLnNldFZlcnNpb24ob3B0aW9ucy52ZXJzaW9uKTtcblxuICAgICAgICAgICAgICAgIGNoYW5nZVZlclJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXN0b21VcGdyYWRlTmVlZGVkRXZ0ID0gbmV3IEV2ZW50KCd1cGdyYWRlbmVlZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbVVwZ3JhZGVOZWVkZWRFdnQub2xkVmVyc2lvbiA9IG9sZFZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbVVwZ3JhZGVOZWVkZWRFdnQubmV3VmVyc2lvbiA9IG9wdGlvbnMudmVyc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgb3BlbkNvbm5SZXF1ZXN0Lm9udXBncmFkZW5lZWRlZC5jYWxsKHtyZXN1bHQ6IGV2dC50YXJnZXQuc291cmNlfSwgY3VzdG9tVXBncmFkZU5lZWRlZEV2dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YWJhc2UuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgc2tsYWRBUEkub3BlbihkYk5hbWUsIG9wdGlvbnMpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgY2hhbmdlVmVyUmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBldnQudGFyZ2V0LmVycm9yTWVzc2FnZSB8fCBldnQudGFyZ2V0LndlYmtpdEVycm9yTWVzc2FnZSB8fCBldnQudGFyZ2V0Lm1vekVycm9yTWVzc2FnZSB8fCBldnQudGFyZ2V0Lm1zRXJyb3JNZXNzYWdlIHx8IGV2dC50YXJnZXQuZXJyb3IubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVuc3VyZUVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHN0b3JlIG9iamVjdCBzdG9yZXMgcHJvcGVydGllcyBpbiB0aGVpciBvd24gbWFwXG4gICAgICAgICAgICBvYmpTdG9yZXNNZXRhLnNldChkYk5hbWUsIG5ldyBNYXAoKSk7XG5cbiAgICAgICAgICAgIHJlc29sdmUoT2JqZWN0LmNyZWF0ZShza2xhZENvbm5lY3Rpb24sIHtcbiAgICAgICAgICAgICAgICBkYXRhYmFzZToge1xuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YWJhc2UsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgaXNSZXNvbHZlZE9yUmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIG9wZW5Db25uUmVxdWVzdC5vbmJsb2NrZWQgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICBpZiAoaXNSZXNvbHZlZE9yUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ0ludmFsaWRTdGF0ZUVycm9yJywgYERhdGFiYXNlICR7ZGJOYW1lfSBpcyBibG9ja2VkYCkpO1xuICAgICAgICAgICAgaXNSZXNvbHZlZE9yUmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBEZWxldGVzIGRhdGFiYXNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRiTmFtZVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgQHBhcmFtIHtFcnJvcn0gW2Vycl0gaWYgcHJvbWlzZSBpcyByZWplY3RlZFxuICovXG5za2xhZEFQSS5kZWxldGVEYXRhYmFzZSA9IGZ1bmN0aW9uIHNrbGFkX2RlbGV0ZURhdGFiYXNlKGRiTmFtZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmICghaW5kZXhlZERiUmVmKSB7XG4gICAgICAgICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05vdFN1cHBvcnRlZEVycm9yJywgJ1lvdXIgYnJvd3NlciBkb2VzblxcJ3Qgc3VwcG9ydCBJbmRleGVkREInKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvcGVuRGJSZXF1ZXN0ID0gaW5kZXhlZERiUmVmLmRlbGV0ZURhdGFiYXNlKGRiTmFtZSk7XG5cbiAgICAgICAgb3BlbkRiUmVxdWVzdC5vbnN1Y2Nlc3MgPSBvcGVuRGJSZXF1ZXN0Lm9uZXJyb3IgPSBvcGVuRGJSZXF1ZXN0Lm9uYmxvY2tlZCA9IGZ1bmN0aW9uIHNrbGFkX2RlbGV0ZURhdGFiYXNlX29uRmluaXNoKGV2dCkge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gKGV2dC50eXBlID09PSAnYmxvY2tlZCcpXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVFcnJvcignSW52YWxpZFN0YXRlRXJyb3InLCBgRGF0YWJhc2UgJHtkYk5hbWV9IGlzIGJsb2NrZWRgKVxuICAgICAgICAgICAgICAgIDogZXZ0LnRhcmdldC5lcnJvcjtcblxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlbnN1cmVFcnJvcihlcnIpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXZ0LnR5cGUgIT09ICdzdWNjZXNzJykge1xuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xufTtcblxuc2tsYWRBUEkua2V5VmFsdWUgPSBmdW5jdGlvbiBza2xhZF9rZXlWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoc2tsYWRLZXlWYWx1ZUNvbnRhaW5lciwge1xuICAgICAgICBrZXk6IHt2YWx1ZToga2V5LCBjb25maWd1cmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2V9LFxuICAgICAgICB2YWx1ZToge3ZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlfVxuICAgIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc2tsYWRBUEk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2xpYi9za2xhZC5qc1xuICoqL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrOi8vL2xpYi9za2xhZC5qcyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG5jbGFzcyBLaW5vUHJvbWlzZSBleHRlbmRzIFByb21pc2Uge1xuICAgIHNwcmVhZChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICBmdW5jdGlvbiBvbkZ1bGZpbGxlZEludGVybmFsKHJlcykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvbkZ1bGZpbGxlZC5hcHBseSh1bmRlZmluZWQsIF90b0NvbnN1bWFibGVBcnJheShyZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy50aGVuKG9uRnVsZmlsbGVkSW50ZXJuYWwsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbn1cblxuS2lub1Byb21pc2UuYWxsID0gZnVuY3Rpb24gS2lub1Byb21pc2Vfc3RhdGljX2FsbChwcm9taXNlcykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSB8fCB0eXBlb2YgcHJvbWlzZXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbC5hcHBseShQcm9taXNlLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgS2lub1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBpc1Byb21pc2VzTGlzdCA9IEFycmF5LmlzQXJyYXkocHJvbWlzZXMpO1xuICAgICAgICBsZXQgcHJvbWlzZXNBcnJheTtcbiAgICAgICAgbGV0IHByb21pc2VzS2V5cztcblxuICAgICAgICBpZiAoaXNQcm9taXNlc0xpc3QpIHtcbiAgICAgICAgICAgIHByb21pc2VzQXJyYXkgPSBwcm9taXNlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2VzS2V5cyA9IE9iamVjdC5rZXlzKHByb21pc2VzKTtcbiAgICAgICAgICAgIHByb21pc2VzQXJyYXkgPSBwcm9taXNlc0tleXMubWFwKGtleSA9PiBwcm9taXNlc1trZXldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzQXJyYXkpLnRoZW4ocmVzID0+IHtcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSBvdXRwdXQgaW50byBhbiBvYmplY3RcbiAgICAgICAgICAgIGxldCBvdXRwdXQ7XG5cbiAgICAgICAgICAgIGlmIChpc1Byb21pc2VzTGlzdCkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHJlcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gcmVzLnJlZHVjZSgob3V0cHV0LCBjaHVuaywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W3Byb21pc2VzS2V5c1tpbmRleF1dID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgfSk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLaW5vUHJvbWlzZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2tpbm9wcm9taXNlL2J1aWxkLmpzXG4gKiovXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vfi9raW5vcHJvbWlzZS9idWlsZC5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHZW5lcmF0ZXMgVVVJRHMgZm9yIG9iamVjdHMgd2l0aG91dCBrZXlzIHNldFxuICogQGxpbmsgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0LzIxMTc1MjMjMjExNzUyM1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1dWlkKCkge1xuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG4gICAgICAgIGNvbnN0IHYgPSAoYyA9PT0gJ3gnKSA/IHIgOiAociYweDN8MHg4KTtcblxuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2xpYi91dWlkLmpzXG4gKiovXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbGliL3V1aWQuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFcnJvcihuYW1lLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgZXJyT2JqID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIGVyck9iai5uYW1lID0gbmFtZTtcblxuICAgIHJldHVybiBlcnJPYmo7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVFcnJvcihlcnIpIHtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRXJyb3IoZXJyLm5hbWUsIGVyci5tZXNzYWdlKTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vbGliL2Vycm9yLmpzXG4gKiovXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbGliL2Vycm9yLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBzZXJ2aWNlIHdvcmtlcnMgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gd2luZG93XG5jb25zdCBpc0Jyb3dzZXJVSSA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyk7XG5cbmV4cG9ydCBjb25zdCBpbmRleGVkRGJSZWYgPSBpc0Jyb3dzZXJVSVxuICAgID8gd2luZG93LmluZGV4ZWREQiB8fCB3aW5kb3cubW96SW5kZXhlZERCIHx8IHdpbmRvdy53ZWJraXRJbmRleGVkREIgfHwgd2luZG93Lm1zSW5kZXhlZERCXG4gICAgOiBpbmRleGVkREI7XG5cbmV4cG9ydCBjb25zdCBJREJLZXlSYW5nZVJlZiA9IGlzQnJvd3NlclVJXG4gICAgPyB3aW5kb3cuSURCS2V5UmFuZ2UgfHwgd2luZG93Lm1veklEQktleVJhbmdlIHx8IHdpbmRvdy53ZWJraXRJREJLZXlSYW5nZSB8fCB3aW5kb3cubXNJREJLZXlSYW5nZVxuICAgIDogSURCS2V5UmFuZ2U7XG5cbmV4cG9ydCBjb25zdCBUUkFOU0FDVElPTl9SRUFET05MWSA9IGlzQnJvd3NlclVJXG4gICAgPyB3aW5kb3cuSURCVHJhbnNhY3Rpb24uUkVBRF9PTkxZIHx8ICdyZWFkb25seSdcbiAgICA6ICdyZWFkb25seSc7XG5cbmV4cG9ydCBjb25zdCBUUkFOU0FDVElPTl9SRUFEV1JJVEUgPSBpc0Jyb3dzZXJVSVxuICAgID8gd2luZG93LklEQlRyYW5zYWN0aW9uLlJFQURfV1JJVEUgfHwgJ3JlYWR3cml0ZSdcbiAgICA6ICdyZWFkd3JpdGUnO1xuXG5leHBvcnQgY29uc3QgU09SVF9BU0MgPSBpc0Jyb3dzZXJVSVxuICAgID8gd2luZG93LklEQkN1cnNvci5ORVhUIHx8ICduZXh0J1xuICAgIDogJ25leHQnO1xuXG5leHBvcnQgY29uc3QgU09SVF9BU0NfVU5JUVVFID0gaXNCcm93c2VyVUlcbiAgICA/IHdpbmRvdy5JREJDdXJzb3IuTkVYVF9OT19EVVBMSUNBVEUgfHwgJ25leHR1bmlxdWUnXG4gICAgOiAnbmV4dHVuaXF1ZSc7XG5cbmV4cG9ydCBjb25zdCBTT1JUX0RFU0MgPSBpc0Jyb3dzZXJVSVxuICAgID8gd2luZG93LklEQkN1cnNvci5QUkVWIHx8ICdwcmV2J1xuICAgIDogJ3ByZXYnO1xuXG5leHBvcnQgY29uc3QgU09SVF9ERVNDX1VOSVFVRSA9IGlzQnJvd3NlclVJXG4gICAgPyB3aW5kb3cuSURCQ3Vyc29yLlBSRVZfTk9fRFVQTElDQVRFIHx8ICdwcmV2dW5pcXVlJ1xuICAgIDogJ3ByZXZ1bmlxdWUnO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9saWIvZW52LmpzXG4gKiovXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2s6Ly8vbGliL2Vudi5qcyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHNrbGFkIGZyb20gJ3NrbGFkJztcblxuZXhwb3J0IGNvbnN0IG9wZW5NZXRhID0gYXN5bmMgKCkgPT4ge1xuICAgIHJldHVybiBhd2FpdCBza2xhZC5vcGVuKCdtZXRhJywge1xuICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICBtaWdyYXRpb246IHtcbiAgICAgICAgICAgICcxJzogKGRhdGFiYXNlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0IHN0b3JlIGZvciBsb2dzXG4gICAgICAgICAgICAgICAgZGF0YWJhc2UuY3JlYXRlT2JqZWN0U3RvcmUoJ2xvZycsIHthdXRvSW5jcmVtZW50OiB0cnVlfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBvYmplY3Qgc3RvcmUgZm9yIHNpbXBsZSBsb2NhbFN0b3JhZ2UtbGlrZSBkYXRhXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggd2FzIHByZXZpb3VzbHkgbWFuYWdlZCBieSBTdG9yYWdlTWFuYWdlclxuICAgICAgICAgICAgICAgIGRhdGFiYXNlLmNyZWF0ZU9iamVjdFN0b3JlKCdrZXl2YWx1ZXMnLCB7a2V5UGF0aDogJ2tleSd9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IG9wZW5Vc2VyID0gYXN5bmMgKHVzZXJJZCkgPT4ge1xuICAgIHJldHVybiBhd2FpdCBza2xhZC5vcGVuKGBkYl8ke3VzZXJJZH1gLCB7XG4gICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgIG1pZ3JhdGlvbjoge1xuICAgICAgICAgICAgJzEnOiAoZGF0YWJhc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWN0c1N0b3JlID0gZGF0YWJhc2UuY3JlYXRlT2JqZWN0U3RvcmUoJ2NvbnRhY3RzJywge2tleVBhdGg6ICd1aWQnfSk7XG4gICAgICAgICAgICAgICAgY29udGFjdHNTdG9yZS5jcmVhdGVJbmRleCgnbGFzdF9tZXNzYWdlJywgJ2xhc3RfbWVzc2FnZV90cycpO1xuICAgICAgICAgICAgICAgIGNvbnRhY3RzU3RvcmUuY3JlYXRlSW5kZXgoJ21lc3NhZ2VzX251bScsICdtZXNzYWdlc19udW0nKTtcbiAgICAgICAgICAgICAgICBjb250YWN0c1N0b3JlLmNyZWF0ZUluZGV4KCduYW1lJywgWydmaXJzdF9uYW1lJywgJ2xhc3RfbmFtZSddKTtcbiAgICAgICAgICAgICAgICBjb250YWN0c1N0b3JlLmNyZWF0ZUluZGV4KCdmdWxsdGV4dCcsICdmdWxsdGV4dCcsIHttdWx0aUVudHJ5OiB0cnVlfSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlc1N0b3JlID0gZGF0YWJhc2UuY3JlYXRlT2JqZWN0U3RvcmUoJ21lc3NhZ2VzJywge2tleVBhdGg6ICdtaWQnfSk7XG4gICAgICAgICAgICAgICAgbWVzc2FnZXNTdG9yZS5jcmVhdGVJbmRleCgndXNlcl9jaGF0cycsIFsndWlkJywgJ2NoYXQnXSk7IC8vIGdldCBhbGwgY2hhdHMgd2hlcmUgdXNlciBzYWlkIHNtdGhcbiAgICAgICAgICAgICAgICBtZXNzYWdlc1N0b3JlLmNyZWF0ZUluZGV4KCd1c2VyX21lc3NhZ2VzJywgJ3VpZCcpOyAvLyBnZXQgYWxsIHVzZXIgbWVzc2FnZXNcbiAgICAgICAgICAgICAgICBtZXNzYWdlc1N0b3JlLmNyZWF0ZUluZGV4KCdjaGF0X3BhcnRpY2lwYW50cycsIFsnY2hhdCcsICd1aWQnXSk7IC8vIGdldCBhbGwgY2hhdCBwYXJ0aWNpcGFudHNcbiAgICAgICAgICAgICAgICBtZXNzYWdlc1N0b3JlLmNyZWF0ZUluZGV4KCdjaGF0X21lc3NhZ2VzJywgJ2NoYXQnKTsgLy8gZ2V0IGFsbCBjaGF0IG1lc3NhZ2VzIHNvcnRlZCBieSBkYXRlXG4gICAgICAgICAgICAgICAgbWVzc2FnZXNTdG9yZS5jcmVhdGVJbmRleCgndGFnJywgJ3RhZ3MnLCB7bXVsdGlFbnRyeTogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzU3RvcmUuY3JlYXRlSW5kZXgoJ2Z1bGx0ZXh0JywgJ2Z1bGx0ZXh0Jywge211bHRpRW50cnk6IHRydWV9KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYXRzU3RvcmUgPSBkYXRhYmFzZS5jcmVhdGVPYmplY3RTdG9yZSgnY2hhdHMnLCB7a2V5UGF0aDogJ2lkJ30pO1xuICAgICAgICAgICAgICAgIGNoYXRzU3RvcmUuY3JlYXRlSW5kZXgoJ2xhc3RfbWVzc2FnZScsICdsYXN0X21lc3NhZ2VfdHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGRyb3BVc2VyID0gYXN5bmMgKHVzZXJJZCkgPT4ge1xuICAgIHJldHVybiBhd2FpdCBza2xhZC5kZWxldGVEYXRhYmFzZShgZGJfJHt1c2VySWR9YCk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjX2VsZWN0cm9uL3VpL2pzL2lkYi5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImFzc2VydFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImFzc2VydFwiXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGVycm9yaGFuZGxlciBmcm9tICcuL2Vycm9yaGFuZGxlcic7XG5pbXBvcnQgU3RvcmFnZSBmcm9tICcuL3N0b3JhZ2UnO1xuaW1wb3J0IERhdGFiYXNlTWFuYWdlciBmcm9tICcuL2RiJztcblxuY29uc3Qgc3RvcmFnZU1hbmFnZXIgPSBuZXcgU3RvcmFnZTtcblxuLy8gZW5hYmxlIGVycm9yIHByb2Nlc3NpbmdcbmVycm9yaGFuZGxlcihnbG9iYWwuX19maWxlbmFtZSk7XG5cbnZhciBmb3JjZVNraXBTeW5jID0gZmFsc2U7XG5cbi8qKlxuICog0J/QvtC60LDQt9Cw0YLRjCBjaHJvbWUubm90aWZpY2F0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnRpdGxlXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5tZXNzYWdlXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pY29uXG4gKiBAcGFyYW0ge051bWJlcn0gW2RhdGEudWlkXVxuICogQHBhcmFtIHtTdHJpbmd9IFtkYXRhLmlkXVxuICogQHBhcmFtIHtTdHJpbmd9IFtkYXRhLnNvdW5kXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtkYXRhLnRpbWVvdXRdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZGF0YS5vbmNsaWNrXVxuICovXG5mdW5jdGlvbiBzaG93Q2hyb21lTm90aWZpY2F0aW9uKGRhdGEpIHtcbiAgICAvLyBMaW51eCBjaGVja1xuICAgIC8vIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL25vdGlmaWNhdGlvbnNcbiAgICBpZiAoIWNocm9tZS5ub3RpZmljYXRpb25zKVxuICAgICAgICByZXR1cm47XG5cbiAgICB2YXIgcHJvbWlzZSA9IGRhdGEudWlkXG4gICAgICAgID8gZ2V0QXZhdGFySW1hZ2UoZGF0YS5pY29uLCBkYXRhLnVpZClcbiAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoZGF0YS5pY29uKTtcblxuICAgIHZhciBzaG93Q2hyb21lTm90aWZpY2F0aW9uSW5uZXIgPSBmdW5jdGlvbiAodXJpKSB7XG4gICAgICAgIHVyaSA9IHVyaSB8fCBkYXRhLmljb247XG5cbiAgICAgICAgY2hyb21lLm5vdGlmaWNhdGlvbnMuY3JlYXRlKChkYXRhLmlkIHx8IE1hdGgucmFuZG9tKCkpICsgJycsIHtcbiAgICAgICAgICAgIHR5cGU6ICdiYXNpYycsXG4gICAgICAgICAgICBpY29uVXJsOiB1cmksXG4gICAgICAgICAgICB0aXRsZTogZGF0YS50aXRsZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGRhdGEubWVzc2FnZSxcbiAgICAgICAgICAgIGlzQ2xpY2thYmxlOiB0cnVlXG4gICAgICAgIH0sIGZ1bmN0aW9uIChub3RpZmljYXRpb25JZCkge1xuICAgICAgICAgICAgaWYgKGRhdGEub25jbGljaykge1xuICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXJzW25vdGlmaWNhdGlvbklkXSA9IGRhdGEub25jbGljaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEuc291bmQpIHtcbiAgICAgICAgICAgICAgICBTb3VuZE1hbmFnZXIucGxheShkYXRhLnNvdW5kKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEudGltZW91dCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjaHJvbWUubm90aWZpY2F0aW9ucy5jbGVhcihub3RpZmljYXRpb25JZCwgXy5ub29wKTtcbiAgICAgICAgICAgICAgICB9LCBkYXRhLnRpbWVvdXQgKiAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJvbWlzZS50aGVuKHNob3dDaHJvbWVOb3RpZmljYXRpb25Jbm5lciwgZnVuY3Rpb24gKCkge1xuICAgICAgICBzaG93Q2hyb21lTm90aWZpY2F0aW9uSW5uZXIoKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIHNldHRpbmdzIGJ5IGdldHRpbmcgdGhlaXIgdmFsdWVzIGluIHRoaXMgbW9tZW50XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldEZsYXRTZXR0aW5ncygpIHtcbiAgICB2YXIgZmxhdFNldHRpbmdzID0ge307XG4gICAgU2V0dGluZ3NNYW5hZ2VyLmdldEF2YWlsYWJsZSgpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBmbGF0U2V0dGluZ3Nba2V5XSA9IFNldHRpbmdzTWFuYWdlcltrZXldO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZsYXRTZXR0aW5ncztcbn1cblxuZnVuY3Rpb24gbGVhdmVPbmVBcHBXaW5kb3dJbnN0YW5jZShvcGVuSWZOb0V4aXN0KSB7XG4gICAgdmFyIGFwcFdpbmRvd3MgPSBjaHJvbWUuYXBwLndpbmRvdy5nZXRBbGwoKTtcbiAgICBhcHBXaW5kb3dzLmZvckVhY2goZnVuY3Rpb24gKHdpbiwgaXNOb3RGaXJzdCkge1xuICAgICAgICBpZiAoaXNOb3RGaXJzdCkge1xuICAgICAgICAgICAgd2luLmNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aW4uZm9jdXMoKTtcbiAgICAgICAgICAgIHdpbi5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghYXBwV2luZG93cy5sZW5ndGggJiYgb3BlbklmTm9FeGlzdCkge1xuICAgICAgICBvcGVuQXBwV2luZG93KCk7XG4gICAgfVxufVxuXG4vLyBub3RpZmljYXRpb24gY2xpY2sgaGFuZGxlcnNcbi8vIEZJWE1FIHJlZmFjdG9yXG4vKnZhciBub3RpZmljYXRpb25IYW5kbGVycyA9IHt9O1xuY2hyb21lLm5vdGlmaWNhdGlvbnMub25DbGlja2VkLmFkZExpc3RlbmVyKGZ1bmN0aW9uIG5vdGlmaWNhdGlvbkhhbmRsZXIobm90aWZpY2F0aW9uSWQpIHtcbiAgICB2YXIgbm90aWZpY2F0aW9uQ2FsbGJhY2sgPSBub3RpZmljYXRpb25IYW5kbGVyc1tub3RpZmljYXRpb25JZF07XG5cbiAgICBpZiAobm90aWZpY2F0aW9uSWQgPT09IFwidG9rZW5FeHBpcmVkUmVxdWVzdFwiKSB7XG4gICAgICAgIG5vdGlmaWNhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgQ1BBLnNlbmRFdmVudChcIkFwcC1EYXRhXCIsIFwidG9rZW5FeHBpcmVkIG5vdGlmaWNhdGlvbiBjbGlja1wiKTtcblxuICAgICAgICAgICAgLy8gY2xvc2UgYWxsIGFwcCB3aW5kb3dzXG4gICAgICAgICAgICB2YXIgYXBwV2luZG93cyA9IGNocm9tZS5hcHAud2luZG93LmdldEFsbCgpO1xuICAgICAgICAgICAgYXBwV2luZG93cy5mb3JFYWNoKGZ1bmN0aW9uICh3aW4pIHtcbiAgICAgICAgICAgICAgICB3aW4uY2xvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBvcGVuQXBwV2luZG93KG51bGwsIHRydWUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlmICghbm90aWZpY2F0aW9uQ2FsbGJhY2spXG4gICAgICAgIHJldHVybjtcblxuICAgIGNocm9tZS5ub3RpZmljYXRpb25zLmNsZWFyKG5vdGlmaWNhdGlvbklkLCBfLm5vb3ApO1xuICAgIG5vdGlmaWNhdGlvbkNhbGxiYWNrKCk7XG5cbiAgICBkZWxldGUgbm90aWZpY2F0aW9uSGFuZGxlcnNbbm90aWZpY2F0aW9uSWRdO1xufSk7XG5cbmNocm9tZS5hbGFybXMub25BbGFybS5hZGRMaXN0ZW5lcihmdW5jdGlvbiAoYWxhcm1JbmZvKSB7XG4gICAgc3dpdGNoIChhbGFybUluZm8ubmFtZSkge1xuICAgICAgICBjYXNlIFwiZGF5dXNlXCI6XG4gICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiTGlmZWN5Y2xlXCIsIFwiRGF5dXNlXCIsIFwiVG90YWwgdXNlcnNcIiwgMSk7XG4gICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiTGlmZWN5Y2xlXCIsIFwiRGF5dXNlXCIsIFwiQXV0aG9yaXplZCB1c2Vyc1wiLCBBY2NvdW50c01hbmFnZXIuY3VycmVudFVzZXJJZCA/IDEgOiAwKTtcblxuICAgICAgICAgICAgdmFyIGFwcEluc3RhbGxUaW1lID0gc3RvcmFnZU1hbmFnZXIuZ2V0KFwiYXBwX2luc3RhbGxfdGltZVwiKTtcbiAgICAgICAgICAgIGlmIChhcHBJbnN0YWxsVGltZSkge1xuICAgICAgICAgICAgICAgIHZhciB0b3RhbERheXNMaXZlID0gTWF0aC5mbG9vcigoRGF0ZS5ub3coKSAtIGFwcEluc3RhbGxUaW1lKSAvIDEwMDAgLyA2MCAvIDYwIC8gMjQpO1xuICAgICAgICAgICAgICAgIENQQS5zZW5kRXZlbnQoXCJMaWZlY3ljbGVcIiwgXCJEYXl1c2VcIiwgXCJBcHAgbGlmZSB0aW1lXCIsIHRvdGFsRGF5c0xpdmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVxdWVzdHNMb2cgPSBzdG9yYWdlTWFuYWdlci5nZXQoXCJyZXF1ZXN0c1wiLCB7Y29uc3RydWN0b3I6IE9iamVjdCwgc3RyaWN0OiB0cnVlLCBjcmVhdGU6IHRydWV9KTtcbiAgICAgICAgICAgIGZvciAodmFyIHVybCBpbiByZXF1ZXN0c0xvZykge1xuICAgICAgICAgICAgICAgIENQQS5zZW5kRXZlbnQoXCJMaWZlY3ljbGVcIiwgXCJEYXl1c2VcIiwgXCJSZXF1ZXN0czogXCIgKyB1cmwsIHJlcXVlc3RzTG9nW3VybF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdG9yYWdlTWFuYWdlci5yZW1vdmUoXCJyZXF1ZXN0c1wiKTtcblxuICAgICAgICAgICAgY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0KFwiZGF5dXNlLmRhdVwiLCBmdW5jdGlvbiAocmVjb3Jkcykge1xuICAgICAgICAgICAgICAgIHZhciBpc0FjdGl2ZVVzZXIgPSByZWNvcmRzW1wiZGF5dXNlLmRhdVwiXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQWN0aXZlVXNlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQ1BBLnNlbmRFdmVudChcIkxpZmVjeWNsZVwiLCBcIkRBVVwiKTtcbiAgICAgICAgICAgICAgICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5yZW1vdmUoXCJkYXl1c2UuZGF1XCIsIF8ubm9vcCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIndlZWt1c2VcIjpcbiAgICAgICAgICAgIGNocm9tZS5zdG9yYWdlLmxvY2FsLmdldChcIndlZWt1c2Uud2F1XCIsIGZ1bmN0aW9uIChyZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzQWN0aXZlVXNlciA9IHJlY29yZHNbXCJ3ZWVrdXNlLndhdVwiXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQWN0aXZlVXNlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQ1BBLnNlbmRFdmVudChcIkxpZmVjeWNsZVwiLCBcIldBVVwiKTtcbiAgICAgICAgICAgICAgICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5yZW1vdmUoXCJ3ZWVrdXNlLndhdVwiLCBfLm5vb3ApO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJmZXRjaG5ld3NcIjpcbiAgICAgICAgICAgIFJlcU1hbmFnZXIuYXBpTWV0aG9kKFwid2FsbC5nZXRcIiwge1xuICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbjogbnVsbCwgLy8g0L7QsdGK0Y/QstC70LXQvdC40Y8g0L/QvtC70YPRh9Cw0YLRjCDQvtCx0Y/Qt9Cw0YLQtdC70YzQvdC+LCDQv9C+0Y3RgtC+0LzRgyDRhdC+0LTQuNC8INCx0LXQtyDRgtC+0LrQtdC90L7QslxuICAgICAgICAgICAgICAgIG93bmVyX2lkOiAoMCAtIEFwcC5WS19BRFZfR1JPVVBbMF0pLFxuICAgICAgICAgICAgICAgIGNvdW50OiA1LFxuICAgICAgICAgICAgICAgIGZpbHRlcjogXCJvd25lclwiXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWVuUG9zdHMgPSBzdG9yYWdlTWFuYWdlci5nZXQoXCJ2a2dyb3Vwd2FsbF9zeW5jZWRfcG9zdHNcIiwge2NvbnN0cnVjdG9yOiBBcnJheSwgc3RyaWN0OiB0cnVlLCBjcmVhdGU6IHRydWV9KTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zdHNUb1N0b3JlID0gW107XG5cbiAgICAgICAgICAgICAgICBkYXRhLnJlc3BvbnNlLnNsaWNlKDEpLmZvckVhY2goZnVuY3Rpb24gKHBvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW5Qb3N0cy5pbmRleE9mKHBvc3QuaWQpICE9PSAtMSB8fCBBcHAuVktfQURWX0dST1VQWzFdID49IHBvc3QuaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgcG9zdHNUb1N0b3JlLnB1c2gocG9zdCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zdHNUb1N0b3JlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlTWFuYWdlci5zZXQoXCJ2a2dyb3Vwd2FsbF9zdG9yZWRfcG9zdHNcIiwgcG9zdHNUb1N0b3JlKTtcblxuICAgICAgICAgICAgICAgICAgICBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwibmV3V2FsbFBvc3RzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQb3N0c051bTogcG9zdHNUb1N0b3JlLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfLm5vb3ApO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiYWN0dWFsaXplQ2hhdHNcIjpcbiAgICAgICAgICAgIERhdGFiYXNlTWFuYWdlci5hY3R1YWxpemVDaGF0RGF0ZXMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJhY3R1YWxpemVDb250YWN0c1wiOlxuICAgICAgICAgICAgRGF0YWJhc2VNYW5hZ2VyLmFjdHVhbGl6ZUNvbnRhY3RzKCkuY2F0Y2goZnVuY3Rpb24gKGVyck1zZykge1xuICAgICAgICAgICAgICAgIExvZ01hbmFnZXIuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiQ3VzdG9tLUVycm9yc1wiLCBcIkRhdGFiYXNlIGVycm9yXCIsIGVyck1zZyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcInByb3Bvc2UtbGF1bmNoZXJcIjpcbiAgICAgICAgICAgIC8vIHByb21vdGUgVksgT2ZmbGluZSBsYXVuY2hlclxuICAgICAgICAgICAgY2hyb21lLm5vdGlmaWNhdGlvbnMgJiYgY2hyb21lLm5vdGlmaWNhdGlvbnMuY3JlYXRlKE1hdGgucmFuZG9tKCkgKyBcIlwiLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbWFnZVwiLFxuICAgICAgICAgICAgICAgIGltYWdlVXJsOiBjaHJvbWUucnVudGltZS5nZXRVUkwoXCJwaWMvbGF1bmNoZXIucG5nXCIpLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBjaHJvbWUuaTE4bi5nZXRNZXNzYWdlKFwibGF1bmNoZXJOb3RpZmljYXRpb25UaXRsZVwiKSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaHJvbWUuaTE4bi5nZXRNZXNzYWdlKFwibGF1bmNoZXJOb3RpZmljYXRpb25NZXNzYWdlXCIpLFxuICAgICAgICAgICAgICAgIGljb25Vcmw6IGNocm9tZS5ydW50aW1lLmdldFVSTChcInBpYy9pY29uNDgucG5nXCIpLFxuICAgICAgICAgICAgICAgIGlzQ2xpY2thYmxlOiBmYWxzZVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgU291bmRNYW5hZ2VyLnBsYXkoXCJtZXNzYWdlXCIpO1xuICAgICAgICAgICAgICAgIENQQS5zZW5kRXZlbnQoXCJMaWZlY3ljbGVcIiwgXCJBY3Rpb25zXCIsIFwiSW5zdGFsbC5Ob3RpZnlMYXVuY2hlclByb21vdGUuU2hvd1wiKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwic2xlZXBpbmctYXdha2VcIjpcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmcuIHRoaXMgYWxhcm0gaXMganVzdCBmb3Igd2FraW5nIHVwIGFuIGFwcFxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufSk7XG5cbi8vIGluc3RhbGwgJiB1cGRhdGUgaGFuZGxpbmdcbmNocm9tZS5ydW50aW1lLm9uSW5zdGFsbGVkLmFkZExpc3RlbmVyKGZ1bmN0aW9uIChkZXRhaWxzKSB7XG4gICAgdmFyIGFwcE5hbWUgPSBjaHJvbWUucnVudGltZS5nZXRNYW5pZmVzdCgpLm5hbWU7XG4gICAgdmFyIGN1cnJlbnRWZXJzaW9uID0gY2hyb21lLnJ1bnRpbWUuZ2V0TWFuaWZlc3QoKS52ZXJzaW9uO1xuXG4gICAgc3dpdGNoIChkZXRhaWxzLnJlYXNvbikge1xuICAgICAgICBjYXNlIFwiaW5zdGFsbFwiOlxuICAgICAgICAgICAgQ1BBLmNoYW5nZVBlcm1pdHRlZFN0YXRlKHRydWUpO1xuICAgICAgICAgICAgQ1BBLnNlbmRFdmVudChcIkxpZmVjeWNsZVwiLCBcIkRheXVzZVwiLCBcIkluc3RhbGxcIiwgMSk7XG5cbiAgICAgICAgICAgIE1pZ3JhdGlvbk1hbmFnZXIuc3RhcnQoY3VycmVudFZlcnNpb24pO1xuXG4gICAgICAgICAgICAvLyBwcm9wb3NlIHRvIGluc3RhbGwgVksgT2ZmbGluZSBsYXVuY2hlciBhZnRlciAyIG1pbnV0ZXMgb24gaW5hY3Rpdml0eSBhZnRlciBpbnN0YWxsXG4gICAgICAgICAgICAvLyBpbmFjdGl2aXR5IG1lYW5zIG5vdCBvcGVuaW5nIGFwcCB3aW5kb3dcbiAgICAgICAgICAgIGNocm9tZS5hbGFybXMuY3JlYXRlKFwicHJvcG9zZS1sYXVuY2hlclwiLCB7ZGVsYXlJbk1pbnV0ZXM6IDJ9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJ1cGRhdGVcIjpcbiAgICAgICAgICAgIGlmIChjdXJyZW50VmVyc2lvbiAhPT0gZGV0YWlscy5wcmV2aW91c1ZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBNaWdyYXRpb25NYW5hZ2VyLnN0YXJ0KGN1cnJlbnRWZXJzaW9uKTtcbiAgICAgICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiTGlmZWN5Y2xlXCIsIFwiRGF5dXNlXCIsIFwiVXBncmFkZVwiLCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2hyb21lLmFsYXJtcy5nZXQoXCJkYXl1c2VcIiwgZnVuY3Rpb24gKGFsYXJtSW5mbykge1xuICAgICAgICBpZiAoIWFsYXJtSW5mbykge1xuICAgICAgICAgICAgY2hyb21lLmFsYXJtcy5jcmVhdGUoXCJkYXl1c2VcIiwge1xuICAgICAgICAgICAgICAgIGRlbGF5SW5NaW51dGVzOiAyNCAqIDYwLFxuICAgICAgICAgICAgICAgIHBlcmlvZEluTWludXRlczogMjQgKiA2MFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNocm9tZS5hbGFybXMuZ2V0KFwiZmV0Y2huZXdzXCIsIGZ1bmN0aW9uIChhbGFybUluZm8pIHtcbiAgICAgICAgaWYgKCFhbGFybUluZm8pIHtcbiAgICAgICAgICAgIGNocm9tZS5hbGFybXMuY3JlYXRlKFwiZmV0Y2huZXdzXCIsIHtcbiAgICAgICAgICAgICAgICBwZXJpb2RJbk1pbnV0ZXM6IDI0ICogNjAsXG4gICAgICAgICAgICAgICAgZGVsYXlJbk1pbnV0ZXM6IDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjaHJvbWUuYWxhcm1zLmdldChcIndlZWt1c2VcIiwgZnVuY3Rpb24gKGFsYXJtSW5mbykge1xuICAgICAgICBpZiAoIWFsYXJtSW5mbykge1xuICAgICAgICAgICAgY2hyb21lLmFsYXJtcy5jcmVhdGUoXCJ3ZWVrdXNlXCIsIHtcbiAgICAgICAgICAgICAgICBkZWxheUluTWludXRlczogNyAqIDI0ICogNjAsXG4gICAgICAgICAgICAgICAgcGVyaW9kSW5NaW51dGVzOiA3ICogMjQgKiA2MFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciB1bmluc3RhbGxVcmwgPSBBcHAuR09PREJZRV9QQUdFX1VSTCArIFwiP3Zlcj1cIiArIGN1cnJlbnRWZXJzaW9uO1xuICAgIGlmICh0eXBlb2YgY2hyb21lLnJ1bnRpbWUuc2V0VW5pbnN0YWxsVVJMID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2hyb21lLnJ1bnRpbWUuc2V0VW5pbnN0YWxsVVJMKHVuaW5zdGFsbFVybCk7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbGxEYXRlS2V5ID0gXCJhcHBfaW5zdGFsbF90aW1lXCI7XG4gICAgY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0KGluc3RhbGxEYXRlS2V5LCBmdW5jdGlvbiAocmVjb3Jkcykge1xuICAgICAgICByZWNvcmRzW2luc3RhbGxEYXRlS2V5XSA9IHJlY29yZHNbaW5zdGFsbERhdGVLZXldIHx8IERhdGUubm93KCk7XG4gICAgICAgIGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldChyZWNvcmRzKTtcbiAgICB9KTtcblxuICAgIC8vIGNyZWF0ZSBzbGVlcGluZyBhd2FrZSBhbGFybVxuICAgIGNocm9tZS5hbGFybXMuY3JlYXRlKFwic2xlZXBpbmctYXdha2VcIiwge3BlcmlvZEluTWludXRlczogMX0pO1xufSk7XG5cbi8vIGxpc3RlbiB0byBtZXNzYWdlcyBmcm9tIExpc3RlbiEgYXBwXG5jaHJvbWUucnVudGltZS5vbk1lc3NhZ2VFeHRlcm5hbC5hZGRMaXN0ZW5lcihmdW5jdGlvbiAobXNnLCBzZW5kZXIsIHNlbmRSZXNwb25zZSkge1xuICAgIGlmIChzZW5kZXIuaWQgPT09IEFwcC5MSVNURU5BUFBfSUQgJiYgbXNnLmFjdGlvbiA9PT0gXCJpbXBvcnRBdXRoVG9rZW5cIikge1xuICAgICAgICBpZiAoQWNjb3VudHNNYW5hZ2VyLmN1cnJlbnRVc2VySWQpIHtcbiAgICAgICAgICAgIHNlbmRSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgdXNlcl9pZDogTnVtYmVyKEFjY291bnRzTWFuYWdlci5jdXJyZW50VXNlcklkKSxcbiAgICAgICAgICAgICAgICB0b2tlbjogQWNjb3VudHNNYW5hZ2VyLmxpc3RbQWNjb3VudHNNYW5hZ2VyLmN1cnJlbnRVc2VySWRdLnRva2VuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbmRSZXNwb25zZShudWxsKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2VuZGVyLmlkID09PSBBcHAuTEFVTkNIRVJfRVhURU5TSU9OX0lEICYmIG1zZy5hY3Rpb24gPT09IFwibGF1bmNoXCIpIHtcbiAgICAgICAgbGVhdmVPbmVBcHBXaW5kb3dJbnN0YW5jZSh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzZW5kUmVzcG9uc2UoZmFsc2UpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBvcGVuQXBwV2luZG93KGV2dCwgdG9rZW5FeHBpcmVkKSB7XG4gICAgY2hyb21lLmFwcC53aW5kb3cuY3JlYXRlKFwibWFpbi5odG1sXCIsIHtcbiAgICAgICAgaWQ6IHV1aWQoKSxcbiAgICAgICAgaW5uZXJCb3VuZHM6IHtcbiAgICAgICAgICAgIG1pbldpZHRoOiAxMDAwLFxuICAgICAgICAgICAgbWluSGVpZ2h0OiA3MDBcbiAgICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uICh3aW4pIHtcbiAgICAgICAgLy8gZmxhdHRlbiBzZXR0aW5ncyBieSBnZXR0aW5nIHRoZWlyIHZhbHVlcyBpbiB0aGlzIG1vbWVudFxuICAgICAgICB3aW4uY29udGVudFdpbmRvdy5TZXR0aW5ncyA9IGdldEZsYXRTZXR0aW5ncygpO1xuXG4gICAgICAgIC8vIHBhc3MgY3VycmVudCB1c2VyIGRhdGFcbiAgICAgICAgd2luLmNvbnRlbnRXaW5kb3cuQWNjb3VudCA9IHtcbiAgICAgICAgICAgIGN1cnJlbnRVc2VySWQ6IEFjY291bnRzTWFuYWdlci5jdXJyZW50VXNlcklkLFxuICAgICAgICAgICAgY3VycmVudFVzZXJGaW86IEFjY291bnRzTWFuYWdlci5jdXJyZW50ID8gQWNjb3VudHNNYW5hZ2VyLmN1cnJlbnQuZmlvIDogbnVsbCxcbiAgICAgICAgICAgIHRva2VuRXhwaXJlZDogdG9rZW5FeHBpcmVkXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBjaHJvbWUuYWxhcm1zLmNsZWFyKFwicHJvcG9zZS1sYXVuY2hlclwiLCBfLm5vb3ApO1xufVxuXG4vLyBhcHAgbGlmZWN5Y2xlXG5jaHJvbWUuYXBwLnJ1bnRpbWUub25MYXVuY2hlZC5hZGRMaXN0ZW5lcihvcGVuQXBwV2luZG93KTtcbmNocm9tZS5hcHAucnVudGltZS5vblJlc3RhcnRlZC5hZGRMaXN0ZW5lcihvcGVuQXBwV2luZG93KTsqL1xuXG5Qcm9taXNlLmFsbChbXG4gICAgc3RvcmFnZU1hbmFnZXIubG9hZCgpLFxuICAgIERhdGFiYXNlTWFuYWdlci5pbml0TWV0YSgpXG5dKS50aGVuKGZ1bmN0aW9uIHJlYWR5VG9HbyhlcnIpIHtcbiAgICBTZXR0aW5nc01hbmFnZXIuaW5pdCgpO1xuICAgIExvZ01hbmFnZXIuY29uZmlnKFwiQXBwIHN0YXJ0ZWRcIik7XG5cbiAgICB2YXIgc3luY2luZ0RhdGEgPSB7fSwgLy8g0L7QsdGK0LXQutGCINGBINC60LvRjtGH0LDQvNC4IGluYm94LCBzZW50INC4IGNvbnRhY3RzIC0g0YHRh9C10YLRh9C40Log0LzQsNC60YHQuNC80LDQu9GM0L3Ri9GFINGH0LjRgdC10LtcbiAgICAgICAgdWlkc1Byb2Nlc3NpbmcgPSB7fTsgLy8g0L7QsdGK0LXQutGCINC40Lcg0Y3Qu9C10LzQtdC90YLQvtCyINCy0LjQtNCwIHtjdXJyZW50VXNlcklkMToge3VpZDE6IHRydWUsIHVpZDI6IHRydWUsIHVpZDM6IHRydWV9LCAuLi59XG5cbiAgICB2YXIgY2xlYXJTeW5jaW5nRGF0YUNvdW50ZXJzID0gZnVuY3Rpb24odXNlcklkKSB7XG4gICAgICAgIGlmIChzeW5jaW5nRGF0YVt1c2VySWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN5bmNpbmdEYXRhW3VzZXJJZF0uY29udGFjdHNbMF0gPSAwO1xuICAgICAgICAgICAgc3luY2luZ0RhdGFbdXNlcklkXS5jb250YWN0c1sxXSA9IDA7XG5cbiAgICAgICAgICAgIHN5bmNpbmdEYXRhW3VzZXJJZF0uaW5ib3hbMF0gPSAwO1xuICAgICAgICAgICAgc3luY2luZ0RhdGFbdXNlcklkXS5pbmJveFsxXSA9IDA7XG5cbiAgICAgICAgICAgIHN5bmNpbmdEYXRhW3VzZXJJZF0uc2VudFswXSA9IDA7XG4gICAgICAgICAgICBzeW5jaW5nRGF0YVt1c2VySWRdLnNlbnRbMV0gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3luY2luZ0RhdGFbdXNlcklkXSA9IHtcbiAgICAgICAgICAgICAgICBcImNvbnRhY3RzXCIgOiBbMCwgMF0sIC8vIFt0b3RhbCwgY3VycmVudF1cbiAgICAgICAgICAgICAgICBcImluYm94XCIgOiBbMCwgMF0sXG4gICAgICAgICAgICAgICAgXCJzZW50XCIgOiBbMCwgMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvLyDRg9GB0YLQsNC90LDQstC70LjQstCw0LXQvCDQvtCx0YDQsNCx0L7RgtGH0LjQutC4IG9mZmxpbmUt0YHQvtCx0YvRgtC40LlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSh7XCJhY3Rpb25cIiA6IFwib25saW5lU3RhdHVzQ2hhbmdlZFwiLCBcInN0YXR1c1wiIDogXCJvbmxpbmVcIn0pO1xuXG4gICAgICAgIC8vINC90LAg0YHQsNC80L7QvCDQtNC10LvQtSDRgdC10YLRjCDQvNC+0LbQtdGCINCx0YvRgtGMLCDQsCDRgdCy0Y/Qt9C4INGBINC40L3RgtC10YDQvdC10YLQvtC8IC0g0L3QtdGCXG4gICAgICAgIGlmIChBY2NvdW50c01hbmFnZXIuY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgICAgc3RhcnRVc2VyU2Vzc2lvbigpO1xuICAgICAgICB9XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIFJlcU1hbmFnZXIuYWJvcnRBbGwoKTtcbiAgICAgICAgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe1wiYWN0aW9uXCIgOiBcIm9ubGluZVN0YXR1c0NoYW5nZWRcIiwgXCJzdGF0dXNcIiA6IFwib2ZmbGluZVwifSk7XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgdmFyIGxvbmdQb2xsRXZlbnRzUmVnaXN0cmFyID0ge1xuICAgICAgICBpbml0OiBmdW5jdGlvbihjdXJyZW50VXNlcklkKSB7XG4gICAgICAgICAgICAvLyDQvtCx0YDRi9Cy0LDQtdC8IExQLdC30LDQv9GA0L7RgSDRgdGC0LDRgNC+0LPQviDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y9cbiAgICAgICAgICAgIGlmICh0aGlzLl9sb25nUG9sbFhocklkc1tjdXJyZW50VXNlcklkXSkge1xuICAgICAgICAgICAgICAgIFJlcU1hbmFnZXIuYWJvcnQodGhpcy5fbG9uZ1BvbGxYaHJJZHNbY3VycmVudFVzZXJJZF0pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9sb25nUG9sbFhocklkc1tjdXJyZW50VXNlcklkXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gW0lTU1VFUzZdINGA0LXRiNC10L3QuNC1INC/0YDQvtCx0LvQtdC80YtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdQb2xsWGhySWRzW2N1cnJlbnRVc2VySWRdID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2dldENyZWRlbnRpYWxzKGN1cnJlbnRVc2VySWQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9vbkxvYWQ6IGZ1bmN0aW9uKGN1cnJlbnRVc2VySWQsIHJlcykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAocmVzLmZhaWxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcy5mYWlsZWQgPT09IDIpIHsgLy8g0LrQu9GO0Ycg0YPRgdGC0LDRgNC10LtcbiAgICAgICAgICAgICAgICAgICAgTG9nTWFuYWdlci53YXJuKFwiTG9uZ1BvbGwgc2VydmVyIGtleSBpcyBub3cgb2Jzb2xldGUuIFJlLXJlcXVlc3RpbmcgYSBuZXcga2V5Li4uXCIgKyBcIiBbXCIgKyB0aGlzLl9sb25nUG9sbFhocklkc1tjdXJyZW50VXNlcklkXSArIFwiXVwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBMb2dNYW5hZ2VyLmVycm9yKFwiTG9uZ1BvbGwgc2VydmVyIHJlcXVlc3QgZmFpbGVkOiBcIiArIEpTT04uc3RyaW5naWZ5KHJlcykgKyBcIiBbXCIgKyB0aGlzLl9sb25nUG9sbFhocklkc1tjdXJyZW50VXNlcklkXSArIFwiXVwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fbG9uZ1BvbGxYaHJJZHNbY3VycmVudFVzZXJJZF07XG5cbiAgICAgICAgICAgICAgICB0aGlzLmluaXQoY3VycmVudFVzZXJJZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBMb2dNYW5hZ2VyLmluZm8oSlNPTi5zdHJpbmdpZnkocmVzKSk7XG5cbiAgICAgICAgICAgIHJlcy51cGRhdGVzLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRhdGFbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhWzJdICYgMTI4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g0KHQvtC+0LHRidC10L3QuNC1INGD0LTQsNC70LXQvdC+INC90LAg0YHQsNC50YLQtS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDQsiDQuNC00LXQsNC70LUg0L3Rg9C20L3QviDQvNC10L3Rj9GC0Ywg0YHQvtC+0YLQstC10YLRgdGC0LLRg9GO0YnQuNC5INC40L3QtNC10LrRgSDQvNCw0YHRgdC40LLQsCBcIm1lc3NhZ2VzR290XCIg0LTQu9GPINC60L7RgNGA0LXQutGC0L3QvtC5INGA0LDQsdC+0YLRiyBtYWlsU3luY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vINCSINGC0L4g0LbQtSDQstGA0LXQvNGPINC4INC00LvRjyDQuNGB0YXQvtC00Y/RidC40YUsINC4INC00LvRjyDQstGF0L7QtNGP0YnQuNGFINGB0L7QvtCx0YnQtdC90LjQuSBkYXRhWzJdID09PSAxMjgsINC4INGH0YLQvtCx0Ysg0L7Qv9GA0LXQtNC10LvQuNGC0Ywg0LLRhdC+0LTRj9GJ0LXQtSDRgdC+0L7QsdGJ0LXQvdC40LUg0LjQu9C4INC90LXRgiwg0L3QtdC+0LHRhdC+0LTQuNC80L4g0LTQtdC70LDRgtGMINC00L7Qvy4g0LfQsNC/0YDQvtGBLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vINCX0LAg0Y3RgtC+INCy0YDQtdC80Y8g0LzQvtC20LXRgiDQv9GA0L7QuNC30L7QudGC0Lgg0L7RiNC40LHQutCwIGR1cGxpY2F0ZSBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YVsyXSAmIDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDRgdC+0L7QsdGJ0LXQvdC40LUg0L7RgtC80LXRh9C10L3QviDQutCw0Log0LLQsNC20L3QvtC1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRGF0YWJhc2VNYW5hZ2VyLm1hcmtNZXNzYWdlV2l0aFRhZyhkYXRhWzFdLCBcImltcG9ydGFudFwiLCBfLm5vb3AsIGZ1bmN0aW9uIChpc0RhdGFiYXNlRXJyb3IsIGVyck1zZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNEYXRhYmFzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dNYW5hZ2VyLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiQ3VzdG9tLUVycm9yc1wiLCBcIkRhdGFiYXNlIGVycm9yXCIsIGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YVsyXSAmIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEYXRhYmFzZU1hbmFnZXIubWFya0FzVW5yZWFkKGRhdGFbMV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe1wiYWN0aW9uXCIgOiBcIm1zZ1JlYWRTdGF0dXNDaGFuZ2VcIiwgXCJyZWFkXCIgOiBmYWxzZSwgXCJpZFwiIDogZGF0YVsxXX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJNc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9nTWFuYWdlci5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiQ3VzdG9tLUVycm9yc1wiLCBcIkRhdGFiYXNlIGVycm9yXCIsIGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMyA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVsyXSAmIDEyOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vINGB0L7QvtCx0YnQtdC90LjQtSDQstC+0YHRgdGC0LDQvdC+0LLQu9C10L3QviDQvdCwINGB0LDQudGC0LVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEYXRhYmFzZU1hbmFnZXIudW5tYXJrTWVzc2FnZVdpdGhUYWcoZGF0YVsxXSwgXCJ0cmFzaFwiLCBfLm5vb3AsIGZ1bmN0aW9uIChpc0RhdGFiYXNlRXJyb3IsIGVyck1zZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNEYXRhYmFzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dNYW5hZ2VyLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiQ3VzdG9tLUVycm9yc1wiLCBcIkRhdGFiYXNlIGVycm9yXCIsIGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YVsyXSAmIDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDRgdC+0L7QsdGJ0LXQvdC40LUg0LHQvtC70YzRiNC1INC90LUg0LLQsNC20L3QvtC1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRGF0YWJhc2VNYW5hZ2VyLnVubWFya01lc3NhZ2VXaXRoVGFnKGRhdGFbMV0sIFwiaW1wb3J0YW50XCIsIF8ubm9vcCwgZnVuY3Rpb24gKGlzRGF0YWJhc2VFcnJvciwgZXJyTXNnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0RhdGFiYXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExvZ01hbmFnZXIuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENQQS5zZW5kRXZlbnQoXCJDdXN0b20tRXJyb3JzXCIsIFwiRGF0YWJhc2UgZXJyb3JcIiwgZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhWzJdICYgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIERhdGFiYXNlTWFuYWdlci5tYXJrQXNSZWFkKGRhdGFbMV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe1wiYWN0aW9uXCIgOiBcIm1zZ1JlYWRTdGF0dXNDaGFuZ2VcIiwgXCJyZWFkXCIgOiB0cnVlLCBcImlkXCIgOiBkYXRhWzFdfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVyck1zZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dNYW5hZ2VyLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENQQS5zZW5kRXZlbnQoXCJDdXN0b20tRXJyb3JzXCIsIFwiRGF0YWJhc2UgZXJyb3JcIiwgZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1aWQgPSAoZGF0YVs3XS5mcm9tICE9PSB1bmRlZmluZWQpID8gZGF0YVs3XS5mcm9tIDogZGF0YVszXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWlsVHlwZSA9IChkYXRhWzJdICYgMikgPyBcInNlbnRcIiA6IFwiaW5ib3hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblVzZXJEYXRhUmVhZHk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNpbmdEYXRhW2N1cnJlbnRVc2VySWRdW21haWxUeXBlXVsxXSArPSAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBvblVzZXJEYXRhUmVhZHkgPSBmdW5jdGlvbih1c2VyRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRhY2htZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2dEYXRhID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmaWVsZCBpbiBkYXRhWzddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gZmllbGQubWF0Y2goL15hdHRhY2goW1xcZF0rKSQvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dGFjaFR5cGUgPSBkYXRhWzddW1wiYXR0YWNoXCIgKyBtYXRjaGVzWzFdICsgXCJfdHlwZVwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudHMucHVzaChbYXR0YWNoVHlwZV0uY29uY2F0KGRhdGFbN11bZmllbGRdLnNwbGl0KFwiX1wiKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhWzddLmdlbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRzLnB1c2goW1wiZ2VvcG9pbnRcIiwgZGF0YVs3XS5nZW9dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2dEYXRhLm1pZCA9IGRhdGFbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNnRGF0YS51aWQgPSB1c2VyRGF0YS51aWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNnRGF0YS5kYXRlID0gZGF0YVs0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2dEYXRhLnRpdGxlID0gZGF0YVs1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2dEYXRhLmJvZHkgPSBkYXRhWzZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZ0RhdGEucmVhZF9zdGF0ZSA9IChkYXRhWzJdICYgMSkgPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2dEYXRhLmF0dGFjaG1lbnRzID0gYXR0YWNobWVudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNnRGF0YS5jaGF0X2lkID0gKGRhdGFbN10uZnJvbSAhPT0gdW5kZWZpbmVkKSA/IGRhdGFbM10gLSAyMDAwMDAwMDAwIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2dEYXRhLnRhZ3MgPSBbbWFpbFR5cGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZ0RhdGEuZW1vamkgPSBkYXRhWzddLmVtb2ppID8gMSA6IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZ0RhdGEudGFncy5wdXNoKFwiYXR0YWNobWVudHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRGF0YWJhc2VNYW5hZ2VyLmluc2VydE1lc3NhZ2VzKGN1cnJlbnRVc2VySWQsIFttc2dEYXRhXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDQvtCx0L3QvtCy0LvRj9C10Lwg0YTRgNC+0L3RgtC10L3QtFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwibWVzc2FnZVJlY2VpdmVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBtc2dEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcmRhdGE6IHVzZXJEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWlsVHlwZSA9PT0gXCJpbmJveFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXZhdGFyID0gdXNlckRhdGEucGhvdG8gfHwgY2hyb21lLnJ1bnRpbWUuZ2V0VVJMKFwicGljL3F1ZXN0aW9uX3RoLmdpZlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dOb3RpZmljYXRpb24oYXZhdGFyLCB1c2VyRGF0YS51aWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gc2hvd05vdGlmaWNhdGlvbihhdmF0YXJVcmwsIHVpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFNldHRpbmdzTWFuYWdlci5Ob3RpZmljYXRpb25zVGltZSA9PT0gMC8qIHx8IFNldHRpbmdzTWFuYWdlci5TaG93V2hlblZLID09PSAwKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93Q2hyb21lTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aWQ6IHVpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogdXNlckRhdGEuZmlyc3RfbmFtZSArIFwiIFwiICsgdXNlckRhdGEubGFzdF9uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZ0RhdGEuYm9keS5yZXBsYWNlKC88YnI+L2dtLCBcIlxcblwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uOiBhdmF0YXJVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291bmQ6IFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IChTZXR0aW5nc01hbmFnZXIuTm90aWZpY2F0aW9uc1RpbWUgPT09IDEyKSA/IHVuZGVmaW5lZCA6IFNldHRpbmdzTWFuYWdlci5Ob3RpZmljYXRpb25zVGltZSAqIDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dNYW5hZ2VyLmNvbmZpZyhcIkNsaWNrZWQgbm90aWZpY2F0aW9uIHdpdGggbWVzc2FnZSAjXCIgKyBtc2dEYXRhLm1pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlYXZlT25lQXBwV2luZG93SW5zdGFuY2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExvZ01hbmFnZXIuY29uZmlnKFwiT3BlbiBub3RpZmljYXRpb24gd2l0aCBtZXNzYWdlICNcIiArIG1zZ0RhdGEubWlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgRGF0YWJhc2VNYW5hZ2VyLmdldENvbnRhY3RCeUlkKGN1cnJlbnRVc2VySWQsIHVpZCwgb25Vc2VyRGF0YVJlYWR5LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g0YLQtdC+0YDQtdGC0LjRh9C10YHQutC4INC80L7QttC10YIg0LjQt9C80LXQvdC40YLRjNGB0Y8gY3VycmVudFVzZXJJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VXNlcklkID09PSBBY2NvdW50c01hbmFnZXIuY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRVc2VyUHJvZmlsZShjdXJyZW50VXNlcklkLCBwYXJzZUludCh1aWQsIDEwKSwgb25Vc2VyRGF0YVJlYWR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4IDogLy8g0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GMIC1kYXRhWzFdINC+0L3Qu9Cw0LnQvVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFNldHRpbmdzTWFuYWdlci5TaG93T25saW5lID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe1wiYWN0aW9uXCIgOiBcImNvbnRhY3RPbmxpbmVTdGF0dXNcIiwgXCJ1aWRcIiA6IC1kYXRhWzFdLCBcIm9ubGluZVwiIDogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDkgOiAvLyDQv9C+0LvRjNC30L7QstCw0YLQtdC70YwgLWRhdGFbMV0g0L7RhNGE0LvQsNC50L0gKNC90LDQttCw0Lsg0LrQvdC+0L/QutGDIFwi0LLRi9C50YLQuFwiINC10YHQu9C4IGRhdGFbMl0gPT09IDAsINC40L3QsNGH0LUg0L/QviDRgtCw0LnQvNCw0YPRgtGDKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFNldHRpbmdzTWFuYWdlci5TaG93T25saW5lID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe1wiYWN0aW9uXCIgOiBcImNvbnRhY3RPbmxpbmVTdGF0dXNcIiwgXCJ1aWRcIiA6IC1kYXRhWzFdLCBcIm9ubGluZVwiIDogZmFsc2V9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2MSA6IC8vINC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjCBkYXRhWzFdINC90LDRh9Cw0Lsg0L3QsNCx0LjRgNCw0YLRjCDRgtC10LrRgdGCINCyINC00LjQsNC70L7Qs9C1XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjIgOiAvLyDQv9C+0LvRjNC30L7QstCw0YLQtdC70YwgZGF0YVsxXSDQvdCw0YfQsNC7INC90LDQsdC40YDQsNGC0Ywg0YLQtdC60YHRgiDQsiDQsdC10YHQtdC00LUgZGF0YVsyXVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgICAgICBMb2dNYW5hZ2VyLmluZm8oW2RhdGFbMF0sIGRhdGFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKEFjY291bnRzTWFuYWdlci5jdXJyZW50VXNlcklkID09PSBjdXJyZW50VXNlcklkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ1BvbGxEYXRhW2N1cnJlbnRVc2VySWRdLnRzID0gcmVzLnRzO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdQb2xsSW5pdChjdXJyZW50VXNlcklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfb25FcnJvcjogZnVuY3Rpb24oY3VycmVudFVzZXJJZCwgZXJyb3JDb2RlLCBlcnJvckRhdGEpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9sb25nUG9sbFhocklkc1tjdXJyZW50VXNlcklkXTtcbiAgICAgICAgICAgIGlmIChlcnJvckNvZGUgPT09IFJlcU1hbmFnZXIuQUJPUlQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICB0aGlzLmluaXQoY3VycmVudFVzZXJJZCk7XG5cbiAgICAgICAgICAgIGlmIChBY2NvdW50c01hbmFnZXIuY3VycmVudFVzZXJJZCA9PT0gY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgICAgICAgIG1haWxTeW5jKGN1cnJlbnRVc2VySWQsIFwiaW5ib3hcIik7XG4gICAgICAgICAgICAgICAgbWFpbFN5bmMoY3VycmVudFVzZXJJZCwgXCJzZW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRDcmVkZW50aWFsczogZnVuY3Rpb24oY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBSZXFNYW5hZ2VyLmFwaU1ldGhvZChcIm1lc3NhZ2VzLmdldExvbmdQb2xsU2VydmVyXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFjY291bnRzTWFuYWdlci5jdXJyZW50VXNlcklkICE9PSBjdXJyZW50VXNlcklkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBzZWxmLl9sb25nUG9sbERhdGFbY3VycmVudFVzZXJJZF0gPSBkYXRhLnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIHNlbGYuX2xvbmdQb2xsSW5pdChjdXJyZW50VXNlcklkKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJDb2RlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYuX2xvbmdQb2xsWGhySWRzW2N1cnJlbnRVc2VySWRdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVyckNvZGUgPT09IFJlcU1hbmFnZXIuQUNDRVNTX0RFTklFRCkge1xuICAgICAgICAgICAgICAgICAgICBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSh7YWN0aW9uOiBcInRva2VuRXhwaXJlZFwifSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChlcnJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5BQk9SVDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLkFDQ0VTU19ERU5JRUQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoc2VsZi5pbml0LmJpbmQoc2VsZiksIDUwMDAsIGN1cnJlbnRVc2VySWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2xvbmdQb2xsSW5pdDogZnVuY3Rpb24oY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgICAgdmFyIGRvbWFpbiA9IHRoaXMuX2xvbmdQb2xsRGF0YVtjdXJyZW50VXNlcklkXS5zZXJ2ZXIucmVwbGFjZShcInZrb250YWt0ZS5ydVwiLCBcInZrLmNvbVwiKTtcblxuICAgICAgICAgICAgdGhpcy5fbG9uZ1BvbGxYaHJJZHNbY3VycmVudFVzZXJJZF0gPSBSZXFNYW5hZ2VyLmZvcmNlVXJsR2V0KFwiaHR0cHM6Ly9cIiArIGRvbWFpbiwge1xuICAgICAgICAgICAgICAgIFwiYWN0XCIgOiBcImFfY2hlY2tcIixcbiAgICAgICAgICAgICAgICBcImtleVwiIDogdGhpcy5fbG9uZ1BvbGxEYXRhW2N1cnJlbnRVc2VySWRdLmtleSxcbiAgICAgICAgICAgICAgICBcInRzXCIgOiB0aGlzLl9sb25nUG9sbERhdGFbY3VycmVudFVzZXJJZF0udHMsXG4gICAgICAgICAgICAgICAgXCJ3YWl0XCIgOiAyNSxcbiAgICAgICAgICAgICAgICBcIm1vZGVcIiA6IDIsXG4gICAgICAgICAgICAgICAgXCJ0aW1lb3V0XCIgOiAzMFxuICAgICAgICAgICAgfSwgdGhpcy5fb25Mb2FkLmJpbmQodGhpcywgY3VycmVudFVzZXJJZCksIHRoaXMuX29uRXJyb3IuYmluZCh0aGlzLCBjdXJyZW50VXNlcklkKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2xvbmdQb2xsRGF0YToge30sXG4gICAgICAgIF9sb25nUG9sbFhocklkczoge30sXG4gICAgICAgIF90YWdzOiB7fVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDQl9Cw0L/RgNC+0YEg0LogQVBJINCS0JrQvtC90YLQsNC60YLQtSDQt9CwINC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRj9C80Lgg0Lgg0L/QvtGB0LvQtdC00YPRjtGJ0LDRjyDQt9Cw0L/QuNGB0Ywg0LjRhSDQsiDQkdCUXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY3VycmVudFVzZXJJZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB1aWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayDRhNGD0L3QutGG0LjRjywg0LIg0LrQvtGC0L7RgNGD0Y4g0L/QtdGA0LXQtNCw0LXRgtGB0Y8g0LLQtdGB0Ywg0L7QsdGK0LXQutGCLdC+0YLQstC10YIg0L7RgiBBUEkg0JLQmtC+0L3RgtCw0LrRgtC1XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VXNlclByb2ZpbGUoY3VycmVudFVzZXJJZCwgdWlkLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgdG9rZW5Gb3JSZXF1ZXN0ID0gQWNjb3VudHNNYW5hZ2VyLmxpc3RbY3VycmVudFVzZXJJZF0udG9rZW47XG5cbiAgICAgICAgdWlkc1Byb2Nlc3NpbmdbY3VycmVudFVzZXJJZF0gPSB1aWRzUHJvY2Vzc2luZ1tjdXJyZW50VXNlcklkXSB8fCB7fTtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBfLm5vb3A7XG5cbiAgICAgICAgLy8g0L/RgNC+0LLQtdGA0Y/QtdC8IHVpZCDQvdCwINC90LDRhdC+0LbQtNC10L3QuNC1INCyINGB0L/QuNGB0LrQtSDQvtCx0YDQsNCx0LDRgtGL0LLQsNC10LzRi9GFXG4gICAgICAgIGlmICh1aWRzUHJvY2Vzc2luZ1tjdXJyZW50VXNlcklkXVt1aWRdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBSZXFNYW5hZ2VyLmFwaU1ldGhvZChcInVzZXJzLmdldFwiLCB7XG4gICAgICAgICAgICB1aWRzOiBTdHJpbmcodWlkKSxcbiAgICAgICAgICAgIGZpZWxkczogXCJmaXJzdF9uYW1lLGxhc3RfbmFtZSxzZXgsZG9tYWluLGJkYXRlLHBob3RvLGNvbnRhY3RzXCIsXG4gICAgICAgICAgICBhY2Nlc3NfdG9rZW46IHRva2VuRm9yUmVxdWVzdFxuICAgICAgICB9LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgLy8g0LfQsNC/0LjRgdGL0LLQsNC10Lwg0LTQsNC90L3Ri9C1INC00YDRg9C30LXQuSDQsiDQkdCUINC4INGB0LrQsNGH0LjQstCw0LXQvCDQuNGFINCw0LLQsNGC0LDRgNC60LhcbiAgICAgICAgICAgIHVwZGF0ZVVzZXJzRGF0YShjdXJyZW50VXNlcklkLCBkYXRhLnJlc3BvbnNlKS50aGVuKGZ1bmN0aW9uICh1c2Vycykge1xuICAgICAgICAgICAgICAgIHZhciB1c2VyRGF0YSA9IHVzZXJzWzBdO1xuXG4gICAgICAgICAgICAgICAgLy8g0YPQtNCw0LvRj9C10Lwg0LjQtyDRgdC/0LjRgdC60LAg0L7QsdGA0LDQsdCw0YLRi9Cy0LDQtdC80YvRhVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB1aWRzUHJvY2Vzc2luZ1tjdXJyZW50VXNlcklkXVt1c2VyRGF0YS51aWRdO1xuXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodXNlckRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJDb2RlLCBlcnJEYXRhKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGVyckNvZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuQUJPUlQgOlxuICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5BQ0NFU1NfREVOSUVEIDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChnZXRVc2VyUHJvZmlsZSwgNSoxMDAwLCBjdXJyZW50VXNlcklkLCB1aWQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog0KHQuNC90YXRgNC+0L3QuNC30LDRhtC40Y8g0YHQv9C40YHQutCwINC00YDRg9C30LXQuVxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gY3VycmVudFVzZXJJZFxuICAgICAqL1xuICAgIHZhciBmcmllbmRzU3luYyA9IGZ1bmN0aW9uIChjdXJyZW50VXNlcklkKSB7XG4gICAgICAgIGlmIChmcmllbmRzU3luYy5ydW5uaW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIC8vINGE0LvQsNCzLCDRh9GC0L7QsdGLINC90LUg0LLRi9C30YvQstCw0YLRjCDQvNC10YLQvtC0INC+0LTQvdC+0LLRgNC10LzQtdC90L3QviDQvdC10YHQutC+0LvRjNC60L4g0YDQsNC3INC/0L7QtNGA0Y/QtFxuICAgICAgICBmcmllbmRzU3luYy5ydW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICB2YXIgZnJpZW5kc1N5bmNUaW1lcyA9IHN0b3JhZ2VNYW5hZ2VyLmdldChcImZyaWVuZHNfc3luY190aW1lXCIsIHtjb25zdHJ1Y3RvcjogT2JqZWN0LCBzdHJpY3Q6IHRydWUsIGNyZWF0ZTogdHJ1ZX0pO1xuICAgICAgICB2YXIgbWlsbGlTZWNvbmRzVGltZW91dCA9IEFwcC5GUklFTkRTX1VQREFURV9USU1FT1VUICogMTAwMDtcbiAgICAgICAgdmFyIG5leHRSZXF1ZXN0VGltZW91dDtcblxuICAgICAgICAvLyDQv9GA0L7QstC10YDRj9C10LwsINGH0YLQvtCx0Ysg0LfQsNC/0YDQvtGB0Ysg0L3QsCDRgdC40L3RhdGA0L7QvdC40LfQsNGG0LjRjiDRiNC70Lgg0YLQvtC70YzQutC+INC+0YIg0YLQtdC60YPRidC10LPQviDQsNC60YLQuNCy0L3QvtCz0L4g0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GPXG4gICAgICAgIGlmIChjdXJyZW50VXNlcklkICE9PSBBY2NvdW50c01hbmFnZXIuY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgICAgZnJpZW5kc1N5bmMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g0L/RgNC+0LLQtdGA0Y/QtdC8LCDRh9GC0L7QsdGLINC90LUg0LHRi9C70L4g0YHQu9C40YjQutC+0Lwg0YfQsNGB0YLRi9GFINC30LDQv9GA0L7RgdC+0LJcbiAgICAgICAgaWYgKGZyaWVuZHNTeW5jVGltZXNbY3VycmVudFVzZXJJZF0pIHtcbiAgICAgICAgICAgIG5leHRSZXF1ZXN0VGltZW91dCA9IE1hdGgubWF4KChtaWxsaVNlY29uZHNUaW1lb3V0IC0gTWF0aC5hYnMoRGF0ZS5ub3coKSAtIGZyaWVuZHNTeW5jVGltZXNbY3VycmVudFVzZXJJZF0pKSwgMCk7XG4gICAgICAgICAgICBpZiAobmV4dFJlcXVlc3RUaW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZyaWVuZHNTeW5jLCBuZXh0UmVxdWVzdFRpbWVvdXQsIGN1cnJlbnRVc2VySWQpO1xuXG4gICAgICAgICAgICAgICAgZnJpZW5kc1N5bmMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vINC/0L7Qt9C00YDQsNCy0LvRj9C10Lwg0YLQtdC60YPRidC10LPQviDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y8g0YEg0JTQoFxuICAgICAgICBnZXRVc2VyUHJvZmlsZShjdXJyZW50VXNlcklkLCBjdXJyZW50VXNlcklkLCBmdW5jdGlvbiAoY3VycmVudFVzZXJEYXRhKSB7XG4gICAgICAgICAgICB2YXIgbm93RGF0ZSA9IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgbm93RGF5ID0gbm93RGF0ZS5nZXREYXRlKCksXG4gICAgICAgICAgICAgICAgbm93WWVhciA9IG5vd0RhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICAgICAgICBub3dNb250aCA9IG5vd0RhdGUuZ2V0TW9udGgoKSArIDEsXG4gICAgICAgICAgICAgICAgYkRhdGUsIGksIG5vdGlmaWNhdGlvbiwgbXNnO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFVzZXJEYXRhLmJkYXRlID09PSB1bmRlZmluZWQgfHwgY3VycmVudFVzZXJEYXRhLmJkYXRlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIC8vINGA0LDQt9Cx0LjQstCw0LXQvCDQuCDQv9GA0LXQvtCx0YDQsNC30YPQtdC8INCyINGH0LjRgdC70LBcbiAgICAgICAgICAgIGJEYXRlID0gY3VycmVudFVzZXJEYXRhLmJkYXRlLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBiRGF0ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBiRGF0ZVtpXSA9IHBhcnNlSW50KGJEYXRlW2ldLCAxMCk7XG5cbiAgICAgICAgICAgIGlmIChiRGF0ZVswXSAhPT0gbm93RGF5IHx8IGJEYXRlWzFdICE9PSBub3dNb250aClcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIHNob3dDaHJvbWVOb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgICAgIHRpdGxlOiBBcHAuTkFNRSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaHJvbWUuaTE4bi5nZXRNZXNzYWdlKFwiaGFwcHlCaXJ0aGRheVwiKS5yZXBsYWNlKFwiJWFwcG5hbWUlXCIsIEFwcC5OQU1FKSxcbiAgICAgICAgICAgICAgICBpY29uOiBjaHJvbWUucnVudGltZS5nZXRVUkwoXCJwaWMvc21pbGUucG5nXCIpLFxuICAgICAgICAgICAgICAgIHNvdW5kOiBcIm1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIENQQS5zZW5kRXZlbnQoXCJBcHAtQWN0aW9uc1wiLCBcIkJEIG5vdGlmaWNhdGlvbiBjbGlja1wiKTtcbiAgICAgICAgICAgICAgICAgICAgbGVhdmVPbmVBcHBXaW5kb3dJbnN0YW5jZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgQ1BBLnNlbmRFdmVudChcIkFwcC1EYXRhXCIsIFwiU2hvdyBCRCBub3RpZmljYXRpb25cIik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIFJlcU1hbmFnZXIuYXBpTWV0aG9kKFwiZnJpZW5kcy5nZXRcIiwge2ZpZWxkczogXCJmaXJzdF9uYW1lLGxhc3RfbmFtZSxzZXgsZG9tYWluLGJkYXRlLHBob3RvLGNvbnRhY3RzXCJ9LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIG5vd0RhdGUgPSBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIG5vd0RheSA9IG5vd0RhdGUuZ2V0RGF0ZSgpLFxuICAgICAgICAgICAgICAgIG5vd1llYXIgPSBub3dEYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICAgICAgbm93TW9udGggPSBub3dEYXRlLmdldE1vbnRoKCkgKyAxO1xuXG4gICAgICAgICAgICBzeW5jaW5nRGF0YVtjdXJyZW50VXNlcklkXS5jb250YWN0c1swXSArPSBkYXRhLnJlc3BvbnNlLmxlbmd0aDtcblxuICAgICAgICAgICAgLy8g0LfQsNC/0LjRgdGL0LLQsNC10Lwg0LTQsNC90L3Ri9C1INC00YDRg9C30LXQuSDQsiDQkdCUINC4INGB0LrQsNGH0LjQstCw0LXQvCDQuNGFINCw0LLQsNGC0LDRgNC60LhcbiAgICAgICAgICAgIHVwZGF0ZVVzZXJzRGF0YShjdXJyZW50VXNlcklkLCBkYXRhLnJlc3BvbnNlKS50aGVuKGZ1bmN0aW9uICh1c2Vycykge1xuICAgICAgICAgICAgICAgIHVzZXJzLmZvckVhY2goZnVuY3Rpb24gKHVzZXJEb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJEYXRlLCBpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vINGD0LTQsNC70Y/QtdC8INC40Lcg0YHQv9C40YHQutCwINC+0LHRgNCw0LHQsNGC0YvQstCw0LXQvNGL0YVcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHVpZHNQcm9jZXNzaW5nW2N1cnJlbnRVc2VySWRdW3VzZXJEb2MudWlkXTtcblxuICAgICAgICAgICAgICAgICAgICBzeW5jaW5nRGF0YVtjdXJyZW50VXNlcklkXS5jb250YWN0c1sxXSArPSAxO1xuICAgICAgICAgICAgICAgICAgICBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwic3luY1Byb2dyZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQ6IGN1cnJlbnRVc2VySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbnRhY3RzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbDogc3luY2luZ0RhdGFbY3VycmVudFVzZXJJZF0uY29udGFjdHNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50OiBzeW5jaW5nRGF0YVtjdXJyZW50VXNlcklkXS5jb250YWN0c1sxXVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoU2V0dGluZ3NNYW5hZ2VyLlNob3dCaXJ0aGRheU5vdGlmaWNhdGlvbnMgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgLy8g0L/QvtC60LDQt9GL0LLQsNC10Lwg0YPQstC10LTQvtC80LvQtdC90LjQtSwg0LXRgdC70Lgg0YMg0LrQvtCz0L4t0YLQviDQuNC3INC00YDRg9C30LXQuSDQlNCgXG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyRG9jLmJkYXRlID09PSB1bmRlZmluZWQgfHwgdXNlckRvYy5iZGF0ZS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgLy8g0YDQsNC30LHQuNCy0LDQtdC8INC4INC/0YDQtdC+0LHRgNCw0LfRg9C10Lwg0LIg0YfQuNGB0LvQsFxuICAgICAgICAgICAgICAgICAgICBiRGF0ZSA9IHVzZXJEb2MuYmRhdGUuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYkRhdGUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBiRGF0ZVtpXSA9IHBhcnNlSW50KGJEYXRlW2ldLCAxMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJEYXRlWzBdICE9PSBub3dEYXkgfHwgYkRhdGVbMV0gIT09IG5vd01vbnRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vINC/0L7QutCw0LfRi9Cy0LDQtdC8INGD0LLQtdC00L7QvNC70LXQvdC40LUg0L4g0JTQoFxuICAgICAgICAgICAgICAgICAgICB2YXIgaTE4bkJpcnRoRGF5ID0gY2hyb21lLmkxOG4uZ2V0TWVzc2FnZShcImJpcnRoZGF5XCIpLnNwbGl0KFwifFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkxOG5ZZWFycyA9IGNocm9tZS5pMThuLmdldE1lc3NhZ2UoXCJ5ZWFyc1wiKS5zcGxpdChcInxcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBoaXNIZXJNYXRjaGVzID0gaTE4bkJpcnRoRGF5WzBdLm1hdGNoKC8oW15cXHNdKyktKFteXFxzXSspLyksXG4gICAgICAgICAgICAgICAgICAgICAgICBtc2csIHlvTm93LCBub3RpZmljYXRpb247XG5cbiAgICAgICAgICAgICAgICAgICAgdXNlckRvYy5zZXggPSB1c2VyRG9jLnNleCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHVzZXJEb2Muc2V4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEgOiAvLyBmZW1hbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBpMThuQmlydGhEYXlbMF0ucmVwbGFjZShoaXNIZXJNYXRjaGVzWzBdLCBoaXNIZXJNYXRjaGVzWzJdKSArIFwiIVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIgOiAvLyBtYWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNnID0gaTE4bkJpcnRoRGF5WzBdLnJlcGxhY2UoaGlzSGVyTWF0Y2hlc1swXSwgaGlzSGVyTWF0Y2hlc1sxXSkgKyBcIiFcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6IC8vIG5vbi1zcGVjaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBpMThuQmlydGhEYXlbMF0ucmVwbGFjZShoaXNIZXJNYXRjaGVzWzBdLCBoaXNIZXJNYXRjaGVzWzFdICsgXCIgKFwiICsgaGlzSGVyTWF0Y2hlc1syXSArIFwiKVwiKSArIFwiIVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJEYXRlLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgeW9Ob3cgPSBub3dZZWFyIC0gYkRhdGVbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cgKz0gXCIgKFwiICsgaTE4bkJpcnRoRGF5WzFdLnJlcGxhY2UoXCIleWVhcnMlXCIsIHlvTm93ICsgXCIgXCIgKyBVdGlscy5zdHJpbmcucGx1cmFsKHlvTm93LCBpMThuWWVhcnMpKSArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2hvd0Nocm9tZU5vdGlmaWNhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1aWQ6IHVzZXJEb2MudWlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHVzZXJEb2MuZmlyc3RfbmFtZSArIFwiIFwiICsgdXNlckRvYy5sYXN0X25hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uOiB1c2VyRG9jLnBob3RvIHx8IGNocm9tZS5ydW50aW1lLmdldFVSTChcInBpYy9xdWVzdGlvbl90aC5naWZcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VuZDogXCJtZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVhdmVPbmVBcHBXaW5kb3dJbnN0YW5jZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5ib3hTeW5jZWQgPSAoc3RvcmFnZU1hbmFnZXIuZ2V0KFwicGVybV9pbmJveF9cIiArIGN1cnJlbnRVc2VySWQpICE9PSBudWxsKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VudFN5bmNlZCA9IChzdG9yYWdlTWFuYWdlci5nZXQoXCJwZXJtX291dGJveF9cIiArIGN1cnJlbnRVc2VySWQpICE9PSBudWxsKTtcblxuICAgICAgICAgICAgICAgIGZyaWVuZHNTeW5jVGltZXNbY3VycmVudFVzZXJJZF0gPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIHN0b3JhZ2VNYW5hZ2VyLnNldChcImZyaWVuZHNfc3luY190aW1lXCIsIGZyaWVuZHNTeW5jVGltZXMpO1xuXG4gICAgICAgICAgICAgICAgLy8g0YHQu9C10LTRg9GO0YnQsNGPINGB0LjQvdGF0YDQvtC90LjQt9Cw0YbQuNGPINC00L7Qu9C20L3QsCDQvdCw0YfQsNGC0YzRgdGPINGH0LXRgNC10LcgRlJJRU5EU19VUERBVEVfVElNRU9VVFxuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZyaWVuZHNTeW5jLCBtaWxsaVNlY29uZHNUaW1lb3V0LCBjdXJyZW50VXNlcklkKTtcblxuICAgICAgICAgICAgICAgIC8vINC10YHQu9C4INC6INGN0YLQvtC80YMg0LzQvtC80LXQvdGC0YMg0YPQttC1INGB0LjQvdGF0YDQvtC90LjQt9C40YDQvtCy0LDQvdGLINCy0YXQvtC00Y/RidC40LUg0Lgg0LjRgdGF0L7QtNGP0YnQuNC1XG4gICAgICAgICAgICAgICAgaWYgKEFjY291bnRzTWFuYWdlci5jdXJyZW50VXNlcklkID09PSBjdXJyZW50VXNlcklkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmJveFN5bmNlZCAmJiBzZW50U3luY2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDRgdCx0YDQsNGB0YvQstCw0LXQvCDRgdGH0LXRgtGH0LjQuiDRgdC40L3RhdGA0L7QvdC40LfQsNGG0LjQuFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJTeW5jaW5nRGF0YUNvdW50ZXJzKGN1cnJlbnRVc2VySWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRGF0YWJhc2VNYW5hZ2VyLmFjdHVhbGl6ZUNvbnRhY3RzKGN1cnJlbnRVc2VySWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIERhdGFiYXNlTWFuYWdlci5hY3R1YWxpemVDaGF0RGF0ZXMoY3VycmVudFVzZXJJZClcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tZS5ydW50aW1lLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInVpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoOiBcInVzZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFVzZXJJZDogQWNjb3VudHNNYW5hZ2VyLmN1cnJlbnRVc2VySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVc2VyRmlvOiBBY2NvdW50c01hbmFnZXIuY3VycmVudCA/IEFjY291bnRzTWFuYWdlci5jdXJyZW50LmZpbyA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnJpZW5kc1N5bmMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJDb2RlLCBlcnJEYXRhKSB7XG4gICAgICAgICAgICBmcmllbmRzU3luYy5ydW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoZXJyQ29kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5BQk9SVCA6XG4gICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLkFDQ0VTU19ERU5JRUQgOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZyaWVuZHNTeW5jLCA1KjEwMDAsIGN1cnJlbnRVc2VySWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog0KTRg9C90LrRhtC40Y8t0L7QsdGA0LDQsdC+0YLRh9C40LosINC60L7RgtC+0YDQsNGPINC30LDQv9GD0YHQutCw0LXRgtGB0Y8g0LIg0LzQtdGC0L7QtNCw0YUgZnJpZW5kcy5nZXQvdXNlcnMuZ2V0LCDQv9C+0YHQutC+0LvRjNC60YMg0L7QsdCwINC80LXRgtC+0LTQsCDQstC+0LfQstGA0LDRidCw0Y7RgiDQv9GA0LjQvNC10YDQvdC+XG4gICAgICog0L7QtNC40L3QsNC60L7QstGL0Lkg0L7RgtCy0LXRgiDQuCDQuNC80LXRjtGCINC+0LHRidGD0Y4g0LvQvtCz0LjQutGDINC30LDQv9C40YHQuCDQtNCw0L3QvdGL0YUg0LIg0JHQlFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGN1cnJlbnRVc2VySWRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB1c2Vyc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVVc2Vyc0RhdGEoY3VycmVudFVzZXJJZCwgdXNlcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBkYXRhVG9SZXBsYWNlID0gW107XG4gICAgICAgICAgICB1aWRzUHJvY2Vzc2luZ1tjdXJyZW50VXNlcklkXSA9IHVpZHNQcm9jZXNzaW5nW2N1cnJlbnRVc2VySWRdIHx8IHt9O1xuXG4gICAgICAgICAgICB1c2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh1c2VyRGF0YSkge1xuICAgICAgICAgICAgICAgIC8vINC00L7QsdCw0LLQu9GP0LXQvCB1aWQg0LIg0YHQv9C40YHQvtC6INC+0LHRgNCw0LHQsNGC0YvQstCw0LXQvNGL0YVcbiAgICAgICAgICAgICAgICB1aWRzUHJvY2Vzc2luZ1tjdXJyZW50VXNlcklkXVt1c2VyRGF0YS51aWRdID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vINC+0LHQvdC+0LLQu9GP0LXQvCDQpNCY0J4g0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GPXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRVc2VySWQgPT09IHVzZXJEYXRhLnVpZCkge1xuICAgICAgICAgICAgICAgICAgICBBY2NvdW50c01hbmFnZXIuc2V0RmlvKGN1cnJlbnRVc2VySWQsIHVzZXJEYXRhLmZpcnN0X25hbWUgKyBcIiBcIiArIHVzZXJEYXRhLmxhc3RfbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGF0YVRvUmVwbGFjZS5wdXNoKFt1c2VyRGF0YS51aWQsIHVzZXJEYXRhLmZpcnN0X25hbWUsIHVzZXJEYXRhLmxhc3RfbmFtZSwgdXNlckRhdGFdKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWRhdGFUb1JlcGxhY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBEYXRhYmFzZU1hbmFnZXIucmVwbGFjZUNvbnRhY3RzKGN1cnJlbnRVc2VySWQsIGRhdGFUb1JlcGxhY2UpLnRoZW4ocmVzb2x2ZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHZhciBlcnJNZXNzYWdlID0gZXJyLm5hbWUgKyBcIjogXCIgKyBlcnIubWVzc2FnZTtcblxuICAgICAgICAgICAgICAgIExvZ01hbmFnZXIuZXJyb3IoZXJyTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgQ1BBLnNlbmRFdmVudChcIkN1c3RvbS1FcnJvcnNcIiwgXCJEYXRhYmFzZSBlcnJvclwiLCBcIkZhaWxlZCB0byByZXBsYWNlIGNvbnRhY3Q6IFwiICsgZXJyTWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgICByZWplY3QoZXJyTWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog0J7RgdC+0LHQtdC90L3QvtGB0YLRjCBtYWlsU3luYyDQt9Cw0LrQu9GO0YfQsNC10YLRgdGPINCyINGC0L7QvCwg0YfRgtC+INC+0L3QsCDQtNC+0LvQttC90LAg0LfQsNC/0YPRgdC60LDRgtGM0YHRjyDRgNC10LTQutC+INC4INC40Lcgc3RhcnRVc2VyU2Vzc2lvblxuICAgICAqINCaINC80L7QvNC10L3RgtGDINC90LDRh9Cw0LvQsCDRgNCw0LHQvtGC0YsgbWFpbFN5bmMg0YLQtdC60YPRidC40Lkg0LDQutGC0LjQstC90YvQuSDQv9C+0LvRjNC30L7QstCw0YLQtdC70Ywg0LzQvtC20LXRgiDRgdC80LXQvdC40YLRjNGB0Y8uINCi0LXQvCDQvdC1INC80LXQvdC10LVcbiAgICAgKiDRhNGD0L3QutGG0LjRjyDQtNC+0LvQttC90LAg0L7RgtGA0LDQsdC+0YLQsNGC0Ywg0LTQviDQutC+0L3RhtCwLCDRgtC+INC10YHRgtGMINC40LvQuCDRgdC60LDRh9Cw0YLRjCDQstGB0LUg0YHQvtC+0LHRidC10L3QuNGPINC00L4g0L3Rg9C70Y8gaW4gZGVzY2VuZGluZyBvcmRlciwg0LjQu9C4XG4gICAgICog0LTQvtC50YLQuCDQtNC+INC80L7QvNC10L3RgtCwLCDQutC+0LPQtNCwINCy0L3Rg9GC0YDQtdC90L3QvdGP0Y8g0YTRg9C90LrRhtC40Y8g0LfQsNC/0LjRgdC4INGB0L7QvtCx0YnQtdC90LjQuSDQsiDQkdCUINCy0LXRgNC90LXRgiDQvtGI0LjQsdC60YMgRFVQTElDQVRFIElELiBtYWlsU3luYyDQvdC1INC00L7Qu9C20L3QsFxuICAgICAqINC/0L7QutCw0LfRi9Cy0LDRgtGMINCy0YHQv9C70YvQstCw0Y7RidC40LUg0YPQstC10LTQvtC80LvQtdC90LjRjywg0Y3RgtC+INC/0YDQtdGA0L7Qs9Cw0YLQuNCy0LAg0L7QsdGA0LDQsdC+0YLRh9C40LrQsCDQtNCw0L3QvdGL0YUg0L7RgiBMb25nUG9sbC3RgdC10YDQstC10YDQsFxuICAgICAqL1xuICAgIHZhciBtYWlsU3luYyA9IGZ1bmN0aW9uKGN1cnJlbnRVc2VySWQsIG1haWxUeXBlLCBsYXRlc3RNZXNzYWdlSWQpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHN5bmNpbmdEYXRhW2N1cnJlbnRVc2VySWRdW21haWxUeXBlXVsxXTtcbiAgICAgICAgdmFyIHVzZXJEYXRhRm9yUmVxdWVzdCA9IEFjY291bnRzTWFuYWdlci5saXN0W2N1cnJlbnRVc2VySWRdLFxuICAgICAgICAgICAgY29tcGF0TmFtZSA9IChtYWlsVHlwZSA9PT0gXCJpbmJveFwiKSA/IFwiaW5ib3hcIiA6IFwib3V0Ym94XCIsXG4gICAgICAgICAgICBwZXJtS2V5ID0gXCJwZXJtX1wiICsgY29tcGF0TmFtZSArIFwiX1wiICsgY3VycmVudFVzZXJJZCxcbiAgICAgICAgICAgIGZpcnN0U3luYyA9IChzdG9yYWdlTWFuYWdlci5nZXQocGVybUtleSkgPT09IG51bGwpO1xuXG4gICAgICAgIHZhciBsYXRlc3RNc2cgPSBvZmZzZXRcbiAgICAgICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKGxhdGVzdE1lc3NhZ2VJZClcbiAgICAgICAgICAgIDogRGF0YWJhc2VNYW5hZ2VyLmdldExhdGVzdFRhZ01lc3NhZ2VJZChtYWlsVHlwZSk7XG5cbiAgICAgICAgdmFyIGdldE1lc3NhZ2VzID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHJlcURhdGEgPSB7XG4gICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiB1c2VyRGF0YUZvclJlcXVlc3QudG9rZW4sXG4gICAgICAgICAgICAgICAgY291bnQ6IDEwMCxcbiAgICAgICAgICAgICAgICBwcmV2aWV3X2xlbmd0aDogMCxcbiAgICAgICAgICAgICAgICBvdXQ6IChtYWlsVHlwZSA9PT0gXCJzZW50XCIpID8gMSA6IDAsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFJlcU1hbmFnZXIuYXBpTWV0aG9kKFwibWVzc2FnZXMuZ2V0XCIsIHJlcURhdGEsIHJlc29sdmUsIGZ1bmN0aW9uIChlcnJDb2RlLCBlcnJEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogZXJyQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZXJyRGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGdldE1lc3NhZ2VzLFxuICAgICAgICAgICAgbGF0ZXN0TXNnXG4gICAgICAgIF0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSByZXNbMF07XG4gICAgICAgICAgICB2YXIgbGF0ZXN0TWVzc2FnZUlkID0gcmVzWzFdO1xuICAgICAgICAgICAgdmFyIHRpbWVUb1N0b3BBZnRlciA9IGZhbHNlOyAvLyBtZXNzYWdlIGZvdW5kIHdpdGggaWQgZXF1YWwgdG8gbGF0ZXN0TWVzc2FnZUlkXG5cbiAgICAgICAgICAgIC8vIGZsYXR0ZW4gcmVzcG9uc2Ugc3RydWN0dXJlXG4gICAgICAgICAgICB2YXIgbWVzc2FnZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBkYXRhU3luY2VkRm47XG5cbiAgICAgICAgICAgIGRhdGFTeW5jZWRGbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmJveFN5bmNlZCwgc2VudFN5bmNlZCwgZnJpZW5kc1N5bmNlZCxcbiAgICAgICAgICAgICAgICAgICAgd2FsbFRva2VuVXBkYXRlZDtcblxuICAgICAgICAgICAgICAgIHN0b3JhZ2VNYW5hZ2VyLnNldChwZXJtS2V5LCAxKTtcblxuICAgICAgICAgICAgICAgIGluYm94U3luY2VkID0gKHN0b3JhZ2VNYW5hZ2VyLmdldChcInBlcm1faW5ib3hfXCIgKyBjdXJyZW50VXNlcklkKSAhPT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgc2VudFN5bmNlZCA9IChzdG9yYWdlTWFuYWdlci5nZXQoXCJwZXJtX291dGJveF9cIiArIGN1cnJlbnRVc2VySWQpICE9PSBudWxsKTtcbiAgICAgICAgICAgICAgICBmcmllbmRzU3luY2VkID0gKHN0b3JhZ2VNYW5hZ2VyLmdldChcImZyaWVuZHNfc3luY190aW1lXCIsIHtjb25zdHJ1Y3RvcjogT2JqZWN0LCBzdHJpY3Q6IHRydWUsIGNyZWF0ZTogdHJ1ZX0pW2N1cnJlbnRVc2VySWRdICE9PSB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKEFjY291bnRzTWFuYWdlci5jdXJyZW50VXNlcklkID09PSBjdXJyZW50VXNlcklkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vINC10YHQu9C4INC6INGN0YLQvtC80YMg0LzQvtC80LXQvdGC0YMg0LLRgdGPINC/0L7Rh9GC0LAg0YHQuNC90YXRgNC+0L3QuNC30LjRgNC+0LLQsNC90LAg0Lgg0LTRgNGD0LfRjNGPINGC0L7QttC1LCDRgtC+INC/0LXRgNC10YDQuNGB0L7QstGL0LLQsNC10Lwg0YTRgNC+0L3RglxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5ib3hTeW5jZWQgJiYgc2VudFN5bmNlZCAmJiBmcmllbmRzU3luY2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDRgdCx0YDQsNGB0YvQstCw0LXQvCDRgdGH0LXRgtGH0LjQuiDRgdC40L3RhdGA0L7QvdC40LfQsNGG0LjQuFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJTeW5jaW5nRGF0YUNvdW50ZXJzKGN1cnJlbnRVc2VySWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDQvNCw0LvQtdC90YzQutC+0LUg0LfQsNC80LXRh9C10L3QuNC1OiDQv9C+0YHQu9C1INGC0L7Qs9C+INC60LDQuiDQsNC60LrQsNGD0L3RgiDQvNC40LPRgNC40YDQvtCy0LDQvSDRgSAzINC90LAgNCDQstC10YDRgdC40Y4sINGB0YLQsNGA0YLRg9C10YIgc3RhcnRVc2VyU2Vzc2lvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDQvtC90LAg0LfQsNC/0YPRgdC60LDQtdGCIG1haWxTeW5jKCksINGH0YLQviDQsiDRgdCy0L7RjiDQvtGH0LXRgNC10LTRjCDQv9C+0YDQvtC00LjRgiDQv9C10YDQtdGA0LjRgdC+0LLQutGDINGE0YDQvtC90YLQsCDQvdCwIFwidWlcIiA9PiBcInVzZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g0YfRgtC+0LHRiyDQt9Cw0YnQuNGC0LjRgtGM0YHRjyDQvtGCINGN0YLQvtCz0L4g0L/RgNC+0LLQtdGA0Y/QtdC8LCDQsdGL0Lsg0LvQuCDQvtCx0L3QvtCy0LvQtdC9INGC0L7QutC10L1cbiAgICAgICAgICAgICAgICAgICAgICAgIHdhbGxUb2tlblVwZGF0ZWQgPSAoc3RvcmFnZU1hbmFnZXIuZ2V0KFwid2FsbF90b2tlbl91cGRhdGVkXCIsIHtjb25zdHJ1Y3RvcjogT2JqZWN0LCBzdHJpY3Q6IHRydWUsIGNyZWF0ZTogdHJ1ZX0pW0FjY291bnRzTWFuYWdlci5jdXJyZW50VXNlcklkXSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YWxsVG9rZW5VcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEYXRhYmFzZU1hbmFnZXIuYWN0dWFsaXplQ29udGFjdHMoY3VycmVudFVzZXJJZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERhdGFiYXNlTWFuYWdlci5hY3R1YWxpemVDaGF0RGF0ZXMoY3VycmVudFVzZXJJZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInVpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaDogXCJ1c2VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VXNlcklkOiBBY2NvdW50c01hbmFnZXIuY3VycmVudFVzZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVc2VyRmlvOiBBY2NvdW50c01hbmFnZXIuY3VycmVudCA/IEFjY291bnRzTWFuYWdlci5jdXJyZW50LmZpbyA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyDQstGB0LUg0L/QvtC70YPRh9C40LvQuFxuICAgICAgICAgICAgaWYgKGRhdGEucmVzcG9uc2UgPT09IDAgfHwgKGRhdGEucmVzcG9uc2UgaW5zdGFuY2VvZiBBcnJheSAmJiBkYXRhLnJlc3BvbnNlLmxlbmd0aCA9PT0gMSkgfHwgZm9yY2VTa2lwU3luYykge1xuICAgICAgICAgICAgICAgIGRhdGFTeW5jZWRGbigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3luY2luZ0RhdGFbY3VycmVudFVzZXJJZF1bbWFpbFR5cGVdWzBdID0gZGF0YS5yZXNwb25zZVswXTtcblxuICAgICAgICAgICAgaWYgKHVpZHNQcm9jZXNzaW5nW2N1cnJlbnRVc2VySWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB1aWRzUHJvY2Vzc2luZ1tjdXJyZW50VXNlcklkXSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDQvtGC0YHQtdC60LDQtdC8INC+0LHRidC40Lkg0YHRh9C10YLRh9C40Log0YHQvtC+0LHRidC10L3QuNC5XG4gICAgICAgICAgICBfLmZvckVhY2goZGF0YS5yZXNwb25zZSwgZnVuY3Rpb24gKG1zZ0RhdGEsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkcztcblxuICAgICAgICAgICAgICAgIC8vINC/0YDQvtC/0YPRgdC60LDQtdC8INC+0LHRidC40Lkg0YHRh9C10YLRh9C40LpcbiAgICAgICAgICAgICAgICBpZiAoIWluZGV4KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBpZiAobXNnRGF0YS5taWQgPT09IGxhdGVzdE1lc3NhZ2VJZCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lVG9TdG9wQWZ0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkuINCU0L4gNCDQstC10YDRgdC40Lgg0L/RgNC4INC+0YLRgdGD0YLRgdGC0LLQuNC4INCy0LvQvtC20LXQvdC40Lkg0L/QuNGB0LDQu9GB0Y8g0L/Rg9GB0YLQvtC5INC+0LHRitC10LrRglxuICAgICAgICAgICAgICAgIC8vINGC0LXQv9C10YDRjCDQvNGLINC+0L/RgNC10LTQtdC70Y/QtdC8INGN0YLQviDQvdCwINGE0YDQvtC90YLQtSDQv9GA0Lgg0L7RgtGA0LjRgdC+0LLQutC1XG4gICAgICAgICAgICAgICAgbXNnRGF0YS5hdHRhY2htZW50cyA9IG1zZ0RhdGEuYXR0YWNobWVudHMgfHwgW107XG5cbiAgICAgICAgICAgICAgICAvLyDQs9C10L7QtNCw0L3QvdGL0LUg0YLQsNC60LbQtSDQv9C40YjQtdC8INC60LDQuiDQstC70L7QttC10L3QuNC1XG4gICAgICAgICAgICAgICAgaWYgKG1zZ0RhdGEuZ2VvICYmIG1zZ0RhdGEuZ2VvLnR5cGUgPT09IFwicG9pbnRcIikge1xuICAgICAgICAgICAgICAgICAgICBjb29yZHMgPSBtc2dEYXRhLmdlby5jb29yZGluYXRlcy5zcGxpdChcIiBcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgbXNnRGF0YS5hdHRhY2htZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZ2VvcG9pbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb3BvaW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0OiBjb29yZHNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG5nOiBjb29yZHNbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbXNnRGF0YS5jaGF0X2lkID0gbXNnRGF0YS5jaGF0X2lkIHx8IDA7XG4gICAgICAgICAgICAgICAgbXNnRGF0YS50YWdzID0gW21haWxUeXBlXTtcblxuICAgICAgICAgICAgICAgIGlmIChtc2dEYXRhLmF0dGFjaG1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbXNnRGF0YS50YWdzLnB1c2goXCJhdHRhY2htZW50c1wiKTtcblxuICAgICAgICAgICAgICAgIC8vINC/0YDQvtCy0LXRgNGP0LXQvCDRgdGD0YnQtdGB0YLQstGD0LXRgiDQu9C4INC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjFxuICAgICAgICAgICAgICAgIGlmICghdWlkc1Byb2Nlc3NpbmdbY3VycmVudFVzZXJJZF1bbXNnRGF0YS51aWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIERhdGFiYXNlTWFuYWdlci5nZXRDb250YWN0QnlJZChjdXJyZW50VXNlcklkLCBtc2dEYXRhLnVpZCwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VXNlclByb2ZpbGUoY3VycmVudFVzZXJJZCwgbXNnRGF0YS51aWQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZXNzYWdlcy5wdXNoKG1zZ0RhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChtc2dEYXRhLnJlYWRfc3RhdGUgPT09IDAgJiYgc3RvcmFnZU1hbmFnZXIuZ2V0KHBlcm1LZXkpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBjYWxjdWxhdGUgbnVtYmVyIG9mIG5ldyBtZXNzYWdlc1xuICAgICAgICAgICAgICAgICAgICAvLyBzaG93IG5vdGlmaWNhdGlvbiBhZnRlcndhcmRzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIERhdGFiYXNlTWFuYWdlci5pbnNlcnRNZXNzYWdlcyhjdXJyZW50VXNlcklkLCBtZXNzYWdlcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN5bmNpbmdEYXRhW2N1cnJlbnRVc2VySWRdW21haWxUeXBlXVsxXSArPSBtZXNzYWdlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIFwiYWN0aW9uXCIgOiBcInN5bmNQcm9ncmVzc1wiLFxuICAgICAgICAgICAgICAgICAgICBcInVzZXJJZFwiIDogY3VycmVudFVzZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCIgOiBtYWlsVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0b3RhbFwiIDogc3luY2luZ0RhdGFbY3VycmVudFVzZXJJZF1bbWFpbFR5cGVdWzBdLFxuICAgICAgICAgICAgICAgICAgICBcImN1cnJlbnRcIiA6IHN5bmNpbmdEYXRhW2N1cnJlbnRVc2VySWRdW21haWxUeXBlXVsxXVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVUb1N0b3BBZnRlciB8fCBzeW5jaW5nRGF0YVtjdXJyZW50VXNlcklkXVttYWlsVHlwZV1bMV0gPiBkYXRhLnJlc3BvbnNlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTeW5jZWRGbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWFpbFN5bmMoY3VycmVudFVzZXJJZCwgbWFpbFR5cGUsIGxhdGVzdE1lc3NhZ2VJZCk7XG4gICAgICAgICAgICB9LCBfLm5vb3ApO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyLm5hbWUgaW5zdGFuY2VvZiBET01FcnJvcikge1xuICAgICAgICAgICAgICAgIHZhciBlcnJNc2cgPSBlcnIubmFtZSArIFwiOiBcIiArIGVyci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKGVyci5jb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLkFDQ0VTU19ERU5JRUQgOlxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciAnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChtYWlsU3luYywgNTAwMCwgY3VycmVudFVzZXJJZCwgbWFpbFR5cGUsIGxhdGVzdE1lc3NhZ2VJZCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog0JTQvtC70LbQtdC9INC30LDQv9GD0YHQutCw0YLRjNGB0Y8g0YLQvtC70YzQutC+INCyINGH0LXRgtGL0YDQtdGFINGB0LvRg9GH0LDRj9GFOiDQv9GA0Lgg0YHRgtCw0YDRgtC1INC/0YDQuNC70L7QttC10L3QuNGPICjRgtC+INC10YHRgtGMINC/0YDQuCDQt9Cw0LPRgNGD0LfQutC1INCe0KEpLCDQv9GA0Lgg0YHQvNC10L3QtSDQsNC60LrQsNGD0L3RgtCwLFxuICAgICAqINC/0YDQuCDQtNC+0LHQsNCy0LvQtdC90LjQuCDQuCDQv9GA0Lgg0YPQtNCw0LvQtdC90LjQuCDQsNC60LrQsNGD0L3RgtCwLiDQn9GA0Lgg0L7RgtGA0LjRgdC+0LLQutC1IFVJINC90LjRh9C10LPQviDQt9Cw0L/Rg9GB0LrQsNGC0Ywg0L3QtSDQvdGD0LbQvdC+IC0g0L7QvdCwINC00L7Qu9C20L3QsCDRgNCw0LHQvtGC0LDRgtGMINGBINC60Y3RiNC10Lwg0Lgg0YHQvtCx0YvRgtC40Y/QvNC4LlxuICAgICAqINCe0YLQu9C40YfQuNC1INC20LUgZnJpZW5kc1N5bmMvZXZlbnRzUmVnaXN0cmFyL21haWxTeW5jINCyINGC0L7QvCwg0YfRgtC+INC/0LXRgNCy0YvQtSDQtNCy0LAg0L3QtdC30LDQstC40YHQuNC80Ysg0Lgg0YDQsNCx0L7RgtCw0Y7RgiDRgtC+0LvRjNC60L4g0LTQu9GPINGC0LXQutGD0YnQtdCz0L4g0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GPLFxuICAgICAqINCwIG1haWxTeW5jINC00L7Qu9C20LXQvSDRg9C80LXRgtGMINGA0LDQsdC+0YLQsNGC0Ywg0L3QtSDQt9C90LDRjyDQutGC0L4g0Y/QstC70Y/QtdGC0YHRjyDRgtC10LrRg9GJ0LjQvFxuICAgICAqL1xuICAgIHZhciBzdGFydFVzZXJTZXNzaW9uID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGN1cnJlbnRVc2VySWQgPSBBY2NvdW50c01hbmFnZXIuY3VycmVudFVzZXJJZDtcblxuICAgICAgICAvLyDRgdCx0YDQsNGB0YvQstCw0LXQvCDQstGB0LUgWEhSLdC30LDQv9GA0L7RgdGLXG4gICAgICAgIFJlcU1hbmFnZXIuYWJvcnRBbGwoKTtcblxuICAgICAgICAvLyDQuNC90LjRhtC40LDQu9C40LfQuNGA0YPQtdC8INCR0JRcbiAgICAgICAgRGF0YWJhc2VNYW5hZ2VyLmluaXRVc2VyKGN1cnJlbnRVc2VySWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChBY2NvdW50c01hbmFnZXIuY3VycmVudFVzZXJJZCAhPT0gY3VycmVudFVzZXJJZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIC8vINGB0LHRgNCw0YHRi9Cy0LDQtdC8INGB0YfQtdGC0YfQuNC60Lgg0YHQuNC90YXRgNC+0L3QuNC30LDRhtC40LhcbiAgICAgICAgICAgIGNsZWFyU3luY2luZ0RhdGFDb3VudGVycyhBY2NvdW50c01hbmFnZXIuY3VycmVudFVzZXJJZCk7XG5cbiAgICAgICAgICAgIGlmIChuYXZpZ2F0b3Iub25MaW5lKSB7XG4gICAgICAgICAgICAgICAgZnJpZW5kc1N5bmMoQWNjb3VudHNNYW5hZ2VyLmN1cnJlbnRVc2VySWQpO1xuICAgICAgICAgICAgICAgIGxvbmdQb2xsRXZlbnRzUmVnaXN0cmFyLmluaXQoQWNjb3VudHNNYW5hZ2VyLmN1cnJlbnRVc2VySWQpO1xuXG4gICAgICAgICAgICAgICAgbWFpbFN5bmMoQWNjb3VudHNNYW5hZ2VyLmN1cnJlbnRVc2VySWQsIFwiaW5ib3hcIik7XG4gICAgICAgICAgICAgICAgbWFpbFN5bmMoQWNjb3VudHNNYW5hZ2VyLmN1cnJlbnRVc2VySWQsIFwic2VudFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24gKGVyck1zZykge1xuICAgICAgICAgICAgTG9nTWFuYWdlci5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgQ1BBLnNlbmRFdmVudChcIkNyaXRpY2FsLUVycm9yc1wiLCBcIkRhdGFiYXNlIGluaXQgdXNlclwiLCBlcnJNc2cpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyDQstC60LvRjtGH0LDQtdC8INGB0YLQsNGC0LjRgdGC0LjQutGDINC30LDQv9GA0L7RgdC+0LIg0JLQmlxuICAgICAgICAvLyBAc2VlIGh0dHA6Ly92ay5jb20vZGV2L3N0YXRzLnRyYWNrVmlzaXRvclxuICAgICAgICBSZXFNYW5hZ2VyLmFwaU1ldGhvZChcInN0YXRzLnRyYWNrVmlzaXRvclwiLCBfLm5vb3ApO1xuICAgIH07XG5cbiAgICBjaHJvbWUucnVudGltZS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoZnVuY3Rpb24gKHJlcXVlc3QsIHNlbmRlciwgc2VuZFJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBzZW5kQXN5bmNSZXNwb25zZSA9IGZhbHNlO1xuXG4gICAgICAgIHN3aXRjaCAocmVxdWVzdC5hY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgXCJhZGRGaXJzdEFjY291bnRcIjpcbiAgICAgICAgICAgICAgICBBY2NvdW50c01hbmFnZXIuc2V0RGF0YShyZXF1ZXN0LnVpZCwgcmVxdWVzdC50b2tlbiwgXCIuLi5cIik7XG4gICAgICAgICAgICAgICAgQWNjb3VudHNNYW5hZ2VyLmN1cnJlbnRVc2VySWQgPSByZXF1ZXN0LnVpZDtcblxuICAgICAgICAgICAgICAgIHZhciB3YWxsVG9rZW5VcGRhdGVkID0gc3RvcmFnZU1hbmFnZXIuZ2V0KFwid2FsbF90b2tlbl91cGRhdGVkXCIsIHtjb25zdHJ1Y3RvcjogT2JqZWN0LCBzdHJpY3Q6IHRydWUsIGNyZWF0ZTogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgIHdhbGxUb2tlblVwZGF0ZWRbQWNjb3VudHNNYW5hZ2VyLmN1cnJlbnRVc2VySWRdID0gMTtcbiAgICAgICAgICAgICAgICBzdG9yYWdlTWFuYWdlci5zZXQoXCJ3YWxsX3Rva2VuX3VwZGF0ZWRcIiwgd2FsbFRva2VuVXBkYXRlZCk7XG5cbiAgICAgICAgICAgICAgICBzdGFydFVzZXJTZXNzaW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInVpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGljaDogXCJzeW5jaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VXNlcklkOiBBY2NvdW50c01hbmFnZXIuY3VycmVudFVzZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVc2VyRmlvOiBBY2NvdW50c01hbmFnZXIuY3VycmVudCA/IEFjY291bnRzTWFuYWdlci5jdXJyZW50LmZpbyA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcImFkZEFub3RoZXJBY2NvdW50XCI6XG4gICAgICAgICAgICAgICAgdmFyIG5ld1VzZXJHcmFudGVkID0gKEFjY291bnRzTWFuYWdlci5saXN0W3JlcXVlc3QudWlkXSA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5ld1VzZXJHcmFudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIEFjY291bnRzTWFuYWdlci5zZXREYXRhKHJlcXVlc3QudWlkLCByZXF1ZXN0LnRva2VuKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyDRg9Cy0LXQtNC+0LzQu9GP0LXQvCDQvtCxINC+0YjQuNCx0LrQtVxuICAgICAgICAgICAgICAgICAgICBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwidG9rZW5VcGRhdGVkSW5zdGVhZE9mQWNjb3VudEFkZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiByZXF1ZXN0LnVpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbzogQWNjb3VudHNNYW5hZ2VyLmxpc3RbcmVxdWVzdC51aWRdLmZpb1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQ1BBLnNlbmRFdmVudChcIkFwcC1BY3Rpb25zXCIsIFwiMisgYWNjb3VudCBhZGRlZFwiKTtcblxuICAgICAgICAgICAgICAgIEFjY291bnRzTWFuYWdlci5zZXREYXRhKHJlcXVlc3QudWlkLCByZXF1ZXN0LnRva2VuLCBcIi4uLlwiKTtcbiAgICAgICAgICAgICAgICBBY2NvdW50c01hbmFnZXIuY3VycmVudFVzZXJJZCA9IHJlcXVlc3QudWlkO1xuXG4gICAgICAgICAgICAgICAgdmFyIHdhbGxUb2tlblVwZGF0ZWQgPSBzdG9yYWdlTWFuYWdlci5nZXQoXCJ3YWxsX3Rva2VuX3VwZGF0ZWRcIiwge2NvbnN0cnVjdG9yOiBPYmplY3QsIHN0cmljdDogdHJ1ZSwgY3JlYXRlOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgd2FsbFRva2VuVXBkYXRlZFtBY2NvdW50c01hbmFnZXIuY3VycmVudFVzZXJJZF0gPSAxO1xuICAgICAgICAgICAgICAgIHN0b3JhZ2VNYW5hZ2VyLnNldChcIndhbGxfdG9rZW5fdXBkYXRlZFwiLCB3YWxsVG9rZW5VcGRhdGVkKTtcblxuICAgICAgICAgICAgICAgIHN0YXJ0VXNlclNlc3Npb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwidWlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoOiBcInN5bmNpbmdcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwidXBkYXRlRXhpc3RpbmdUb2tlblwiOlxuICAgICAgICAgICAgICAgIHZhciBuZWVkZWRVc2VyVG9rZW5VcGRhdGVkID0gKHJlcXVlc3QubmVlZGVkVWlkID09PSByZXF1ZXN0LnVpZCk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1VzZXJHcmFudGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGxpc3RVc2VySWQgaW4gQWNjb3VudHNNYW5hZ2VyLmxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdFVzZXJJZCA9IE51bWJlcihsaXN0VXNlcklkKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdFVzZXJJZCA9PT0gcmVxdWVzdC51aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1VzZXJHcmFudGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChuZXdVc2VyR3JhbnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyDRg9Cy0LXQtNC+0LzQu9GP0LXQvCDQvtCxINC+0YjQuNCx0LrQtVxuICAgICAgICAgICAgICAgICAgICBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwidG9rZW5BZGRlZEluc3RlYWRPZlVwZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiByZXF1ZXN0LnVpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiByZXF1ZXN0LnRva2VuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBBY2NvdW50c01hbmFnZXIuc2V0RGF0YShyZXF1ZXN0LnVpZCwgcmVxdWVzdC50b2tlbik7XG5cbiAgICAgICAgICAgICAgICBpZiAobmVlZGVkVXNlclRva2VuVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiQXBwLUFjdGlvbnNcIiwgXCJBY2NvdW50IHRva2VuIHVwZGF0ZWRcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInRva2VuVXBkYXRlZFwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNocm9tZS5ydW50aW1lLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJ0b2tlblVwZGF0ZWRGb3JXcm9uZ1VzZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpZDogcmVxdWVzdC51aWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW86IEFjY291bnRzTWFuYWdlci5saXN0W3JlcXVlc3QudWlkXS5maW9cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJnZXRBY2NvdW50c0xpc3RcIjpcbiAgICAgICAgICAgICAgICBzZW5kQXN5bmNSZXNwb25zZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgYWNjb3VudHMgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIHZhciBhc3NpZ25BdmF0YXIgPSBmdW5jdGlvbiAoYWNjb3VudCwgdWlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBEYXRhYmFzZU1hbmFnZXIuZ2V0Q29udGFjdEJ5SWQoQWNjb3VudHNNYW5hZ2VyLmN1cnJlbnRVc2VySWQsIHVpZCwgZnVuY3Rpb24gKGNvbnRhY3REYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudC5hdmF0YXIgPSBjb250YWN0RGF0YS5waG90bztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dNYW5hZ2VyLmVycm9yKGVyciArICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfLmZvckluKEFjY291bnRzTWFuYWdlci5saXN0LCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50c1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goYXNzaWduQXZhdGFyKHZhbHVlLCBrZXkpKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKGFjY291bnRzKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwic2F2ZVNldHRpbmdzXCI6XG4gICAgICAgICAgICAgICAgXy5mb3JJbihyZXF1ZXN0LnNldHRpbmdzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICBTZXR0aW5nc01hbmFnZXJba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gbm90aWZ5IGFwcCB3aW5kb3dzXG4gICAgICAgICAgICAgICAgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwic2V0dGluZ3NDaGFuZ2VkXCIsXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzOiBnZXRGbGF0U2V0dGluZ3MoKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJ0b2tlbkV4cGlyZWRSZXF1ZXN0XCI6XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuRXhwaXJlZEFsYXJtTmFtZSA9IFwidG9rZW5FeHBpcmVkTm90aWZ5VGhyb3R0bGVcIjtcbiAgICAgICAgICAgICAgICBjaHJvbWUuYWxhcm1zLmdldCh0b2tlbkV4cGlyZWRBbGFybU5hbWUsIGZ1bmN0aW9uIChhbGFybUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYWxhcm0gaXMgc2V0IHVzZXIgaGFzIGFscmVhZHkgc2VlbiBub3RpZmljYXRpb24gYWJvdXQgZXhwaXJlZCB0b2tlblxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxhcm1JbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYWxhcm0gdG8gcHJldmVudCBub3RpZnlpbmcgdXNlciB0b28gb2Z0ZW5cbiAgICAgICAgICAgICAgICAgICAgY2hyb21lLmFsYXJtcy5jcmVhdGUodG9rZW5FeHBpcmVkQWxhcm1OYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxheUluTWludXRlczogNjAgKiAyNFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBzaG93IG5vdGlmaWNhdGlvblxuICAgICAgICAgICAgICAgICAgICBzaG93Q2hyb21lTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInRva2VuRXhwaXJlZFJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBjaHJvbWUuaTE4bi5nZXRNZXNzYWdlKFwidG9rZW5FeHBpcmVkTm90aWZpY2F0aW9uVGl0bGVcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaHJvbWUuaTE4bi5nZXRNZXNzYWdlKFwidG9rZW5FeHBpcmVkTm90aWZpY2F0aW9uTWVzc2FnZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb246IGNocm9tZS5ydW50aW1lLmdldFVSTChcInBpYy9pY29uNDgucG5nXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291bmQ6IFwiZXJyb3JcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiQXBwLURhdGFcIiwgXCJ0b2tlbkV4cGlyZWQgbm90aWZpY2F0aW9uIHNlZW5cIik7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcInVpRHJhd1wiIDpcbiAgICAgICAgICAgICAgICBzZW5kQXN5bmNSZXNwb25zZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKHRydWUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHVpVHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlbG9nTm90aWZpZWQgPSBzdG9yYWdlTWFuYWdlci5nZXQoXCJjaGFuZ2Vsb2dfbm90aWZpZWRcIiwge2NvbnN0cnVjdG9yOiBBcnJheSwgc3RyaWN0OiB0cnVlLCBjcmVhdGU6IHRydWV9KTtcbiAgICAgICAgICAgICAgICB2YXIgaW5ib3hTeW5jZWQsIHNlbnRTeW5jZWQsIGZyaWVuZHNTeW5jZWQ7XG4gICAgICAgICAgICAgICAgdmFyIHdhbGxUb2tlblVwZGF0ZWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoQWNjb3VudHNNYW5hZ2VyLmN1cnJlbnRVc2VySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5ib3hTeW5jZWQgPSAoc3RvcmFnZU1hbmFnZXIuZ2V0KFwicGVybV9pbmJveF9cIiArIEFjY291bnRzTWFuYWdlci5jdXJyZW50VXNlcklkKSAhPT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbnRTeW5jZWQgPSAoc3RvcmFnZU1hbmFnZXIuZ2V0KFwicGVybV9vdXRib3hfXCIgKyBBY2NvdW50c01hbmFnZXIuY3VycmVudFVzZXJJZCkgIT09IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBmcmllbmRzU3luY2VkID0gKHN0b3JhZ2VNYW5hZ2VyLmdldChcImZyaWVuZHNfc3luY190aW1lXCIsIHtjb25zdHJ1Y3RvcjogT2JqZWN0LCBzdHJpY3Q6IHRydWUsIGNyZWF0ZTogdHJ1ZX0pW0FjY291bnRzTWFuYWdlci5jdXJyZW50VXNlcklkXSAhPT0gdW5kZWZpbmVkKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5ib3hTeW5jZWQgJiYgc2VudFN5bmNlZCAmJiBmcmllbmRzU3luY2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1aVR5cGUgPSBcInVzZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpVHlwZSA9IFwic3luY2luZ1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdWlUeXBlID0gXCJndWVzdFwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN3aXRjaCAodWlUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1c2VyXCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgQ1BBLnNlbmRBcHBWaWV3KFwiVXNlcnNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiVUktRHJhd1wiLCBcIlVzZXJzXCIsIEFjY291bnRzTWFuYWdlci5jdXJyZW50VXNlcklkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2hyb21lLnN0b3JhZ2UubG9jYWwuc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRheXVzZS5kYXVcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndlZWt1c2Uud2F1XCI6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3luY2luZ1wiIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIENQQS5zZW5kQXBwVmlldyhcIlN5bmNpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiVUktRHJhd1wiLCBcIlN5bmNpbmdcIiwgQWNjb3VudHNNYW5hZ2VyLmN1cnJlbnRVc2VySWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImd1ZXN0XCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgQ1BBLnNlbmRBcHBWaWV3KFwiR3Vlc3RzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgQ1BBLnNlbmRFdmVudChcIlVJLURyYXdcIiwgXCJHdWVzdHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyDRg9Cy0LXQtNC+0LzQu9GP0LXQvCDRhNGA0L7QvdGCXG4gICAgICAgICAgICAgICAgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwidWlcIixcbiAgICAgICAgICAgICAgICAgICAgd2hpY2g6IHVpVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFVzZXJJZDogQWNjb3VudHNNYW5hZ2VyLmN1cnJlbnRVc2VySWQsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVc2VyRmlvOiBBY2NvdW50c01hbmFnZXIuY3VycmVudCA/IEFjY291bnRzTWFuYWdlci5jdXJyZW50LmZpbyA6IG51bGxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiY2xvc2VOb3RpZmljYXRpb25cIjpcbiAgICAgICAgICAgICAgICBpZiAobm90aWZpY2F0aW9uSGFuZGxlcnNbcmVxdWVzdC5taWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNocm9tZS5ub3RpZmljYXRpb25zLmNsZWFyKHJlcXVlc3QubWlkLCBfLm5vb3ApO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbm90aWZpY2F0aW9uSGFuZGxlcnNbcmVxdWVzdC5taWRdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyBOQi4g0JXRgdGC0Ywg0LHQsNCzLCDQutC+0LPQtNCwINCyINC90LXQutC+0YLQvtGA0YvRhSDQstC10YDRgdC40Y/RhSDQsdGA0LDRg9C30LXRgNCwINGB0L7RgNGC0LjRgNC+0LLQutCwINGA0LDQsdC+0YLQsNC10YIg0YHQu9C40YjQutC+0Lwg0LTQvtC70LPQvi4g0JTQu9GPINC+0L/RgNC10LTQtdC70LXQvdC40Y8g0Y3RgtC+0LPQviDQvNC+0LzQtdC90YLQsCDQsiA0LjQg0LLQvdC10LTRgNC10L3QviDRgdC70LXQtNGD0Y7RidC10LUg0YDQtdGI0LXQvdC40LU6XG4gICAgICAgICAgICAvLyDQn9GA0Lgg0L/QtdGA0LLQvtC8INC30LDQv9GA0L7RgdC1INC60L7QvdGC0LDQutGC0L7QsiDQv9GA0L7QstC10YDRj9C10LwsINGB0LrQvtC70YzQutC+INCy0YDQtdC80LXQvdC4INGA0LDQsdC+0YLQsNC7INC30LDQv9GA0L7RgSDQuiDQsdGN0LrQtdC90LTRgy4g0JXRgdC70Lgg0Y3RgtC+INC30LDQvdGP0LvQviDQsdC+0LvRjNGI0LUgMyDRgdC10LrRg9C90LQsINGC0L4g0LzQtdC90Y/QtdC8INC90LDRgdGC0YDQvtC50LrRgyDRgdC+0YDRgtC40YDQvtCy0LrQuC5cbiAgICAgICAgICAgIC8vINCh0L7QvtGC0LLQtdGC0YHRgtCy0LXQvdC90L4gXCLQt9Cw0LHRi9Cy0LDQtdC8XCIg0LfQsNC/0YDQvtGBINC4INC/0L7RgNC+0LbQtNCw0LXQvCDQvdC+0LLRi9C5LlxuICAgICAgICAgICAgLy8gMTMuMC43NTUuMCAoODM4NzkpIC0g0LTQvtC70LPQsNGPINCy0YvQsdC+0YDQutCwINC60L7QvdGC0LDQutGC0L7QslxuICAgICAgICAgICAgY2FzZSBcImZldGNoQ29udGFjdExpc3RcIiA6XG4gICAgICAgICAgICAgICAgdmFyIGJyZWFrTmVlZGVkID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRJZCxcbiAgICAgICAgICAgICAgICAgICAgb25Db250YWN0c0xpc3RSZWFkeTtcblxuICAgICAgICAgICAgICAgIHNlbmRBc3luY1Jlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBvbkNvbnRhY3RzTGlzdFJlYWR5ID0gZnVuY3Rpb24oY29udGFjdHNMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWN0c0xpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFjdHNJZHMgPSBjb250YWN0c0xpc3QubWFwKGZ1bmN0aW9uKGNvbnRhY3REYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGFjdERhdGEudWlkO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBSZXFNYW5hZ2VyLmFwaU1ldGhvZChcInVzZXJzLmdldFwiLCB7XCJ1aWRzXCIgOiBjb250YWN0c0lkcy5qb2luKFwiLFwiKSwgXCJmaWVsZHNcIiA6IFwib25saW5lXCJ9LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNPbmxpbmUgPSAoY2h1bmsub25saW5lID09PSAxIHx8IGNodW5rLm9ubGluZV9tb2JpbGUgPT09IDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tZS5ydW50aW1lLnNlbmRNZXNzYWdlKHtcImFjdGlvblwiIDogXCJjb250YWN0T25saW5lU3RhdHVzXCIsIFwidWlkXCIgOiBjaHVuay51aWQsIFwib25saW5lXCIgOiBpc09ubGluZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0aW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRTZXR0aW5nc1VzZWQgPSAoc3RvcmFnZU1hbmFnZXIuZ2V0KFwic2V0dGluZ3NcIikgPT09IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdFNldHRpbmdzVXNlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgU2V0dGluZ3NNYW5hZ2VyLlNvcnRDb250YWN0cyA9IDI7XG5cbiAgICAgICAgICAgICAgICAgICAgRGF0YWJhc2VNYW5hZ2VyLmdldENvbnRhY3RMaXN0KFwiYWxwaGFcIiwgcmVxdWVzdC50b3RhbFNob3duLCBmdW5jdGlvbihjb250YWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKGNvbnRhY3RzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFNldHRpbmdzTWFuYWdlci5TaG93T25saW5lID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Db250YWN0c0xpc3RSZWFkeShjb250YWN0c1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyck1zZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKFtbXSwgMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nTWFuYWdlci5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCAzMDAwKTtcblxuICAgICAgICAgICAgICAgIERhdGFiYXNlTWFuYWdlci5nZXRDb250YWN0TGlzdChyZXF1ZXN0LnR5cGUsIHJlcXVlc3QudG90YWxTaG93biwgZnVuY3Rpb24oY29udGFjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJyZWFrTmVlZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UoY29udGFjdHMpO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFNldHRpbmdzTWFuYWdlci5TaG93T25saW5lID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNvbnRhY3RzTGlzdFJlYWR5KGNvbnRhY3RzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyck1zZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnJlYWtOZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZShbW10sIDBdKTtcbiAgICAgICAgICAgICAgICAgICAgTG9nTWFuYWdlci5lcnJvcihlcnJNc2cpO1xuXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiZmV0Y2hDb252ZXJzYXRpb25zXCIgOlxuICAgICAgICAgICAgICAgIHNlbmRBc3luY1Jlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBEYXRhYmFzZU1hbmFnZXIuZ2V0Q29udmVyc2F0aW9ucyhyZXF1ZXN0LnRvdGFsU2hvd24sIHNlbmRSZXNwb25zZSwgZnVuY3Rpb24gKGVyck1zZykge1xuICAgICAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UoW1tdLCAwXSk7XG4gICAgICAgICAgICAgICAgICAgIExvZ01hbmFnZXIuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiZ2V0RGlhbG9nVGhyZWFkXCIgOlxuICAgICAgICAgICAgICAgIHNlbmRBc3luY1Jlc3BvbnNlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIERhdGFiYXNlTWFuYWdlci5nZXREaWFsb2dUaHJlYWQocmVxdWVzdC5pZCwge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiAocmVxdWVzdC5mcm9tICE9PSB1bmRlZmluZWQpID8gcmVxdWVzdC5mcm9tIDogMCxcbiAgICAgICAgICAgICAgICAgICAgZXZlcnl0aGluZzogQm9vbGVhbihyZXF1ZXN0LnByaW50KVxuICAgICAgICAgICAgICAgIH0sIHNlbmRSZXNwb25zZSwgZnVuY3Rpb24gKGVyck1zZykge1xuICAgICAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UoW1tdLCAwXSk7XG4gICAgICAgICAgICAgICAgICAgIExvZ01hbmFnZXIuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiZ2V0TWVzc2FnZUluZm9cIiA6XG4gICAgICAgICAgICAgICAgc2VuZEFzeW5jUmVzcG9uc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIERhdGFiYXNlTWFuYWdlci5nZXRNZXNzYWdlQnlJZChOdW1iZXIocmVxdWVzdC5taWQpLCBzZW5kUmVzcG9uc2UsIGZ1bmN0aW9uIChpc0RhdGFiYXNlRXJyb3IsIGVyck1zZykge1xuICAgICAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UodW5kZWZpbmVkKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEYXRhYmFzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBMb2dNYW5hZ2VyLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiQ3VzdG9tLUVycm9yc1wiLCBcIkRhdGFiYXNlIGVycm9yXCIsIGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiZ2V0Q29udmVyc2F0aW9uVGhyZWFkc1dpdGhDb250YWN0XCIgOlxuICAgICAgICAgICAgICAgIHNlbmRBc3luY1Jlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBEYXRhYmFzZU1hbmFnZXIuZ2V0Q29udmVyc2F0aW9uVGhyZWFkc1dpdGhDb250YWN0KHJlcXVlc3QudWlkLCBzZW5kUmVzcG9uc2UsIGZ1bmN0aW9uIChlcnJNc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgTG9nTWFuYWdlci5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJnZXRDb250YWN0RGF0YVwiIDpcbiAgICAgICAgICAgICAgICBzZW5kQXN5bmNSZXNwb25zZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgRGF0YWJhc2VNYW5hZ2VyLmdldENvbnRhY3RCeUlkKEFjY291bnRzTWFuYWdlci5jdXJyZW50VXNlcklkLCByZXF1ZXN0LnVpZCwgc2VuZFJlc3BvbnNlLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZShudWxsKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChTZXR0aW5nc01hbmFnZXIuU2hvd09ubGluZSA9PT0gMSAmJiByZXF1ZXN0LmluY2x1ZGVPbmxpbmVTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgUmVxTWFuYWdlci5hcGlNZXRob2QoXCJ1c2Vycy5nZXRcIiwge1widWlkc1wiIDogcmVxdWVzdC51aWQsIFwiZmllbGRzXCIgOiBcIm9ubGluZVwifSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzT25saW5lID0gKGNodW5rLm9ubGluZSA9PT0gMSB8fCBjaHVuay5vbmxpbmVfbW9iaWxlID09PSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSh7XCJhY3Rpb25cIiA6IFwiY29udGFjdE9ubGluZVN0YXR1c1wiLCBcInVpZFwiIDogY2h1bmsudWlkLCBcIm9ubGluZVwiIDogaXNPbmxpbmV9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLy8gVE9ETyDQutCw0Lot0YLQviDRhNC+0YDQvNCw0LvQuNC30LjRgNC+0LLQsNGC0YxcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvckdvdFwiIDpcbiAgICAgICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiQ3VzdG9tLUVycm9yc1wiLCByZXF1ZXN0LmVycm9yLCByZXF1ZXN0Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwic2VuZE1lc3NhZ2VcIiA6XG4gICAgICAgICAgICAgICAgdmFyIG1zZ1BhcmFtcyA9IHt9O1xuICAgICAgICAgICAgICAgIHNlbmRBc3luY1Jlc3BvbnNlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmJvZHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtc2dQYXJhbXMubWVzc2FnZSA9IHJlcXVlc3QuYm9keTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zdWJqZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnUGFyYW1zLnRpdGxlID0gcmVxdWVzdC5zdWJqZWN0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnNpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZ1BhcmFtcy5jYXB0Y2hhX3NpZCA9IHJlcXVlc3Quc2lkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZ1BhcmFtcy5jYXB0Y2hhX2tleSA9IHJlcXVlc3Qua2V5O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmF0dGFjaG1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBtc2dQYXJhbXMuYXR0YWNobWVudCA9IHJlcXVlc3QuYXR0YWNobWVudHMuam9pbihcIixcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKC9eW1xcZF0rJC8udGVzdChyZXF1ZXN0LnRvKSkge1xuICAgICAgICAgICAgICAgICAgICBtc2dQYXJhbXMuY2hhdF9pZCA9IHJlcXVlc3QudG87XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnUGFyYW1zLnVpZCA9IHJlcXVlc3QudG8uc3BsaXQoXCJfXCIpWzFdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmNvb3JkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZ1BhcmFtcy5sYXQgPSByZXF1ZXN0LmNvb3Jkcy5sYXRpdHVkZTtcbiAgICAgICAgICAgICAgICAgICAgbXNnUGFyYW1zLmxvbmcgPSByZXF1ZXN0LmNvb3Jkcy5sb25naXR1ZGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgUmVxTWFuYWdlci5hcGlNZXRob2QoXCJtZXNzYWdlcy5zZW5kXCIsIG1zZ1BhcmFtcywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiQXBwLUFjdGlvbnNcIiwgXCJTZW50IE1lc3NhZ2VcIiwgQWNjb3VudHNNYW5hZ2VyLmN1cnJlbnRVc2VySWQpO1xuICAgICAgICAgICAgICAgICAgICBTb3VuZE1hbmFnZXIucGxheShcInNlbnRcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKFswLCBkYXRhXSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyQ29kZSwgZXJyRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiQ3VzdG9tLUVycm9yc1wiLCBcIkZhaWxlZCB0byBzZW5kIG1lc3NhZ2VcIiwgZXJyQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIFNvdW5kTWFuYWdlci5wbGF5KFwiZXJyb3JcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlcnJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuQ0FQVENIQSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKFsxLCBlcnJEYXRhXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJDb2RlID09PSBSZXFNYW5hZ2VyLlJFU1BPTlNFX0VSUk9SICYmIGVyckRhdGEuY29kZSA9PT0gNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UoWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZShbM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcImdldE1lc3NhZ2VzVXBsb2FkU2VydmVyXCIgOlxuICAgICAgICAgICAgICAgIHZhciBzZW5kUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBSZXFNYW5hZ2VyLmFwaU1ldGhvZChcInBob3Rvcy5nZXRNZXNzYWdlc1VwbG9hZFNlcnZlclwiLCBzZW5kUmVzcG9uc2UsIGZ1bmN0aW9uKGVyckNvZGUsIGVyckRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXJyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5OT19JTlRFUk5FVCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLk5PVF9KU09OIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuVElNRU9VVCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLlJFU1BPTlNFX0VSUk9SIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoc2VuZFJlcXVlc3QsIDUqMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHNlbmRSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgc2VuZEFzeW5jUmVzcG9uc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiZ2V0RG9jc1VwbG9hZFNlcnZlclwiIDpcbiAgICAgICAgICAgICAgICB2YXIgc2VuZFJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgUmVxTWFuYWdlci5hcGlNZXRob2QoXCJkb2NzLmdldFVwbG9hZFNlcnZlclwiLCBzZW5kUmVzcG9uc2UsIGZ1bmN0aW9uKGVyckNvZGUsIGVyckRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXJyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5OT19JTlRFUk5FVCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLk5PVF9KU09OIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuVElNRU9VVCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLlJFU1BPTlNFX0VSUk9SIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoc2VuZFJlcXVlc3QsIDUqMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHNlbmRSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgc2VuZEFzeW5jUmVzcG9uc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwic2F2ZU1lc3NhZ2VzUGhvdG9cIiA6XG4gICAgICAgICAgICAgICAgdmFyIHNlbmRSZXF1ZXN0ID0gZnVuY3Rpb24ocmVxdWVzdERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgUmVxTWFuYWdlci5hcGlNZXRob2QoXCJwaG90b3Muc2F2ZU1lc3NhZ2VzUGhvdG9cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzZXJ2ZXJcIiA6IHJlcXVlc3REYXRhLnNlcnZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicGhvdG9cIiA6IHJlcXVlc3REYXRhLnBob3RvLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJoYXNoXCIgOiByZXF1ZXN0RGF0YS5oYXNoXG4gICAgICAgICAgICAgICAgICAgIH0sIHNlbmRSZXNwb25zZSwgZnVuY3Rpb24oZXJyQ29kZSwgZXJyRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlcnJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLk5PX0lOVEVSTkVUIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuTk9UX0pTT04gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5USU1FT1VUIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuUkVTUE9OU0VfRVJST1IgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChzZW5kUmVxdWVzdCwgNSoxMDAwLCByZXF1ZXN0RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHNlbmRSZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIHNlbmRBc3luY1Jlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcInNhdmVNZXNzYWdlc0RvY1wiIDpcbiAgICAgICAgICAgICAgICB2YXIgc2VuZFJlcXVlc3QgPSBmdW5jdGlvbihyZXF1ZXN0RGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBSZXFNYW5hZ2VyLmFwaU1ldGhvZChcImRvY3Muc2F2ZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImZpbGVcIiA6IHJlcXVlc3REYXRhLmZpbGVcbiAgICAgICAgICAgICAgICAgICAgfSwgc2VuZFJlc3BvbnNlLCBmdW5jdGlvbihlcnJDb2RlLCBlcnJEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGVyckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuTk9fSU5URVJORVQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5OT1RfSlNPTiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLlRJTUVPVVQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5SRVNQT05TRV9FUlJPUiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHNlbmRSZXF1ZXN0LCA1KjEwMDAsIHJlcXVlc3REYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgc2VuZFJlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgc2VuZEFzeW5jUmVzcG9uc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiYWRkTGlrZVwiIDpcbiAgICAgICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiQXBwLUFjdGlvbnNcIiwgXCJMaWtlIGFuZCByZXBvc3RcIik7XG4gICAgICAgICAgICAgICAgc2VuZEFzeW5jUmVzcG9uc2UgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNlbmRMaWtlUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBSZXFNYW5hZ2VyLmFwaU1ldGhvZChcIndhbGwuYWRkTGlrZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIm93bmVyX2lkXCIgOiAtMjk4MDkwNTMsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInBvc3RfaWRcIiA6IDQ1NCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmVwb3N0XCIgOiAxXG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyQ29kZSwgZXJyRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlcnJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLk5PX0lOVEVSTkVUIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuTk9UX0pTT04gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5USU1FT1VUIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoc2VuZExpa2VSZXF1ZXN0LCA1KjEwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5SRVNQT05TRV9FUlJPUiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJEYXRhLmNvZGUgPT09IDIxNyB8fCBlcnJEYXRhLmNvZGUgPT09IDIxNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoc2VuZExpa2VSZXF1ZXN0LCA1KjEwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgc2VuZEpvaW5Hcm91cFJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgUmVxTWFuYWdlci5hcGlNZXRob2QoXCJncm91cHMuam9pblwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImdpZFwiIDogMjk4MDkwNTNcbiAgICAgICAgICAgICAgICAgICAgfSwgbnVsbCwgZnVuY3Rpb24oZXJyQ29kZSwgZXJyRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlcnJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLk5PX0lOVEVSTkVUIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuTk9UX0pTT04gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5USU1FT1VUIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuUkVTUE9OU0VfRVJST1IgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChzZW5kSm9pbkdyb3VwUmVxdWVzdCwgNSoxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBzZW5kTGlrZVJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICBzZW5kSm9pbkdyb3VwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiZ2V0RG9jQnlJZFwiIDpcbiAgICAgICAgICAgICAgICAvLyB2ayBidWc6INC80LXRgtC+0LQgZG9jcy5nZXRCeUlkINCy0L7Qt9Cy0YDQsNGJ0LDQtdGCIHJlc3BvbnNlOiBbXVxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly92a29udGFrdGUucnUvdG9waWMtMV8yMTk3MjE2OT9wb3N0PTM2MDE0XG4gICAgICAgICAgICAgICAgdmFyIHNlbmRSZXF1ZXN0O1xuXG4gICAgICAgICAgICAgICAgc2VuZEFzeW5jUmVzcG9uc2UgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QubWlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZFJlcXVlc3QgPSBmdW5jdGlvbihyZXF1ZXN0RGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdERhdGEub3duZXJJZCA9IHBhcnNlSW50KHJlcXVlc3REYXRhLm93bmVySWQsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3REYXRhLmlkID0gcGFyc2VJbnQocmVxdWVzdERhdGEuaWQsIDEwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgUmVxTWFuYWdlci5hcGlNZXRob2QoXCJtZXNzYWdlcy5nZXRCeUlkXCIsIHtcIm1pZFwiIDogcmVxdWVzdERhdGEubWlkfSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZGF0YS5yZXNwb25zZSBpbnN0YW5jZW9mIEFycmF5KSA9PT0gZmFsc2UgfHwgZGF0YS5yZXNwb25zZS5sZW5ndGggIT09IDIgfHwgZGF0YS5yZXNwb25zZVsxXS5hdHRhY2htZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENQQS5zZW5kRXZlbnQoXCJDdXN0b20tRXJyb3JzXCIsIFwiQXR0YWNobWVudCBpbmZvIG1pc3NpbmdcIiwgcmVxdWVzdERhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGEucmVzcG9uc2VbMV0uYXR0YWNobWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEucmVzcG9uc2VbMV0uYXR0YWNobWVudHNbaV0udHlwZSA9PT0gXCJkb2NcIiAmJiBkYXRhLnJlc3BvbnNlWzFdLmF0dGFjaG1lbnRzW2ldLmRvYy5vd25lcl9pZCA9PT0gcmVxdWVzdERhdGEub3duZXJJZCAmJiBkYXRhLnJlc3BvbnNlWzFdLmF0dGFjaG1lbnRzW2ldLmRvYy5kaWQgPT09IHJlcXVlc3REYXRhLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UoZGF0YS5yZXNwb25zZVsxXS5hdHRhY2htZW50c1tpXS5kb2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ1BBLnNlbmRFdmVudChcIkN1c3RvbS1FcnJvcnNcIiwgXCJBdHRhY2htZW50IGluZm8gbWlzc2luZ1wiLCByZXF1ZXN0RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJDb2RlLCBlcnJEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlcnJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5OT19JTlRFUk5FVCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5OT1RfSlNPTiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5USU1FT1VUIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLlJFU1BPTlNFX0VSUk9SIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHNlbmRSZXF1ZXN0LCA1KjEwMDAsIHJlcXVlc3REYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRSZXF1ZXN0ID0gZnVuY3Rpb24ocmVxdWVzdERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlcU1hbmFnZXIuYXBpTWV0aG9kKFwiZG9jcy5nZXRCeUlkXCIsIHtcImRvY3NcIiA6IHJlcXVlc3REYXRhLm93bmVySWQgKyBcIl9cIiArIHJlcXVlc3REYXRhLmlkfSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSAoZGF0YS5yZXNwb25zZS5sZW5ndGgpID8gZGF0YS5yZXNwb25zZVswXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiQ3VzdG9tLUVycm9yc1wiLCBcIkF0dGFjaG1lbnQgaW5mbyBtaXNzaW5nXCIsIHJlcXVlc3REYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2Uob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyckNvZGUsIGVyckRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGVyckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLk5PX0lOVEVSTkVUIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLk5PVF9KU09OIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLlRJTUVPVVQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuUkVTUE9OU0VfRVJST1IgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoc2VuZFJlcXVlc3QsIDUqMTAwMCwgcmVxdWVzdERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VuZFJlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJnZXRHZW9wb2ludEJ5SWRcIiA6XG4gICAgICAgICAgICAgICAgc2VuZEFzeW5jUmVzcG9uc2UgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNlbmRSZXF1ZXN0ID0gZnVuY3Rpb24obXNnSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgUmVxTWFuYWdlci5hcGlNZXRob2QoXCJtZXNzYWdlcy5nZXRCeUlkXCIsIHtcIm1pZFwiIDogbXNnSWR9LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGRhdGEucmVzcG9uc2UgaW5zdGFuY2VvZiBBcnJheSkgPT09IGZhbHNlIHx8IGRhdGEucmVzcG9uc2UubGVuZ3RoICE9PSAyIHx8IGRhdGEucmVzcG9uc2VbMV0uZ2VvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiQ3VzdG9tLUVycm9yc1wiLCBcIkF0dGFjaG1lbnQgaW5mbyBtaXNzaW5nXCIsIHJlcXVlc3QpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkcyA9IGRhdGEucmVzcG9uc2VbMV0uZ2VvLmNvb3JkaW5hdGVzLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZShjb29yZHMpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJDb2RlLCBlcnJEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGVyckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuTk9fSU5URVJORVQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5OT1RfSlNPTiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLlRJTUVPVVQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5SRVNQT05TRV9FUlJPUiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHNlbmRSZXF1ZXN0LCA1KjEwMDAsIG1zZ0lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgc2VuZFJlcXVlc3QocmVxdWVzdC5taWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiZ2V0QXVkaW9CeUlkXCIgOlxuICAgICAgICAgICAgICAgIHZhciBzZW5kUmVxdWVzdCA9IGZ1bmN0aW9uKHJlcXVlc3REYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIFJlcU1hbmFnZXIuYXBpTWV0aG9kKFwiYXVkaW8uZ2V0QnlJZFwiLCB7XCJhdWRpb3NcIiA6IHJlcXVlc3REYXRhLm93bmVySWQgKyBcIl9cIiArIHJlcXVlc3REYXRhLmlkfSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IChkYXRhLnJlc3BvbnNlLmxlbmd0aCkgPyBkYXRhLnJlc3BvbnNlWzBdIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiQ3VzdG9tLUVycm9yc1wiLCBcIkF0dGFjaG1lbnQgaW5mbyBtaXNzaW5nXCIsIHJlcXVlc3REYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyckNvZGUsIGVyckRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXJyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5OT19JTlRFUk5FVCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLk5PVF9KU09OIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuVElNRU9VVCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLlJFU1BPTlNFX0VSUk9SIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoc2VuZFJlcXVlc3QsIDUqMTAwMCwgcmVxdWVzdERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBzZW5kUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICBzZW5kQXN5bmNSZXNwb25zZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJnZXRWaWRlb0J5SWRcIiA6XG4gICAgICAgICAgICAgICAgdmFyIHNlbmRSZXF1ZXN0ID0gZnVuY3Rpb24ocmVxdWVzdERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgUmVxTWFuYWdlci5hcGlNZXRob2QoXCJ2aWRlby5nZXRcIiwge1widmlkZW9zXCIgOiByZXF1ZXN0RGF0YS5vd25lcklkICsgXCJfXCIgKyByZXF1ZXN0RGF0YS5pZH0sIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSAoZGF0YS5yZXNwb25zZSBpbnN0YW5jZW9mIEFycmF5ICYmIGRhdGEucmVzcG9uc2UubGVuZ3RoID09PSAyKSA/IGRhdGEucmVzcG9uc2VbMV0gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENQQS5zZW5kRXZlbnQoXCJDdXN0b20tRXJyb3JzXCIsIFwiQXR0YWNobWVudCBpbmZvIG1pc3NpbmdcIiwgcmVxdWVzdERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2Uob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyQ29kZSwgZXJyRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlcnJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLk5PX0lOVEVSTkVUIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuTk9UX0pTT04gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5USU1FT1VUIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuUkVTUE9OU0VfRVJST1IgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChzZW5kUmVxdWVzdCwgNSoxMDAwLCByZXF1ZXN0RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHNlbmRSZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIHNlbmRBc3luY1Jlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcImdldFBob3RvQnlJZFwiIDpcbiAgICAgICAgICAgICAgICB2YXIgc2VuZFJlcXVlc3Q7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5taWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZW5kUmVxdWVzdCA9IGZ1bmN0aW9uKHJlcXVlc3REYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RGF0YS5vd25lcklkID0gcGFyc2VJbnQocmVxdWVzdERhdGEub3duZXJJZCwgMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdERhdGEuaWQgPSBwYXJzZUludChyZXF1ZXN0RGF0YS5pZCwgMTApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBSZXFNYW5hZ2VyLmFwaU1ldGhvZChcIm1lc3NhZ2VzLmdldEJ5SWRcIiwge1wibWlkXCIgOiByZXF1ZXN0RGF0YS5taWR9LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChkYXRhLnJlc3BvbnNlIGluc3RhbmNlb2YgQXJyYXkpID09PSBmYWxzZSB8fCBkYXRhLnJlc3BvbnNlLmxlbmd0aCAhPT0gMiB8fCBkYXRhLnJlc3BvbnNlWzFdLmF0dGFjaG1lbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ1BBLnNlbmRFdmVudChcIkN1c3RvbS1FcnJvcnNcIiwgXCJBdHRhY2htZW50IGluZm8gbWlzc2luZ1wiLCByZXF1ZXN0RGF0YSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5yZXNwb25zZVsxXS5hdHRhY2htZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5yZXNwb25zZVsxXS5hdHRhY2htZW50c1tpXS50eXBlID09PSBcInBob3RvXCIgJiYgZGF0YS5yZXNwb25zZVsxXS5hdHRhY2htZW50c1tpXS5waG90by5vd25lcl9pZCA9PT0gcmVxdWVzdERhdGEub3duZXJJZCAmJiBkYXRhLnJlc3BvbnNlWzFdLmF0dGFjaG1lbnRzW2ldLnBob3RvLnBpZCA9PT0gcmVxdWVzdERhdGEuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZShkYXRhLnJlc3BvbnNlWzFdLmF0dGFjaG1lbnRzW2ldLnBob3RvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENQQS5zZW5kRXZlbnQoXCJDdXN0b20tRXJyb3JzXCIsIFwiQXR0YWNobWVudCBpbmZvIG1pc3NpbmdcIiwgcmVxdWVzdERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyQ29kZSwgZXJyRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXJyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuTk9fSU5URVJORVQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuTk9UX0pTT04gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuVElNRU9VVCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5SRVNQT05TRV9FUlJPUiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChzZW5kUmVxdWVzdCwgNSoxMDAwLCByZXF1ZXN0RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZW5kUmVxdWVzdCA9IGZ1bmN0aW9uKHJlcXVlc3REYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZXFNYW5hZ2VyLmFwaU1ldGhvZChcInBob3Rvcy5nZXRCeUlkXCIsIHtcInBob3Rvc1wiIDogcmVxdWVzdERhdGEub3duZXJJZCArIFwiX1wiICsgcmVxdWVzdERhdGEuaWR9LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IChkYXRhLnJlc3BvbnNlLmxlbmd0aCkgPyBkYXRhLnJlc3BvbnNlWzBdIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENQQS5zZW5kRXZlbnQoXCJDdXN0b20tRXJyb3JzXCIsIFwiQXR0YWNobWVudCBpbmZvIG1pc3NpbmdcIiwgcmVxdWVzdERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZShvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyQ29kZSwgZXJyRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXJyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuTk9fSU5URVJORVQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuTk9UX0pTT04gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuVElNRU9VVCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5SRVNQT05TRV9FUlJPUiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChzZW5kUmVxdWVzdCwgNSoxMDAwLCByZXF1ZXN0RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZW5kUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICBzZW5kQXN5bmNSZXNwb25zZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJtYXJrTWVzc2FnZVRhZ1wiIDpcbiAgICAgICAgICAgICAgICBEYXRhYmFzZU1hbmFnZXIubWFya01lc3NhZ2VXaXRoVGFnKHJlcXVlc3QubWlkLCByZXF1ZXN0LnRhZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoaXNEYXRhYmFzZUVycm9yLCBlcnJNc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGF0YWJhc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nTWFuYWdlci5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgQ1BBLnNlbmRFdmVudChcIkN1c3RvbS1FcnJvcnNcIiwgXCJEYXRhYmFzZSBlcnJvclwiLCBlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHNlbmRBc3luY1Jlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIm1pZ3JhdGVJbnRyZXN0ZWRcIjpcbiAgICAgICAgICAgICAgICBvcGVuQXBwV2luZG93KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJ1bm1hcmtNZXNzYWdlVGFnXCIgOlxuICAgICAgICAgICAgICAgIERhdGFiYXNlTWFuYWdlci51bm1hcmtNZXNzYWdlV2l0aFRhZyhyZXF1ZXN0Lm1pZCwgcmVxdWVzdC50YWcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oaXNEYXRhYmFzZUVycm9yLCBlcnJNc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGF0YWJhc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nTWFuYWdlci5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgQ1BBLnNlbmRFdmVudChcIkN1c3RvbS1FcnJvcnNcIiwgXCJEYXRhYmFzZSBlcnJvclwiLCBlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHNlbmRBc3luY1Jlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcInNlcnZlckRlbGV0ZU1lc3NhZ2VcIiA6XG4gICAgICAgICAgICAgICAgdmFyIHNlbmREcm9wTWVzc2FnZVJlcXVlc3QgPSBmdW5jdGlvbihtc2dJZCkge1xuICAgICAgICAgICAgICAgICAgICBSZXFNYW5hZ2VyLmFwaU1ldGhvZChcIm1lc3NhZ2VzLmRlbGV0ZVwiLCB7XCJtaWRcIiA6IG1zZ0lkfSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJDb2RlLCBlcnJEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGVyckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuTk9fSU5URVJORVQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5OT1RfSlNPTiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLlRJTUVPVVQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5SRVNQT05TRV9FUlJPUiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHNlbmREcm9wTWVzc2FnZVJlcXVlc3QsIDYwKjEwMDAsIG1zZ0lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ01hbmFnZXIuZXJyb3IoXCJEZWxldGluZyBtZXNzYWdlIGZhaWxlZCAoZ290IGVycm9yIGNvZGUgXCIgKyBlcnJDb2RlICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHNlbmREcm9wTWVzc2FnZVJlcXVlc3QocmVxdWVzdC5taWQpO1xuICAgICAgICAgICAgICAgIHNlbmRBc3luY1Jlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcInNlcnZlclJlc3RvcmVNZXNzYWdlXCIgOlxuICAgICAgICAgICAgICAgIENQQS5zZW5kRXZlbnQoXCJBcHAtRGF0YVwiLCBcIlVzZSByZXN0b3JlIG1lc3NhZ2VzXCIpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNlbmRSZXN0b3JlTWVzc2FnZVJlcXVlc3QgPSBmdW5jdGlvbihtc2dJZCkge1xuICAgICAgICAgICAgICAgICAgICBSZXFNYW5hZ2VyLmFwaU1ldGhvZChcIm1lc3NhZ2VzLnJlc3RvcmVcIiwge1wibWlkXCIgOiBtc2dJZH0sIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyQ29kZSwgZXJyRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlcnJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLk5PX0lOVEVSTkVUIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuTk9UX0pTT04gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5USU1FT1VUIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoc2VuZFJlc3RvcmVNZXNzYWdlUmVxdWVzdCwgNjAqMTAwMCwgbXNnSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgTG9nTWFuYWdlci5lcnJvcihcIlJlc3RvcmluZyBtZXNzYWdlIGZhaWxlZCAoZ290IGVycm9yIGNvZGUgXCIgKyBlcnJDb2RlICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHNlbmRSZXN0b3JlTWVzc2FnZVJlcXVlc3QocmVxdWVzdC5taWQpO1xuICAgICAgICAgICAgICAgIHNlbmRBc3luY1Jlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcImRlbGV0ZU1lc3NhZ2VGb3JldmVyXCIgOlxuICAgICAgICAgICAgICAgIHZhciBvbkRyb3AsXG4gICAgICAgICAgICAgICAgICAgIHNlbmREcm9wTWVzc2FnZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnNUb0dvID0gKHJlcXVlc3Quc2VydmVyVG9vKSA/IDIgOiAxLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zTWFkZSA9IDA7XG5cbiAgICAgICAgICAgICAgICBzZW5kQXN5bmNSZXNwb25zZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBvbkRyb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uc01hZGUgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbnNNYWRlICE9PSBhY3Rpb25zVG9Hbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlbmREcm9wTWVzc2FnZVJlcXVlc3QgPSBmdW5jdGlvbihtc2dJZCkge1xuICAgICAgICAgICAgICAgICAgICBSZXFNYW5hZ2VyLmFwaU1ldGhvZChcIm1lc3NhZ2VzLmRlbGV0ZVwiLCB7XCJtaWRcIiA6IG1zZ0lkfSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Ecm9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyckNvZGUsIGVyckRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXJyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5OT19JTlRFUk5FVCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLk5PVF9KU09OIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuVElNRU9VVCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHNlbmREcm9wTWVzc2FnZVJlcXVlc3QsIDYwKjEwMDAsIG1zZ0lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ01hbmFnZXIuZXJyb3IoXCJEZWxldGluZyBtZXNzYWdlIGZhaWxlZCAoZ290IGVycm9yIGNvZGUgXCIgKyBlcnJDb2RlICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Ecm9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zZXJ2ZXJUb28pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g0L/QvtGB0YvQu9Cw0LXQvCDQt9Cw0L/RgNC+0YEg0L3QsCDRgdC10YDQstC10YBcbiAgICAgICAgICAgICAgICAgICAgc2VuZERyb3BNZXNzYWdlUmVxdWVzdChyZXF1ZXN0Lm1pZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8g0YPQtNCw0LvRj9C10Lwg0LLRgdC1INC00LDQvdC90YvQtSDQviDRgdC+0L7QsdGJ0LXQvdC40Lgg0LIg0JHQlFxuICAgICAgICAgICAgICAgIERhdGFiYXNlTWFuYWdlci5kZWxldGVNZXNzYWdlKHJlcXVlc3QubWlkLCBvbkRyb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwic3BlZWNoQ2hhbmdlXCIgOlxuICAgICAgICAgICAgICAgIENQQS5zZW5kRXZlbnQoXCJBcHAtQWN0aW9uc1wiLCBcIlNwZWVjaCBjaGFuZ2VcIiwge1xuICAgICAgICAgICAgICAgICAgICBcImNocm9tZVwiIDogcHJvY2Vzcy52ZXJzaW9ucy5jaHJvbWUsXG4gICAgICAgICAgICAgICAgICAgIFwiYXBwXCIgOiBBcHAuVkVSU0lPTixcbiAgICAgICAgICAgICAgICAgICAgXCJ1aWRcIiA6IEFjY291bnRzTWFuYWdlci5jdXJyZW50VXNlcklkXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIm5ld3NQb3N0U2VlblwiIDpcbiAgICAgICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiQXBwLURhdGFcIiwgXCJOZXdzIHNlZW5cIiwgcmVxdWVzdC5pZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJuZXdzTGlua0NsaWNrZWRcIiA6XG4gICAgICAgICAgICAgICAgQ1BBLnNlbmRFdmVudChcIkFwcC1BY3Rpb25zXCIsIFwiTmV3cyBsaW5rIGNsaWNrZWRcIiwgW3JlcXVlc3QuaWQsIHJlcXVlc3QudXJsXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJuZXdzQXVkaW9QbGF5aW5nXCIgOlxuICAgICAgICAgICAgICAgIENQQS5zZW5kRXZlbnQoXCJBcHAtQWN0aW9uc1wiLCBcIkF1ZGlvIHBsYXlpbmdcIiwgW3JlcXVlc3QuaWQsIHJlcXVlc3Qub3duZXJfaWQsIHJlcXVlc3QuYWlkXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJ0b3VyV2F0Y2hcIiA6XG4gICAgICAgICAgICAgICAgQ1BBLnNlbmRFdmVudChcIkFwcC1EYXRhXCIsIFwiV1Agc2VlblwiLCByZXF1ZXN0LnN0ZXApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwidXNlSW1wb3J0YW50VGFnXCIgOlxuICAgICAgICAgICAgICAgIENQQS5zZW5kRXZlbnQoXCJBcHAtRGF0YVwiLCBcIlVzZSBpbXBvcnRhbnQgdGFnXCIsIHJlcXVlc3QudHlwZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJnZXRUYWdzRnJlcXVlbmN5XCIgOlxuICAgICAgICAgICAgICAgIHNlbmRBc3luY1Jlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBEYXRhYmFzZU1hbmFnZXIuZ2V0VGFnc0NvdW50KHNlbmRSZXNwb25zZSwgZnVuY3Rpb24gKGVyck1zZykge1xuICAgICAgICAgICAgICAgICAgICBMb2dNYW5hZ2VyLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgIENQQS5zZW5kRXZlbnQoXCJDdXN0b20tRXJyb3JzXCIsIFwiRGF0YWJhc2UgZXJyb3JcIiwgZXJyTXNnKTtcblxuICAgICAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2Uoe30pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJnZXRNZXNzYWdlc0J5VGFnTmFtZVwiIDpcbiAgICAgICAgICAgICAgICBzZW5kQXN5bmNSZXNwb25zZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgRGF0YWJhc2VNYW5hZ2VyLmdldE1lc3NhZ2VzQnlUeXBlKHJlcXVlc3QudGFnLCByZXF1ZXN0LnRvdGFsU2hvd24gfHwgMCwgc2VuZFJlc3BvbnNlLCBmdW5jdGlvbihlcnJNc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nTWFuYWdlci5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiQ3VzdG9tLUVycm9yc1wiLCBcIkRhdGFiYXNlIGVycm9yXCIsIGVyck1zZyk7XG5cbiAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKFtbXSwgMF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJzZWFyY2hDb250YWN0XCIgOlxuICAgICAgICAgICAgICAgIERhdGFiYXNlTWFuYWdlci5zZWFyY2hDb250YWN0KHJlcXVlc3QudmFsdWUsIHJlcXVlc3QudG90YWxTaG93biwgZnVuY3Rpb24gKGNvbnRhY3RzLCB0b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UoW2NvbnRhY3RzLCB0b3RhbCwgcmVxdWVzdC52YWx1ZV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChTZXR0aW5nc01hbmFnZXIuU2hvd09ubGluZSA9PT0gMSAmJiBjb250YWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1aWRzID0gY29udGFjdHMubWFwKGZ1bmN0aW9uKGNvbnRhY3REYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhY3REYXRhLnVpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBSZXFNYW5hZ2VyLmFwaU1ldGhvZChcInVzZXJzLmdldFwiLCB7XCJ1aWRzXCIgOiB1aWRzLmpvaW4oXCIsXCIpLCBcImZpZWxkc1wiIDogXCJvbmxpbmVcIn0sIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzT25saW5lID0gKGNodW5rLm9ubGluZSA9PT0gMSB8fCBjaHVuay5vbmxpbmVfbW9iaWxlID09PSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe1wiYWN0aW9uXCIgOiBcImNvbnRhY3RPbmxpbmVTdGF0dXNcIiwgXCJ1aWRcIiA6IGNodW5rLnVpZCwgXCJvbmxpbmVcIiA6IGlzT25saW5lfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJNc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nTWFuYWdlci5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiQ3VzdG9tLUVycm9yc1wiLCBcIkRhdGFiYXNlIGVycm9yXCIsIGVyck1zZyk7XG5cbiAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKFtbXSwgMCwgcmVxdWVzdC52YWx1ZV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgc2VuZEFzeW5jUmVzcG9uc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwic2VhcmNoTWFpbFwiIDpcbiAgICAgICAgICAgICAgICBzZW5kQXN5bmNSZXNwb25zZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBEYXRhYmFzZU1hbmFnZXIuc2VhcmNoTWFpbChyZXF1ZXN0LnBhcmFtcywgcmVxdWVzdC52YWx1ZSwgcmVxdWVzdC50b3RhbFNob3duLCBmdW5jdGlvbiAoY29ycmVzcG9uZGVuY2UsIHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZShbY29ycmVzcG9uZGVuY2UsIHRvdGFsLCByZXF1ZXN0LnZhbHVlXSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyTXNnKSB7XG4gICAgICAgICAgICAgICAgICAgIExvZ01hbmFnZXIuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgQ1BBLnNlbmRFdmVudChcIkN1c3RvbS1FcnJvcnNcIiwgXCJEYXRhYmFzZSBlcnJvclwiLCBlcnJNc2cpO1xuXG4gICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZShbW10sIDAsIHJlcXVlc3QudmFsdWVdKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwic2tpcFN5bmNcIjpcbiAgICAgICAgICAgICAgICBmb3JjZVNraXBTeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBDUEEuc2VuZEV2ZW50KFwiQXBwLUFjdGlvbnNcIiwgXCJTa2lwIHN5bmNcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJjdXJyZW50U3luY1ZhbHVlc1wiIDpcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gc3luY2luZ0RhdGFbQWNjb3VudHNNYW5hZ2VyLmN1cnJlbnRVc2VySWRdO1xuICAgICAgICAgICAgICAgIHNlbmRBc3luY1Jlc3BvbnNlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIERhdGFiYXNlTWFuYWdlci5nZXRDb250YWN0QnlJZChBY2NvdW50c01hbmFnZXIuY3VycmVudFVzZXJJZCwgQWNjb3VudHNNYW5hZ2VyLmN1cnJlbnRVc2VySWQsIGZ1bmN0aW9uICh1c2VyRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogb3V0cHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXZhdGFyOiB1c2VyRGF0YS5waG90b1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcInN3aXRjaFRvQWNjb3VudFwiIDpcbiAgICAgICAgICAgICAgICBSZXFNYW5hZ2VyLmFib3J0QWxsKCk7XG4gICAgICAgICAgICAgICAgQWNjb3VudHNNYW5hZ2VyLmN1cnJlbnRVc2VySWQgPSByZXF1ZXN0LnVpZDtcblxuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2Vsb2dOb3RpZmllZCA9IHN0b3JhZ2VNYW5hZ2VyLmdldChcImNoYW5nZWxvZ19ub3RpZmllZFwiLCB7Y29uc3RydWN0b3I6IEFycmF5LCBzdHJpY3Q6IHRydWUsIGNyZWF0ZTogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgIHZhciB3YWxsVG9rZW5VcGRhdGVkID0gKHN0b3JhZ2VNYW5hZ2VyLmdldChcIndhbGxfdG9rZW5fdXBkYXRlZFwiLCB7Y29uc3RydWN0b3I6IE9iamVjdCwgc3RyaWN0OiB0cnVlLCBjcmVhdGU6IHRydWV9KVtBY2NvdW50c01hbmFnZXIuY3VycmVudFVzZXJJZF0gIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0VXNlciA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRVc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VXNlclNlc3Npb24obGVhdmVPbmVBcHBXaW5kb3dJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVhdmVPbmVBcHBXaW5kb3dJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiZGVsZXRlQWNjb3VudFwiIDpcbiAgICAgICAgICAgICAgICBSZXFNYW5hZ2VyLmFib3J0QWxsKCk7XG4gICAgICAgICAgICAgICAgQWNjb3VudHNNYW5hZ2VyLmRyb3AocmVxdWVzdC51aWQpO1xuICAgICAgICAgICAgICAgIERhdGFiYXNlTWFuYWdlci5kcm9wVXNlcihyZXF1ZXN0LnVpZCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZnJpZW5kc1N5bmNUaW1lID0gc3RvcmFnZU1hbmFnZXIuZ2V0KFwiZnJpZW5kc19zeW5jX3RpbWVcIiwge2NvbnN0cnVjdG9yOiBPYmplY3QsIHN0cmljdDogdHJ1ZSwgY3JlYXRlOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGZyaWVuZHNTeW5jVGltZVtyZXF1ZXN0LnVpZF07XG4gICAgICAgICAgICAgICAgc3RvcmFnZU1hbmFnZXIuc2V0KFwiZnJpZW5kc19zeW5jX3RpbWVcIiwgZnJpZW5kc1N5bmNUaW1lKTtcblxuICAgICAgICAgICAgICAgIHZhciB3YWxsVG9rZW5VcGRhdGVkID0gc3RvcmFnZU1hbmFnZXIuZ2V0KFwid2FsbF90b2tlbl91cGRhdGVkXCIsIHtjb25zdHJ1Y3RvcjogT2JqZWN0LCBzdHJpY3Q6IHRydWUsIGNyZWF0ZTogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB3YWxsVG9rZW5VcGRhdGVkW3JlcXVlc3QudWlkXTtcbiAgICAgICAgICAgICAgICBzdG9yYWdlTWFuYWdlci5zZXQoXCJ3YWxsX3Rva2VuX3VwZGF0ZWRcIiwgd2FsbFRva2VuVXBkYXRlZCk7XG5cbiAgICAgICAgICAgICAgICBzdG9yYWdlTWFuYWdlci5yZW1vdmUoXCJwZXJtX2luYm94X1wiICsgcmVxdWVzdC51aWQpO1xuICAgICAgICAgICAgICAgIHN0b3JhZ2VNYW5hZ2VyLnJlbW92ZShcInBlcm1fb3V0Ym94X1wiICsgcmVxdWVzdC51aWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QubmV4dCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgQWNjb3VudHNNYW5hZ2VyLmN1cnJlbnRVc2VySWQgPSByZXF1ZXN0Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VXNlclNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyDQt9Cw0LrRgNGL0LLQsNC10Lwg0LLRgdC1INGC0LDQsdGLINC/0YDQuNC70L7QttC10L3QuNGPINC60YDQvtC80LUg0L7QtNC90L7Qs9C+XG4gICAgICAgICAgICAgICAgbGVhdmVPbmVBcHBXaW5kb3dJbnN0YW5jZSgpO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJtYXJrQXNSZWFkXCIgOlxuICAgICAgICAgICAgICAgIHZhciBzZW5kUmVhZE1lc3NhZ2VSZXF1ZXN0ID0gZnVuY3Rpb24gKG1zZ0lkKSB7XG4gICAgICAgICAgICAgICAgICAgIFJlcU1hbmFnZXIuYXBpTWV0aG9kKFwibWVzc2FnZXMubWFya0FzUmVhZFwiLCB7XCJtaWRzXCIgOiBtc2dJZH0sIG51bGwsIGZ1bmN0aW9uIChlcnJDb2RlLCBlcnJEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGVyckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlcU1hbmFnZXIuTk9fSU5URVJORVQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVxTWFuYWdlci5OT1RfSlNPTiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXFNYW5hZ2VyLlRJTUVPVVQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChzZW5kUmVhZE1lc3NhZ2VSZXF1ZXN0LCA2MCoxMDAwLCBtc2dJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBMb2dNYW5hZ2VyLmVycm9yKFwiTWFya2luZyBtZXNzYWdlIGFzIHJlYWQgZmFpbGVkIChnb3QgZXJyb3IgY29kZSBcIiArIGVyckNvZGUgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBzZW5kUmVhZE1lc3NhZ2VSZXF1ZXN0KHJlcXVlc3QubWlkKTtcbiAgICAgICAgICAgICAgICBEYXRhYmFzZU1hbmFnZXIubWFya0FzUmVhZChyZXF1ZXN0Lm1pZCwgbnVsbCwgZnVuY3Rpb24gKGVyck1zZykge1xuICAgICAgICAgICAgICAgICAgICBMb2dNYW5hZ2VyLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgIENQQS5zZW5kRXZlbnQoXCJDdXN0b20tRXJyb3JzXCIsIFwiRGF0YWJhc2UgZXJyb3JcIiwgZXJyTXNnKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiRE5EaGFwcGVuZWRcIiA6XG4gICAgICAgICAgICAgICAgQ1BBLnNlbmRFdmVudChcIkFwcC1BY3Rpb25zXCIsIFwiRE5EXCIsIHJlcXVlc3QubnVtKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZW5kQXN5bmNSZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vINC/0YDQuCDQt9Cw0LPRgNGD0LfQutC1INC/0YDQuNC70L7QttC10L3QuNGPLi4uXG4gICAgaWYgKEFjY291bnRzTWFuYWdlci5jdXJyZW50VXNlcklkKSB7XG4gICAgICAgIHN0YXJ0VXNlclNlc3Npb24oKTtcbiAgICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyY19lbGVjdHJvbi91aS9qcy9zeW5jLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQge3ZhbHVlcywgbm9vcCwgY29tcGFjdH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7QVNDLCBERVNDLCBBU0NfVU5JUVVFfSBmcm9tICdza2xhZCc7XG5pbXBvcnQge29wZW5Vc2VyLCBvcGVuTWV0YSwgZHJvcFVzZXJ9IGZyb20gJy4vaWRiJztcblxuY29uc3QgdmFsaWRhdGVKU09OU3RyaW5nID0gKGRhdGEsIGNvbnN0cikgPT4ge1xuICAgIGxldCBzb21lRGF0YTtcblxuICAgIHRyeSB7XG4gICAgICAgIHNvbWVEYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgYXNzZXJ0KHNvbWVEYXRhIGluc3RhbmNlb2YgY29uc3RyKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBzb21lRGF0YSA9IG5ldyBjb25zdHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvbWVEYXRhO1xufTtcblxuY29uc3QgZ2V0TWVzc2FnZUZ1bGx0ZXh0ID0gKG1zZ0JvZHkpID0+IHtcbiAgICByZXR1cm4gbXNnQm9keS5yZXBsYWNlKC88YnJcXHM/XFwvP1xccz8+L2csICcgJykudG9Mb3dlckNhc2UoKS5zcGxpdCgnICcpLmZpbHRlcih3b3JkID0+IHdvcmQubGVuZ3RoID49IDMpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIC8qKlxuICAgICAqIE1pZ3JhdGUgYWxsIFdlYkRhdGFiYXNlcyBpbnRvIEluZGV4ZWREQlxuICAgICAqL1xuICAgIG1pZ3JhdGVXZWJEYXRhYmFzZTogZnVuY3Rpb24gRGF0YWJhc2VNYW5hZ2VyX21pZ3JhdGVXZWJEYXRhYmFzZSh1aWRzLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIk1pZ3JhdGUgV2ViRGF0YWJhc2UgaW50byBJbmRleGVkREJcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVUlEU1wiLCB1aWRzKTtcblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciB3ZWJEYXRhYmFzZUxpbmsgPSB3aW5kb3cub3BlbkRhdGFiYXNlKFwidmtvZmZsaW5lXCIsIFwiMS4wLjFcIiwgbnVsbCwgMCk7XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0QWxsV2ViRGF0YWJhc2VEYXRhKHRhYmxlLCB1aWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29sbGVjdCBkYXRhIGZyb20gJXNfJXNcIiwgdGFibGUsIHVpZCk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgd2ViRGF0YWJhc2VMaW5rLnJlYWRUcmFuc2FjdGlvbihmdW5jdGlvbiAodHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdHguZXhlY3V0ZVNxbChcIlNFTEVDVCByb3dpZCwgKiBGUk9NIFwiICsgdGFibGUgKyBcIl9cIiArIHVpZCArIFwiIE9SREVSIEJZIHJvd2lkXCIsIFtdLCBmdW5jdGlvbiAodHgsIHJlc3VsdFNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsUmVjb3JkcyA9IHJlc3VsdFNldC5yb3dzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIlcyByZWNvcmRzIGZvdW5kIGluICVzXCIsIHRvdGFsUmVjb3JkcywgdGFibGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsUmVjb3JkczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocmVzdWx0U2V0LnJvd3MuaXRlbShpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHR4LCBlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIENQQS5zZW5kRXZlbnQoXCJNaWdyYXRlMVwiLCBcIldlYkRhdGFiYXNlIHdhcm5cIiwgZXJyLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQgaXQgYmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKFwibm8gc3VjaCB0YWJsZVwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtaWdyYXRlVXNlckRhdGEodWlkKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY3VycmVudFVzZXJJZCA9IE51bWJlcih1aWQpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHRoYXQuaW5pdFVzZXIodWlkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVXNlciBpbml0aWFsaXplZFwiKTtcblxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRBbGxXZWJEYXRhYmFzZURhdGEoXCJjb250YWN0c1wiLCB1aWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QWxsV2ViRGF0YWJhc2VEYXRhKFwicG1cIiwgdWlkKVxuICAgICAgICAgICAgICAgICAgICBdKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmZXRjaGVkQ29udGFjdHMgPSByZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmV0Y2hlZE1lc3NhZ2VzID0gcmVzWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFjdHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXRzID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoZWRDb250YWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJEYXRhID0gdmFsaWRhdGVKU09OU3RyaW5nKHJlY29yZC5vdGhlcl9kYXRhLCBPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1aWQgPSBOdW1iZXIocmVjb3JkLnVpZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWN0c1tyZWNvcmQudWlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiB1aWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0X25hbWU6IHJlY29yZC5maXJzdF9uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0X25hbWU6IHJlY29yZC5sYXN0X25hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVzOiByZWNvcmQubm90ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfbWVzc2FnZV90czogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNfbnVtOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxsdGV4dDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkLmZpcnN0X25hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZC5sYXN0X25hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckRhdGEuZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhY3RzW3JlY29yZC51aWRdLmZ1bGx0ZXh0LnB1c2gob3RoZXJEYXRhLmRvbWFpbi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJwaG90b1wiLCBcImJkYXRlXCIsIFwiZG9tYWluXCIsIFwiaG9tZV9waG9uZVwiLCBcIm1vYmlsZV9waG9uZVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJEYXRhW2ZpZWxkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdHNbcmVjb3JkLnVpZF1bZmllbGRdID0gb3RoZXJEYXRhW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyRGF0YS5zZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdHNbcmVjb3JkLnVpZF0uc2V4ID0gTnVtYmVyKG90aGVyRGF0YS5zZXgpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoZWRNZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNNdWx0aUNoYXQgPSBCb29sZWFuKHJlY29yZC5jaGF0aWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGF0SWQgPSBpc011bHRpQ2hhdCA/IFN0cmluZyhyZWNvcmQuY2hhdGlkKSA6IFwiMF9cIiArIHJlY29yZC51aWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVzZXJJZCA9IE51bWJlcihyZWNvcmQudWlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdENoYXRNZXNzYWdlRGF0ZSA9IGNoYXRzW2NoYXRJZF0gPyBjaGF0c1tjaGF0SWRdLmxhc3RfbWVzc2FnZV90cyA6IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGF0c1tjaGF0SWRdID0gY2hhdHNbY2hhdElkXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGF0c1tjaGF0SWRdLmlkID0gY2hhdElkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXRzW2NoYXRJZF0udGl0bGUgPSByZWNvcmQudGl0bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhdHNbY2hhdElkXS5sYXN0X21lc3NhZ2VfdHMgPSBNYXRoLm1heChyZWNvcmQuZGF0ZSwgbGFzdENoYXRNZXNzYWdlRGF0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0YWNobWVudHMgPSB2YWxpZGF0ZUpTT05TdHJpbmcocmVjb3JkLmF0dGFjaG1lbnRzLCBBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZ3MgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFwcC5JTklUX1RBR1MuZm9yRWFjaChmdW5jdGlvbiAodGFnLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQudGFncyAmIE1hdGgucG93KDIsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdzLnB1c2godGFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyRGF0YSA9IHZhbGlkYXRlSlNPTlN0cmluZyhyZWNvcmQub3RoZXJfZGF0YSwgT2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzRW1vamkgPSBCb29sZWFuKG90aGVyRGF0YS5lbW9qaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1tyZWNvcmQubWlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlkOiBOdW1iZXIocmVjb3JkLm1pZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpZDogdXNlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogcmVjb3JkLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiByZWNvcmQuYm9keSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZTogcmVjb3JkLmRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWQ6IEJvb2xlYW4ocmVjb3JkLnN0YXR1cyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRzOiBhdHRhY2htZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnczogdGFncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzX2Vtb2ppOiBoYXNFbW9qaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhdDogY2hhdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxsdGV4dDogZ2V0TWVzc2FnZUZ1bGx0ZXh0KHJlY29yZC5ib2R5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRhY3RzW3VzZXJJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTm8gY29udGFjdCB3aXRoIHN1Y2ggaWQ6ICVzXCIsIHVzZXJJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWN0c1t1c2VySWRdLm1lc3NhZ2VzX251bSArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhY3RzW3VzZXJJZF0ubGFzdF9tZXNzYWdlX3RzID0gTWF0aC5tYXgoY29udGFjdHNbdXNlcklkXS5sYXN0X21lc3NhZ2VfdHMsIHJlY29yZC5kYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlN0YXJ0IGluc2VydGluZyBkYXRhIHdpdGggdWlkICVzXCIsIHVpZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2VydCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9jb25uW3VpZF0uaW5zZXJ0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNoYXRzXCI6IF8udmFsdWVzKGNoYXRzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbnRhY3RzXCI6IF8udmFsdWVzKGNvbnRhY3RzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1lc3NhZ2VzXCI6IF8udmFsdWVzKG1lc3NhZ2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgaW5zZXJ0ZWRLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyTXNnID0gZXJyLm5hbWUgKyBcIjogXCIgKyBlcnIubWVzc2FnZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fY29ublt1aWRdLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7fVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENQQS5zZW5kRXZlbnQoXCJNaWdyYXRlMVwiLCBcIklEQiBpbnNlcnQgZmFpbFwiLCBlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyTXNnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb250YWN0cyBhbmQgUE1zIGluc2VydGVkXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fY29ublt1aWRdLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJNc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIENQQS5zZW5kRXZlbnQoXCJNaWdyYXRlMVwiLCBcImdldEFsbFdlYkRhdGFiYXNlIGZhaWxcIiwgZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyTXNnKSB7XG4gICAgICAgICAgICAgICAgICAgIENQQS5zZW5kRXZlbnQoXCJNaWdyYXRlMVwiLCBcImluaXRVc2VyIGZhaWxcIiwgZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVyck1zZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9taXNlcyA9IHVpZHMubWFwKGZ1bmN0aW9uICh1aWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVUlEIGZvdW5kOiAlc1wiLCB1aWQpO1xuICAgICAgICAgICAgcmV0dXJuIG1pZ3JhdGVVc2VyRGF0YS5jYWxsKHRoYXQsIHVpZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIG1ldGEgZGF0YWJhc2Ugd2l0aCBsb2cgb2JqZWN0IHN0b3JlXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBpbml0TWV0YTogYXN5bmMgZnVuY3Rpb24gRGF0YWJhc2VNYW5hZ2VyX2luaXRNZXRhKCkge1xuICAgICAgICB0aGlzLl9tZXRhID0gYXdhaXQgb3Blbk1ldGEoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSB1c2VySWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbkZhaWwg0L/RgNC40L3QuNC80LDQtdGCIHtTdHJpbmd9INGC0LXQutGB0YIg0L7RiNC40LHQutC4XG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBpbml0VXNlcjogYXN5bmMgZnVuY3Rpb24gRGF0YWJhc2VNYW5hZ2VyX2luaXRVc2VyKHVzZXJJZCwgZm5TdWNjZXNzLCBmbkZhaWwpIHtcbiAgICAgICAgdGhpcy5fdXNlcklkID0gdXNlcklkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9jb25uW3VzZXJJZF0gPSBhd2FpdCBvcGVuVXNlcih1c2VySWQpO1xuICAgICAgICAgICAgdGhpcy5fdXNlcklkID0gdXNlcklkO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGZuRmFpbChlcnIubmFtZSArICc6ICcgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmblN1Y2Nlc3MoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkcm9wVXNlcjogYXN5bmMgZnVuY3Rpb24gRGF0YWJhc2VNYW5hZ2VyX2Ryb3BVc2VyKHVzZXJJZCkge1xuICAgICAgICB0aGlzLl9jb25uW3VzZXJJZF0uY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIGRyb3BVc2VyKHVzZXJJZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvdXRwdXRUeXBlIC0gYWxwaGEgKNCyINCw0LvRhNCw0LLQuNGC0L3QvtC8INC/0L7RgNGP0LTQutC1KSwgbGFzdGRhdGUgKNC/0L4g0LTQsNGC0LUg0L/QvtGB0LvQtdC00L3QtdCz0L4g0YHQvtC+0LHRidC10L3QuNGPKSwgbWVzc2FnZXNudW0gKNC/0L4g0L7QsdGJ0LXQvNGDINC60L7Qu9C40YfQtdGB0YLQstGDINGB0L7QvtCx0YnQtdC90LjQuSlcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHN0YXJ0RnJvbVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuU3VjY2VzcyDQv9GA0LjQvdC40LzQsNC10YI6XG4gICAgICogICAgIHtBcnJheX0g0LzQsNGB0YHQuNCyINC+0LHRitC10LrRgtC+0LIt0LrQvtC90YLQsNC60YLQvtCyXG4gICAgICogICAgIHtOdW1iZXJ9INC+0LHRidC10LUg0LrQvtC70LjRh9C10YHRgtCy0L4g0LrQvtC90YLQsNC60YLQvtCyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5GYWlsINC/0YDQuNC90LjQvNCw0LXRgjpcbiAgICAgKiAgICAge1N0cmluZ30gZXJyb3JNZXNzYWdlXG4gICAgICovXG4gICAgZ2V0Q29udGFjdExpc3Q6IGZ1bmN0aW9uIERhdGFiYXNlTWFuYWdlcl9nZXRDb250YWN0TGlzdChvdXRwdXRUeXBlLCBzdGFydEZyb20sIGZuU3VjY2VzcywgZm5GYWlsKSB7XG4gICAgICAgIHZhciB1c2VySWQgPSB0aGlzLl91c2VySWQ7XG4gICAgICAgIHZhciBjb25uID0gdGhpcy5fY29ublt1c2VySWRdO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvdW50Q29udGFjdHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGNvbm4uY291bnQoXCJjb250YWN0c1wiLCBmdW5jdGlvbiAoZXJyLCB0b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodG90YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldENvbnRhY3RzKCkge1xuICAgICAgICAgICAgdmFyIGluZGV4TmFtZTtcbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb247XG5cbiAgICAgICAgICAgIHN3aXRjaCAob3V0cHV0VHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhbHBoYVwiOlxuICAgICAgICAgICAgICAgICAgICBpbmRleE5hbWUgPSBcIm5hbWVcIjtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gQVNDO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJsYXN0ZGF0ZVwiOlxuICAgICAgICAgICAgICAgICAgICBpbmRleE5hbWUgPSBcImxhc3RfbWVzc2FnZVwiO1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBERVNDO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlc251bVwiOlxuICAgICAgICAgICAgICAgICAgICBpbmRleE5hbWUgPSBcIm1lc3NhZ2VzX251bVwiO1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBERVNDO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25uLmdldChcImNvbnRhY3RzXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbGltaXQ6IDMwLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHN0YXJ0RnJvbSxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhLm1hcChmdW5jdGlvbiAobXNnRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtc2dEYXRhLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGdldENvbnRhY3RzKCksXG4gICAgICAgICAgICBjb3VudENvbnRhY3RzKClcbiAgICAgICAgXSkudGhlbihmblN1Y2Nlc3MsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGZuRmFpbChlcnIubmFtZSArIFwiOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gdWlkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5TdWNjZXNzINC/0YDQuNC90LjQvNCw0LXRgiDQv9Cw0YDQsNC80LXRgtGAIHtPYmplY3R9INC60L7QvdGC0LDQutGCXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5GYWlsINC/0YDQuNC90LjQvNCw0LXRgiDQv9Cw0YDQsNC80LXRgtGA0Ysge0Jvb2xlYW59IGlzRGF0YWJhc2VFcnJvciDQuCB7U3RyaW5nfSBlcnJvck1lc3NhZ2VcbiAgICAgKi9cbiAgICBnZXRDb250YWN0QnlJZDogZnVuY3Rpb24gRGF0YWJhc2VNYW5hZ2VyX2dldENvbnRhY3RCeUlkKGN1cnJlbnRVc2VySWQsIHVpZCwgZm5TdWNjZXNzLCBmbkZhaWwpIHtcbiAgICAgICAgdmFyIHVzZXJJZCA9IGN1cnJlbnRVc2VySWQ7XG4gICAgICAgIHZhciBzZWFyY2hVc2VySWQgPSBOdW1iZXIodWlkKTtcblxuICAgICAgICBmblN1Y2Nlc3MgPSBmblN1Y2Nlc3MgfHwgXy5ub29wO1xuICAgICAgICBmbkZhaWwgPSBmbkZhaWwgfHwgXy5ub29wO1xuXG4gICAgICAgIHRoaXMuX2Nvbm5bdXNlcklkXS5nZXQoXCJjb250YWN0c1wiLCB7XG4gICAgICAgICAgICByYW5nZTogSURCS2V5UmFuZ2Uub25seShzZWFyY2hVc2VySWQpXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlY29yZHMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBmbkZhaWwoZXJyLm5hbWUgKyBcIjogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXJlY29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm5GYWlsKG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm5TdWNjZXNzKHJlY29yZHNbMF0udmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNoYXRzIGxpc3Qgb3JkZXJlZCBkZXNjZW5kaW5nIGJ5IGRhdGVcbiAgICAgKiBOZWVkIGFsc28gdG8gZ2V0IGNoYXRzJyBwYXJ0aWNpcGFudHMsIGNoYXQgaWQsIHRpdGxlLCBkYXRlICYgYm9keSBvZiB0aGUgbGFzdCBtZXNzYWdlLCB0b3RhbCBtZXNzYWdlcyBpbiBjaGF0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRGcm9tXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5TdWNjZXNzIHdoaWNoIGludm9rZXMge0FycmF5fSB3aXRoIHtOdW1iZXJ9IHRvdGFsIGNoYXRzIG51bWJlciBhbmQge0FycmF5fSBjaGF0cyBkYXRhXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5GYWlsXG4gICAgICovXG4gICAgZ2V0Q29udmVyc2F0aW9uczogZnVuY3Rpb24gRGF0YWJhc2VNYW5hZ2VyX2dldENvbnZlcnNhdGlvbnMoc3RhcnRGcm9tLCBmblN1Y2Nlc3MsIGZuRmFpbCkge1xuICAgICAgICB2YXIgdXNlcklkID0gdGhpcy5fdXNlcklkO1xuICAgICAgICB2YXIgY29ubiA9IHRoaXMuX2Nvbm5bdXNlcklkXTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRDaGF0c0xpc3Qoc3RhcnRGcm9tKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGNvbm4uZ2V0KFwiY2hhdHNcIiwge1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogXCJsYXN0X21lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBzdGFydEZyb20sXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogREVTQyxcbiAgICAgICAgICAgICAgICAgICAgbGltaXQ6IDMwXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVjb3Jkcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0VG90YWxDaGF0cygpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgY29ubi5jb3VudChcImNoYXRzXCIsIGZ1bmN0aW9uIChlcnIsIHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0b3RhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Q29udGFjdEJ5SWQoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgY29ubi5nZXQoXCJjb250YWN0c1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5vbmx5KGlkKVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlY29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVyci5uYW1lICsgXCI6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFyZWNvcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTm8gc3VjaCBjb250YWN0OiBcIiArIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RfbmFtZTogcmVjb3Jkc1swXS52YWx1ZS5maXJzdF9uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfbmFtZTogcmVjb3Jkc1swXS52YWx1ZS5sYXN0X25hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldENoYXRQYXJ0aWNpcGFudHMocmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGNvbm4uZ2V0KFwibWVzc2FnZXNcIiwge1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogXCJjaGF0X3BhcnRpY2lwYW50c1wiLFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IEFTQ19VTklRVUUsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5ib3VuZChbcmVjb3JkLmlkXSwgW3JlY29yZC5pZCwgRGF0ZS5ub3coKV0pLFxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50VXNlcklzUGFydGljaXBhbnQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChjb250YWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhY3QudmFsdWUudWlkID09IHVzZXJJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VXNlcklzUGFydGljaXBhbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChnZXRDb250YWN0QnlJZChjb250YWN0LnZhbHVlLnVpZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQucGFydGljaXBhbnRzID0gXy5jb21wYWN0KHJlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFVzZXJJc1BhcnRpY2lwYW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZC5wYXJ0aWNpcGFudHMucHVzaCh7dWlkOiB1c2VySWR9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkLnBhcnRpY2lwYW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldENoYXRMYXN0TWVzc2FnZShyZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgY29ubi5nZXQoXCJtZXNzYWdlc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBcImNoYXRfbWVzc2FnZXNcIixcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IElEQktleVJhbmdlLm9ubHkocmVjb3JkLmlkKSxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBERVNDLFxuICAgICAgICAgICAgICAgICAgICBsaW1pdDogMVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlY29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQuYm9keSA9IHJlY29yZHNbMF0udmFsdWUuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZC51aWQgPSByZWNvcmRzWzBdLnZhbHVlLnVpZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldENoYXRUb3RhbE1lc3NhZ2VzKHJlY29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25uLmNvdW50KFwibWVzc2FnZXNcIiwge1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogXCJjaGF0X21lc3NhZ2VzXCIsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5vbmx5KHJlY29yZC5pZCksXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgdG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQudG90YWwgPSB0b3RhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBnZXRDaGF0c0xpc3Qoc3RhcnRGcm9tKSxcbiAgICAgICAgICAgIGdldFRvdGFsQ2hhdHMoKVxuICAgICAgICBdKS50aGVuKChbY2hhdHMsIHRvdGFsXSkgPT4ge1xuICAgICAgICAgICAgdmFyIGZpbGxEYXRhUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSByZXMuY2hhdHMubWFwKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhdERhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiByZWNvcmQudmFsdWUuaWQsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiByZWNvcmQudmFsdWUudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGU6IHJlY29yZC52YWx1ZS5sYXN0X21lc3NhZ2VfdHNcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZmlsbERhdGFQcm9taXNlcy5wdXNoKGdldENoYXRQYXJ0aWNpcGFudHMoY2hhdERhdGEpKTtcbiAgICAgICAgICAgICAgICBmaWxsRGF0YVByb21pc2VzLnB1c2goZ2V0Q2hhdExhc3RNZXNzYWdlKGNoYXREYXRhKSk7XG4gICAgICAgICAgICAgICAgZmlsbERhdGFQcm9taXNlcy5wdXNoKGdldENoYXRUb3RhbE1lc3NhZ2VzKGNoYXREYXRhKSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhdERhdGE7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgUHJvbWlzZS5hbGwoZmlsbERhdGFQcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm5TdWNjZXNzKFtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgICAgICAgICByZXMudG90YWxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBmbkZhaWwoZXJyLm5hbWUgKyBcIjogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgZm5GYWlsKGVyci5uYW1lICsgXCI6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSB1aWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblN1Y2Nlc3Mg0L/RgNC40L3QuNC80LDQtdGCINC/0LDRgNCw0LzQtdGC0YAge0FycmF5fSDRgdC/0LjRgdC+0Log0L7QsdGK0LXQutGC0L7QslxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuRmFpbCDQv9GA0LjQvdC40LzQsNC10YIg0L/QsNGA0LDQvNC10YLRgCB7U3RyaW5nfSBlcnJvck1lc3NhZ2VcbiAgICAgKi9cbiAgICBnZXRDb252ZXJzYXRpb25UaHJlYWRzV2l0aENvbnRhY3Q6IGZ1bmN0aW9uIERhdGFiYXNlTWFuYWdlcl9nZXRDb252ZXJzYXRpb25UaHJlYWRzV2l0aENvbnRhY3QodWlkLCBmblN1Y2Nlc3MsIGZuRmFpbCkge1xuICAgICAgICB2YXIgdXNlcklkID0gdGhpcy5fdXNlcklkO1xuICAgICAgICB2YXIgY29ubiA9IHRoaXMuX2Nvbm5bdXNlcklkXTtcblxuICAgICAgICB1aWQgPSBOdW1iZXIodWlkKTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRDb250YWN0QnlJZChpZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25uLmdldChcImNvbnRhY3RzXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IElEQktleVJhbmdlLm9ubHkoaWQpXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVjb3Jkcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghcmVjb3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aWQ6IHJlY29yZHNbMF0ua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0X25hbWU6IHJlY29yZHNbMF0udmFsdWUuZmlyc3RfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0X25hbWU6IHJlY29yZHNbMF0udmFsdWUubGFzdF9uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRDaGF0UGFydGljaXBhbnRzKHJlY29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhdElkID0gcmVjb3JkLmlkO1xuICAgICAgICAgICAgICAgIHZhciB0byA9IGNoYXRJZC5zdWJzdHIoMCwgY2hhdElkLmxlbmd0aCAtIDEpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaGF0SWQuY2hhckNvZGVBdChjaGF0SWQubGVuZ3RoIC0gMSkgKyAxKTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbY2hhdElkXSwgW3RvXSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBjb25uLmdldChcIm1lc3NhZ2VzXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IFwiY2hhdF9wYXJ0aWNpcGFudHNcIixcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IEFTQ19VTklRVUVcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZ2V0Q29udGFjdEJ5SWQocmVjb3JkLnZhbHVlLnVpZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQucGFydGljaXBhbnRzID0gXy5jb21wYWN0KHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRDaGF0TGFzdE1lc3NhZ2UocmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGNvbm4uZ2V0KFwibWVzc2FnZXNcIiwge1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogXCJjaGF0X21lc3NhZ2VzXCIsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5vbmx5KHJlY29yZC5pZCksXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogREVTQ1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlY29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGl0bGUgPSByZWNvcmRzLmxlbmd0aCA/IHJlY29yZHNbMF0udmFsdWUudGl0bGUgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gcmVjb3Jkcy5sZW5ndGggPyByZWNvcmRzWzBdLnZhbHVlLmJvZHkgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRlID0gcmVjb3Jkcy5sZW5ndGggPyByZWNvcmRzWzBdLnZhbHVlLmRhdGUgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVpZCA9IHJlY29yZHMubGVuZ3RoID8gcmVjb3Jkc1swXS52YWx1ZS51aWQgOiB1c2VySWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVjb3JkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZTogZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aWQ6IHVpZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb3VudENoYXRNZXNzYWdlcyhyZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgY29ubi5jb3VudChcIm1lc3NhZ2VzXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IFwiY2hhdF9tZXNzYWdlc1wiLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogSURCS2V5UmFuZ2Uub25seShyZWNvcmQuaWQpXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgdG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQudG90YWwgPSB0b3RhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25uLmdldChcIm1lc3NhZ2VzXCIsIHtcbiAgICAgICAgICAgIGluZGV4OiBcInVzZXJfY2hhdHNcIixcbiAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5ib3VuZChbdWlkXSwgW3VpZCArIDFdLCB0cnVlLCB0cnVlKSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogQVNDX1VOSVFVRVxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZWNvcmRzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZm5GYWlsKGVyci5uYW1lICsgXCI6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXRSZWNvcmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiByZWNvcmQua2V5WzFdXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGNoYXRSZWNvcmQpO1xuXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChnZXRDaGF0TGFzdE1lc3NhZ2UoY2hhdFJlY29yZCkpO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZ2V0Q2hhdFBhcnRpY2lwYW50cyhjaGF0UmVjb3JkKSk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChjb3VudENoYXRNZXNzYWdlcyhjaGF0UmVjb3JkKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIHNvcnQgY2hhdHNcbiAgICAgICAgICAgICAgICBvdXRwdXQuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYi5kYXRlIC0gYS5kYXRlO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZm5TdWNjZXNzKG91dHB1dCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZm5GYWlsKGVyci5uYW1lICsgXCI6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDQn9C+0LvRg9GH0LXQvdC40LUg0YHQvtC+0LHRidC10L3QuNC5INC40Lcg0LTQuNCw0LvQvtCz0LBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkaWFsb2dJZCDQuNC00LXQvdGC0LjRhNC40LrQsNGC0L7RgCDQtNC40LDQu9C+0LPQsDogW1xcZF0rINCyINGB0LvRg9GH0LDQtSDRh9Cw0YLQsCwgMF9bXFxkXSsg0LIg0YHQu9GD0YfQsNC1INC/0LXRgNC10L/QuNGB0LrQuCDQvtC00LjQvSDQvdCwINC+0LTQuNC9XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdHMuZnJvbSA9IHVuZGVmaW5lZF0g0YEg0LrQsNC60L7QuSDQt9Cw0L/QuNGB0Lgg0L3Rg9C20L3QviDQstGB0LUg0L/QvtC70YPRh9C40YLRjFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdHMuZXZlcnl0aGluZyA9IGZhbHNlXSDQvdGD0LbQvdC+INC70Lgg0L/QvtC70YPRh9C40YLRjCDQstGB0LUg0LfQsNC/0LjRgdC4INCyINC00LjQsNC70L7Qs9C1XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5TdWNjZXNzINC/0YDQuNC90LjQvNCw0LXRgjpcbiAgICAgKiAgICAge0FycmF5fSDRgdC+0L7QsdGJ0LXQvdC40Y9cbiAgICAgKiAgICAge051bWJlcn0g0LrQvtC70LjRh9C10YHRgtCy0L4g0YHQvtC+0LHRidC10L3QuNC5INCyINC00LjQsNC70L7Qs9C1XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5GYWlsINC/0YDQuNC90LjQvNCw0LXRgjpcbiAgICAgKiAgICAge1N0cmluZ30g0YHRgtGA0L7QutCwINC+0YjQuNCx0LrQuFxuICAgICAqL1xuICAgIGdldERpYWxvZ1RocmVhZDogZnVuY3Rpb24gRGF0YWJhc2VNYW5hZ2VyX2dldERpYWxvZ1RocmVhZChkaWFsb2dJZCwgb3B0cywgZm5TdWNjZXNzLCBmbkZhaWwpIHtcbiAgICAgICAgdmFyIHVzZXJJZCA9IHRoaXMuX3VzZXJJZDtcbiAgICAgICAgdmFyIGNvbm4gPSB0aGlzLl9jb25uW3VzZXJJZF07XG5cbiAgICAgICAgb3B0cy5mcm9tID0gb3B0cy5mcm9tIHx8IDA7XG4gICAgICAgIG9wdHMuZXZlcnl0aGluZyA9IG9wdHMuZXZlcnl0aGluZyB8fCBmYWxzZTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRDb250YWN0QnlJZChpZCkge1xuICAgICAgICAgICAgaWQgPSBOdW1iZXIoaWQpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGNvbm4uZ2V0KFwiY29udGFjdHNcIiwge1xuICAgICAgICAgICAgICAgICAgICByYW5nZTogSURCS2V5UmFuZ2Uub25seShpZClcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFyZWNvcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpZDogcmVjb3Jkc1swXS5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGhvdG86IHJlY29yZHNbMF0udmFsdWUucGhvdG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RfbmFtZTogcmVjb3Jkc1swXS52YWx1ZS5maXJzdF9uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfbmFtZTogcmVjb3Jkc1swXS52YWx1ZS5sYXN0X25hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvdW50Q2hhdE1lc3NhZ2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25uLmNvdW50KFwibWVzc2FnZXNcIiwge1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogXCJjaGF0X21lc3NhZ2VzXCIsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5vbmx5KGRpYWxvZ0lkKVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0b3RhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Q2hhdE1lc3NhZ2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2V0T3B0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IFwiY2hhdF9tZXNzYWdlc1wiLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogSURCS2V5UmFuZ2Uub25seShkaWFsb2dJZCksXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogREVTQyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvcHRzLmZyb21cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFvcHRzLmV2ZXJ5dGhpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0T3B0cy5saW1pdCA9IDMwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbm4uZ2V0KFwibWVzc2FnZXNcIiwgZ2V0T3B0cywgZnVuY3Rpb24gKGVyciwgcmVjb3Jkcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgZ2V0Q2hhdE1lc3NhZ2VzKCksXG4gICAgICAgICAgICBjb3VudENoYXRNZXNzYWdlcygpXG4gICAgICAgIF0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2VzID0gcmVzWzBdLnJldmVyc2UoKTtcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IHJlc1sxXTtcbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IHt9O1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuXG4gICAgICAgICAgICAvLyBnZXQgY3VycmVudCB1c2VyIGluZm9cbiAgICAgICAgICAgIHByb21pc2VzW3VzZXJJZF0gPSBnZXRDb250YWN0QnlJZCh1c2VySWQpO1xuXG4gICAgICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1pZDogcmVjb3JkLnZhbHVlLm1pZCxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHJlY29yZC52YWx1ZS50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogcmVjb3JkLnZhbHVlLmJvZHksXG4gICAgICAgICAgICAgICAgICAgIGRhdGU6IHJlY29yZC52YWx1ZS5kYXRlLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IE51bWJlcihyZWNvcmQudmFsdWUucmVhZCksXG4gICAgICAgICAgICAgICAgICAgIHVpZDogcmVjb3JkLnZhbHVlLnVpZCxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogcmVjb3JkLnZhbHVlLnRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIGhhc19lbW9qaTogcmVjb3JkLnZhbHVlLmhhc19lbW9qaSxcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudHM6IHJlY29yZC52YWx1ZS5hdHRhY2htZW50c1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwcm9taXNlc1tyZWNvcmQudmFsdWUudWlkXSAmJiByZWNvcmQudmFsdWUudWlkICE9IHVzZXJJZCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlc1tyZWNvcmQudmFsdWUudWlkXSA9IGdldENvbnRhY3RCeUlkKHJlY29yZC52YWx1ZS51aWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBLaW5vUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50VXNlclBob3RvID0gcmVzW3VzZXJJZF0gPyByZXNbdXNlcklkXS5waG90byA6IG51bGw7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNbbWVzc2FnZS51aWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZpcnN0X25hbWUgPSByZXNbbWVzc2FnZS51aWRdLmZpcnN0X25hbWU7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGFzdF9uYW1lID0gcmVzW21lc3NhZ2UudWlkXS5sYXN0X25hbWU7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGhvdG8gPSAobWVzc2FnZS50YWdzLmluZGV4T2YoXCJzZW50XCIpID09PSAtMSkgPyByZXNbbWVzc2FnZS51aWRdLnBob3RvIDogY3VycmVudFVzZXJQaG90bztcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGZuU3VjY2VzcyhbXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgICAgICAgICAgdG90YWxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBmbkZhaWwoZXJyLm5hbWUgKyBcIjogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgZm5GYWlsKGVyci5uYW1lICsgXCI6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuU3VjY2VzcyDQv9GA0LjQvdC40LzQsNC10YIg0L/QsNGA0LDQvNC10YLRgCB7T2JqZWN0fVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuRmFpbCDQv9GA0LjQvdC40LzQsNC10YIg0L/QsNGA0LDQvNC10YLRgNGLIHtCb29sZWFufSBpc0RhdGFiYXNlRXJyb3Ig0Lgge1N0cmluZ30gZXJyb3JNZXNzYWdlXG4gICAgICovXG4gICAgZ2V0TWVzc2FnZUJ5SWQ6IGZ1bmN0aW9uIERhdGFiYXNlTWFuYWdlcl9nZXRNZXNzYWdlQnlJZChtaWQsIGZuU3VjY2VzcywgZm5GYWlsKSB7XG4gICAgICAgIHZhciB1c2VySWQgPSB0aGlzLl91c2VySWQ7XG4gICAgICAgIHZhciBjb25uID0gdGhpcy5fY29ublt1c2VySWRdO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldENvbnRhY3RQaG90byh1aWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgY29ubi5nZXQoXCJjb250YWN0c1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5vbmx5KHVpZClcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFyZWNvcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVjb3Jkc1swXS52YWx1ZS5waG90byk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29ubi5nZXQoXCJtZXNzYWdlc1wiLCB7XG4gICAgICAgICAgICByYW5nZTogSURCS2V5UmFuZ2Uub25seShtaWQpXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlY29yZHMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBmbkZhaWwodHJ1ZSwgZXJyLm5hbWUgKyBcIjogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXJlY29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm5GYWlsKGZhbHNlLCBcIk5vIG1lc3NhZ2Ugd2l0aCBJRCAjXCIgKyBtaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1zZyA9IHJlY29yZHNbMF0udmFsdWU7XG4gICAgICAgICAgICBnZXRDb250YWN0UGhvdG8obXNnLnVpZCkudGhlbihmdW5jdGlvbiAocGhvdG8pIHtcbiAgICAgICAgICAgICAgICBtc2cuYXZhdGFyID0gcGhvdG87XG4gICAgICAgICAgICAgICAgZm5TdWNjZXNzKG1zZyk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZm5GYWlsKHRydWUsIGVyci5uYW1lICsgXCI6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDQktC90LXRgdC10L3QuNC1INC4INC+0LHQvdC+0LLQu9C10L3QuNC1INC60L7QvdGC0LDQutGC0L7QslxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHVzZXJJZFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEg0LzQsNGB0YHQuNCyINC40Lcg0LzQsNGB0YHQuNCy0L7QsiDQstC40LTQsCBbdWlkLCBmaXJzdE5hbWUsIGxhc3ROYW1lLCBvdGhlckRhdGEsIG9sZE5hbWVzLCBub3Rlc11cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHJlcGxhY2VDb250YWN0czogZnVuY3Rpb24gRGF0YWJhc2VNYW5hZ2VyX3JlcGxhY2VDb250YWN0cyh1c2VySWQsIGRhdGEpIHtcbiAgICAgICAgdmFyIGNvbm4gPSB0aGlzLl9jb25uW3VzZXJJZF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBzZWFyY2hPcHRzID0ge307XG4gICAgICAgICAgICB2YXIgdWlkcyA9IGRhdGEubWFwKGZ1bmN0aW9uICh1c2VyRGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIodXNlckRhdGFbMF0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICh1aWRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBzZWFyY2hPcHRzLmluZGV4ID0gXCJtZXNzYWdlc19udW1cIjtcbiAgICAgICAgICAgICAgICBzZWFyY2hPcHRzLnJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZCgxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoT3B0cy5yYW5nZSA9IElEQktleVJhbmdlLm9ubHkodWlkc1swXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbm4uZ2V0KFwiY29udGFjdHNcIiwgc2VhcmNoT3B0cywgZnVuY3Rpb24gKGVyciwgcmVjb3Jkcykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDb250YWN0cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICByZWNvcmRzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVpZHMuaW5kZXhPZihyZWNvcmQudmFsdWUudWlkKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFjdHNbcmVjb3JkLnZhbHVlLnVpZF0gPSByZWNvcmQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cHNlcnRDb250YWN0cyA9IGRhdGEubWFwKGZ1bmN0aW9uICh1c2VyRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyRGF0YSA9IHVzZXJEYXRhWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVpZCA9IE51bWJlcih1c2VyRGF0YVswXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250YWN0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpZDogdWlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0X25hbWU6IHVzZXJEYXRhWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfbmFtZTogdXNlckRhdGFbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90ZXM6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbHRleHQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFbMV0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFbMl0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyRGF0YS5kb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWN0LmZ1bGx0ZXh0LnB1c2gob3RoZXJEYXRhLmRvbWFpbi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgW1wicGhvdG9cIiwgXCJiZGF0ZVwiLCBcImRvbWFpblwiLCBcImhvbWVfcGhvbmVcIiwgXCJtb2JpbGVfcGhvbmVcIl0uZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJEYXRhW2ZpZWxkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWN0W2ZpZWxkXSA9IG90aGVyRGF0YVtmaWVsZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckRhdGEuc2V4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdC5zZXggPSBOdW1iZXIob3RoZXJEYXRhLnNleCkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdC5sYXN0X21lc3NhZ2VfdHMgPSBjdXJyZW50Q29udGFjdHNbdWlkXSA/IGN1cnJlbnRDb250YWN0c1t1aWRdLmxhc3RfbWVzc2FnZV90cyA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWN0Lm1lc3NhZ2VzX251bSA9IGN1cnJlbnRDb250YWN0c1t1aWRdID8gY3VycmVudENvbnRhY3RzW3VpZF0ubWVzc2FnZXNfbnVtIDogMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhY3Q7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbm4udXBzZXJ0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhY3RzOiB1cHNlcnRDb250YWN0c1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodXBzZXJ0Q29udGFjdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqINCS0L3QtdGB0LXQvdC40LUg0YHQvtC+0LHRidC10L3QuNC5LlxuICAgICAqINCV0YHRgtGMINC40L3RgtC10YDQtdGB0L3QsNGPINC+0YHQvtCx0LXQvdC90L7RgdGC0YwgQVBJINCS0JrQvtC90YLQsNC60YLQtTog0LzQtdGC0L7QtCBtZXNzYWdlcy5nZXQg0L3QtSDQv9C+0LTQtNC10YDQttC40LLQsNC10YIg0YHQvtGA0YLQuNGA0L7QstC60YMg0Lgg0L7RgtC00LDQtdGCINGB0L/QtdGA0LLQsCDRgdCw0LzRi9C1INC90L7QstGL0LUg0YHQvtC+0LHRidC10L3QuNGPLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGN1cnJlbnRVc2VySWQgSUQg0LDQutC60LDRg9C90YLQsCwg0LTQu9GPINC60L7RgtC+0YDQvtCz0L4g0LfQsNC90L7RgdGP0YLRgdGPINGB0L7QvtCx0YnQtdC90LjRj1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1lc3NhZ2VzIC0g0YHQvtC+0LHRidC10L3QuNGPLdC+0LHRitC10LrRgtGLINGBINC60LvRjtGH0LDQvNC4IChtaWQsIHVpZCwgZGF0ZSwgdGl0bGUsIGJvZHksIHJlYWRfc3RhdGUsIGF0dGFjaG1lbnRzLCBjaGF0X2lkLCB0YWdzLCBlbW9qaSlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbkZhaWxcbiAgICAgKi9cbiAgICBpbnNlcnRNZXNzYWdlczogZnVuY3Rpb24gRGF0YWJhc2VNYW5hZ2VyX2luc2VydE1lc3NhZ2VzKGN1cnJlbnRVc2VySWQsIG1lc3NhZ2VzLCBmblN1Y2Nlc3MsIGZuRmFpbCkge1xuICAgICAgICB2YXIgY2hhdHMgPSB7fTtcbiAgICAgICAgdmFyIG1lc3NhZ2VzVG9JbnNlcnQgPSBbXTtcblxuICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgY2hhdElkID0gbWVzc2FnZS5jaGF0X2lkID8gU3RyaW5nKG1lc3NhZ2UuY2hhdF9pZCkgOiBcIjBfXCIgKyBtZXNzYWdlLnVpZDtcblxuICAgICAgICAgICAgLy8gY2hhdCBzaG91bGQgYmUgaW5zZXJ0ZWQgb25seSBvbmNlXG4gICAgICAgICAgICBpZiAoIWNoYXRzW2NoYXRJZF0pIHtcbiAgICAgICAgICAgICAgICBjaGF0c1tjaGF0SWRdID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogY2hhdElkLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogbWVzc2FnZS50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdF9tZXNzYWdlX3RzOiBtZXNzYWdlLmRhdGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbXNnRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBtaWQ6IE51bWJlcihtZXNzYWdlLm1pZCksXG4gICAgICAgICAgICAgICAgdWlkOiBOdW1iZXIobWVzc2FnZS51aWQpLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBtZXNzYWdlLnRpdGxlLFxuICAgICAgICAgICAgICAgIGJvZHk6IG1lc3NhZ2UuYm9keSxcbiAgICAgICAgICAgICAgICBkYXRlOiBtZXNzYWdlLmRhdGUsXG4gICAgICAgICAgICAgICAgcmVhZDogQm9vbGVhbihtZXNzYWdlLnJlYWRfc3RhdGUpLFxuICAgICAgICAgICAgICAgIGNoYXQ6IGNoYXRJZCxcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50czogQXJyYXkuaXNBcnJheShtZXNzYWdlLmF0dGFjaG1lbnRzKSA/IG1lc3NhZ2UuYXR0YWNobWVudHMgOiBbXSxcbiAgICAgICAgICAgICAgICB0YWdzOiBtZXNzYWdlLnRhZ3MsXG4gICAgICAgICAgICAgICAgaGFzX2Vtb2ppOiBCb29sZWFuKG1lc3NhZ2UuZW1vamkpLFxuICAgICAgICAgICAgICAgIGZ1bGx0ZXh0OiBnZXRNZXNzYWdlRnVsbHRleHQobWVzc2FnZS5ib2R5KVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW1wb3J0YW50KSB7XG4gICAgICAgICAgICAgICAgbXNnRGF0YS50YWdzLnB1c2goXCJpbXBvcnRhbnRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICBtc2dEYXRhLnRhZ3MucHVzaChcInRyYXNoXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZXNzYWdlc1RvSW5zZXJ0LnB1c2gobXNnRGF0YSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2Nvbm5bY3VycmVudFVzZXJJZF0udXBzZXJ0KHtcbiAgICAgICAgICAgIGNoYXRzOiBfLnZhbHVlcyhjaGF0cyksXG4gICAgICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNUb0luc2VydFxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZm5GYWlsKGVyci5uYW1lICsgXCI6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm5TdWNjZXNzKCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWFpbFR5cGUgLSBvbmUgb2YgXCJpbmJveFwiLCBcInNlbnRcIlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZ2V0TGF0ZXN0VGFnTWVzc2FnZUlkOiBmdW5jdGlvbiBEYXRhYmFzZU1hbmFnZXJfZ2V0TGF0ZXN0VGFnTWVzc2FnZUlkKG1haWxUeXBlKSB7XG4gICAgICAgIHZhciB1c2VySWQgPSB0aGlzLl91c2VySWQ7XG4gICAgICAgIHZhciBjb25uID0gdGhpcy5fY29ublt1c2VySWRdO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBjb25uLmdldChcIm1lc3NhZ2VzXCIsIHtcbiAgICAgICAgICAgICAgICBpbmRleDogXCJ0YWdcIixcbiAgICAgICAgICAgICAgICByYW5nZTogSURCS2V5UmFuZ2Uub25seShtYWlsVHlwZSksXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBERVNDLFxuICAgICAgICAgICAgICAgIGxpbWl0OiAxXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gcmVjb3Jkcy5sZW5ndGggPyByZWNvcmRzWzBdLnZhbHVlLm1pZCA6IDA7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFjdHVhbGl6ZSBjaGF0cycgZGF0ZXNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGFjdHVhbGl6ZUNoYXREYXRlczogZnVuY3Rpb24gRGF0YWJhc2VNYW5hZ2VyX2FjdHVhbGl6ZUNoYXREYXRlcyh1c2VySWQpIHtcbiAgICAgICAgdXNlcklkID0gdXNlcklkIHx8IHRoaXMuX3VzZXJJZDtcbiAgICAgICAgdmFyIGNvbm4gPSB0aGlzLl9jb25uW3VzZXJJZF07XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Q2hhdExhc3REYXRlKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGNvbm4uZ2V0KFwibWVzc2FnZXNcIiwge1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogXCJjaGF0X21lc3NhZ2VzXCIsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5vbmx5KGlkKSxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBERVNDLFxuICAgICAgICAgICAgICAgICAgICBsaW1pdDogMVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlY29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHJlY29yZHNbMF0udmFsdWUudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9tZXNzYWdlX3RzOiByZWNvcmRzWzBdLnZhbHVlLmRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5COiBjYW4ndCBzZWFyY2ggd2l0aCB7aW5kZXg6IFwiY2hhdF9tZXNzYWdlc1wiLCBkaXJlY3Rpb246IERFU0NfVU5JUVVFfSBoZXJlXG4gICAgICAgIC8vIGJlY2F1c2UgZmlyc3QgcmVjb3JkIGlzIG5vdCB0aGUgbGFzdCBzb3J0ZWQgYnkgbWlkIHVuZm9ydHVuYXRlbHkgOihcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIC8vIGdldCBhbGwgY2hhdHMgZ3JvdXBlZCBieSBpZFxuICAgICAgICAgICAgY29ubi5nZXQoXCJtZXNzYWdlc1wiLCB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IFwiY2hhdF9tZXNzYWdlc1wiLFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogREVTQ19VTklRVUVcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlY29yZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIubmFtZSArIFwiOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IHJlY29yZHMubWFwKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldENoYXRMYXN0RGF0ZShyZWNvcmQua2V5KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uICh1cHNlcnREYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm4udXBzZXJ0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXRzOiB1cHNlcnREYXRhXG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyLm5hbWUgKyBcIjogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVyci5uYW1lICsgXCI6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBhY3R1YWxpemVDb250YWN0czogZnVuY3Rpb24gRGF0YWJhc2VNYW5hZ2VyX2FjdHVhbGl6ZUNvbnRhY3RzKHVzZXJJZCkge1xuICAgICAgICB1c2VySWQgPSB1c2VySWQgfHwgdGhpcy5fdXNlcklkO1xuICAgICAgICB2YXIgY29ubiA9IHRoaXMuX2Nvbm5bdXNlcklkXTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRMYXN0VXNlck1lc3NhZ2UoY29udGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25uLmdldChcIm1lc3NhZ2VzXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IFwidXNlcl9tZXNzYWdlc1wiLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogSURCS2V5UmFuZ2Uub25seShjb250YWN0LnVpZCksXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogREVTQyxcbiAgICAgICAgICAgICAgICAgICAgbGltaXQ6IDFcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdC5sYXN0X21lc3NhZ2VfdHMgPSByZWNvcmRzLmxlbmd0aCA/IHJlY29yZHNbMF0udmFsdWUuZGF0ZSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY291bnRVc2VyTWVzc2FnZXMoY29udGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25uLmNvdW50KFwibWVzc2FnZXNcIiwge1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogXCJ1c2VyX21lc3NhZ2VzXCIsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5vbmx5KGNvbnRhY3QudWlkKSxcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCB0b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhY3QubWVzc2FnZXNfbnVtID0gdG90YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGNvbm4uZ2V0KFwiY29udGFjdHNcIiwgZnVuY3Rpb24gKGVyciwgcmVjb3Jkcykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVyci5uYW1lICsgXCI6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhY3RzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgICAgICByZWNvcmRzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IHJlY29yZC52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGdldExhc3RVc2VyTWVzc2FnZShjb250YWN0KSk7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goY291bnRVc2VyTWVzc2FnZXMoY29udGFjdCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3RzLnB1c2goY29udGFjdCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm4udXBzZXJ0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhY3RzOiBjb250YWN0c1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVyci5uYW1lICsgXCI6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIubmFtZSArIFwiOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBtc2dJZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuU3VjY2VzcyDQv9GA0LjQvdC40LzQsNC10YIge1ZvaWR9XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5GYWlsINC/0YDQuNC90LjQvNCw0LXRgiB7U3RyaW5nfSBlcnJvck1lc3NhZ2VcbiAgICAgKi9cbiAgICBtYXJrQXNSZWFkOiBmdW5jdGlvbiBEYXRhYmFzZU1hbmFnZXJfbWFya0FzUmVhZChtc2dJZCwgZm5TdWNjZXNzLCBmbkZhaWwpIHtcbiAgICAgICAgdmFyIHVzZXJJZCA9IHRoaXMuX3VzZXJJZDtcbiAgICAgICAgdmFyIGNvbm4gPSB0aGlzLl9jb25uW3VzZXJJZF07XG5cbiAgICAgICAgY29ubi5nZXQoXCJtZXNzYWdlc1wiLCB7XG4gICAgICAgICAgICByYW5nZTogSURCS2V5UmFuZ2Uub25seShOdW1iZXIobXNnSWQpKVxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZWNvcmRzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZm5GYWlsKGVyci5uYW1lICsgXCI6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFyZWNvcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZuU3VjY2VzcyAmJiBmblN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gcmVjb3Jkc1swXS52YWx1ZTtcbiAgICAgICAgICAgIG1lc3NhZ2UucmVhZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGNvbm4udXBzZXJ0KFwibWVzc2FnZXNcIiwgbWVzc2FnZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm5GYWlsKGVyci5uYW1lICsgXCI6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm5TdWNjZXNzICYmIGZuU3VjY2VzcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IG1zZ0lkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5TdWNjZXNzINC/0YDQuNC90LjQvNCw0LXRgiB7Vm9pZH1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbkZhaWwg0L/RgNC40L3QuNC80LDQtdGCIHtTdHJpbmd9IGVycm9yTWVzc2FnZVxuICAgICAqL1xuICAgIG1hcmtBc1VucmVhZDogZnVuY3Rpb24gRGF0YWJhc2VNYW5hZ2VyX21hcmtBc1VucmVhZChtc2dJZCwgZm5TdWNjZXNzLCBmbkZhaWwpIHtcbiAgICAgICAgdmFyIHVzZXJJZCA9IHRoaXMuX3VzZXJJZDtcbiAgICAgICAgdmFyIGNvbm4gPSB0aGlzLl9jb25uW3VzZXJJZF07XG5cbiAgICAgICAgY29ubi5nZXQoXCJtZXNzYWdlc1wiLCB7XG4gICAgICAgICAgICByYW5nZTogSURCS2V5UmFuZ2Uub25seShOdW1iZXIobXNnSWQpKVxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZWNvcmRzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZm5GYWlsKGVyci5uYW1lICsgXCI6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFyZWNvcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZuU3VjY2VzcyAmJiBmblN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gcmVjb3Jkc1swXS52YWx1ZTtcbiAgICAgICAgICAgIG1lc3NhZ2UucmVhZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBjb25uLnVwc2VydChcIm1lc3NhZ2VzXCIsIG1lc3NhZ2UsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuRmFpbChlcnIubmFtZSArIFwiOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZuU3VjY2VzcyAmJiBmblN1Y2Nlc3MoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog0JTQvtCx0LDQstC70LXQvdC40LUg0LzQtdGC0LrQuCDQuiDRgdC+0L7QsdGJ0LXQvdC40Y5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbXNnSWQgSUQg0YHQvtC+0LHRidC10L3QuNGPXG4gICAgICogQHBhcmFtIHtTdHJpbmd9INGC0Y3Qs1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuU3VjY2VzcyDQv9GA0LjQvdC40LzQsNC10YIge1ZvaWR9XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5GYWlsINC/0YDQuNC90LjQvNCw0LXRgiB7Qm9vbGVhbn0gaXNEYXRhYmFzZUVycm9yINC4IHtTdHJpbmd9IGVycm9yTWVzc2FnZVxuICAgICAqL1xuICAgIG1hcmtNZXNzYWdlV2l0aFRhZzogZnVuY3Rpb24gRGF0YWJhc2VNYW5hZ2VyX21hcmtNZXNzYWdlV2l0aFRhZyhtc2dJZCwgdGFnLCBmblN1Y2Nlc3MsIGZuRmFpbCkge1xuICAgICAgICB2YXIgdXNlcklkID0gdGhpcy5fdXNlcklkO1xuICAgICAgICB2YXIgY29ubiA9IHRoaXMuX2Nvbm5bdXNlcklkXTtcblxuICAgICAgICBjb25uLmdldChcIm1lc3NhZ2VzXCIsIHtcbiAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5vbmx5KE51bWJlcihtc2dJZCkpXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlY29yZHMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBmbkZhaWwodHJ1ZSwgZXJyLm5hbWUgKyBcIjogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXJlY29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm5GYWlsKGZhbHNlLCBcIk5vIHJvd3Mgd2VyZSBhZmZlY3RlZCB3aGVuIHVwZGF0aW5nIHRhZ3MgY29sdW1uIChtaWQ6IFwiICsgbXNnSWQgKyBcIiwgdGFnOiBcIiArIHRhZyArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gcmVjb3Jkc1swXS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGZuRmFpbChmYWxzZSwgXCJObyByb3dzIHdlcmUgYWZmZWN0ZWQgd2hlbiB1cGRhdGluZyB0YWdzIGNvbHVtbiAobWlkOiBcIiArIG1zZ0lkICsgXCIsIHRhZzogXCIgKyB0YWcgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZXNzYWdlLnRhZ3MucHVzaCh0YWcpO1xuICAgICAgICAgICAgY29ubi51cHNlcnQoXCJtZXNzYWdlc1wiLCBtZXNzYWdlLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBmbkZhaWwodHJ1ZSwgZXJyLm5hbWUgKyBcIjogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmblN1Y2Nlc3MoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog0KPQtNCw0LvQtdC90LjQtSDQvNC10YLQutC4INGBINGB0L7QvtCx0YnQtdC90LjRj1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtc2dJZCBJRCDRgdC+0L7QsdGJ0LXQvdC40Y9cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30g0YLRjdCzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5TdWNjZXNzINC/0YDQuNC90LjQvNCw0LXRgiB7Vm9pZH1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbkZhaWwg0L/RgNC40L3QuNC80LDQtdGCIHtCb29sZWFufSBpc0RhdGFiYXNlRXJyb3Ig0Lgge1N0cmluZ30gZXJyb3JNZXNzYWdlXG4gICAgICovXG4gICAgdW5tYXJrTWVzc2FnZVdpdGhUYWc6IGZ1bmN0aW9uIERhdGFiYXNlTWFuYWdlcl91bm1hcmtNZXNzYWdlV2l0aFRhZyhtc2dJZCwgdGFnLCBmblN1Y2Nlc3MsIGZuRmFpbCkge1xuICAgICAgICB2YXIgdXNlcklkID0gdGhpcy5fdXNlcklkO1xuICAgICAgICB2YXIgY29ubiA9IHRoaXMuX2Nvbm5bdXNlcklkXTtcblxuICAgICAgICBjb25uLmdldChcIm1lc3NhZ2VzXCIsIHtcbiAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5vbmx5KE51bWJlcihtc2dJZCkpXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlY29yZHMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBmbkZhaWwodHJ1ZSwgZXJyLm5hbWUgKyBcIjogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXJlY29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm5GYWlsKGZhbHNlLCBcIk5vIHJvd3Mgd2VyZSBhZmZlY3RlZCB3aGVuIHVwZGF0aW5nIHRhZ3MgY29sdW1uIChtaWQ6IFwiICsgbXNnSWQgKyBcIiwgdGFnOiBcIiArIHRhZyArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gcmVjb3Jkc1swXS52YWx1ZTtcbiAgICAgICAgICAgIHZhciB0YWdJbmRleCA9IG1lc3NhZ2UudGFncy5pbmRleE9mKHRhZyk7XG5cbiAgICAgICAgICAgIGlmICh0YWdJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBmbkZhaWwoZmFsc2UsIFwiTm8gcm93cyB3ZXJlIGFmZmVjdGVkIHdoZW4gdXBkYXRpbmcgdGFncyBjb2x1bW4gKG1pZDogXCIgKyBtc2dJZCArIFwiLCB0YWc6IFwiICsgdGFnICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWVzc2FnZS50YWdzLnNwbGljZSh0YWdJbmRleCwgMSk7XG4gICAgICAgICAgICBjb25uLnVwc2VydChcIm1lc3NhZ2VzXCIsIG1lc3NhZ2UsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuRmFpbCh0cnVlLCBlcnIubmFtZSArIFwiOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZuU3VjY2VzcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDQn9C+0LvQvdC+0LUg0YPQtNCw0LvQtdC90LjQtSDRgdC+0L7QsdGJ0LXQvdC40Y8g0LjQtyDQkdCUXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBtc2dJZCBJRCDRgdC+0L7QsdGJ0LXQvdC40Y9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqL1xuICAgIGRlbGV0ZU1lc3NhZ2U6IGZ1bmN0aW9uIERhdGFiYXNlTWFuYWdlcl9kZWxldGVNZXNzYWdlKG1zZ0lkLCBmbikge1xuICAgICAgICB2YXIgdXNlcklkID0gdGhpcy5fdXNlcklkO1xuXG4gICAgICAgIC8vINC/0YDQvtCx0LvQtdC80LAg0LfQtNC10YHRjCAtINGA0LDRgdGB0LjQvdGF0YDQvtC90LjQt9Cw0YbQuNGPIG1lc3NhZ2VzINC4IGNoYXRzLmxhc3RfbWVzc2FnZV90c1xuICAgICAgICB0aGlzLl9jb25uW3VzZXJJZF0uZGVsZXRlKFwibWVzc2FnZXNcIiwgTnVtYmVyKG1zZ0lkKSwgZm4pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDQn9C+0LvRg9GH0LXQvdC40LUg0YfQsNGB0YLQvtGC0Ysg0LjRgdC/0L7Qu9GM0LfQvtCy0LDQvdC40Y8g0YLRjdCz0L7QslxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuU3VjY2VzcyDQv9GA0LjQvdC40LzQsNC10YIge09iamVjdH0g0L7QsdGK0LXQutGCIGZyZXFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbkZhaWwg0L/RgNC40L3QuNC80LDQtdGCIHtTdHJpbmd9IGVycm9yTWVzc2FnZVxuICAgICAqL1xuICAgIGdldFRhZ3NDb3VudDogZnVuY3Rpb24gRGF0YWJhc2VNYW5hZ2VyX2dldFRhZ3NDb3VudChmblN1Y2Nlc3MsIGZuRmFpbCkge1xuICAgICAgICB2YXIgdXNlcklkID0gdGhpcy5fdXNlcklkO1xuICAgICAgICB2YXIgY29ubiA9IHRoaXMuX2Nvbm5bdXNlcklkXTtcblxuICAgICAgICBmdW5jdGlvbiBjb3VudFRhZ09jY3VycmVuY2VzKHRhZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25uLmNvdW50KFwibWVzc2FnZXNcIiwge1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogXCJ0YWdcIixcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IElEQktleVJhbmdlLm9ubHkodGFnKVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0b3RhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29ubi5nZXQoXCJtZXNzYWdlc1wiLCB7XG4gICAgICAgICAgICBpbmRleDogXCJ0YWdcIixcbiAgICAgICAgICAgIGRpcmVjdGlvbjogQVNDX1VOSVFVRVxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZWNvcmRzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZm5GYWlsKGVyci5uYW1lICsgXCI6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByb21pc2VzID0ge307XG4gICAgICAgICAgICByZWNvcmRzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzW3JlY29yZC5rZXldID0gY291bnRUYWdPY2N1cnJlbmNlcyhyZWNvcmQua2V5KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBLaW5vUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZm5TdWNjZXNzLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZm5GYWlsKGVyci5uYW1lICsgXCI6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDQn9C+0LvRg9GH0LXQvdC40LUg0LLRgdC10YUg0YHQvtC+0LHRidC10L3QuNC5INGBINCy0LvQvtC20LXQvdC40Y/QvNC4LCDQv9C+0LvRg9GH0LXQvdC90YvRhSDRgSDQvtGI0LjQsdC60LDQvNC4INCyINCy0LXRgNGB0LjQuCA0LjExXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBnZXRNZXNzYWdlc1dpdGhGYWxzeUF0dGFjaG1lbnRzOiBmdW5jdGlvbiBEYXRhYmFzZU1hbmFnZXJfZ2V0TWVzc2FnZXNXaXRoRmFsc3lBdHRhY2htZW50cygpIHtcbiAgICAgICAgdmFyIHVzZXJJZCA9IHRoaXMuX3VzZXJJZDtcbiAgICAgICAgdmFyIGNvbm4gPSB0aGlzLl9jb25uW3VzZXJJZF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGNvbm4uZ2V0KFwibWVzc2FnZXNcIiwge1xuICAgICAgICAgICAgICAgIGluZGV4OiBcInRhZ1wiLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5vbmx5KFwiYXR0YWNobWVudHNcIilcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlY29yZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIubmFtZSArIFwiOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQudmFsdWUuYXR0YWNobWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChyZWNvcmQudmFsdWUubWlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog0J/QvtC70YPRh9C10L3QuNC1INGB0L7QvtCx0YnQtdC90LjQuSDQvtC/0YDQtdC00LXQu9C10L3QvdC+0LPQviDRgtC40L/QsFxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRhZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEZyb21cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblN1Y2Nlc3Mg0L/RgNC40L3QuNC80LDQtdGCIHtBcnJheX0gW3tBcnJheX0g0YHQvtC+0LHRidC10L3QuNGPLCB7SW50ZWdlcn0gdG90YWxdXG4gICAgICogQG9hcmFtIHtGdW5jdGlvbn0gZm5GYWlsINC/0YDQuNC90LjQvNCw0LXRgiB7U3RyaW5nfSBlcnJvck1lc3NhZ2VcbiAgICAgKi9cbiAgICBnZXRNZXNzYWdlc0J5VHlwZTogZnVuY3Rpb24gRGF0YWJhc2VNYW5hZ2VyX2dldE1lc3NhZ2VzQnlUeXBlKHRhZywgc3RhcnRGcm9tLCBmblN1Y2Nlc3MsIGZuRmFpbCkge1xuICAgICAgICB2YXIgdXNlcklkID0gdGhpcy5fdXNlcklkO1xuICAgICAgICB2YXIgY29ubiA9IHRoaXMuX2Nvbm5bdXNlcklkXTtcblxuICAgICAgICBmdW5jdGlvbiBjb3VudFRhZ01lc3NhZ2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25uLmNvdW50KFwibWVzc2FnZXNcIiwge1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogXCJ0YWdcIixcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IElEQktleVJhbmdlLm9ubHkodGFnKVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0b3RhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Q29udGFjdERhdGEobWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25uLmdldChcImNvbnRhY3RzXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IElEQktleVJhbmdlLm9ubHkobWVzc2FnZS51aWQpXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVjb3Jkcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBXVEZcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmlyc3RfbmFtZSA9IHJlY29yZHMubGVuZ3RoID8gcmVjb3Jkc1swXS52YWx1ZS5maXJzdF9uYW1lIDogXCJOb3RcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGFzdF9uYW1lID0gcmVjb3Jkcy5sZW5ndGggPyByZWNvcmRzWzBdLnZhbHVlLmxhc3RfbmFtZSA6IFwiRm91bmRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXZhdGFyID0gcmVjb3Jkcy5sZW5ndGggPyByZWNvcmRzWzBdLnZhbHVlLnBob3RvIDogbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFRhZ01lc3NhZ2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25uLmdldChcIm1lc3NhZ2VzXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IFwidGFnXCIsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5vbmx5KHRhZyksXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogREVTQyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBzdGFydEZyb20sXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0OiAyMFxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlY29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHJlY29yZC52YWx1ZS5jaGF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogcmVjb3JkLnZhbHVlLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiByZWNvcmQudmFsdWUuYm9keSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZTogcmVjb3JkLnZhbHVlLmRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpZDogcmVjb3JkLnZhbHVlLnVpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlkOiByZWNvcmQudmFsdWUubWlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdzOiByZWNvcmQudmFsdWUudGFncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBOdW1iZXIocmVjb3JkLnZhbHVlLnJlYWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZ2V0Q29udGFjdERhdGEobWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGdldFRhZ01lc3NhZ2VzKCksXG4gICAgICAgICAgICBjb3VudFRhZ01lc3NhZ2VzKClcbiAgICAgICAgXSkudGhlbihmblN1Y2Nlc3MsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGZuRmFpbChlcnIubmFtZSArIFwiOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqINCf0L7QuNGB0Log0LrQvtC90YLQsNC60YLQvtCyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEZyb21cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblN1Y2Nlc3Mg0L/RgNC40L3QuNC80LDQtdGCOlxuICAgICAqICAgICB7QXJyYXl9INC80LDRgdGB0LjQsiDQvtCx0YrQtdC60YLQvtCyLdC60L7QvdGC0LDQutGC0L7QslxuICAgICAqICAgICB7TnVtYmVyfSDQvtCx0YnQtdC1INC60L7Qu9C40YfQtdGB0YLQstC+INC90LDQudC00LXQvdC90YvRhSDQutC+0L3RgtCw0LrRgtC+0LJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbkZhaWwg0L/RgNC40L3QuNC80LDQtdGCOlxuICAgICAqICAgICB7U3RyaW5nfSBlcnJvck1lc3NhZ2VcbiAgICAgKi9cbiAgICBzZWFyY2hDb250YWN0OiBmdW5jdGlvbiBEYXRhYmFzZU1hbmFnZXJfc2VhcmNoQ29udGFjdChxLCBzdGFydEZyb20sIGZuU3VjY2VzcywgZm5GYWlsKSB7XG4gICAgICAgIHEgPSBxLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgdmFyIHVzZXJJZCA9IHRoaXMuX3VzZXJJZDtcbiAgICAgICAgdmFyIGNvbm4gPSB0aGlzLl9jb25uW3VzZXJJZF07XG4gICAgICAgIHZhciB0byA9IHEuc3Vic3RyKDAsIHEubGVuZ3RoIC0gMSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKHEuY2hhckNvZGVBdChxLmxlbmd0aCAtIDEpICsgMSk7XG4gICAgICAgIHZhciByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKHEsIHRvLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgICAgICAgZnVuY3Rpb24gY291bnRDb250YWN0cygpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgY29ubi5jb3VudChcImNvbnRhY3RzXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IFwiZnVsbHRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgdG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodG90YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNlYXJjaENvbnRhY3RzKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25uLmdldChcImNvbnRhY3RzXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IFwiZnVsbHRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHN0YXJ0RnJvbSxcbiAgICAgICAgICAgICAgICAgICAgbGltaTogMjBcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlY29yZHMubWFwKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHNlYXJjaENvbnRhY3RzKCksXG4gICAgICAgICAgICBjb3VudENvbnRhY3RzKClcbiAgICAgICAgXSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICBmblN1Y2Nlc3MuYXBwbHkobnVsbCwgcmVzKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgZm5GYWlsKGVyci5uYW1lICsgXCI6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog0J/QvtC40YHQuiDQv9C40YHQtdC8XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBxXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0RnJvbVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuU3VjY2VzcyDQv9GA0LjQvdC40LzQsNC10YI6XG4gICAgICogICAgIHtBcnJheX0g0LzQsNGB0YHQuNCyINGB0L7QvtCx0YnQtdC90LjQuVxuICAgICAqICAgICB7TnVtYmVyfSDQvtCx0YnQtdC1INC60L7Qu9C40YfQtdGB0YLQstC+INC90LDQudC00LXQvdC90YvRhSDRgdC+0L7QsdGJ0LXQvdC40LlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbkZhaWwg0L/RgNC40L3QuNC80LDQtdGCOlxuICAgICAqICAgICB7U3RyaW5nfSDRgtC10LrRgdGCINC+0YjQuNCx0LrQuFxuICAgICAqL1xuICAgIHNlYXJjaE1haWw6IGZ1bmN0aW9uIERhdGFiYXNlTWFuYWdlcl9zZWFyY2hNYWlsKHBhcmFtcywgcSwgc3RhcnRGcm9tLCBmblN1Y2Nlc3MsIGZuRmFpbCkge1xuICAgICAgICBxID0gcS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIHZhciB1c2VySWQgPSB0aGlzLl91c2VySWQ7XG4gICAgICAgIHZhciBjb25uID0gdGhpcy5fY29ublt1c2VySWRdO1xuICAgICAgICB2YXIgdG8gPSBxLnN1YnN0cigwLCBxLmxlbmd0aCAtIDEpICsgU3RyaW5nLmZyb21DaGFyQ29kZShxLmNoYXJDb2RlQXQocS5sZW5ndGggLSAxKSArIDEpO1xuICAgICAgICB2YXIgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChxLCB0bywgZmFsc2UsIHRydWUpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvdW50TWVzc2FnZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGNvbm4uY291bnQoXCJtZXNzYWdlc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBcImZ1bGx0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiByYW5nZVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0b3RhbClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRNZXNzYWdlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgY29ubi5nZXQoXCJtZXNzYWdlc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBcImZ1bGx0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBzdGFydEZyb20sXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0OiAyMCxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBERVNDXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVjb3Jkcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Q29udGFjdEJ5SWQocmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGNvbm4uZ2V0KFwiY29udGFjdHNcIiwge1xuICAgICAgICAgICAgICAgICAgICByYW5nZTogSURCS2V5UmFuZ2Uub25seShyZWNvcmQudWlkKVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlY29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXJlY29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQuZmlyc3RfbmFtZSA9IHJlY29yZHNbMF0udmFsdWUuZmlyc3RfbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZC5sYXN0X25hbWUgPSByZWNvcmRzWzBdLnZhbHVlLmxhc3RfbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZC5hdmF0YXIgPSByZWNvcmRzWzBdLnZhbHVlLnBob3RvO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIEZJWE1FOiB3YXMgZHJvcHBlZCBpbiA0LjExXG4gICAgICAgICAgICBwYXJhbXMuaWQgLT4gV0hFUkUgZGlhbG9nSWQgPSA/XG4gICAgICAgICAgICBwYXJhbXMudGFnIC0+IFdIRVJFIHRhZyAmXG4gICAgICAgICAqL1xuICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBjb3VudE1lc3NhZ2VzKCksXG4gICAgICAgICAgICBnZXRNZXNzYWdlcygpXG4gICAgICAgIF0pLnRoZW4oKFt0b3RhbCwgbWVzc2FnZXNdKSA9PiB7XG4gICAgICAgICAgICB2YXIgdG90YWwgPSByZXMudG90YWw7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXTtcblxuICAgICAgICAgICAgcmVzLm1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogcmVjb3JkLnZhbHVlLmNoYXQsXG4gICAgICAgICAgICAgICAgICAgIG1pZDogcmVjb3JkLnZhbHVlLm1pZCxcbiAgICAgICAgICAgICAgICAgICAgdWlkOiByZWNvcmQudmFsdWUudWlkLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogcmVjb3JkLnZhbHVlLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiByZWNvcmQudmFsdWUuYm9keSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBOdW1iZXIocmVjb3JkLnZhbHVlLnJlYWQpLFxuICAgICAgICAgICAgICAgICAgICBkYXRlOiByZWNvcmQudmFsdWUuZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogcmVjb3JkLnZhbHVlLnRhZ3NcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudWlkICE9IHVzZXJJZCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGdldENvbnRhY3RCeUlkKG1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm5TdWNjZXNzKG91dHB1dCwgdG90YWwpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGZuRmFpbChlcnIubmFtZSArIFwiOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBmbkZhaWwoZXJyLm5hbWUgKyBcIjogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDQl9Cw0L/QuNGB0Ywg0LTQsNC90L3Ri9GFINCyINC+0LHRidC40Lkg0LvQvtCzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsZXZlbFxuICAgICAqL1xuICAgIGxvZzogZnVuY3Rpb24gRGF0YWJhc2VNYW5hZ2VyX2xvZyhkYXRhLCBsZXZlbCkge1xuICAgICAgICB0aGlzLl9tZXRhLmluc2VydChcImxvZ1wiLCB7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgdHM6IERhdGUubm93KCksXG4gICAgICAgICAgICBsZXZlbDogbGV2ZWxcbiAgICAgICAgfSwgXy5ub29wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog0JLRi9Cx0L7RgNC60LAg0LLRgdC10YUg0LfQsNC/0LjRgdC10Lkg0LjQtyDQu9C+0LPQsFxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5TdWNjZXNzINC/0YDQuNC90LjQvNCw0LXRgiB7QXJyYXl9INC80LDRgdGB0LjQsiDQt9Cw0L/QuNGB0LXQuSDQuNC3INC70L7Qs9CwLCDQs9C+0YLQvtCy0YvRhSDQuiDQvtGC0L/RgNCw0LLQutC1LCDQvtGC0YHQvtGA0YLQuNGA0L7QstCw0L3QvdGL0YUg0L/QviDQtNCw0YLQtVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuRmFpbCDRgtC10LrRgdGCINC+0YjQuNCx0LrQuFxuICAgICAqL1xuICAgIGNvbGxlY3RMb2dEYXRhOiBmdW5jdGlvbiBEYXRhYmFzZU1hbmFnZXJfY29sbGVjdExvZ0RhdGEoZm5TdWNjZXNzLCBmbkZhaWwpIHtcbiAgICAgICAgdGhpcy5fbWV0YS5nZXQoXCJsb2dcIiwgZnVuY3Rpb24gKGVyciwgcmVjb3Jkcykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGZuRmFpbChlcnIubmFtZSArIFwiOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0aW1lTGFzdCA9IDA7XG4gICAgICAgICAgICB2YXIgbG9nUmVjb3JkcyA9IHJlY29yZHMubWFwKGZ1bmN0aW9uIChyZWNvcmQsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHJlY29yZC52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKGl0ZW0udHMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRpbWVEaWZmID0gaXRlbS50cyAtIHRpbWVMYXN0O1xuICAgICAgICAgICAgICAgIHRpbWVMYXN0ID0gaXRlbS50cztcblxuICAgICAgICAgICAgICAgIHJldHVybiAoaSA+IDApXG4gICAgICAgICAgICAgICAgICAgID8gXCJbXCIgKyBkYXRlICsgXCIgK1wiICsgdGltZURpZmYgKyBcIm1zXSBcIiArIGl0ZW0uZGF0YVxuICAgICAgICAgICAgICAgICAgICA6IFwiW1wiICsgZGF0ZSArIFwiXSBcIiArIGl0ZW0uZGF0YTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmblN1Y2Nlc3MobG9nUmVjb3Jkcyk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZGJMaW5rOiBudWxsLFxuICAgIF91c2VySWQ6IG51bGwsXG5cbiAgICBfY29ubjoge30sXG4gICAgX21ldGE6IG51bGxcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmNfZWxlY3Ryb24vdWkvanMvZGIuanMiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBsb2Rhc2ggPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuOyhmdW5jdGlvbigpIHtcblxuICAvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUtRVM1IGVudmlyb25tZW50cy4gKi9cbiAgdmFyIHVuZGVmaW5lZDtcblxuICAvKiogVXNlZCBhcyB0aGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuICovXG4gIHZhciBWRVJTSU9OID0gJzQuMTUuMCc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG4gIHZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG4gIHZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbiAgLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xuICB2YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIGludGVybmFsIGFyZ3VtZW50IHBsYWNlaG9sZGVyLiAqL1xuICB2YXIgUExBQ0VIT0xERVIgPSAnX19sb2Rhc2hfcGxhY2Vob2xkZXJfXyc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG4gIHZhciBCSU5EX0ZMQUcgPSAxLFxuICAgICAgQklORF9LRVlfRkxBRyA9IDIsXG4gICAgICBDVVJSWV9CT1VORF9GTEFHID0gNCxcbiAgICAgIENVUlJZX0ZMQUcgPSA4LFxuICAgICAgQ1VSUllfUklHSFRfRkxBRyA9IDE2LFxuICAgICAgUEFSVElBTF9GTEFHID0gMzIsXG4gICAgICBQQVJUSUFMX1JJR0hUX0ZMQUcgPSA2NCxcbiAgICAgIEFSWV9GTEFHID0gMTI4LFxuICAgICAgUkVBUkdfRkxBRyA9IDI1NixcbiAgICAgIEZMSVBfRkxBRyA9IDUxMjtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjb21wYXJpc29uIHN0eWxlcy4gKi9cbiAgdmFyIFVOT1JERVJFRF9DT01QQVJFX0ZMQUcgPSAxLFxuICAgICAgUEFSVElBTF9DT01QQVJFX0ZMQUcgPSAyO1xuXG4gIC8qKiBVc2VkIGFzIGRlZmF1bHQgb3B0aW9ucyBmb3IgYF8udHJ1bmNhdGVgLiAqL1xuICB2YXIgREVGQVVMVF9UUlVOQ19MRU5HVEggPSAzMCxcbiAgICAgIERFRkFVTFRfVFJVTkNfT01JU1NJT04gPSAnLi4uJztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG4gIHZhciBIT1RfQ09VTlQgPSAxNTAsXG4gICAgICBIT1RfU1BBTiA9IDE2O1xuXG4gIC8qKiBVc2VkIHRvIGluZGljYXRlIHRoZSB0eXBlIG9mIGxhenkgaXRlcmF0ZWVzLiAqL1xuICB2YXIgTEFaWV9GSUxURVJfRkxBRyA9IDEsXG4gICAgICBMQVpZX01BUF9GTEFHID0gMixcbiAgICAgIExBWllfV0hJTEVfRkxBRyA9IDM7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG4gIHZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsXG4gICAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4LFxuICAgICAgTkFOID0gMCAvIDA7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdGhlIG1heGltdW0gbGVuZ3RoIGFuZCBpbmRleCBvZiBhbiBhcnJheS4gKi9cbiAgdmFyIE1BWF9BUlJBWV9MRU5HVEggPSA0Mjk0OTY3Mjk1LFxuICAgICAgTUFYX0FSUkFZX0lOREVYID0gTUFYX0FSUkFZX0xFTkdUSCAtIDEsXG4gICAgICBIQUxGX01BWF9BUlJBWV9MRU5HVEggPSBNQVhfQVJSQVlfTEVOR1RIID4+PiAxO1xuXG4gIC8qKiBVc2VkIHRvIGFzc29jaWF0ZSB3cmFwIG1ldGhvZHMgd2l0aCB0aGVpciBiaXQgZmxhZ3MuICovXG4gIHZhciB3cmFwRmxhZ3MgPSBbXG4gICAgWydhcnknLCBBUllfRkxBR10sXG4gICAgWydiaW5kJywgQklORF9GTEFHXSxcbiAgICBbJ2JpbmRLZXknLCBCSU5EX0tFWV9GTEFHXSxcbiAgICBbJ2N1cnJ5JywgQ1VSUllfRkxBR10sXG4gICAgWydjdXJyeVJpZ2h0JywgQ1VSUllfUklHSFRfRkxBR10sXG4gICAgWydmbGlwJywgRkxJUF9GTEFHXSxcbiAgICBbJ3BhcnRpYWwnLCBQQVJUSUFMX0ZMQUddLFxuICAgIFsncGFydGlhbFJpZ2h0JywgUEFSVElBTF9SSUdIVF9GTEFHXSxcbiAgICBbJ3JlYXJnJywgUkVBUkdfRkxBR11cbiAgXTtcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gIHZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXScsXG4gICAgICB3ZWFrU2V0VGFnID0gJ1tvYmplY3QgV2Vha1NldF0nO1xuXG4gIHZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi9cbiAgdmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG4gIHZhciByZUVzY2FwZWRIdG1sID0gLyYoPzphbXB8bHR8Z3R8cXVvdHwjMzl8Izk2KTsvZyxcbiAgICAgIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInYF0vZyxcbiAgICAgIHJlSGFzRXNjYXBlZEh0bWwgPSBSZWdFeHAocmVFc2NhcGVkSHRtbC5zb3VyY2UpLFxuICAgICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZUVzY2FwZSA9IC88JS0oW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICAgIHJlTGVhZGluZ0RvdCA9IC9eXFwuLyxcbiAgICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAgICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gICAqL1xuICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nLFxuICAgICAgcmVIYXNSZWdFeHBDaGFyID0gUmVnRXhwKHJlUmVnRXhwQ2hhci5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG4gIHZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZyxcbiAgICAgIHJlVHJpbVN0YXJ0ID0gL15cXHMrLyxcbiAgICAgIHJlVHJpbUVuZCA9IC9cXHMrJC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggd3JhcCBkZXRhaWwgY29tbWVudHMuICovXG4gIHZhciByZVdyYXBDb21tZW50ID0gL1xceyg/OlxcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggLitcXF0gXFwqXFwvKT9cXG4/LyxcbiAgICAgIHJlV3JhcERldGFpbHMgPSAvXFx7XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAoLispXFxdIFxcKi8sXG4gICAgICByZVNwbGl0RGV0YWlscyA9IC8sPyAmIC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgY29tcG9zZWQgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuICovXG4gIHZhciByZUFzY2lpV29yZCA9IC9bXlxceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceDdmXSsvZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoXG4gICAqIFtFUyB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50cykuXG4gICAqL1xuICB2YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUhhc0hleFByZWZpeCA9IC9eMHgvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xuICB2YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xuICB2YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIExhdGluIFVuaWNvZGUgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xuICB2YXIgcmVMYXRpbiA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxceGZmXFx1MDEwMC1cXHUwMTdmXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG4gIHZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZlxcXFx1ZmUyMC1cXFxcdWZlMjMnLFxuICAgICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGYwJyxcbiAgICAgIHJzRGluZ2JhdFJhbmdlID0gJ1xcXFx1MjcwMC1cXFxcdTI3YmYnLFxuICAgICAgcnNMb3dlclJhbmdlID0gJ2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZicsXG4gICAgICByc01hdGhPcFJhbmdlID0gJ1xcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjcnLFxuICAgICAgcnNOb25DaGFyUmFuZ2UgPSAnXFxcXHgwMC1cXFxceDJmXFxcXHgzYS1cXFxceDQwXFxcXHg1Yi1cXFxceDYwXFxcXHg3Yi1cXFxceGJmJyxcbiAgICAgIHJzUHVuY3R1YXRpb25SYW5nZSA9ICdcXFxcdTIwMDAtXFxcXHUyMDZmJyxcbiAgICAgIHJzU3BhY2VSYW5nZSA9ICcgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMCcsXG4gICAgICByc1VwcGVyUmFuZ2UgPSAnQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlJyxcbiAgICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJyxcbiAgICAgIHJzQnJlYWtSYW5nZSA9IHJzTWF0aE9wUmFuZ2UgKyByc05vbkNoYXJSYW5nZSArIHJzUHVuY3R1YXRpb25SYW5nZSArIHJzU3BhY2VSYW5nZTtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG4gIHZhciByc0Fwb3MgPSBcIlsnXFx1MjAxOV1cIixcbiAgICAgIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICAgIHJzQnJlYWsgPSAnWycgKyByc0JyZWFrUmFuZ2UgKyAnXScsXG4gICAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib01hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlICsgJ10nLFxuICAgICAgcnNEaWdpdHMgPSAnXFxcXGQrJyxcbiAgICAgIHJzRGluZ2JhdCA9ICdbJyArIHJzRGluZ2JhdFJhbmdlICsgJ10nLFxuICAgICAgcnNMb3dlciA9ICdbJyArIHJzTG93ZXJSYW5nZSArICddJyxcbiAgICAgIHJzTWlzYyA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgcnNCcmVha1JhbmdlICsgcnNEaWdpdHMgKyByc0RpbmdiYXRSYW5nZSArIHJzTG93ZXJSYW5nZSArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgICAgcnNVcHBlciA9ICdbJyArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG4gIHZhciByc0xvd2VyTWlzYyA9ICcoPzonICsgcnNMb3dlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICAgIHJzVXBwZXJNaXNjID0gJyg/OicgKyByc1VwcGVyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgICAgcnNPcHRMb3dlckNvbnRyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86ZHxsbHxtfHJlfHN8dHx2ZSkpPycsXG4gICAgICByc09wdFVwcGVyQ29udHIgPSAnKD86JyArIHJzQXBvcyArICcoPzpEfExMfE18UkV8U3xUfFZFKSk/JyxcbiAgICAgIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgICAgcnNFbW9qaSA9ICcoPzonICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNTZXEsXG4gICAgICByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBhcG9zdHJvcGhlcy4gKi9cbiAgdmFyIHJlQXBvcyA9IFJlZ0V4cChyc0Fwb3MsICdnJyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKSBhbmRcbiAgICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrcyBmb3Igc3ltYm9sc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX2Zvcl9TeW1ib2xzKS5cbiAgICovXG4gIHZhciByZUNvbWJvTWFyayA9IFJlZ0V4cChyc0NvbWJvLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG4gIHZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBjb21wbGV4IG9yIGNvbXBvdW5kIHdvcmRzLiAqL1xuICB2YXIgcmVVbmljb2RlV29yZCA9IFJlZ0V4cChbXG4gICAgcnNVcHBlciArICc/JyArIHJzTG93ZXIgKyAnKycgKyByc09wdExvd2VyQ29udHIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgICByc1VwcGVyTWlzYyArICcrJyArIHJzT3B0VXBwZXJDb250ciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIgKyByc0xvd2VyTWlzYywgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gICAgcnNVcHBlciArICc/JyArIHJzTG93ZXJNaXNjICsgJysnICsgcnNPcHRMb3dlckNvbnRyLFxuICAgIHJzVXBwZXIgKyAnKycgKyByc09wdFVwcGVyQ29udHIsXG4gICAgcnNEaWdpdHMsXG4gICAgcnNFbW9qaVxuICBdLmpvaW4oJ3wnKSwgJ2cnKTtcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cbiAgdmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib01hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlICsgcnNWYXJSYW5nZSArICddJyk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3MgdGhhdCBuZWVkIGEgbW9yZSByb2J1c3QgcmVnZXhwIHRvIG1hdGNoIHdvcmRzLiAqL1xuICB2YXIgcmVIYXNVbmljb2RlV29yZCA9IC9bYS16XVtBLVpdfFtBLVpdezIsfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLztcblxuICAvKiogVXNlZCB0byBhc3NpZ24gZGVmYXVsdCBgY29udGV4dGAgb2JqZWN0IHByb3BlcnRpZXMuICovXG4gIHZhciBjb250ZXh0UHJvcHMgPSBbXG4gICAgJ0FycmF5JywgJ0J1ZmZlcicsICdEYXRhVmlldycsICdEYXRlJywgJ0Vycm9yJywgJ0Zsb2F0MzJBcnJheScsICdGbG9hdDY0QXJyYXknLFxuICAgICdGdW5jdGlvbicsICdJbnQ4QXJyYXknLCAnSW50MTZBcnJheScsICdJbnQzMkFycmF5JywgJ01hcCcsICdNYXRoJywgJ09iamVjdCcsXG4gICAgJ1Byb21pc2UnLCAnUmVnRXhwJywgJ1NldCcsICdTdHJpbmcnLCAnU3ltYm9sJywgJ1R5cGVFcnJvcicsICdVaW50OEFycmF5JyxcbiAgICAnVWludDhDbGFtcGVkQXJyYXknLCAnVWludDE2QXJyYXknLCAnVWludDMyQXJyYXknLCAnV2Vha01hcCcsXG4gICAgJ18nLCAnY2xlYXJUaW1lb3V0JywgJ2lzRmluaXRlJywgJ3BhcnNlSW50JywgJ3NldFRpbWVvdXQnXG4gIF07XG5cbiAgLyoqIFVzZWQgdG8gbWFrZSB0ZW1wbGF0ZSBzb3VyY2VVUkxzIGVhc2llciB0byBpZGVudGlmeS4gKi9cbiAgdmFyIHRlbXBsYXRlQ291bnRlciA9IC0xO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbiAgdmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG4gIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIHR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xuICB2YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuICBjbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICBjbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gbWFwIExhdGluIFVuaWNvZGUgbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLiAqL1xuICB2YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAgIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cbiAgICAnXFx4YzAnOiAnQScsICAnXFx4YzEnOiAnQScsICdcXHhjMic6ICdBJywgJ1xceGMzJzogJ0EnLCAnXFx4YzQnOiAnQScsICdcXHhjNSc6ICdBJyxcbiAgICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICAgJ1xceGQwJzogJ0QnLCAgJ1xceGYwJzogJ2QnLFxuICAgICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgICAnXFx4Y2MnOiAnSScsICAnXFx4Y2QnOiAnSScsICdcXHhjZSc6ICdJJywgJ1xceGNmJzogJ0knLFxuICAgICdcXHhlYyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAgICdcXHhkMic6ICdPJywgICdcXHhkMyc6ICdPJywgJ1xceGQ0JzogJ08nLCAnXFx4ZDUnOiAnTycsICdcXHhkNic6ICdPJywgJ1xceGQ4JzogJ08nLFxuICAgICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAgICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICAgJ1xceGY5JzogJ3UnLCAgJ1xceGZhJzogJ3UnLCAnXFx4ZmInOiAndScsICdcXHhmYyc6ICd1JyxcbiAgICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAgICdcXHhkZSc6ICdUaCcsICdcXHhmZSc6ICd0aCcsXG4gICAgJ1xceGRmJzogJ3NzJyxcbiAgICAvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuICAgICdcXHUwMTAwJzogJ0EnLCAgJ1xcdTAxMDInOiAnQScsICdcXHUwMTA0JzogJ0EnLFxuICAgICdcXHUwMTAxJzogJ2EnLCAgJ1xcdTAxMDMnOiAnYScsICdcXHUwMTA1JzogJ2EnLFxuICAgICdcXHUwMTA2JzogJ0MnLCAgJ1xcdTAxMDgnOiAnQycsICdcXHUwMTBhJzogJ0MnLCAnXFx1MDEwYyc6ICdDJyxcbiAgICAnXFx1MDEwNyc6ICdjJywgICdcXHUwMTA5JzogJ2MnLCAnXFx1MDEwYic6ICdjJywgJ1xcdTAxMGQnOiAnYycsXG4gICAgJ1xcdTAxMGUnOiAnRCcsICAnXFx1MDExMCc6ICdEJywgJ1xcdTAxMGYnOiAnZCcsICdcXHUwMTExJzogJ2QnLFxuICAgICdcXHUwMTEyJzogJ0UnLCAgJ1xcdTAxMTQnOiAnRScsICdcXHUwMTE2JzogJ0UnLCAnXFx1MDExOCc6ICdFJywgJ1xcdTAxMWEnOiAnRScsXG4gICAgJ1xcdTAxMTMnOiAnZScsICAnXFx1MDExNSc6ICdlJywgJ1xcdTAxMTcnOiAnZScsICdcXHUwMTE5JzogJ2UnLCAnXFx1MDExYic6ICdlJyxcbiAgICAnXFx1MDExYyc6ICdHJywgICdcXHUwMTFlJzogJ0cnLCAnXFx1MDEyMCc6ICdHJywgJ1xcdTAxMjInOiAnRycsXG4gICAgJ1xcdTAxMWQnOiAnZycsICAnXFx1MDExZic6ICdnJywgJ1xcdTAxMjEnOiAnZycsICdcXHUwMTIzJzogJ2cnLFxuICAgICdcXHUwMTI0JzogJ0gnLCAgJ1xcdTAxMjYnOiAnSCcsICdcXHUwMTI1JzogJ2gnLCAnXFx1MDEyNyc6ICdoJyxcbiAgICAnXFx1MDEyOCc6ICdJJywgICdcXHUwMTJhJzogJ0knLCAnXFx1MDEyYyc6ICdJJywgJ1xcdTAxMmUnOiAnSScsICdcXHUwMTMwJzogJ0knLFxuICAgICdcXHUwMTI5JzogJ2knLCAgJ1xcdTAxMmInOiAnaScsICdcXHUwMTJkJzogJ2knLCAnXFx1MDEyZic6ICdpJywgJ1xcdTAxMzEnOiAnaScsXG4gICAgJ1xcdTAxMzQnOiAnSicsICAnXFx1MDEzNSc6ICdqJyxcbiAgICAnXFx1MDEzNic6ICdLJywgICdcXHUwMTM3JzogJ2snLCAnXFx1MDEzOCc6ICdrJyxcbiAgICAnXFx1MDEzOSc6ICdMJywgICdcXHUwMTNiJzogJ0wnLCAnXFx1MDEzZCc6ICdMJywgJ1xcdTAxM2YnOiAnTCcsICdcXHUwMTQxJzogJ0wnLFxuICAgICdcXHUwMTNhJzogJ2wnLCAgJ1xcdTAxM2MnOiAnbCcsICdcXHUwMTNlJzogJ2wnLCAnXFx1MDE0MCc6ICdsJywgJ1xcdTAxNDInOiAnbCcsXG4gICAgJ1xcdTAxNDMnOiAnTicsICAnXFx1MDE0NSc6ICdOJywgJ1xcdTAxNDcnOiAnTicsICdcXHUwMTRhJzogJ04nLFxuICAgICdcXHUwMTQ0JzogJ24nLCAgJ1xcdTAxNDYnOiAnbicsICdcXHUwMTQ4JzogJ24nLCAnXFx1MDE0Yic6ICduJyxcbiAgICAnXFx1MDE0Yyc6ICdPJywgICdcXHUwMTRlJzogJ08nLCAnXFx1MDE1MCc6ICdPJyxcbiAgICAnXFx1MDE0ZCc6ICdvJywgICdcXHUwMTRmJzogJ28nLCAnXFx1MDE1MSc6ICdvJyxcbiAgICAnXFx1MDE1NCc6ICdSJywgICdcXHUwMTU2JzogJ1InLCAnXFx1MDE1OCc6ICdSJyxcbiAgICAnXFx1MDE1NSc6ICdyJywgICdcXHUwMTU3JzogJ3InLCAnXFx1MDE1OSc6ICdyJyxcbiAgICAnXFx1MDE1YSc6ICdTJywgICdcXHUwMTVjJzogJ1MnLCAnXFx1MDE1ZSc6ICdTJywgJ1xcdTAxNjAnOiAnUycsXG4gICAgJ1xcdTAxNWInOiAncycsICAnXFx1MDE1ZCc6ICdzJywgJ1xcdTAxNWYnOiAncycsICdcXHUwMTYxJzogJ3MnLFxuICAgICdcXHUwMTYyJzogJ1QnLCAgJ1xcdTAxNjQnOiAnVCcsICdcXHUwMTY2JzogJ1QnLFxuICAgICdcXHUwMTYzJzogJ3QnLCAgJ1xcdTAxNjUnOiAndCcsICdcXHUwMTY3JzogJ3QnLFxuICAgICdcXHUwMTY4JzogJ1UnLCAgJ1xcdTAxNmEnOiAnVScsICdcXHUwMTZjJzogJ1UnLCAnXFx1MDE2ZSc6ICdVJywgJ1xcdTAxNzAnOiAnVScsICdcXHUwMTcyJzogJ1UnLFxuICAgICdcXHUwMTY5JzogJ3UnLCAgJ1xcdTAxNmInOiAndScsICdcXHUwMTZkJzogJ3UnLCAnXFx1MDE2Zic6ICd1JywgJ1xcdTAxNzEnOiAndScsICdcXHUwMTczJzogJ3UnLFxuICAgICdcXHUwMTc0JzogJ1cnLCAgJ1xcdTAxNzUnOiAndycsXG4gICAgJ1xcdTAxNzYnOiAnWScsICAnXFx1MDE3Nyc6ICd5JywgJ1xcdTAxNzgnOiAnWScsXG4gICAgJ1xcdTAxNzknOiAnWicsICAnXFx1MDE3Yic6ICdaJywgJ1xcdTAxN2QnOiAnWicsXG4gICAgJ1xcdTAxN2EnOiAneicsICAnXFx1MDE3Yyc6ICd6JywgJ1xcdTAxN2UnOiAneicsXG4gICAgJ1xcdTAxMzInOiAnSUonLCAnXFx1MDEzMyc6ICdpaicsXG4gICAgJ1xcdTAxNTInOiAnT2UnLCAnXFx1MDE1Myc6ICdvZScsXG4gICAgJ1xcdTAxNDknOiBcIiduXCIsICdcXHUwMTdmJzogJ3NzJ1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXG4gIHZhciBodG1sRXNjYXBlcyA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5OycsXG4gICAgJ2AnOiAnJiM5NjsnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy4gKi9cbiAgdmFyIGh0bWxVbmVzY2FwZXMgPSB7XG4gICAgJyZhbXA7JzogJyYnLFxuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmIzM5Oyc6IFwiJ1wiLFxuICAgICcmIzk2Oyc6ICdgJ1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICAvKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xuICB2YXIgZnJlZVBhcnNlRmxvYXQgPSBwYXJzZUZsb2F0LFxuICAgICAgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG4gIHZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xuICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG4gIHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuICAvKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbiAgdmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0oKSk7XG5cbiAgLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIG5vZGVJc0FycmF5QnVmZmVyID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNBcnJheUJ1ZmZlcixcbiAgICAgIG5vZGVJc0RhdGUgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc0RhdGUsXG4gICAgICBub2RlSXNNYXAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc01hcCxcbiAgICAgIG5vZGVJc1JlZ0V4cCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzUmVnRXhwLFxuICAgICAgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQsXG4gICAgICBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBrZXktdmFsdWUgYHBhaXJgIHRvIGBtYXBgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYWlyIFRoZSBrZXktdmFsdWUgcGFpciB0byBhZGQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG1hcGAuXG4gICAqL1xuICBmdW5jdGlvbiBhZGRNYXBFbnRyeShtYXAsIHBhaXIpIHtcbiAgICAvLyBEb24ndCByZXR1cm4gYG1hcC5zZXRgIGJlY2F1c2UgaXQncyBub3QgY2hhaW5hYmxlIGluIElFIDExLlxuICAgIG1hcC5zZXQocGFpclswXSwgcGFpclsxXSk7XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGB2YWx1ZWAgdG8gYHNldGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFkZC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgc2V0YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFkZFNldEVudHJ5KHNldCwgdmFsdWUpIHtcbiAgICAvLyBEb24ndCByZXR1cm4gYHNldC5hZGRgIGJlY2F1c2UgaXQncyBub3QgY2hhaW5hYmxlIGluIElFIDExLlxuICAgIHNldC5hZGQodmFsdWUpO1xuICAgIHJldHVybiBzZXQ7XG4gIH1cblxuICAvKipcbiAgICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUFnZ3JlZ2F0b3JgIGZvciBhcnJheXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5QWdncmVnYXRvcihhcnJheSwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RWFjaFJpZ2h0KGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZXZlcnlgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RXZlcnkoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKCFwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5jbHVkZXNgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgcmV0dXJuICEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIGFycmF5W2luZGV4XSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICAgKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gICAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlSZWR1Y2VSaWdodChhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGFycmF5Wy0tbGVuZ3RoXTtcbiAgICB9XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiBhbiBBU0NJSSBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgdmFyIGFzY2lpU2l6ZSA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIGFuIEFTQ0lJIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXNjaWlXb3JkcyhzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlQXNjaWlXb3JkKSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZmluZEtleWAgYW5kIGBfLmZpbmRMYXN0S2V5YCxcbiAgICogd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYFxuICAgKiB1c2luZyBgZWFjaEZ1bmNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50IG9yIGl0cyBrZXksIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRmluZEtleShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGVhY2hGdW5jKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICBpZiAodmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlSW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2ZXaXRoKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4LCBjb21wYXJhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVhbmAgYW5kIGBfLm1lYW5CeWAgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZU1lYW4oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICByZXR1cm4gbGVuZ3RoID8gKGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSAvIGxlbmd0aCkgOiBOQU47XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAsIHdpdGhvdXQgc3VwcG9ydFxuICAgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgYGVhY2hGdW5jYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRBY2N1bSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgb2ZcbiAgICogIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VSZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGVhY2hGdW5jKSB7XG4gICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGluaXRBY2N1bVxuICAgICAgICA/IChpbml0QWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgIDogaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZSB0aGVcbiAgICogc29ydCBvcmRlciBvZiBgYXJyYXlgIGFuZCByZXBsYWNlcyBjcml0ZXJpYSBvYmplY3RzIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZ1xuICAgKiB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnN1bWAgYW5kIGBfLnN1bUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIHJlc3VsdCxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdKTtcbiAgICAgIGlmIChjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBjdXJyZW50IDogKHJlc3VsdCArIGN1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAgICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1BhaXJzYCBhbmQgYF8udG9QYWlyc0luYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5XG4gICAqIG9mIGtleS12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGAgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYHByb3BzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUb1BhaXJzKG9iamVjdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIFtrZXksIG9iamVjdFtrZXldXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gICAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICAgKiBvZiBgcHJvcHNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gICAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICAgIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltU3RhcnRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBgcGxhY2Vob2xkZXJgIG9jY3VycmVuY2VzIGluIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjb3VudC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvdW50SG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSAwO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoYXJyYXlbbGVuZ3RoXSA9PT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgcmVzdWx0Kys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgTGF0aW4tMSBTdXBwbGVtZW50IGFuZCBMYXRpbiBFeHRlbmRlZC1BXG4gICAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gICAqL1xuICB2YXIgZGVidXJyTGV0dGVyID0gYmFzZVByb3BlcnR5T2YoZGVidXJyZWRMZXR0ZXJzKTtcblxuICAvKipcbiAgICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgdmFyIGVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbEVzY2FwZXMpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIGEgd29yZCBjb21wb3NlZCBvZiBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSB3b3JkIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNVbmljb2RlV29yZChzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVIYXNVbmljb2RlV29yZC50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgICAvLyBNYW55IGhvc3Qgb2JqZWN0cyBhcmUgYE9iamVjdGAgb2JqZWN0cyB0aGF0IGNhbiBjb2VyY2UgdG8gc3RyaW5nc1xuICAgIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYGl0ZXJhdG9yYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZXJhdG9yIFRoZSBpdGVyYXRvciB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGl0ZXJhdG9yVG9BcnJheShpdGVyYXRvcikge1xuICAgIHZhciBkYXRhLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICghKGRhdGEgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGRhdGEudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBgcGxhY2Vob2xkZXJgIGVsZW1lbnRzIGluIGBhcnJheWAgd2l0aCBhbiBpbnRlcm5hbCBwbGFjZWhvbGRlclxuICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVpciBpbmRleGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byByZXBsYWNlLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAodmFsdWUgPT09IHBsYWNlaG9sZGVyIHx8IHZhbHVlID09PSBQTEFDRUhPTERFUikge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBQTEFDRUhPTERFUjtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gaXRzIHZhbHVlLXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIHNldFRvUGFpcnMoc2V0KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSBbdmFsdWUsIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBzeW1ib2xzIGluIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdTaXplKHN0cmluZykge1xuICAgIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgID8gdW5pY29kZVNpemUoc3RyaW5nKVxuICAgICAgOiBhc2NpaVNpemUoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHVuaWNvZGVUb0FycmF5KHN0cmluZylcbiAgICAgIDogYXNjaWlUb0FycmF5KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy51bmVzY2FwZWAgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIHVuZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgdmFyIHVuZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sVW5lc2NhcGVzKTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiBhIFVuaWNvZGUgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVTaXplKHN0cmluZykge1xuICAgIHZhciByZXN1bHQgPSByZVVuaWNvZGUubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAocmVVbmljb2RlLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgcmVzdWx0Kys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBVbmljb2RlIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIGEgVW5pY29kZSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVXb3JkcyhzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmQpIHx8IFtdO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB1c2luZyB0aGUgYGNvbnRleHRgIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMS4xLjBcbiAgICogQGNhdGVnb3J5IFV0aWxcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PXJvb3RdIFRoZSBjb250ZXh0IG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgbmV3IGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLm1peGluKHsgJ2Zvbyc6IF8uY29uc3RhbnQoJ2ZvbycpIH0pO1xuICAgKlxuICAgKiB2YXIgbG9kYXNoID0gXy5ydW5JbkNvbnRleHQoKTtcbiAgICogbG9kYXNoLm1peGluKHsgJ2Jhcic6IGxvZGFzaC5jb25zdGFudCgnYmFyJykgfSk7XG4gICAqXG4gICAqIF8uaXNGdW5jdGlvbihfLmZvbyk7XG4gICAqIC8vID0+IHRydWVcbiAgICogXy5pc0Z1bmN0aW9uKF8uYmFyKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmZvbyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5iYXIpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIC8vIFVzZSBgY29udGV4dGAgdG8gc3R1YiBgRGF0ZSNnZXRUaW1lYCB1c2UgaW4gYF8ubm93YC5cbiAgICogdmFyIHN0dWJiZWQgPSBfLnJ1bkluQ29udGV4dCh7XG4gICAqICAgJ0RhdGUnOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHJldHVybiB7ICdnZXRUaW1lJzogc3R1YkdldFRpbWUgfTtcbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBDcmVhdGUgYSBzdXBlZC11cCBgZGVmZXJgIGluIE5vZGUuanMuXG4gICAqIHZhciBkZWZlciA9IF8ucnVuSW5Db250ZXh0KHsgJ3NldFRpbWVvdXQnOiBzZXRJbW1lZGlhdGUgfSkuZGVmZXI7XG4gICAqL1xuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnRleHQgPSBjb250ZXh0ID8gXy5kZWZhdWx0cyhyb290Lk9iamVjdCgpLCBjb250ZXh0LCBfLnBpY2socm9vdCwgY29udGV4dFByb3BzKSkgOiByb290O1xuXG4gICAgLyoqIEJ1aWx0LWluIGNvbnN0cnVjdG9yIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIEFycmF5ID0gY29udGV4dC5BcnJheSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHQuRGF0ZSxcbiAgICAgICAgRXJyb3IgPSBjb250ZXh0LkVycm9yLFxuICAgICAgICBGdW5jdGlvbiA9IGNvbnRleHQuRnVuY3Rpb24sXG4gICAgICAgIE1hdGggPSBjb250ZXh0Lk1hdGgsXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHQuT2JqZWN0LFxuICAgICAgICBSZWdFeHAgPSBjb250ZXh0LlJlZ0V4cCxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dC5TdHJpbmcsXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHQuVHlwZUVycm9yO1xuXG4gICAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgICAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbiAgICB2YXIgY29yZUpzRGF0YSA9IGNvbnRleHRbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbiAgICB2YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gICAgICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG4gICAgfSgpKTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbiAgICB2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xuICAgIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gICAgLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xuICAgIHZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAgICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgKiBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgdmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBgX2AgcmVmZXJlbmNlIGluIGBfLm5vQ29uZmxpY3RgLiAqL1xuICAgIHZhciBvbGREYXNoID0gcm9vdC5fO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbiAgICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICAgICAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICAgIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IGNvbnRleHQuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgICAgICBTeW1ib2wgPSBjb250ZXh0LlN5bWJvbCxcbiAgICAgICAgVWludDhBcnJheSA9IGNvbnRleHQuVWludDhBcnJheSxcbiAgICAgICAgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCksXG4gICAgICAgIGl0ZXJhdG9yU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLml0ZXJhdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlLFxuICAgICAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgICAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICAgICAgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbiAgICAvKiogTW9ja2VkIGJ1aWx0LWlucy4gKi9cbiAgICB2YXIgY3R4Q2xlYXJUaW1lb3V0ID0gY29udGV4dC5jbGVhclRpbWVvdXQgIT09IHJvb3QuY2xlYXJUaW1lb3V0ICYmIGNvbnRleHQuY2xlYXJUaW1lb3V0LFxuICAgICAgICBjdHhOb3cgPSBEYXRlICYmIERhdGUubm93ICE9PSByb290LkRhdGUubm93ICYmIERhdGUubm93LFxuICAgICAgICBjdHhTZXRUaW1lb3V0ID0gY29udGV4dC5zZXRUaW1lb3V0ICE9PSByb290LnNldFRpbWVvdXQgJiYgY29udGV4dC5zZXRUaW1lb3V0O1xuXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuICAgIHZhciBuYXRpdmVDZWlsID0gTWF0aC5jZWlsLFxuICAgICAgICBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgICAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICAgICAgbmF0aXZlSXNGaW5pdGUgPSBjb250ZXh0LmlzRmluaXRlLFxuICAgICAgICBuYXRpdmVKb2luID0gYXJyYXlQcm90by5qb2luLFxuICAgICAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KSxcbiAgICAgICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluLFxuICAgICAgICBuYXRpdmVQYXJzZUludCA9IGNvbnRleHQucGFyc2VJbnQsXG4gICAgICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tLFxuICAgICAgICBuYXRpdmVSZXZlcnNlID0gYXJyYXlQcm90by5yZXZlcnNlO1xuXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuICAgIHZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShjb250ZXh0LCAnRGF0YVZpZXcnKSxcbiAgICAgICAgTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdNYXAnKSxcbiAgICAgICAgUHJvbWlzZSA9IGdldE5hdGl2ZShjb250ZXh0LCAnUHJvbWlzZScpLFxuICAgICAgICBTZXQgPSBnZXROYXRpdmUoY29udGV4dCwgJ1NldCcpLFxuICAgICAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdXZWFrTWFwJyksXG4gICAgICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuICAgIC8qIFVzZWQgdG8gc2V0IGB0b1N0cmluZ2AgbWV0aG9kcy4gKi9cbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpLFxuICAgICAgICAgIG5hbWUgPSBnZXROYXRpdmUubmFtZTtcblxuICAgICAgcmV0dXJuIChuYW1lICYmIG5hbWUubGVuZ3RoID4gMikgPyBmdW5jIDogdW5kZWZpbmVkO1xuICAgIH0oKSk7XG5cbiAgICAvKiogVXNlZCB0byBzdG9yZSBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbiAgICB2YXIgbWV0YU1hcCA9IFdlYWtNYXAgJiYgbmV3IFdlYWtNYXA7XG5cbiAgICAvKiogRGV0ZWN0IGlmIHByb3BlcnRpZXMgc2hhZG93aW5nIHRob3NlIG9uIGBPYmplY3QucHJvdG90eXBlYCBhcmUgbm9uLWVudW1lcmFibGUuICovXG4gICAgdmFyIG5vbkVudW1TaGFkb3dzID0gIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAndmFsdWVPZic6IDEgfSwgJ3ZhbHVlT2YnKTtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCB1bm1pbmlmaWVkIGZ1bmN0aW9uIG5hbWVzLiAqL1xuICAgIHZhciByZWFsTmFtZXMgPSB7fTtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG4gICAgdmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICAgICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgICAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4gICAgLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG4gICAgdmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBpbXBsaWNpdCBtZXRob2RcbiAgICAgKiBjaGFpbiBzZXF1ZW5jZXMuIE1ldGhvZHMgdGhhdCBvcGVyYXRlIG9uIGFuZCByZXR1cm4gYXJyYXlzLCBjb2xsZWN0aW9ucyxcbiAgICAgKiBhbmQgZnVuY3Rpb25zIGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLiBNZXRob2RzIHRoYXQgcmV0cmlldmUgYSBzaW5nbGUgdmFsdWVcbiAgICAgKiBvciBtYXkgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlIHdpbGwgYXV0b21hdGljYWxseSBlbmQgdGhlIGNoYWluIHNlcXVlbmNlXG4gICAgICogYW5kIHJldHVybiB0aGUgdW53cmFwcGVkIHZhbHVlLiBPdGhlcndpc2UsIHRoZSB2YWx1ZSBtdXN0IGJlIHVud3JhcHBlZFxuICAgICAqIHdpdGggYF8jdmFsdWVgLlxuICAgICAqXG4gICAgICogRXhwbGljaXQgY2hhaW4gc2VxdWVuY2VzLCB3aGljaCBtdXN0IGJlIHVud3JhcHBlZCB3aXRoIGBfI3ZhbHVlYCwgbWF5IGJlXG4gICAgICogZW5hYmxlZCB1c2luZyBgXy5jaGFpbmAuXG4gICAgICpcbiAgICAgKiBUaGUgZXhlY3V0aW9uIG9mIGNoYWluZWQgbWV0aG9kcyBpcyBsYXp5LCB0aGF0IGlzLCBpdCdzIGRlZmVycmVkIHVudGlsXG4gICAgICogYF8jdmFsdWVgIGlzIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBMYXp5IGV2YWx1YXRpb24gYWxsb3dzIHNldmVyYWwgbWV0aG9kcyB0byBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbi5cbiAgICAgKiBTaG9ydGN1dCBmdXNpb24gaXMgYW4gb3B0aW1pemF0aW9uIHRvIG1lcmdlIGl0ZXJhdGVlIGNhbGxzOyB0aGlzIGF2b2lkc1xuICAgICAqIHRoZSBjcmVhdGlvbiBvZiBpbnRlcm1lZGlhdGUgYXJyYXlzIGFuZCBjYW4gZ3JlYXRseSByZWR1Y2UgdGhlIG51bWJlciBvZlxuICAgICAqIGl0ZXJhdGVlIGV4ZWN1dGlvbnMuIFNlY3Rpb25zIG9mIGEgY2hhaW4gc2VxdWVuY2UgcXVhbGlmeSBmb3Igc2hvcnRjdXRcbiAgICAgKiBmdXNpb24gaWYgdGhlIHNlY3Rpb24gaXMgYXBwbGllZCB0byBhbiBhcnJheSBvZiBhdCBsZWFzdCBgMjAwYCBlbGVtZW50c1xuICAgICAqIGFuZCBhbnkgaXRlcmF0ZWVzIGFjY2VwdCBvbmx5IG9uZSBhcmd1bWVudC4gVGhlIGhldXJpc3RpYyBmb3Igd2hldGhlciBhXG4gICAgICogc2VjdGlvbiBxdWFsaWZpZXMgZm9yIHNob3J0Y3V0IGZ1c2lvbiBpcyBzdWJqZWN0IHRvIGNoYW5nZS5cbiAgICAgKlxuICAgICAqIENoYWluaW5nIGlzIHN1cHBvcnRlZCBpbiBjdXN0b20gYnVpbGRzIGFzIGxvbmcgYXMgdGhlIGBfI3ZhbHVlYCBtZXRob2QgaXNcbiAgICAgKiBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIGxvZGFzaCBtZXRob2RzLCB3cmFwcGVycyBoYXZlIGBBcnJheWAgYW5kIGBTdHJpbmdgIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgQXJyYXlgIG1ldGhvZHMgYXJlOlxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGBzaGlmdGAsIGBzb3J0YCwgYHNwbGljZWAsIGFuZCBgdW5zaGlmdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGBTdHJpbmdgIG1ldGhvZHMgYXJlOlxuICAgICAqIGByZXBsYWNlYCBhbmQgYHNwbGl0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uIGFyZTpcbiAgICAgKiBgYXRgLCBgY29tcGFjdGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBkcm9wV2hpbGVgLCBgZmlsdGVyYCwgYGZpbmRgLFxuICAgICAqIGBmaW5kTGFzdGAsIGBoZWFkYCwgYGluaXRpYWxgLCBgbGFzdGAsIGBtYXBgLCBgcmVqZWN0YCwgYHJldmVyc2VgLCBgc2xpY2VgLFxuICAgICAqIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGFuZCBgdG9BcnJheWBcbiAgICAgKlxuICAgICAqIFRoZSBjaGFpbmFibGUgd3JhcHBlciBtZXRob2RzIGFyZTpcbiAgICAgKiBgYWZ0ZXJgLCBgYXJ5YCwgYGFzc2lnbmAsIGBhc3NpZ25JbmAsIGBhc3NpZ25JbldpdGhgLCBgYXNzaWduV2l0aGAsIGBhdGAsXG4gICAgICogYGJlZm9yZWAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsIGBjYXN0QXJyYXlgLCBgY2hhaW5gLCBgY2h1bmtgLFxuICAgICAqIGBjb21taXRgLCBgY29tcGFjdGAsIGBjb25jYXRgLCBgY29uZm9ybXNgLCBgY29uc3RhbnRgLCBgY291bnRCeWAsIGBjcmVhdGVgLFxuICAgICAqIGBjdXJyeWAsIGBkZWJvdW5jZWAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgZGVmZXJgLCBgZGVsYXlgLFxuICAgICAqIGBkaWZmZXJlbmNlYCwgYGRpZmZlcmVuY2VCeWAsIGBkaWZmZXJlbmNlV2l0aGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsXG4gICAgICogYGRyb3BSaWdodFdoaWxlYCwgYGRyb3BXaGlsZWAsIGBleHRlbmRgLCBgZXh0ZW5kV2l0aGAsIGBmaWxsYCwgYGZpbHRlcmAsXG4gICAgICogYGZsYXRNYXBgLCBgZmxhdE1hcERlZXBgLCBgZmxhdE1hcERlcHRoYCwgYGZsYXR0ZW5gLCBgZmxhdHRlbkRlZXBgLFxuICAgICAqIGBmbGF0dGVuRGVwdGhgLCBgZmxpcGAsIGBmbG93YCwgYGZsb3dSaWdodGAsIGBmcm9tUGFpcnNgLCBgZnVuY3Rpb25zYCxcbiAgICAgKiBgZnVuY3Rpb25zSW5gLCBgZ3JvdXBCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnRlcnNlY3Rpb25CeWAsXG4gICAgICogYGludGVyc2VjdGlvbldpdGhgLCBgaW52ZXJ0YCwgYGludmVydEJ5YCwgYGludm9rZU1hcGAsIGBpdGVyYXRlZWAsIGBrZXlCeWAsXG4gICAgICogYGtleXNgLCBga2V5c0luYCwgYG1hcGAsIGBtYXBLZXlzYCwgYG1hcFZhbHVlc2AsIGBtYXRjaGVzYCwgYG1hdGNoZXNQcm9wZXJ0eWAsXG4gICAgICogYG1lbW9pemVgLCBgbWVyZ2VgLCBgbWVyZ2VXaXRoYCwgYG1ldGhvZGAsIGBtZXRob2RPZmAsIGBtaXhpbmAsIGBuZWdhdGVgLFxuICAgICAqIGBudGhBcmdgLCBgb21pdGAsIGBvbWl0QnlgLCBgb25jZWAsIGBvcmRlckJ5YCwgYG92ZXJgLCBgb3ZlckFyZ3NgLFxuICAgICAqIGBvdmVyRXZlcnlgLCBgb3ZlclNvbWVgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLCBgcGFydGl0aW9uYCwgYHBpY2tgLFxuICAgICAqIGBwaWNrQnlgLCBgcGxhbnRgLCBgcHJvcGVydHlgLCBgcHJvcGVydHlPZmAsIGBwdWxsYCwgYHB1bGxBbGxgLCBgcHVsbEFsbEJ5YCxcbiAgICAgKiBgcHVsbEFsbFdpdGhgLCBgcHVsbEF0YCwgYHB1c2hgLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZWFyZ2AsIGByZWplY3RgLFxuICAgICAqIGByZW1vdmVgLCBgcmVzdGAsIGByZXZlcnNlYCwgYHNhbXBsZVNpemVgLCBgc2V0YCwgYHNldFdpdGhgLCBgc2h1ZmZsZWAsXG4gICAgICogYHNsaWNlYCwgYHNvcnRgLCBgc29ydEJ5YCwgYHNwbGljZWAsIGBzcHJlYWRgLCBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gICAgICogYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGB0YXBgLCBgdGhyb3R0bGVgLCBgdGhydWAsIGB0b0FycmF5YCxcbiAgICAgKiBgdG9QYWlyc2AsIGB0b1BhaXJzSW5gLCBgdG9QYXRoYCwgYHRvUGxhaW5PYmplY3RgLCBgdHJhbnNmb3JtYCwgYHVuYXJ5YCxcbiAgICAgKiBgdW5pb25gLCBgdW5pb25CeWAsIGB1bmlvbldpdGhgLCBgdW5pcWAsIGB1bmlxQnlgLCBgdW5pcVdpdGhgLCBgdW5zZXRgLFxuICAgICAqIGB1bnNoaWZ0YCwgYHVuemlwYCwgYHVuemlwV2l0aGAsIGB1cGRhdGVgLCBgdXBkYXRlV2l0aGAsIGB2YWx1ZXNgLFxuICAgICAqIGB2YWx1ZXNJbmAsIGB3aXRob3V0YCwgYHdyYXBgLCBgeG9yYCwgYHhvckJ5YCwgYHhvcldpdGhgLCBgemlwYCxcbiAgICAgKiBgemlwT2JqZWN0YCwgYHppcE9iamVjdERlZXBgLCBhbmQgYHppcFdpdGhgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgYXJlICoqbm90KiogY2hhaW5hYmxlIGJ5IGRlZmF1bHQgYXJlOlxuICAgICAqIGBhZGRgLCBgYXR0ZW1wdGAsIGBjYW1lbENhc2VgLCBgY2FwaXRhbGl6ZWAsIGBjZWlsYCwgYGNsYW1wYCwgYGNsb25lYCxcbiAgICAgKiBgY2xvbmVEZWVwYCwgYGNsb25lRGVlcFdpdGhgLCBgY2xvbmVXaXRoYCwgYGNvbmZvcm1zVG9gLCBgZGVidXJyYCxcbiAgICAgKiBgZGVmYXVsdFRvYCwgYGRpdmlkZWAsIGBlYWNoYCwgYGVhY2hSaWdodGAsIGBlbmRzV2l0aGAsIGBlcWAsIGBlc2NhcGVgLFxuICAgICAqIGBlc2NhcGVSZWdFeHBgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLCBgZmluZEtleWAsIGBmaW5kTGFzdGAsXG4gICAgICogYGZpbmRMYXN0SW5kZXhgLCBgZmluZExhc3RLZXlgLCBgZmlyc3RgLCBgZmxvb3JgLCBgZm9yRWFjaGAsIGBmb3JFYWNoUmlnaHRgLFxuICAgICAqIGBmb3JJbmAsIGBmb3JJblJpZ2h0YCwgYGZvck93bmAsIGBmb3JPd25SaWdodGAsIGBnZXRgLCBgZ3RgLCBgZ3RlYCwgYGhhc2AsXG4gICAgICogYGhhc0luYCwgYGhlYWRgLCBgaWRlbnRpdHlgLCBgaW5jbHVkZXNgLCBgaW5kZXhPZmAsIGBpblJhbmdlYCwgYGludm9rZWAsXG4gICAgICogYGlzQXJndW1lbnRzYCwgYGlzQXJyYXlgLCBgaXNBcnJheUJ1ZmZlcmAsIGBpc0FycmF5TGlrZWAsIGBpc0FycmF5TGlrZU9iamVjdGAsXG4gICAgICogYGlzQm9vbGVhbmAsIGBpc0J1ZmZlcmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCwgYGlzRW1wdHlgLCBgaXNFcXVhbGAsXG4gICAgICogYGlzRXF1YWxXaXRoYCwgYGlzRXJyb3JgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc0ludGVnZXJgLCBgaXNMZW5ndGhgLFxuICAgICAqIGBpc01hcGAsIGBpc01hdGNoYCwgYGlzTWF0Y2hXaXRoYCwgYGlzTmFOYCwgYGlzTmF0aXZlYCwgYGlzTmlsYCwgYGlzTnVsbGAsXG4gICAgICogYGlzTnVtYmVyYCwgYGlzT2JqZWN0YCwgYGlzT2JqZWN0TGlrZWAsIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCxcbiAgICAgKiBgaXNTYWZlSW50ZWdlcmAsIGBpc1NldGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsIGBpc1R5cGVkQXJyYXlgLFxuICAgICAqIGBpc1dlYWtNYXBgLCBgaXNXZWFrU2V0YCwgYGpvaW5gLCBga2ViYWJDYXNlYCwgYGxhc3RgLCBgbGFzdEluZGV4T2ZgLFxuICAgICAqIGBsb3dlckNhc2VgLCBgbG93ZXJGaXJzdGAsIGBsdGAsIGBsdGVgLCBgbWF4YCwgYG1heEJ5YCwgYG1lYW5gLCBgbWVhbkJ5YCxcbiAgICAgKiBgbWluYCwgYG1pbkJ5YCwgYG11bHRpcGx5YCwgYG5vQ29uZmxpY3RgLCBgbm9vcGAsIGBub3dgLCBgbnRoYCwgYHBhZGAsXG4gICAgICogYHBhZEVuZGAsIGBwYWRTdGFydGAsIGBwYXJzZUludGAsIGBwb3BgLCBgcmFuZG9tYCwgYHJlZHVjZWAsIGByZWR1Y2VSaWdodGAsXG4gICAgICogYHJlcGVhdGAsIGByZXN1bHRgLCBgcm91bmRgLCBgcnVuSW5Db250ZXh0YCwgYHNhbXBsZWAsIGBzaGlmdGAsIGBzaXplYCxcbiAgICAgKiBgc25ha2VDYXNlYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgc29ydGVkSW5kZXhCeWAsIGBzb3J0ZWRMYXN0SW5kZXhgLFxuICAgICAqIGBzb3J0ZWRMYXN0SW5kZXhCeWAsIGBzdGFydENhc2VgLCBgc3RhcnRzV2l0aGAsIGBzdHViQXJyYXlgLCBgc3R1YkZhbHNlYCxcbiAgICAgKiBgc3R1Yk9iamVjdGAsIGBzdHViU3RyaW5nYCwgYHN0dWJUcnVlYCwgYHN1YnRyYWN0YCwgYHN1bWAsIGBzdW1CeWAsXG4gICAgICogYHRlbXBsYXRlYCwgYHRpbWVzYCwgYHRvRmluaXRlYCwgYHRvSW50ZWdlcmAsIGB0b0pTT05gLCBgdG9MZW5ndGhgLFxuICAgICAqIGB0b0xvd2VyYCwgYHRvTnVtYmVyYCwgYHRvU2FmZUludGVnZXJgLCBgdG9TdHJpbmdgLCBgdG9VcHBlcmAsIGB0cmltYCxcbiAgICAgKiBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBgdHJ1bmNhdGVgLCBgdW5lc2NhcGVgLCBgdW5pcXVlSWRgLCBgdXBwZXJDYXNlYCxcbiAgICAgKiBgdXBwZXJGaXJzdGAsIGB2YWx1ZWAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAbmFtZSBfXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDIsIDNdKTtcbiAgICAgKlxuICAgICAqIC8vIFJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIHdyYXBwZWQucmVkdWNlKF8uYWRkKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiAvLyBSZXR1cm5zIGEgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKiB2YXIgc3F1YXJlcyA9IHdyYXBwZWQubWFwKHNxdWFyZSk7XG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzLnZhbHVlKCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2Rhc2godmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdExpa2UodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExvZGFzaFdyYXBwZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX3dyYXBwZWRfXycpKSB7XG4gICAgICAgICAgcmV0dXJuIHdyYXBwZXJDbG9uZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHdob3NlIHByb3RvdHlwZSBjaGFpbiBzZXF1ZW5jZSB3cmFwcGVycyBpbmhlcml0IGZyb20uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMb2Rhc2goKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGNvbnN0cnVjdG9yIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2hhaW5BbGxdIEVuYWJsZSBleHBsaWNpdCBtZXRob2QgY2hhaW4gc2VxdWVuY2VzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XG4gICAgICB0aGlzLl9faW5kZXhfXyA9IDA7XG4gICAgICB0aGlzLl9fdmFsdWVzX18gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBsb2Rhc2ggYXJlIGxpa2UgdGhvc2UgaW5cbiAgICAgKiBlbWJlZGRlZCBSdWJ5IChFUkIpLiBDaGFuZ2UgdGhlIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2VcbiAgICAgKiBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogcmVFc2NhcGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2V2YWx1YXRlJzogcmVFdmFsdWF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgJ2ltcG9ydHMnOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgICdfJzogbG9kYXNoXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEVuc3VyZSB3cmFwcGVycyBhcmUgaW5zdGFuY2VzIG9mIGBiYXNlTG9kYXNoYC5cbiAgICBsb2Rhc2gucHJvdG90eXBlID0gYmFzZUxvZGFzaC5wcm90b3R5cGU7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGxvZGFzaDtcblxuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2Rhc2hXcmFwcGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxhenkgd3JhcHBlciBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgbGF6eSBldmFsdWF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExhenlXcmFwcGVyKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fZGlyX18gPSAxO1xuICAgICAgdGhpcy5fX2ZpbHRlcmVkX18gPSBmYWxzZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlZXNfXyA9IFtdO1xuICAgICAgdGhpcy5fX3Rha2VDb3VudF9fID0gTUFYX0FSUkFZX0xFTkdUSDtcbiAgICAgIHRoaXMuX192aWV3c19fID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBsYXp5IHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbG9uZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5Q2xvbmUoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMuX193cmFwcGVkX18pO1xuICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHRoaXMuX19hY3Rpb25zX18pO1xuICAgICAgcmVzdWx0Ll9fZGlyX18gPSB0aGlzLl9fZGlyX187XG4gICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdGhpcy5fX2ZpbHRlcmVkX187XG4gICAgICByZXN1bHQuX19pdGVyYXRlZXNfXyA9IGNvcHlBcnJheSh0aGlzLl9faXRlcmF0ZWVzX18pO1xuICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSB0aGlzLl9fdGFrZUNvdW50X187XG4gICAgICByZXN1bHQuX192aWV3c19fID0gY29weUFycmF5KHRoaXMuX192aWV3c19fKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgdGhlIGRpcmVjdGlvbiBvZiBsYXp5IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyByZXZlcnNlZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5UmV2ZXJzZSgpIHtcbiAgICAgIGlmICh0aGlzLl9fZmlsdGVyZWRfXykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyA9IC0xO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gKj0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB1bndyYXBwZWQgdmFsdWUgZnJvbSBpdHMgbGF6eSB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVZhbHVlKCkge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5fX3dyYXBwZWRfXy52YWx1ZSgpLFxuICAgICAgICAgIGRpciA9IHRoaXMuX19kaXJfXyxcbiAgICAgICAgICBpc0FyciA9IGlzQXJyYXkoYXJyYXkpLFxuICAgICAgICAgIGlzUmlnaHQgPSBkaXIgPCAwLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGlzQXJyID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICB2aWV3ID0gZ2V0VmlldygwLCBhcnJMZW5ndGgsIHRoaXMuX192aWV3c19fKSxcbiAgICAgICAgICBzdGFydCA9IHZpZXcuc3RhcnQsXG4gICAgICAgICAgZW5kID0gdmlldy5lbmQsXG4gICAgICAgICAgbGVuZ3RoID0gZW5kIC0gc3RhcnQsXG4gICAgICAgICAgaW5kZXggPSBpc1JpZ2h0ID8gZW5kIDogKHN0YXJ0IC0gMSksXG4gICAgICAgICAgaXRlcmF0ZWVzID0gdGhpcy5fX2l0ZXJhdGVlc19fLFxuICAgICAgICAgIGl0ZXJMZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICB0YWtlQ291bnQgPSBuYXRpdmVNaW4obGVuZ3RoLCB0aGlzLl9fdGFrZUNvdW50X18pO1xuXG4gICAgICBpZiAoIWlzQXJyIHx8IGFyckxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgfHxcbiAgICAgICAgICAoYXJyTGVuZ3RoID09IGxlbmd0aCAmJiB0YWtlQ291bnQgPT0gbGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZShhcnJheSwgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKGxlbmd0aC0tICYmIHJlc0luZGV4IDwgdGFrZUNvdW50KSB7XG4gICAgICAgIGluZGV4ICs9IGRpcjtcblxuICAgICAgICB2YXIgaXRlckluZGV4ID0gLTEsXG4gICAgICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICB3aGlsZSAoKytpdGVySW5kZXggPCBpdGVyTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBpdGVyYXRlZXNbaXRlckluZGV4XSxcbiAgICAgICAgICAgICAgaXRlcmF0ZWUgPSBkYXRhLml0ZXJhdGVlLFxuICAgICAgICAgICAgICB0eXBlID0gZGF0YS50eXBlLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICAgIGlmICh0eXBlID09IExBWllfTUFQX0ZMQUcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gY29tcHV0ZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmICghY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09IExBWllfRklMVEVSX0ZMQUcpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBgTGF6eVdyYXBwZXJgIGlzIGFuIGluc3RhbmNlIG9mIGBiYXNlTG9kYXNoYC5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXp5V3JhcHBlcjtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG4gICAgSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG4gICAgSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbiAgICBIYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuICAgIEhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG4gICAgSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICAgICAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgICAgICBkYXRhLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICAgICAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAgICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgICBnZXRNYXBEYXRhKHRoaXMsIGtleSkuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlcyA/IHZhbHVlcy5sZW5ndGggOiAwO1xuXG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgYWRkXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQGFsaWFzIHB1c2hcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICAgICAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX19bJ2RlbGV0ZSddKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGNhY2hlID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIGlmIChjYWNoZSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgICAgICB2YXIgcGFpcnMgPSBjYWNoZS5fX2RhdGFfXztcbiAgICAgICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjYWNoZSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICAgICAgfVxuICAgICAgY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cbiAgICBTdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuICAgIFN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcbiAgICBTdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG4gICAgU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuICAgIFN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gICAgICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICAgICAgLy8gU2FmYXJpIDkgbWFrZXMgYGFyZ3VtZW50cy5sZW5ndGhgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gICAgICB2YXIgcmVzdWx0ID0gKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSlcbiAgICAgICAgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpXG4gICAgICAgIDogW107XG5cbiAgICAgIHZhciBsZW5ndGggPSByZXN1bHQubGVuZ3RoLFxuICAgICAgICAgIHNraXBJbmRleGVzID0gISFsZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoa2V5ID09ICdsZW5ndGgnIHx8IGlzSW5kZXgoa2V5LCBsZW5ndGgpKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbkluRGVmYXVsdHMob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAoZXEob2JqVmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgcmV0dXJuIHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gICAgICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgICAgICh0eXBlb2Yga2V5ID09ICdudW1iZXInICYmIHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZ2dyZWdhdGVzIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBvbiBgYWNjdW11bGF0b3JgIHdpdGgga2V5cyB0cmFuc2Zvcm1lZFxuICAgICAqIGJ5IGBpdGVyYXRlZWAgYW5kIHZhbHVlcyBzZXQgYnkgYHNldHRlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBZ2dyZWdhdG9yKGNvbGxlY3Rpb24sIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICAgICAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWwgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIG9mIGVsZW1lbnRzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwaWNrZWQgZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUF0KG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzTmlsID0gb2JqZWN0ID09IG51bGwsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBpc05pbCA/IHVuZGVmaW5lZCA6IGdldChvYmplY3QsIHBhdGhzW2luZGV4XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsYW1wYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHtcbiAgICAgIGlmIChudW1iZXIgPT09IG51bWJlcikge1xuICAgICAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG51bWJlciA9IG51bWJlciA8PSB1cHBlciA/IG51bWJlciA6IHVwcGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbnVtYmVyID0gbnVtYmVyID49IGxvd2VyID8gbnVtYmVyIDogbG93ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICAgICAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRnVsbF0gU3BlY2lmeSBhIGNsb25lIGluY2x1ZGluZyBzeW1ib2xzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBpc0Z1bGwsIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgICAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgICAgICBpZiAoaXNIb3N0T2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZU9iamVjdChpc0Z1bmMgPyB7fSA6IHZhbHVlKTtcbiAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBiYXNlQ2xvbmUsIGlzRGVlcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQ7XG4gICAgICB9XG4gICAgICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgICAgIGlmICghaXNBcnIpIHtcbiAgICAgICAgdmFyIHByb3BzID0gaXNGdWxsID8gZ2V0QWxsS2V5cyh2YWx1ZSkgOiBrZXlzKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgaXNEZWVwLCBpc0Z1bGwsIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY29uZm9ybXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ29uZm9ybXMoc291cmNlKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwgcHJvcHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb25mb3Jtc1RvYCB3aGljaCBhY2NlcHRzIGBwcm9wc2AgdG8gY2hlY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGNvbmZvcm1zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIHByb3BzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2xlbmd0aF0sXG4gICAgICAgICAgICBwcmVkaWNhdGUgPSBzb3VyY2Vba2V5XSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgaWYgKCh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHx8ICFwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gICAgICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ3JlYXRlKHByb3RvKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QocHJvdG8pID8gb2JqZWN0Q3JlYXRlKHByb3RvKSA6IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRlbGF5YCBhbmQgYF8uZGVmZXJgIHdoaWNoIGFjY2VwdHMgYGFyZ3NgXG4gICAgICogdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8T2JqZWN0fSBSZXR1cm5zIHRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGVsYXkoZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgd2FpdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRpZmZlcmVuY2VgIHdpdGhvdXQgc3VwcG9ydFxuICAgICAqIGZvciBleGNsdWRpbmcgbXVsdGlwbGUgYXJyYXlzIG9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFsdWVzID0gYXJyYXlNYXAodmFsdWVzLCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzID0gbmV3IFNldENhY2hlKHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIHZhciB2YWx1ZXNJbmRleCA9IHZhbHVlc0xlbmd0aDtcbiAgICAgICAgICB3aGlsZSAodmFsdWVzSW5kZXgtLSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1t2YWx1ZXNJbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWluY2x1ZGVzKHZhbHVlcywgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICovXG4gICAgdmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICovXG4gICAgdmFyIGJhc2VFYWNoUmlnaHQgPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duUmlnaHQsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZXZlcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgPSAhIXByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5tYXhgIGFuZCBgXy5taW5gIHdoaWNoIGFjY2VwdHMgYVxuICAgICAqIGBjb21wYXJhdG9yYCB0byBkZXRlcm1pbmUgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciB1c2VkIHRvIGNvbXBhcmUgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRXh0cmVtdW0oYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT0gbnVsbCAmJiAoY29tcHV0ZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IChjdXJyZW50ID09PSBjdXJyZW50ICYmICFpc1N5bWJvbChjdXJyZW50KSlcbiAgICAgICAgICAgICAgOiBjb21wYXJhdG9yKGN1cnJlbnQsIGNvbXB1dGVkKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHZhciBjb21wdXRlZCA9IGN1cnJlbnQsXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbGxgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgc3RhcnQgPSB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICAgICAgfVxuICAgICAgZW5kID0gKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IGxlbmd0aCkgPyBsZW5ndGggOiB0b0ludGVnZXIoZW5kKTtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbmQgPSBzdGFydCA+IGVuZCA/IDAgOiB0b0xlbmd0aChlbmQpO1xuICAgICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgIGFycmF5W3N0YXJ0KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsdGVyYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICAgICAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAgICAgKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgdmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJhc2VGb3JgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllc1xuICAgICAqIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvclJpZ2h0ID0gY3JlYXRlQmFzZUZvcih0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25SaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yUmlnaHQob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZnVuY3Rpb25zYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mXG4gICAgICogYG9iamVjdGAgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZmlsdGVyZWQgZnJvbSBgcHJvcHNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZmlsdGVyLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZ1bmN0aW9ucyhvYmplY3QsIHByb3BzKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaWx0ZXIocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvYmplY3Rba2V5XSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcGF0aCA9IGlzS2V5KHBhdGgsIG9iamVjdCkgPyBbcGF0aF0gOiBjYXN0UGF0aChwYXRoKTtcblxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gICAgICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgICAgIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ3RgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUd0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID4gb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUhhcyhvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluUmFuZ2VgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBudW1iZXJgIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIG51bWJlciA+PSBuYXRpdmVNaW4oc3RhcnQsIGVuZCkgJiYgbnVtYmVyIDwgbmF0aXZlTWF4KHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gLCB3aXRob3V0IHN1cHBvcnRcbiAgICAgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2Ygc2hhcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW50ZXJzZWN0aW9uKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmNsdWRlcyA9IGNvbXBhcmF0b3IgPyBhcnJheUluY2x1ZGVzV2l0aCA6IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXlzWzBdLmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoLFxuICAgICAgICAgIGNhY2hlcyA9IEFycmF5KG90aExlbmd0aCksXG4gICAgICAgICAgbWF4TGVuZ3RoID0gSW5maW5pdHksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlIChvdGhJbmRleC0tKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tvdGhJbmRleF07XG4gICAgICAgIGlmIChvdGhJbmRleCAmJiBpdGVyYXRlZSkge1xuICAgICAgICAgIGFycmF5ID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgICB9XG4gICAgICAgIG1heExlbmd0aCA9IG5hdGl2ZU1pbihhcnJheS5sZW5ndGgsIG1heExlbmd0aCk7XG4gICAgICAgIGNhY2hlc1tvdGhJbmRleF0gPSAhY29tcGFyYXRvciAmJiAoaXRlcmF0ZWUgfHwgKGxlbmd0aCA+PSAxMjAgJiYgYXJyYXkubGVuZ3RoID49IDEyMCkpXG4gICAgICAgICAgPyBuZXcgU2V0Q2FjaGUob3RoSW5kZXggJiYgYXJyYXkpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnJheSA9IGFycmF5c1swXTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgc2VlbiA9IGNhY2hlc1swXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKCEoc2VlblxuICAgICAgICAgICAgICA/IGNhY2hlSGFzKHNlZW4sIGNvbXB1dGVkKVxuICAgICAgICAgICAgICA6IGluY2x1ZGVzKHJlc3VsdCwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKC0tb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IGNhY2hlc1tvdGhJbmRleF07XG4gICAgICAgICAgICBpZiAoIShjYWNoZVxuICAgICAgICAgICAgICAgICAgPyBjYWNoZUhhcyhjYWNoZSwgY29tcHV0ZWQpXG4gICAgICAgICAgICAgICAgICA6IGluY2x1ZGVzKGFycmF5c1tvdGhJbmRleF0sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52ZXJ0YCBhbmQgYF8uaW52ZXJ0QnlgIHdoaWNoIGludmVydHNcbiAgICAgKiBgb2JqZWN0YCB3aXRoIHZhbHVlcyB0cmFuc2Zvcm1lZCBieSBgaXRlcmF0ZWVgIGFuZCBzZXQgYnkgYHNldHRlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIGl0ZXJhdGVlKHZhbHVlKSwga2V5LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52b2tlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBtZXRob2QgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpIHtcbiAgICAgIGlmICghaXNLZXkocGF0aCwgb2JqZWN0KSkge1xuICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCk7XG4gICAgICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICAgICAgICBwYXRoID0gbGFzdChwYXRoKTtcbiAgICAgIH1cbiAgICAgIHZhciBmdW5jID0gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBvYmplY3RbdG9LZXkocGF0aCldO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFwcGx5KGZ1bmMsIG9iamVjdCwgYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcnJheUJ1ZmZlcmAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcnJheUJ1ZmZlclRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0RhdGVgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGRhdGUgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZGF0ZVRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gICAgICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2JpdG1hc2tdIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuXG4gICAgICogIFRoZSBiaXRtYXNrIG1heSBiZSBjb21wb3NlZCBvZiB0aGUgZm9sbG93aW5nIGZsYWdzOlxuICAgICAqICAgICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAgICAgKiAgICAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xuICAgICAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdCh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJhc2VJc0VxdWFsLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2JpdG1hc2tdIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXG4gICAgICogIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gICAgICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgICAgICBvYmpUYWcgPSBhcnJheVRhZyxcbiAgICAgICAgICBvdGhUYWcgPSBhcnJheVRhZztcblxuICAgICAgaWYgKCFvYmpJc0Fycikge1xuICAgICAgICBvYmpUYWcgPSBnZXRUYWcob2JqZWN0KTtcbiAgICAgICAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gICAgICB9XG4gICAgICBpZiAoIW90aElzQXJyKSB7XG4gICAgICAgIG90aFRhZyA9IGdldFRhZyhvdGhlcik7XG4gICAgICAgIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuICAgICAgfVxuICAgICAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyAmJiAhaXNIb3N0T2JqZWN0KG9iamVjdCksXG4gICAgICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnICYmICFpc0hvc3RPYmplY3Qob3RoZXIpLFxuICAgICAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgICAgIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKVxuICAgICAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEoYml0bWFzayAmIFBBUlRJQUxfQ09NUEFSRV9GTEFHKSkge1xuICAgICAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICAgICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzU2FtZVRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBjdXN0b21pemVyLCBVTk9SREVSRURfQ09NUEFSRV9GTEFHIHwgUEFSVElBTF9DT01QQVJFX0ZMQUcsIHN0YWNrKVxuICAgICAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcGF0dGVybiA9IChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gICAgICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNSZWdFeHBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1JlZ0V4cCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSByZWdleHBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAgICAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICAgICAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmx0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gICAgICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gICAgICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgICAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCB1bmRlZmluZWQsIFVOT1JERVJFRF9DT01QQVJFX0ZMQUcgfCBQQVJUSUFMX0NPTVBBUkVfRkxBRyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIShpc0FycmF5KHNvdXJjZSkgfHwgaXNUeXBlZEFycmF5KHNvdXJjZSkpKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGJhc2VLZXlzSW4oc291cmNlKTtcbiAgICAgIH1cbiAgICAgIGFycmF5RWFjaChwcm9wcyB8fCBzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAga2V5ID0gc3JjVmFsdWU7XG4gICAgICAgICAgc3JjVmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgc3JjVmFsdWUgPSBzb3VyY2Vba2V5XSxcbiAgICAgICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgIGlmIChpc0FycmF5KHNyY1ZhbHVlKSB8fCBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBiYXNlQ2xvbmUoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IChzcmNJbmRleCAmJiBpc0Z1bmN0aW9uKG9ialZhbHVlKSkpIHtcbiAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGJhc2VDbG9uZShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5udGhgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG50aCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU50aChhcnJheSwgbikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG4gKz0gbiA8IDAgPyBsZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIGlzSW5kZXgobiwgbGVuZ3RoKSA/IGFycmF5W25dIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcy5sZW5ndGggPyBpdGVyYXRlZXMgOiBbaWRlbnRpdHldLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBjcml0ZXJpYSA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogY3JpdGVyaWEsICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCBmdW5jdGlvbihvYmplY3QsIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVBpY2sob2JqZWN0LCBwcm9wcykge1xuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHByb3BzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgaW4gb2JqZWN0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBwaWNrIGZyb20uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwcm9wcywgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQWxsQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICAgKiBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXhPZiA9IGNvbXBhcmF0b3IgPyBiYXNlSW5kZXhPZldpdGggOiBiYXNlSW5kZXhPZixcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgc2VlbiA9IGFycmF5O1xuXG4gICAgICBpZiAoYXJyYXkgPT09IHZhbHVlcykge1xuICAgICAgICB2YWx1ZXMgPSBjb3B5QXJyYXkodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBzZWVuID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGZyb21JbmRleCA9IDAsXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlc1tpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tSW5kZXggPSBpbmRleE9mKHNlZW4sIGNvbXB1dGVkLCBmcm9tSW5kZXgsIGNvbXBhcmF0b3IpKSA+IC0xKSB7XG4gICAgICAgICAgaWYgKHNlZW4gIT09IGFycmF5KSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChzZWVuLCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogaW5kZXhlcyBvciBjYXB0dXJpbmcgdGhlIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gaW5kZXhlcyBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gaW5kZXhlcy5sZW5ndGggOiAwLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgIGlmIChsZW5ndGggPT0gbGFzdEluZGV4IHx8IGluZGV4ICE9PSBwcmV2aW91cykge1xuICAgICAgICAgIHZhciBwcmV2aW91cyA9IGluZGV4O1xuICAgICAgICAgIGlmIChpc0luZGV4KGluZGV4KSkge1xuICAgICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIWlzS2V5KGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gY2FzdFBhdGgoaW5kZXgpLFxuICAgICAgICAgICAgICAgIG9iamVjdCA9IHBhcmVudChhcnJheSwgcGF0aCk7XG5cbiAgICAgICAgICAgIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgYXJyYXlbdG9LZXkoaW5kZXgpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgc3VwcG9ydCBmb3IgcmV0dXJuaW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpIHtcbiAgICAgIHJldHVybiBsb3dlciArIG5hdGl2ZUZsb29yKG5hdGl2ZVJhbmRvbSgpICogKHVwcGVyIC0gbG93ZXIgKyAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZ2VgIGFuZCBgXy5yYW5nZVJpZ2h0YCB3aGljaCBkb2Vzbid0XG4gICAgICogY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KG5hdGl2ZUNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XSA9IHN0YXJ0O1xuICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXBlYXRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVwZWF0KHN0cmluZywgbikge1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgaWYgKCFzdHJpbmcgfHwgbiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8vIExldmVyYWdlIHRoZSBleHBvbmVudGlhdGlvbiBieSBzcXVhcmluZyBhbGdvcml0aG0gZm9yIGEgZmFzdGVyIHJlcGVhdC5cbiAgICAgIC8vIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FeHBvbmVudGlhdGlvbl9ieV9zcXVhcmluZyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgZG8ge1xuICAgICAgICBpZiAobiAlIDIpIHtcbiAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuYXRpdmVGbG9vcihuIC8gMik7XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAobik7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICAgICAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyQXJnc1tzdGFydF0gPSBhcnJheTtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICBwYXRoID0gaXNLZXkocGF0aCwgb2JqZWN0KSA/IFtwYXRoXSA6IGNhc3RQYXRoKHBhdGgpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICAgICAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXREYXRhYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIGRldGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBiYXNlU2V0RGF0YSA9ICFtZXRhTWFwID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBkYXRhKSB7XG4gICAgICBtZXRhTWFwLnNldChmdW5jLCBkYXRhKTtcbiAgICAgIHJldHVybiBmdW5jO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICAgICAgfVxuICAgICAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6ICgoZW5kIC0gc3RhcnQpID4+PiAwKTtcbiAgICAgIHN0YXJ0ID4+Pj0gMDtcblxuICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvbWVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZEluZGV4YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4YCB3aGljaFxuICAgICAqIHBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBvZiBgYXJyYXlgIHRvIGRldGVybWluZSB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHJldEhpZ2hlc3QpIHtcbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IGxvdztcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PT0gdmFsdWUgJiYgaGlnaCA8PSBIQUxGX01BWF9BUlJBWV9MRU5HVEgpIHtcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGFycmF5W21pZF07XG5cbiAgICAgICAgICBpZiAoY29tcHV0ZWQgIT09IG51bGwgJiYgIWlzU3ltYm9sKGNvbXB1dGVkKSAmJlxuICAgICAgICAgICAgICAocmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSkpKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGlkZW50aXR5LCByZXRIaWdoZXN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleEJ5YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4QnlgXG4gICAgICogd2hpY2ggaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlXG4gICAgICogdGhlaXIgc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFsdWUgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgdmFsSXNOYU4gPSB2YWx1ZSAhPT0gdmFsdWUsXG4gICAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSksXG4gICAgICAgICAgdmFsSXNVbmRlZmluZWQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICB2YXIgbWlkID0gbmF0aXZlRmxvb3IoKGxvdyArIGhpZ2gpIC8gMiksXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKGFycmF5W21pZF0pLFxuICAgICAgICAgICAgb3RoSXNEZWZpbmVkID0gY29tcHV0ZWQgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG90aElzTnVsbCA9IGNvbXB1dGVkID09PSBudWxsLFxuICAgICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBjb21wdXRlZCA9PT0gY29tcHV0ZWQsXG4gICAgICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKGNvbXB1dGVkKTtcblxuICAgICAgICBpZiAodmFsSXNOYU4pIHtcbiAgICAgICAgICB2YXIgc2V0TG93ID0gcmV0SGlnaGVzdCB8fCBvdGhJc1JlZmxleGl2ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1VuZGVmaW5lZCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIChyZXRIaWdoZXN0IHx8IG90aElzRGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNOdWxsKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc051bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzU3ltYm9sKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmICFvdGhJc051bGwgJiYgKHJldEhpZ2hlc3QgfHwgIW90aElzU3ltYm9sKTtcbiAgICAgICAgfSBlbHNlIGlmIChvdGhJc051bGwgfHwgb3RoSXNTeW1ib2wpIHtcbiAgICAgICAgICBzZXRMb3cgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRMb3cgPSByZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0TG93KSB7XG4gICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlTWluKGhpZ2gsIE1BWF9BUlJBWV9JTkRFWCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkVW5pcWAgYW5kIGBfLnNvcnRlZFVuaXFCeWAgd2l0aG91dFxuICAgICAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZFVuaXEoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgaWYgKCFpbmRleCB8fCAhZXEoY29tcHV0ZWQsIHNlZW4pKSB7XG4gICAgICAgICAgdmFyIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b051bWJlcmAgd2hpY2ggZG9lc24ndCBlbnN1cmUgY29ycmVjdFxuICAgICAqIGNvbnZlcnNpb25zIG9mIGJpbmFyeSwgaGV4YWRlY2ltYWwsIG9yIG9jdGFsIHN0cmluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VUb051bWJlcih2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBOQU47XG4gICAgICB9XG4gICAgICByZXR1cm4gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICAgICAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICBzZWVuID0gcmVzdWx0O1xuXG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgdmFyIHNldCA9IGl0ZXJhdGVlID8gbnVsbCA6IGNyZWF0ZVNldChhcnJheSk7XG4gICAgICAgIGlmIChzZXQpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VG9BcnJheShzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgICAgIGlmIChzZWVuW3NlZW5JbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5jbHVkZXMoc2VlbiwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICAgICAgaWYgKHNlZW4gIT09IHJlc3VsdCkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuc2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gdW5zZXQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcGF0aCA9IGlzS2V5KHBhdGgsIG9iamVjdCkgPyBbcGF0aF0gOiBjYXN0UGF0aChwYXRoKTtcbiAgICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuXG4gICAgICB2YXIga2V5ID0gdG9LZXkobGFzdChwYXRoKSk7XG4gICAgICByZXR1cm4gIShvYmplY3QgIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkgfHwgZGVsZXRlIG9iamVjdFtrZXldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVwZGF0ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlciwgY3VzdG9taXplcikge1xuICAgICAgcmV0dXJuIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB1cGRhdGVyKGJhc2VHZXQob2JqZWN0LCBwYXRoKSksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5kcm9wV2hpbGVgIGFuZCBgXy50YWtlV2hpbGVgXG4gICAgICogd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEcm9wXSBTcGVjaWZ5IGRyb3BwaW5nIGVsZW1lbnRzIGluc3RlYWQgb2YgdGFraW5nIHRoZW0uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXaGlsZShhcnJheSwgcHJlZGljYXRlLCBpc0Ryb3AsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xO1xuXG4gICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSAmJlxuICAgICAgICBwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7fVxuXG4gICAgICByZXR1cm4gaXNEcm9wXG4gICAgICAgID8gYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gMCA6IGluZGV4KSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IGxlbmd0aCkpXG4gICAgICAgIDogYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogMCksIChmcm9tUmlnaHQgPyBsZW5ndGggOiBpbmRleCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGB3cmFwcGVyVmFsdWVgIHdoaWNoIHJldHVybnMgdGhlIHJlc3VsdCBvZlxuICAgICAqIHBlcmZvcm1pbmcgYSBzZXF1ZW5jZSBvZiBhY3Rpb25zIG9uIHRoZSB1bndyYXBwZWQgYHZhbHVlYCwgd2hlcmUgZWFjaFxuICAgICAqIHN1Y2Nlc3NpdmUgYWN0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYWN0aW9ucyBBY3Rpb25zIHRvIHBlcmZvcm0gdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV3JhcHBlclZhbHVlKHZhbHVlLCBhY3Rpb25zKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdmFsdWU7XG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnZhbHVlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UoYWN0aW9ucywgZnVuY3Rpb24ocmVzdWx0LCBhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbi5mdW5jLmFwcGx5KGFjdGlvbi50aGlzQXJnLCBhcnJheVB1c2goW3Jlc3VsdF0sIGFjdGlvbi5hcmdzKSk7XG4gICAgICB9LCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy54b3JgLCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VYb3IoYXJyYXlzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXlzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdFxuICAgICAgICAgID8gYXJyYXlQdXNoKFxuICAgICAgICAgICAgICBiYXNlRGlmZmVyZW5jZShyZXN1bHQsIGFycmF5c1tpbmRleF0sIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSxcbiAgICAgICAgICAgICAgYmFzZURpZmZlcmVuY2UoYXJyYXlzW2luZGV4XSwgcmVzdWx0LCBpdGVyYXRlZSwgY29tcGFyYXRvcilcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGFycmF5c1tpbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gKHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoKSA/IGJhc2VVbmlxKHJlc3VsdCwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnppcE9iamVjdGAgd2hpY2ggYXNzaWducyB2YWx1ZXMgdXNpbmcgYGFzc2lnbkZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduRnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VaaXBPYmplY3QocHJvcHMsIHZhbHVlcywgYXNzaWduRnVuYykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHZhbHNMZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpbmRleCA8IHZhbHNMZW5ndGggPyB2YWx1ZXNbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgICBhc3NpZ25GdW5jKHJlc3VsdCwgcHJvcHNbaW5kZXhdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYW4gZW1wdHkgYXJyYXkgaWYgaXQncyBub3QgYW4gYXJyYXkgbGlrZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyB0aGUgY2FzdCBhcnJheS1saWtlIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0QXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpID8gdmFsdWUgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IHN0cmluZ1RvUGF0aCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdFNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQ7XG4gICAgICByZXR1cm4gKCFzdGFydCAmJiBlbmQgPj0gbGVuZ3RoKSA/IGFycmF5IDogYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2xvYmFsIFtgY2xlYXJUaW1lb3V0YF0oaHR0cHM6Ly9tZG4uaW8vY2xlYXJUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ8T2JqZWN0fSBpZCBUaGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3Qgb2YgdGhlIHRpbWVyIHRvIGNsZWFyLlxuICAgICAqL1xuICAgIHZhciBjbGVhclRpbWVvdXQgPSBjdHhDbGVhclRpbWVvdXQgfHwgZnVuY3Rpb24oaWQpIHtcbiAgICAgIHJldHVybiByb290LmNsZWFyVGltZW91dChpZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBidWZmZXIuY29uc3RydWN0b3IoYnVmZmVyLmxlbmd0aCk7XG4gICAgICBidWZmZXIuY29weShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gICAgICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgbWFwYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIG1hcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZU1hcChtYXAsIGlzRGVlcCwgY2xvbmVGdW5jKSB7XG4gICAgICB2YXIgYXJyYXkgPSBpc0RlZXAgPyBjbG9uZUZ1bmMobWFwVG9BcnJheShtYXApLCB0cnVlKSA6IG1hcFRvQXJyYXkobWFwKTtcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZShhcnJheSwgYWRkTWFwRW50cnksIG5ldyBtYXAuY29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gICAgICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGBzZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc2V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lU2V0KHNldCwgaXNEZWVwLCBjbG9uZUZ1bmMpIHtcbiAgICAgIHZhciBhcnJheSA9IGlzRGVlcCA/IGNsb25lRnVuYyhzZXRUb0FycmF5KHNldCksIHRydWUpIDogc2V0VG9BcnJheShzZXQpO1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKGFycmF5LCBhZGRTZXRFbnRyeSwgbmV3IHNldC5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gICAgICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gICAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICAgIHZhciB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpO1xuXG4gICAgICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcixcbiAgICAgICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICAgICAodmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICF2YWxJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIpIHx8XG4gICAgICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gICAgICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gICAgICpcbiAgICAgKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICAgICAqIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXJcbiAgICAgKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW5bXXxzdHJpbmdbXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgICAgIGxlbmd0aCA9IG9iakNyaXRlcmlhLmxlbmd0aCxcbiAgICAgICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgICAgIHJldHVybiByZXN1bHQgKiAob3JkZXIgPT0gJ2Rlc2MnID8gLTEgOiAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAgICAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgICAgIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMsXG4gICAgICogcGxhY2Vob2xkZXJzLCBhbmQgcHJvdmlkZWQgYXJndW1lbnRzIGludG8gYSBzaW5nbGUgYXJyYXkgb2YgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKSB7XG4gICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZWZ0TGVuZ3RoICsgcmFuZ2VMZW5ndGgpLFxuICAgICAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W2hvbGRlcnNbYXJnc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChyYW5nZUxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXgrK10gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBjb21wb3NlQXJnc2AgZXhjZXB0IHRoYXQgdGhlIGFyZ3VtZW50cyBjb21wb3NpdGlvblxuICAgICAqIGlzIHRhaWxvcmVkIGZvciBgXy5wYXJ0aWFsUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBob2xkZXJzSW5kZXggPSAtMSxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgcmlnaHRJbmRleCA9IC0xLFxuICAgICAgICAgIHJpZ2h0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShyYW5nZUxlbmd0aCArIHJpZ2h0TGVuZ3RoKSxcbiAgICAgICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IHJhbmdlTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IGFyZ3NJbmRleDtcbiAgICAgIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xuICAgICAgICByZXN1bHRbb2Zmc2V0ICsgcmlnaHRJbmRleF0gPSBwYXJ0aWFsc1tyaWdodEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2hvbGRlcnNJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgaWYgKGlzVW5jdXJyaWVkIHx8IGFyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbb2Zmc2V0ICsgaG9sZGVyc1tob2xkZXJzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICAgICAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICAgICAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUgPT09IHVuZGVmaW5lZCA/IHNvdXJjZVtrZXldIDogbmV3VmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgb3duIHN5bWJvbCBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmdyb3VwQnlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBhY2N1bXVsYXRvciB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2luaXRpYWxpemVyXSBUaGUgYWNjdW11bGF0b3Igb2JqZWN0IGluaXRpYWxpemVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFnZ3JlZ2F0b3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRvcihzZXR0ZXIsIGluaXRpYWxpemVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlBZ2dyZWdhdG9yIDogYmFzZUFnZ3JlZ2F0b3IsXG4gICAgICAgICAgICBhY2N1bXVsYXRvciA9IGluaXRpYWxpemVyID8gaW5pdGlhbGl6ZXIoKSA6IHt9O1xuXG4gICAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIHNldHRlciwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBhY2N1bXVsYXRvcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIHRoZSBvcHRpb25hbCBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCaW5kKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5sb3dlckZpcnN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBTdHJpbmdgIGNhc2UgbWV0aG9kIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhc2VGaXJzdChtZXRob2ROYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgICAgICA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIHZhciBjaHIgPSBzdHJTeW1ib2xzXG4gICAgICAgICAgPyBzdHJTeW1ib2xzWzBdXG4gICAgICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xuXG4gICAgICAgIHZhciB0cmFpbGluZyA9IHN0clN5bWJvbHNcbiAgICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKCcnKVxuICAgICAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgICAgIHJldHVybiBjaHJbbWV0aG9kTmFtZV0oKSArIHRyYWlsaW5nO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5jYW1lbENhc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBlYWNoIHdvcmQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBhcnJheVJlZHVjZSh3b3JkcyhkZWJ1cnIoc3RyaW5nKS5yZXBsYWNlKHJlQXBvcywgJycpKSwgY2FsbGJhY2ssICcnKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gaW5zdGFuY2Ugb2YgYEN0b3JgIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgKiB3aGV0aGVyIGl0IHdhcyBpbnZva2VkIGFzIHBhcnQgb2YgYSBgbmV3YCBleHByZXNzaW9uIG9yIGJ5IGBjYWxsYCBvciBgYXBwbHlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdG9yIFRoZSBjb25zdHJ1Y3RvciB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3RvcihDdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFVzZSBhIGBzd2l0Y2hgIHN0YXRlbWVudCB0byB3b3JrIHdpdGggY2xhc3MgY29uc3RydWN0b3JzLiBTZWVcbiAgICAgICAgLy8gaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1mdW5jdGlvbi1vYmplY3RzLWNhbGwtdGhpc2FyZ3VtZW50LWFyZ3VtZW50c2xpc3RcbiAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQ3RvcjtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgICAgICBjYXNlIDc6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdLCBhcmdzWzZdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuXG4gICAgICAgIC8vIE1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBlbmFibGUgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJpdHkgVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KSB7XG4gICAgICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpO1xuXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBob2xkZXJzID0gKGxlbmd0aCA8IDMgJiYgYXJnc1swXSAhPT0gcGxhY2Vob2xkZXIgJiYgYXJnc1tsZW5ndGggLSAxXSAhPT0gcGxhY2Vob2xkZXIpXG4gICAgICAgICAgPyBbXVxuICAgICAgICAgIDogcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuXG4gICAgICAgIGxlbmd0aCAtPSBob2xkZXJzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFyZ3MsIGhvbGRlcnMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSAtIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG4gICAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgICAgIGNvbGxlY3Rpb24gPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gZmluZEluZGV4RnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCk7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gaXRlcmFibGVbaXRlcmF0ZWUgPyBjb2xsZWN0aW9uW2luZGV4XSA6IGluZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZsb3dgIG9yIGBfLmZsb3dSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsb3cgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmxvdyhmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihmdW5jcykge1xuICAgICAgICBmdW5jcyA9IGJhc2VGbGF0dGVuKGZ1bmNzLCAxKTtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gZnVuY3MubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBwcmVyZXEgPSBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS50aHJ1O1xuXG4gICAgICAgIGlmIChmcm9tUmlnaHQpIHtcbiAgICAgICAgICBmdW5jcy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmNzW2luZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJlcmVxICYmICF3cmFwcGVyICYmIGdldEZ1bmNOYW1lKGZ1bmMpID09ICd3cmFwcGVyJykge1xuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBuZXcgTG9kYXNoV3JhcHBlcihbXSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gd3JhcHBlciA/IGluZGV4IDogbGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGZ1bmMgPSBmdW5jc1tpbmRleF07XG5cbiAgICAgICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICAgICAgZGF0YSA9IGZ1bmNOYW1lID09ICd3cmFwcGVyJyA/IGdldERhdGEoZnVuYykgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoZGF0YSAmJiBpc0xhemlhYmxlKGRhdGFbMF0pICYmXG4gICAgICAgICAgICAgICAgZGF0YVsxXSA9PSAoQVJZX0ZMQUcgfCBDVVJSWV9GTEFHIHwgUEFSVElBTF9GTEFHIHwgUkVBUkdfRkxBRykgJiZcbiAgICAgICAgICAgICAgICAhZGF0YVs0XS5sZW5ndGggJiYgZGF0YVs5XSA9PSAxXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgd3JhcHBlciA9IHdyYXBwZXJbZ2V0RnVuY05hbWUoZGF0YVswXSldLmFwcGx5KHdyYXBwZXIsIGRhdGFbM10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gKGZ1bmMubGVuZ3RoID09IDEgJiYgaXNMYXppYWJsZShmdW5jKSlcbiAgICAgICAgICAgICAgPyB3cmFwcGVyW2Z1bmNOYW1lXSgpXG4gICAgICAgICAgICAgIDogd3JhcHBlci50aHJ1KGZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIHZhbHVlID0gYXJnc1swXTtcblxuICAgICAgICAgIGlmICh3cmFwcGVyICYmIGFyZ3MubGVuZ3RoID09IDEgJiZcbiAgICAgICAgICAgICAgaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLnBsYW50KHZhbHVlKS52YWx1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgICByZXN1bHQgPSBsZW5ndGggPyBmdW5jc1tpbmRleF0uYXBwbHkodGhpcywgYXJncykgOiB2YWx1ZTtcblxuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jc1tpbmRleF0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLCBwYXJ0aWFsIGFwcGxpY2F0aW9uLCBhbmQgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc1JpZ2h0XSBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZFxuICAgICAqICB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzUmlnaHRdIFRoZSBgcGFydGlhbHNSaWdodGAgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVIeWJyaWQoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNBcnkgPSBiaXRtYXNrICYgQVJZX0ZMQUcsXG4gICAgICAgICAgaXNCaW5kID0gYml0bWFzayAmIEJJTkRfRkxBRyxcbiAgICAgICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgQklORF9LRVlfRkxBRyxcbiAgICAgICAgICBpc0N1cnJpZWQgPSBiaXRtYXNrICYgKENVUlJZX0ZMQUcgfCBDVVJSWV9SSUdIVF9GTEFHKSxcbiAgICAgICAgICBpc0ZsaXAgPSBiaXRtYXNrICYgRkxJUF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ3VycmllZCkge1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKSxcbiAgICAgICAgICAgICAgaG9sZGVyc0NvdW50ID0gY291bnRIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHMpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxzUmlnaHQpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGlzQ3VycmllZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnNDb3VudDtcbiAgICAgICAgaWYgKGlzQ3VycmllZCAmJiBsZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgIHZhciBuZXdIb2xkZXJzID0gcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgZnVuYywgYml0bWFzaywgY3JlYXRlSHlicmlkLCB3cmFwcGVyLnBsYWNlaG9sZGVyLCB0aGlzQXJnLFxuICAgICAgICAgICAgYXJncywgbmV3SG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5IC0gbGVuZ3RoXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcyxcbiAgICAgICAgICAgIGZuID0gaXNCaW5kS2V5ID8gdGhpc0JpbmRpbmdbZnVuY10gOiBmdW5jO1xuXG4gICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBpZiAoYXJnUG9zKSB7XG4gICAgICAgICAgYXJncyA9IHJlb3JkZXIoYXJncywgYXJnUG9zKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0ZsaXAgJiYgbGVuZ3RoID4gMSkge1xuICAgICAgICAgIGFyZ3MucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FyeSAmJiBhcnkgPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcmdzLmxlbmd0aCA9IGFyeTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSB7XG4gICAgICAgICAgZm4gPSBDdG9yIHx8IGNyZWF0ZUN0b3IoZm4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5pbnZlcnRCeWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0b0l0ZXJhdGVlIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIGl0ZXJhdGVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZlcnRlcihzZXR0ZXIsIHRvSXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIHRvSXRlcmF0ZWUoaXRlcmF0ZWUpLCB7fSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgdXNlZCBmb3IgYHVuZGVmaW5lZGAgYXJndW1lbnRzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1hdGhlbWF0aWNhbCBvcGVyYXRpb24gZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTWF0aE9wZXJhdGlvbihvcGVyYXRvciwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIG90aGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb3RoZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZVRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIG90aGVyID0gYmFzZVRvU3RyaW5nKG90aGVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9OdW1iZXIob3RoZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBvcGVyYXRvcih2YWx1ZSwgb3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLm92ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhcnJheUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBpdGVyYXRlZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgb3ZlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVPdmVyKGFycmF5RnVuYykge1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGl0ZXJhdGVlcykge1xuICAgICAgICBpdGVyYXRlZXMgPSAoaXRlcmF0ZWVzLmxlbmd0aCA9PSAxICYmIGlzQXJyYXkoaXRlcmF0ZWVzWzBdKSlcbiAgICAgICAgICA/IGFycmF5TWFwKGl0ZXJhdGVlc1swXSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKVxuICAgICAgICAgIDogYXJyYXlNYXAoYmFzZUZsYXR0ZW4oaXRlcmF0ZWVzLCAxKSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcblxuICAgICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgIHZhciB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gYXJyYXlGdW5jKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZSwgdGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgcGFkZGluZyBmb3IgYHN0cmluZ2AgYmFzZWQgb24gYGxlbmd0aGAuIFRoZSBgY2hhcnNgIHN0cmluZ1xuICAgICAqIGlzIHRydW5jYXRlZCBpZiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgZXhjZWVkcyBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRpbmcgZm9yIGBzdHJpbmdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhZGRpbmcobGVuZ3RoLCBjaGFycykge1xuICAgICAgY2hhcnMgPSBjaGFycyA9PT0gdW5kZWZpbmVkID8gJyAnIDogYmFzZVRvU3RyaW5nKGNoYXJzKTtcblxuICAgICAgdmFyIGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgICAgaWYgKGNoYXJzTGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gY2hhcnNMZW5ndGggPyBiYXNlUmVwZWF0KGNoYXJzLCBsZW5ndGgpIDogY2hhcnM7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZVJlcGVhdChjaGFycywgbmF0aXZlQ2VpbChsZW5ndGggLyBzdHJpbmdTaXplKGNoYXJzKSkpO1xuICAgICAgcmV0dXJuIGhhc1VuaWNvZGUoY2hhcnMpXG4gICAgICAgID8gY2FzdFNsaWNlKHN0cmluZ1RvQXJyYXkocmVzdWx0KSwgMCwgbGVuZ3RoKS5qb2luKCcnKVxuICAgICAgICA6IHJlc3VsdC5zbGljZSgwLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmdcbiAgICAgKiBvZiBgdGhpc0FyZ2AgYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhcnRpYWwoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZWZ0TGVuZ3RoICsgYXJnc0xlbmd0aCksXG4gICAgICAgICAgICBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG5cbiAgICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4KytdID0gYXJndW1lbnRzWysrYXJnc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZm4sIGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5yYW5nZWAgb3IgYF8ucmFuZ2VSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJhbmdlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgICAgaWYgKHN0ZXAgJiYgdHlwZW9mIHN0ZXAgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgICAgICBlbmQgPSBzdGVwID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAgPSBzdGVwID09PSB1bmRlZmluZWQgPyAoc3RhcnQgPCBlbmQgPyAxIDogLTEpIDogdG9GaW5pdGUoc3RlcCk7XG4gICAgICAgIHJldHVybiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSByZWxhdGlvbmFsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlbGF0aW9uYWwgb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24ob3BlcmF0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnICYmIHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICBvdGhlciA9IHRvTnVtYmVyKG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGNvbnRpbnVlIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgYGZ1bmNgIHdyYXBwZXIuXG4gICAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlY3VycnkoZnVuYywgYml0bWFzaywgd3JhcEZ1bmMsIHBsYWNlaG9sZGVyLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNDdXJyeSA9IGJpdG1hc2sgJiBDVVJSWV9GTEFHLFxuICAgICAgICAgIG5ld0hvbGRlcnMgPSBpc0N1cnJ5ID8gaG9sZGVycyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBuZXdIb2xkZXJzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogaG9sZGVycyxcbiAgICAgICAgICBuZXdQYXJ0aWFscyA9IGlzQ3VycnkgPyBwYXJ0aWFscyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBuZXdQYXJ0aWFsc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IHBhcnRpYWxzO1xuXG4gICAgICBiaXRtYXNrIHw9IChpc0N1cnJ5ID8gUEFSVElBTF9GTEFHIDogUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgIGJpdG1hc2sgJj0gfihpc0N1cnJ5ID8gUEFSVElBTF9SSUdIVF9GTEFHIDogUEFSVElBTF9GTEFHKTtcblxuICAgICAgaWYgKCEoYml0bWFzayAmIENVUlJZX0JPVU5EX0ZMQUcpKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihCSU5EX0ZMQUcgfCBCSU5EX0tFWV9GTEFHKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdEYXRhID0gW1xuICAgICAgICBmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBuZXdQYXJ0aWFscywgbmV3SG9sZGVycywgbmV3UGFydGlhbHNSaWdodCxcbiAgICAgICAgbmV3SG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgICAgIF07XG5cbiAgICAgIHZhciByZXN1bHQgPSB3cmFwRnVuYy5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgaWYgKGlzTGF6aWFibGUoZnVuYykpIHtcbiAgICAgICAgc2V0RGF0YShyZXN1bHQsIG5ld0RhdGEpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gc2V0V3JhcFRvU3RyaW5nKHJlc3VsdCwgZnVuYywgYml0bWFzayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ucm91bmRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYE1hdGhgIG1ldGhvZCB0byB1c2Ugd2hlbiByb3VuZGluZy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSb3VuZChtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IE1hdGhbbWV0aG9kTmFtZV07XG4gICAgICByZXR1cm4gZnVuY3Rpb24obnVtYmVyLCBwcmVjaXNpb24pIHtcbiAgICAgICAgbnVtYmVyID0gdG9OdW1iZXIobnVtYmVyKTtcbiAgICAgICAgcHJlY2lzaW9uID0gbmF0aXZlTWluKHRvSW50ZWdlcihwcmVjaXNpb24pLCAyOTIpO1xuICAgICAgICBpZiAocHJlY2lzaW9uKSB7XG4gICAgICAgICAgLy8gU2hpZnQgd2l0aCBleHBvbmVudGlhbCBub3RhdGlvbiB0byBhdm9pZCBmbG9hdGluZy1wb2ludCBpc3N1ZXMuXG4gICAgICAgICAgLy8gU2VlIFtNRE5dKGh0dHBzOi8vbWRuLmlvL3JvdW5kI0V4YW1wbGVzKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgIHZhciBwYWlyID0gKHRvU3RyaW5nKG51bWJlcikgKyAnZScpLnNwbGl0KCdlJyksXG4gICAgICAgICAgICAgIHZhbHVlID0gZnVuYyhwYWlyWzBdICsgJ2UnICsgKCtwYWlyWzFdICsgcHJlY2lzaW9uKSk7XG5cbiAgICAgICAgICBwYWlyID0gKHRvU3RyaW5nKHZhbHVlKSArICdlJykuc3BsaXQoJ2UnKTtcbiAgICAgICAgICByZXR1cm4gKyhwYWlyWzBdICsgJ2UnICsgKCtwYWlyWzFdIC0gcHJlY2lzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMobnVtYmVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNldCBvYmplY3Qgb2YgYHZhbHVlc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFkZCB0byB0aGUgc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gICAgICovXG4gICAgdmFyIGNyZWF0ZVNldCA9ICEoU2V0ICYmICgxIC8gc2V0VG9BcnJheShuZXcgU2V0KFssLTBdKSlbMV0pID09IElORklOSVRZKSA/IG5vb3AgOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy50b1BhaXJzYCBvciBgXy50b1BhaXJzSW5gIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhaXJzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVRvUGFpcnMoa2V5c0Z1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyhvYmplY3QpO1xuICAgICAgICBpZiAodGFnID09IG1hcFRhZykge1xuICAgICAgICAgIHJldHVybiBtYXBUb0FycmF5KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VG9QYWlycyhvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlVG9QYWlycyhvYmplY3QsIGtleXNGdW5jKG9iamVjdCkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYCB3aXRoIG9wdGlvbmFsXG4gICAgICogYHRoaXNgIGJpbmRpbmcgYW5kIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAgICogIFRoZSBiaXRtYXNrIG1heSBiZSBjb21wb3NlZCBvZiB0aGUgZm9sbG93aW5nIGZsYWdzOlxuICAgICAqICAgICAxIC0gYF8uYmluZGBcbiAgICAgKiAgICAgMiAtIGBfLmJpbmRLZXlgXG4gICAgICogICAgIDQgLSBgXy5jdXJyeWAgb3IgYF8uY3VycnlSaWdodGAgb2YgYSBib3VuZCBmdW5jdGlvblxuICAgICAqICAgICA4IC0gYF8uY3VycnlgXG4gICAgICogICAgMTYgLSBgXy5jdXJyeVJpZ2h0YFxuICAgICAqICAgIDMyIC0gYF8ucGFydGlhbGBcbiAgICAgKiAgICA2NCAtIGBfLnBhcnRpYWxSaWdodGBcbiAgICAgKiAgIDEyOCAtIGBfLnJlYXJnYFxuICAgICAqICAgMjU2IC0gYF8uYXJ5YFxuICAgICAqICAgNTEyIC0gYF8uZmxpcGBcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0JpbmRLZXkgPSBiaXRtYXNrICYgQklORF9LRVlfRkxBRztcbiAgICAgIGlmICghaXNCaW5kS2V5ICYmIHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IHBhcnRpYWxzID8gcGFydGlhbHMubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihQQVJUSUFMX0ZMQUcgfCBQQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnkgPSBhcnkgPT09IHVuZGVmaW5lZCA/IGFyeSA6IG5hdGl2ZU1heCh0b0ludGVnZXIoYXJ5KSwgMCk7XG4gICAgICBhcml0eSA9IGFyaXR5ID09PSB1bmRlZmluZWQgPyBhcml0eSA6IHRvSW50ZWdlcihhcml0eSk7XG4gICAgICBsZW5ndGggLT0gaG9sZGVycyA/IGhvbGRlcnMubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKGJpdG1hc2sgJiBQQVJUSUFMX1JJR0hUX0ZMQUcpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxzUmlnaHQgPSBwYXJ0aWFscyxcbiAgICAgICAgICAgIGhvbGRlcnNSaWdodCA9IGhvbGRlcnM7XG5cbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBnZXREYXRhKGZ1bmMpO1xuXG4gICAgICB2YXIgbmV3RGF0YSA9IFtcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCxcbiAgICAgICAgYXJnUG9zLCBhcnksIGFyaXR5XG4gICAgICBdO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBtZXJnZURhdGEobmV3RGF0YSwgZGF0YSk7XG4gICAgICB9XG4gICAgICBmdW5jID0gbmV3RGF0YVswXTtcbiAgICAgIGJpdG1hc2sgPSBuZXdEYXRhWzFdO1xuICAgICAgdGhpc0FyZyA9IG5ld0RhdGFbMl07XG4gICAgICBwYXJ0aWFscyA9IG5ld0RhdGFbM107XG4gICAgICBob2xkZXJzID0gbmV3RGF0YVs0XTtcbiAgICAgIGFyaXR5ID0gbmV3RGF0YVs5XSA9IG5ld0RhdGFbOV0gPT0gbnVsbFxuICAgICAgICA/IChpc0JpbmRLZXkgPyAwIDogZnVuYy5sZW5ndGgpXG4gICAgICAgIDogbmF0aXZlTWF4KG5ld0RhdGFbOV0gLSBsZW5ndGgsIDApO1xuXG4gICAgICBpZiAoIWFyaXR5ICYmIGJpdG1hc2sgJiAoQ1VSUllfRkxBRyB8IENVUlJZX1JJR0hUX0ZMQUcpKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihDVVJSWV9GTEFHIHwgQ1VSUllfUklHSFRfRkxBRyk7XG4gICAgICB9XG4gICAgICBpZiAoIWJpdG1hc2sgfHwgYml0bWFzayA9PSBCSU5EX0ZMQUcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZyk7XG4gICAgICB9IGVsc2UgaWYgKGJpdG1hc2sgPT0gQ1VSUllfRkxBRyB8fCBiaXRtYXNrID09IENVUlJZX1JJR0hUX0ZMQUcpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpO1xuICAgICAgfSBlbHNlIGlmICgoYml0bWFzayA9PSBQQVJUSUFMX0ZMQUcgfHwgYml0bWFzayA9PSAoQklORF9GTEFHIHwgUEFSVElBTF9GTEFHKSkgJiYgIWhvbGRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVBhcnRpYWwoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlSHlicmlkLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gICAgICB9XG4gICAgICB2YXIgc2V0dGVyID0gZGF0YSA/IGJhc2VTZXREYXRhIDogc2V0RGF0YTtcbiAgICAgIHJldHVybiBzZXRXcmFwVG9TdHJpbmcoc2V0dGVyKHJlc3VsdCwgbmV3RGF0YSksIGZ1bmMsIGJpdG1hc2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcbiAgICAgKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUcsXG4gICAgICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICAgICAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gICAgICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgICAgICBzZWVuID0gKGJpdG1hc2sgJiBVTk9SREVSRURfQ09NUEFSRV9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICAgICAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gICAgICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAgICAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWVuLmhhcyhvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5hZGQob3RoSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICAgICAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcbiAgICAgKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRztcbiAgICAgICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYml0bWFzayB8PSBVTk9SREVSRURfQ09NUEFSRV9GTEFHO1xuXG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbiAgICAgICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYFxuICAgICAqICBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUcsXG4gICAgICAgICAgb2JqUHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgICAgIG90aFByb3BzID0ga2V5cyhvdGhlciksXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gICAgICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gICAgICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgICAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSlcbiAgICAgICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgICAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGdldERhdGEgPSAhbWV0YU1hcCA/IG5vb3AgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICByZXR1cm4gbWV0YU1hcC5nZXQoZnVuYyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWUgb2YgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZ1bmNOYW1lKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSAoZnVuYy5uYW1lICsgJycpLFxuICAgICAgICAgIGFycmF5ID0gcmVhbE5hbWVzW3Jlc3VsdF0sXG4gICAgICAgICAgbGVuZ3RoID0gaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIHJlc3VsdCkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBhcnJheVtsZW5ndGhdLFxuICAgICAgICAgICAgb3RoZXJGdW5jID0gZGF0YS5mdW5jO1xuICAgICAgICBpZiAob3RoZXJGdW5jID09IG51bGwgfHwgb3RoZXJGdW5jID09IGZ1bmMpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YS5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFyZ3VtZW50IHBsYWNlaG9sZGVyIHZhbHVlIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEhvbGRlcihmdW5jKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gsICdwbGFjZWhvbGRlcicpID8gbG9kYXNoIDogZnVuYztcbiAgICAgIHJldHVybiBvYmplY3QucGxhY2Vob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpdGVyYXRlZVwiIGZ1bmN0aW9uLiBJZiBgXy5pdGVyYXRlZWAgaXMgY3VzdG9taXplZCxcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBiYXNlSXRlcmF0ZWVgLlxuICAgICAqIElmIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIHRoZSBjaG9zZW4gZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIHRoZW0gYW5kXG4gICAgICogaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiB0aGUgY3JlYXRlZCBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNob3NlbiBmdW5jdGlvbiBvciBpdHMgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEl0ZXJhdGVlKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaC5pdGVyYXRlZSB8fCBpdGVyYXRlZTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gaXRlcmF0ZWUgPyBiYXNlSXRlcmF0ZWUgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHJlc3VsdChhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgICAgIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgICAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgICAgICA6IGRhdGEubWFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICAgICAqL1xuICAgIHZhciBnZXRTeW1ib2xzID0gbmF0aXZlR2V0U3ltYm9scyA/IG92ZXJBcmcobmF0aXZlR2V0U3ltYm9scywgT2JqZWN0KSA6IHN0dWJBcnJheTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9sIHByb3BlcnRpZXNcbiAgICAgKiBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAgICAgKi9cbiAgICB2YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHdoaWxlIChvYmplY3QpIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICAgICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgdmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbiAgICAvLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSxcbiAgICAvLyBmb3IgZGF0YSB2aWV3cyBpbiBFZGdlIDwgMTQsIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzLlxuICAgIGlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAgICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgICAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAgICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICAgICAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpLFxuICAgICAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2aWV3LCBhcHBseWluZyBhbnkgYHRyYW5zZm9ybXNgIHRvIHRoZSBgc3RhcnRgIGFuZCBgZW5kYCBwb3NpdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRyYW5zZm9ybXMgVGhlIHRyYW5zZm9ybWF0aW9ucyB0byBhcHBseSB0byB0aGUgdmlldy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgc3RhcnRgIGFuZCBgZW5kYFxuICAgICAqICBwb3NpdGlvbnMgb2YgdGhlIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VmlldyhzdGFydCwgZW5kLCB0cmFuc2Zvcm1zKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0cmFuc2Zvcm1zW2luZGV4XSxcbiAgICAgICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdkcm9wJzogICAgICBzdGFydCArPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICdkcm9wUmlnaHQnOiBlbmQgLT0gc2l6ZTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFrZSc6ICAgICAgZW5kID0gbmF0aXZlTWluKGVuZCwgc3RhcnQgKyBzaXplKTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFrZVJpZ2h0Jzogc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQsIGVuZCAtIHNpemUpOyBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgJ3N0YXJ0Jzogc3RhcnQsICdlbmQnOiBlbmQgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB3cmFwcGVyIGRldGFpbHMgZnJvbSB0aGUgYHNvdXJjZWAgYm9keSBjb21tZW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFRoZSBzb3VyY2UgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdyYXBwZXIgZGV0YWlscy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRXcmFwRGV0YWlscyhzb3VyY2UpIHtcbiAgICAgIHZhciBtYXRjaCA9IHNvdXJjZS5tYXRjaChyZVdyYXBEZXRhaWxzKTtcbiAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KHJlU3BsaXREZXRhaWxzKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gICAgICBwYXRoID0gaXNLZXkocGF0aCwgb2JqZWN0KSA/IFtwYXRoXSA6IGNhc3RQYXRoKHBhdGgpO1xuXG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IG9iamVjdCA/IG9iamVjdC5sZW5ndGggOiAwO1xuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgICAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgICAgIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgICAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICAgICAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICAgICAgOiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICAgICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGNsb25lRnVuYywgaXNEZWVwKSB7XG4gICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICAgICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICAgICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVNYXAob2JqZWN0LCBpc0RlZXAsIGNsb25lRnVuYyk7XG5cbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVNldChvYmplY3QsIGlzRGVlcCwgY2xvbmVGdW5jKTtcblxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHdyYXBwZXIgYGRldGFpbHNgIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBgc291cmNlYCBib2R5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFRoZSBzb3VyY2UgdG8gbW9kaWZ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gZGV0YWlscyBUaGUgZGV0YWlscyB0byBpbnNlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbW9kaWZpZWQgc291cmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgZGV0YWlscykge1xuICAgICAgdmFyIGxlbmd0aCA9IGRldGFpbHMubGVuZ3RoLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgICAgIGRldGFpbHNbbGFzdEluZGV4XSA9IChsZW5ndGggPiAxID8gJyYgJyA6ICcnKSArIGRldGFpbHNbbGFzdEluZGV4XTtcbiAgICAgIGRldGFpbHMgPSBkZXRhaWxzLmpvaW4obGVuZ3RoID4gMiA/ICcsICcgOiAnICcpO1xuICAgICAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKHJlV3JhcENvbW1lbnQsICd7XFxuLyogW3dyYXBwZWQgd2l0aCAnICsgZGV0YWlscyArICddICovXFxuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gICAgICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICAgICApIHtcbiAgICAgICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgICAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICAgICAgOiAodmFsdWUgPT09IG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMYXppYWJsZShmdW5jKSB7XG4gICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICBvdGhlciA9IGxvZGFzaFtmdW5jTmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgIT0gJ2Z1bmN0aW9uJyB8fCAhKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGZ1bmMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBnZXREYXRhKG90aGVyKTtcbiAgICAgIHJldHVybiAhIWRhdGEgJiYgZnVuYyA9PT0gZGF0YVswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gICAgICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaXMgY2FwYWJsZSBvZiBiZWluZyBtYXNrZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2FibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICB2YXIgaXNNYXNrYWJsZSA9IGNvcmVKc0RhdGEgPyBpc0Z1bmN0aW9uIDogc3R1YkZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICAgICAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICAgICAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gICAgICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gICAgICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdGhlIGZ1bmN0aW9uIG1ldGFkYXRhIG9mIGBzb3VyY2VgIGludG8gYGRhdGFgLlxuICAgICAqXG4gICAgICogTWVyZ2luZyBtZXRhZGF0YSByZWR1Y2VzIHRoZSBudW1iZXIgb2Ygd3JhcHBlcnMgdXNlZCB0byBpbnZva2UgYSBmdW5jdGlvbi5cbiAgICAgKiBUaGlzIGlzIHBvc3NpYmxlIGJlY2F1c2UgbWV0aG9kcyBsaWtlIGBfLmJpbmRgLCBgXy5jdXJyeWAsIGFuZCBgXy5wYXJ0aWFsYFxuICAgICAqIG1heSBiZSBhcHBsaWVkIHJlZ2FyZGxlc3Mgb2YgZXhlY3V0aW9uIG9yZGVyLiBNZXRob2RzIGxpa2UgYF8uYXJ5YCBhbmRcbiAgICAgKiBgXy5yZWFyZ2AgbW9kaWZ5IGZ1bmN0aW9uIGFyZ3VtZW50cywgbWFraW5nIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFyZVxuICAgICAqIGV4ZWN1dGVkIGltcG9ydGFudCwgcHJldmVudGluZyB0aGUgbWVyZ2luZyBvZiBtZXRhZGF0YS4gSG93ZXZlciwgd2UgbWFrZVxuICAgICAqIGFuIGV4Y2VwdGlvbiBmb3IgYSBzYWZlIGNvbWJpbmVkIGNhc2Ugd2hlcmUgY3VycmllZCBmdW5jdGlvbnMgaGF2ZSBgXy5hcnlgXG4gICAgICogYW5kIG9yIGBfLnJlYXJnYCBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIFRoZSBkZXN0aW5hdGlvbiBtZXRhZGF0YS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIHNvdXJjZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRhdGFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlRGF0YShkYXRhLCBzb3VyY2UpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gZGF0YVsxXSxcbiAgICAgICAgICBzcmNCaXRtYXNrID0gc291cmNlWzFdLFxuICAgICAgICAgIG5ld0JpdG1hc2sgPSBiaXRtYXNrIHwgc3JjQml0bWFzayxcbiAgICAgICAgICBpc0NvbW1vbiA9IG5ld0JpdG1hc2sgPCAoQklORF9GTEFHIHwgQklORF9LRVlfRkxBRyB8IEFSWV9GTEFHKTtcblxuICAgICAgdmFyIGlzQ29tYm8gPVxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IENVUlJZX0ZMQUcpKSB8fFxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFJFQVJHX0ZMQUcpICYmIChkYXRhWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pKSB8fFxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gKEFSWV9GTEFHIHwgUkVBUkdfRkxBRykpICYmIChzb3VyY2VbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkgJiYgKGJpdG1hc2sgPT0gQ1VSUllfRkxBRykpO1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIG1ldGFkYXRhIGNhbid0IGJlIG1lcmdlZC5cbiAgICAgIGlmICghKGlzQ29tbW9uIHx8IGlzQ29tYm8pKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgdGhpc0FyZ2AgaWYgYXZhaWxhYmxlLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBCSU5EX0ZMQUcpIHtcbiAgICAgICAgZGF0YVsyXSA9IHNvdXJjZVsyXTtcbiAgICAgICAgLy8gU2V0IHdoZW4gY3VycnlpbmcgYSBib3VuZCBmdW5jdGlvbi5cbiAgICAgICAgbmV3Qml0bWFzayB8PSBiaXRtYXNrICYgQklORF9GTEFHID8gMCA6IENVUlJZX0JPVU5EX0ZMQUc7XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgYXJndW1lbnRzLlxuICAgICAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0aWFscyA9IGRhdGFbM107XG4gICAgICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzRdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzNdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNF07XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbNV07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcGFydGlhbHMgPSBkYXRhWzVdO1xuICAgICAgICBkYXRhWzVdID0gcGFydGlhbHMgPyBjb21wb3NlQXJnc1JpZ2h0KHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzZdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzZdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzVdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNl07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcmdQb3NgIGlmIGF2YWlsYWJsZS5cbiAgICAgIHZhbHVlID0gc291cmNlWzddO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRhdGFbN10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyeWAgaWYgaXQncyBzbWFsbGVyLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBBUllfRkxBRykge1xuICAgICAgICBkYXRhWzhdID0gZGF0YVs4XSA9PSBudWxsID8gc291cmNlWzhdIDogbmF0aXZlTWluKGRhdGFbOF0sIHNvdXJjZVs4XSk7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcml0eWAgaWYgb25lIGlzIG5vdCBwcm92aWRlZC5cbiAgICAgIGlmIChkYXRhWzldID09IG51bGwpIHtcbiAgICAgICAgZGF0YVs5XSA9IHNvdXJjZVs5XTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGZ1bmNgIGFuZCBtZXJnZSBiaXRtYXNrcy5cbiAgICAgIGRhdGFbMF0gPSBzb3VyY2VbMF07XG4gICAgICBkYXRhWzFdID0gbmV3Qml0bWFzaztcblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c0RlZXBgIHRvIGN1c3RvbWl6ZSBpdHMgYF8ubWVyZ2VgIHVzZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHBhcmVudCBvYmplY3Qgb2YgYHNyY1ZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZURlZmF1bHRzKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIHtcbiAgICAgIGlmIChpc09iamVjdChvYmpWYWx1ZSkgJiYgaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG9ialZhbHVlKTtcbiAgICAgICAgYmFzZU1lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwgdW5kZWZpbmVkLCBtZXJnZURlZmF1bHRzLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gICAgICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICAgICAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBhcmVudCB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIGdldCB0aGUgcGFyZW50IHZhbHVlIG9mLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwYXJlbnQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyZW50KG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoID09IDEgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVvcmRlciBgYXJyYXlgIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGluZGV4ZXMgd2hlcmUgdGhlIGVsZW1lbnQgYXRcbiAgICAgKiB0aGUgZmlyc3QgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIGZpcnN0IGVsZW1lbnQsIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIHNlY29uZCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgc2Vjb25kIGVsZW1lbnQsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHJlb3JkZXIuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJyYXkgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW9yZGVyKGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihpbmRleGVzLmxlbmd0aCwgYXJyTGVuZ3RoKSxcbiAgICAgICAgICBvbGRBcnJheSA9IGNvcHlBcnJheShhcnJheSk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgIGFycmF5W2xlbmd0aF0gPSBpc0luZGV4KGluZGV4LCBhcnJMZW5ndGgpID8gb2xkQXJyYXlbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiB0aGlzIGZ1bmN0aW9uIGJlY29tZXMgaG90LCBpLmUuIGlzIGludm9rZWQgYSBsb3QgaW4gYSBzaG9ydFxuICAgICAqIHBlcmlvZCBvZiB0aW1lLCBpdCB3aWxsIHRyaXAgaXRzIGJyZWFrZXIgYW5kIHRyYW5zaXRpb24gdG8gYW4gaWRlbnRpdHlcbiAgICAgKiBmdW5jdGlvbiB0byBhdm9pZCBnYXJiYWdlIGNvbGxlY3Rpb24gcGF1c2VzIGluIFY4LiBTZWVcbiAgICAgKiBbVjggaXNzdWUgMjA3MF0oaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjA3MClcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldERhdGEgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgc3RhbXAgPSBub3coKSxcbiAgICAgICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlU2V0RGF0YShrZXksIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIHdyYXBwZXIgYXJvdW5kIHRoZSBnbG9iYWwgW2BzZXRUaW1lb3V0YF0oaHR0cHM6Ly9tZG4uaW8vc2V0VGltZW91dCkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcnxPYmplY3R9IFJldHVybnMgdGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciBzZXRUaW1lb3V0ID0gY3R4U2V0VGltZW91dCB8fCBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgICByZXR1cm4gcm9vdC5zZXRUaW1lb3V0KGZ1bmMsIHdhaXQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgd3JhcHBlcmAgdG8gbWltaWMgdGhlIHNvdXJjZSBvZiBgcmVmZXJlbmNlYFxuICAgICAqIHdpdGggd3JhcHBlciBkZXRhaWxzIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBzb3VyY2UgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlZmVyZW5jZSBUaGUgcmVmZXJlbmNlIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGB3cmFwcGVyYC5cbiAgICAgKi9cbiAgICB2YXIgc2V0V3JhcFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbih3cmFwcGVyLCByZWZlcmVuY2UsIGJpdG1hc2spIHtcbiAgICAgIHZhciBzb3VyY2UgPSAocmVmZXJlbmNlICsgJycpO1xuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KHdyYXBwZXIsICd0b1N0cmluZycsIHtcbiAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgICAgICd2YWx1ZSc6IGNvbnN0YW50KGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgdXBkYXRlV3JhcERldGFpbHMoZ2V0V3JhcERldGFpbHMoc291cmNlKSwgYml0bWFzaykpKVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIHZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplKGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKHJlTGVhZGluZ0RvdC50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goJycpO1xuICAgICAgfVxuICAgICAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgICAgICByZXN1bHQucHVzaChxdW90ZSA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgICAgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgICAgIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgd3JhcHBlciBgZGV0YWlsc2AgYmFzZWQgb24gYGJpdG1hc2tgIGZsYWdzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkZXRhaWxzYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVXcmFwRGV0YWlscyhkZXRhaWxzLCBiaXRtYXNrKSB7XG4gICAgICBhcnJheUVhY2god3JhcEZsYWdzLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICdfLicgKyBwYWlyWzBdO1xuICAgICAgICBpZiAoKGJpdG1hc2sgJiBwYWlyWzFdKSAmJiAhYXJyYXlJbmNsdWRlcyhkZXRhaWxzLCB2YWx1ZSkpIHtcbiAgICAgICAgICBkZXRhaWxzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkZXRhaWxzLnNvcnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHdyYXBwZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gd3JhcHBlciBUaGUgd3JhcHBlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgd3JhcHBlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2xvbmUod3JhcHBlcikge1xuICAgICAgaWYgKHdyYXBwZXIgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICByZXR1cm4gd3JhcHBlci5jbG9uZSgpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZXIuX193cmFwcGVkX18sIHdyYXBwZXIuX19jaGFpbl9fKTtcbiAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh3cmFwcGVyLl9fYWN0aW9uc19fKTtcbiAgICAgIHJlc3VsdC5fX2luZGV4X18gID0gd3JhcHBlci5fX2luZGV4X187XG4gICAgICByZXN1bHQuX192YWx1ZXNfXyA9IHdyYXBwZXIuX192YWx1ZXNfXztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIGdyb3VwcyB0aGUgbGVuZ3RoIG9mIGBzaXplYC5cbiAgICAgKiBJZiBgYXJyYXlgIGNhbid0IGJlIHNwbGl0IGV2ZW5seSwgdGhlIGZpbmFsIGNodW5rIHdpbGwgYmUgdGhlIHJlbWFpbmluZ1xuICAgICAqIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTFdIFRoZSBsZW5ndGggb2YgZWFjaCBjaHVua1xuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY2h1bmtzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAyKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InXSwgWydjJywgJ2QnXV1cbiAgICAgKlxuICAgICAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDMpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYicsICdjJ10sIFsnZCddXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNodW5rKGFycmF5LCBzaXplLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzaXplLCBndWFyZCkgOiBzaXplID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHNpemUgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IG5hdGl2ZU1heCh0b0ludGVnZXIoc2l6ZSksIDApO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoIHx8IHNpemUgPCAxKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG5hdGl2ZUNlaWwobGVuZ3RoIC8gc2l6ZSkpO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gYmFzZVNsaWNlKGFycmF5LCBpbmRleCwgKGluZGV4ICs9IHNpemUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxuICAgICAqIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCwgYW5kIGBOYU5gIGFyZSBmYWxzZXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29tcGFjdChbMCwgMSwgZmFsc2UsIDIsICcnLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFycmF5IGNvbmNhdGVuYXRpbmcgYGFycmF5YCB3aXRoIGFueSBhZGRpdGlvbmFsIGFycmF5c1xuICAgICAqIGFuZC9vciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGNvbmNhdGVuYXRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzFdO1xuICAgICAqIHZhciBvdGhlciA9IF8uY29uY2F0KGFycmF5LCAyLCBbM10sIFtbNF1dKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG90aGVyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGggPyBsZW5ndGggLSAxIDogMCksXG4gICAgICAgICAgYXJyYXkgPSBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIGFyZ3NbaW5kZXggLSAxXSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVuZ3RoXG4gICAgICAgID8gYXJyYXlQdXNoKGlzQXJyYXkoYXJyYXkpID8gY29weUFycmF5KGFycmF5KSA6IFthcnJheV0sIGJhc2VGbGF0dGVuKGFyZ3MsIDEpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgYGFycmF5YCB2YWx1ZXMgbm90IGluY2x1ZGVkIGluIHRoZSBvdGhlciBnaXZlbiBhcnJheXNcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGVcbiAgICAgKiBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBmaXJzdCBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy53aXRob3V0LCBfLnhvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2UoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGlmZmVyZW5jZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBSZXN1bHQgdmFsdWVzIGFyZSBjaG9zZW4gZnJvbSB0aGUgZmlyc3QgYXJyYXkuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxCeWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZGlmZmVyZW5jZUJ5KFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgW3sgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KHZhbHVlcyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kaWZmZXJlbmNlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgIHRvIGB2YWx1ZXNgLiBSZXN1bHQgdmFsdWVzXG4gICAgICogYXJlIGNob3NlbiBmcm9tIHRoZSBmaXJzdCBhcnJheS4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6XG4gICAgICogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbFdpdGhgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlV2l0aChvYmplY3RzLCBbeyAneCc6IDEsICd5JzogMiB9XSwgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdCh2YWx1ZXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGNvbXBhcmF0b3IpKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3AoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgbiA9IGxlbmd0aCAtIG47XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldXG4gICAgICogIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGxzIGVsZW1lbnRzIG9mIGBhcnJheWAgd2l0aCBgdmFsdWVgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdFxuICAgICAqIGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLmZpbGwoYXJyYXksICdhJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdhJywgJ2EnXVxuICAgICAqXG4gICAgICogXy5maWxsKEFycmF5KDMpLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgMiwgMl1cbiAgICAgKlxuICAgICAqIF8uZmlsbChbNCwgNiwgOCwgMTBdLCAnKicsIDEsIDMpO1xuICAgICAqIC8vID0+IFs0LCAnKicsICcqJywgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgJiYgdHlwZW9mIHN0YXJ0ICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV1cbiAgICAgKiAgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldXG4gICAgICogIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAncGViYmxlcyc7IH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGggLSAxO1xuICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4IDwgMFxuICAgICAgICAgID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKVxuICAgICAgICAgIDogbmF0aXZlTWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgMSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmbGF0dGVucyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZWVwKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDQsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkRlZXAoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIElORklOSVRZKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYGFycmF5YCB1cCB0byBgZGVwdGhgIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD0xXSBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgWzIsIFszLCBbNF1dLCA1XV07XG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZXB0aChhcnJheSwgMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVwdGgoYXJyYXksIDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF0sIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkRlcHRoKGFycmF5LCBkZXB0aCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGRlcHRoID0gZGVwdGggPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGgpO1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8udG9QYWlyc2A7IHRoaXMgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkXG4gICAgICogZnJvbSBrZXktdmFsdWUgYHBhaXJzYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIFRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mcm9tUGFpcnMoW1snYScsIDFdLCBbJ2InLCAyXV0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21QYWlycyhwYWlycykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGFpcnMgPyBwYWlycy5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0W3BhaXJbMF1dID0gcGFpclsxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIGZpcnN0XG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaGVhZChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uaGVhZChbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGVhZChhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCBpbiBgYXJyYXlgXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXMgdGhlXG4gICAgICogb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDAsIC0xKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGFyZSBpbmNsdWRlZCBpbiBhbGwgZ2l2ZW4gYXJyYXlzXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlXG4gICAgICogb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgZmlyc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb24oWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsyXVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBSZXN1bHQgdmFsdWVzIGFyZSBjaG9zZW4gZnJvbSB0aGUgZmlyc3QgYXJyYXkuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH1dXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbkJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyksXG4gICAgICAgICAgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcblxuICAgICAgaWYgKGl0ZXJhdGVlID09PSBsYXN0KG1hcHBlZCkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gUmVzdWx0IHZhbHVlcyBhcmUgY2hvc2VuXG4gICAgICogZnJvbSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBjb21wYXJhdG9yIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuICAgICAqIChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9XVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKSxcbiAgICAgICAgICBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuXG4gICAgICBpZiAoY29tcGFyYXRvciA9PT0gbGFzdChtYXBwZWQpKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFsbCBlbGVtZW50cyBpbiBgYXJyYXlgIGludG8gYSBzdHJpbmcgc2VwYXJhdGVkIGJ5IGBzZXBhcmF0b3JgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzZXBhcmF0b3I9JywnXSBUaGUgZWxlbWVudCBzZXBhcmF0b3IuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgam9pbmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5qb2luKFsnYScsICdiJywgJ2MnXSwgJ34nKTtcbiAgICAgKiAvLyA9PiAnYX5ifmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gam9pbihhcnJheSwgc2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gYXJyYXkgPyBuYXRpdmVKb2luLmNhbGwoYXJyYXksIHNlcGFyYXRvcikgOiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBhcnJheWAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiAvLyBTZWFyY2ggZnJvbSB0aGUgYGZyb21JbmRleGAuXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgICBpbmRleCA9IChcbiAgICAgICAgICBpbmRleCA8IDBcbiAgICAgICAgICAgID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKVxuICAgICAgICAgICAgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpXG4gICAgICAgICkgKyAxO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBpbmRleCAtIDEsIHRydWUpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBlbGVtZW50IGF0IGluZGV4IGBuYCBvZiBgYXJyYXlgLiBJZiBgbmAgaXMgbmVnYXRpdmUsIHRoZSBudGhcbiAgICAgKiBlbGVtZW50IGZyb20gdGhlIGVuZCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjExLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG50aCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCddO1xuICAgICAqXG4gICAgICogXy5udGgoYXJyYXksIDEpO1xuICAgICAqIC8vID0+ICdiJ1xuICAgICAqXG4gICAgICogXy5udGgoYXJyYXksIC0yKTtcbiAgICAgKiAvLyA9PiAnYyc7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbnRoKGFycmF5LCBuKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlTnRoKGFycmF5LCB0b0ludGVnZXIobikpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGdpdmVuIHZhbHVlcyBmcm9tIGBhcnJheWAgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ud2l0aG91dGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnJlbW92ZWBcbiAgICAgKiB0byByZW1vdmUgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSBwcmVkaWNhdGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnYScsICdiJywgJ2MnXTtcbiAgICAgKlxuICAgICAqIF8ucHVsbChhcnJheSwgJ2EnLCAnYycpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnYiddXG4gICAgICovXG4gICAgdmFyIHB1bGwgPSBiYXNlUmVzdChwdWxsQWxsKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnYScsICdiJywgJ2MnXTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbChhcnJheSwgWydhJywgJ2MnXSk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYicsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsQWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBhbmQgYHZhbHVlc2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlQnlgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMyB9LCB7ICd4JzogMSB9XTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbEJ5KGFycmF5LCBbeyAneCc6IDEgfSwgeyAneCc6IDMgfV0sICd4Jyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGxCeShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbEFsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YCB0byBgdmFsdWVzYC4gVGhlIGNvbXBhcmF0b3IgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZVdpdGhgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDMsICd5JzogNCB9LCB7ICd4JzogNSwgJ3knOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsV2l0aChhcnJheSwgW3sgJ3gnOiAzLCAneSc6IDQgfV0sIF8uaXNFcXVhbCk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiA1LCAneSc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsV2l0aChhcnJheSwgdmFsdWVzLCBjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIGBhcnJheWAgY29ycmVzcG9uZGluZyB0byBgaW5kZXhlc2AgYW5kIHJldHVybnMgYW5cbiAgICAgKiBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5hdGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gW2luZGV4ZXNdIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnXTtcbiAgICAgKiB2YXIgcHVsbGVkID0gXy5wdWxsQXQoYXJyYXksIFsxLCAzXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydhJywgJ2MnXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cocHVsbGVkKTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnZCddXG4gICAgICovXG4gICAgdmFyIHB1bGxBdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCBpbmRleGVzKSB7XG4gICAgICBpbmRleGVzID0gYmFzZUZsYXR0ZW4oaW5kZXhlcywgMSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gYmFzZUF0KGFycmF5LCBpbmRleGVzKTtcblxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgYXJyYXlNYXAoaW5kZXhlcywgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGlzSW5kZXgoaW5kZXgsIGxlbmd0aCkgPyAraW5kZXggOiBpbmRleDtcbiAgICAgIH0pLnNvcnQoY29tcGFyZUFzY2VuZGluZykpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSBgYXJyYXlgIHRoYXQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yXG4gICAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJlbW92ZWQgZWxlbWVudHMuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmZpbHRlcmAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnB1bGxgXG4gICAgICogdG8gcHVsbCBlbGVtZW50cyBmcm9tIGFuIGFycmF5IGJ5IHZhbHVlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldXG4gICAgICogIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDRdO1xuICAgICAqIHZhciBldmVucyA9IF8ucmVtb3ZlKGFycmF5LCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAgICAgKiAvLyA9PiBbMiwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhlcyA9IFtdLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgcHJlZGljYXRlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBpbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgYGFycmF5YCBzbyB0aGF0IHRoZSBmaXJzdCBlbGVtZW50IGJlY29tZXMgdGhlIGxhc3QsIHRoZSBzZWNvbmRcbiAgICAgKiBlbGVtZW50IGJlY29tZXMgdGhlIHNlY29uZCB0byBsYXN0LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgIGFuZCBpcyBiYXNlZCBvblxuICAgICAqIFtgQXJyYXkjcmV2ZXJzZWBdKGh0dHBzOi8vbWRuLmlvL0FycmF5L3JldmVyc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXy5yZXZlcnNlKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXZlcnNlKGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyYXkgPyBuYXRpdmVSZXZlcnNlLmNhbGwoYXJyYXkpIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgdXNlZCBpbnN0ZWFkIG9mXG4gICAgICogW2BBcnJheSNzbGljZWBdKGh0dHBzOi8vbWRuLmlvL0FycmF5L3NsaWNlKSB0byBlbnN1cmUgZGVuc2UgYXJyYXlzIGFyZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZW5kICYmIHR5cGVvZiBlbmQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHN0YXJ0LCBlbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBsb3dlc3QgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFszMCwgNTBdLCA0MCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXJcbiAgICAgKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XVxuICAgICAqICBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ueDsgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb3J0ZWRJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sICd4Jyk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IHBlcmZvcm1zIGEgYmluYXJ5XG4gICAgICogc2VhcmNoIG9uIGEgc29ydGVkIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXhPZihbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGhpZ2hlc3RcbiAgICAgKiBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG9cbiAgICAgKiBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4KFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gNFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleChhcnJheSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZExhc3RJbmRleGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxuICAgICAqIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldXG4gICAgICogIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDQgfSwgeyAneCc6IDUgfV07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ueDsgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCAneCcpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubGFzdEluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IHBlcmZvcm1zIGEgYmluYXJ5XG4gICAgICogc2VhcmNoIG9uIGEgc29ydGVkIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4T2YoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKSAtIDE7XG4gICAgICAgIGlmIChlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQncyBkZXNpZ25lZCBhbmQgb3B0aW1pemVkXG4gICAgICogZm9yIHNvcnRlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxKFsxLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkVW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVNvcnRlZFVuaXEoYXJyYXkpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxQnlgIGV4Y2VwdCB0aGF0IGl0J3MgZGVzaWduZWQgYW5kIG9wdGltaXplZFxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxQnkoWzEuMSwgMS4yLCAyLjMsIDIuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjEsIDIuM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU29ydGVkVW5pcShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWlsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFpbChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDEsIGxlbmd0aCkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIG4gPSBsZW5ndGggLSBuO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC4gRWxlbWVudHMgYXJlXG4gICAgICogdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XVxuICAgICAqICBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGZhbHNlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLiBFbGVtZW50c1xuICAgICAqIGFyZSB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldXG4gICAgICogIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZX0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBmcm9tIGFsbCBnaXZlbiBhcnJheXMgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb24oWzJdLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIHZhciB1bmlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnlcbiAgICAgKiB3aGljaCB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLiBSZXN1bHQgdmFsdWVzIGFyZSBjaG9zZW4gZnJvbSB0aGUgZmlyc3RcbiAgICAgKiBhcnJheSBpbiB3aGljaCB0aGUgdmFsdWUgb2NjdXJzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XVxuICAgICAqICBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb25CeShbMi4xXSwgWzEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMSwgMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy51bmlvbkJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciB1bmlvbkJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFJlc3VsdCB2YWx1ZXMgYXJlIGNob3NlbiBmcm9tXG4gICAgICogdGhlIGZpcnN0IGFycmF5IGluIHdoaWNoIHRoZSB2YWx1ZSBvY2N1cnMuIFRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnVuaW9uV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIHVuaW9uV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoY29tcGFyYXRvcikpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5LCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpbiB3aGljaCBvbmx5IHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGVhY2hcbiAgICAgKiBlbGVtZW50IGlzIGtlcHQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsyLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVVuaXEoYXJyYXkpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcUJ5KFsyLjEsIDEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMSwgMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy51bmlxQnkoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXFCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgLiBUaGUgY29tcGFyYXRvciBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy51bmlxV2l0aChvYmplY3RzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxV2l0aChhcnJheSwgY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVVuaXEoYXJyYXksIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiBncm91cGVkXG4gICAgICogZWxlbWVudHMgYW5kIGNyZWF0ZXMgYW4gYXJyYXkgcmVncm91cGluZyB0aGUgZWxlbWVudHMgdG8gdGhlaXIgcHJlLXppcFxuICAgICAqIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsnYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV1dXG4gICAgICpcbiAgICAgKiBfLnVuemlwKHppcHBlZCk7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnppcChhcnJheSkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgIGFycmF5ID0gYXJyYXlGaWx0ZXIoYXJyYXksIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChncm91cCkpIHtcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoZ3JvdXAubGVuZ3RoLCBsZW5ndGgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBiYXNlVGltZXMobGVuZ3RoLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gYXJyYXlNYXAoYXJyYXksIGJhc2VQcm9wZXJ0eShpbmRleCkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgcmVncm91cGVkIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhlXG4gICAgICogZWxlbWVudHMgb2YgZWFjaCBncm91cDogKC4uLmdyb3VwKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lXG4gICAgICogIHJlZ3JvdXBlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWzEsIDJdLCBbMTAsIDIwXSwgWzEwMCwgMjAwXSk7XG4gICAgICogLy8gPT4gW1sxLCAxMCwgMTAwXSwgWzIsIDIwLCAyMDBdXVxuICAgICAqXG4gICAgICogXy51bnppcFdpdGgoemlwcGVkLCBfLmFkZCk7XG4gICAgICogLy8gPT4gWzMsIDMwLCAzMDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXBXaXRoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdW56aXAoYXJyYXkpO1xuICAgICAgaWYgKGl0ZXJhdGVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheU1hcChyZXN1bHQsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZSwgdW5kZWZpbmVkLCBncm91cCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgZ2l2ZW4gdmFsdWVzIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLnhvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndpdGhvdXQoWzIsIDEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKi9cbiAgICB2YXIgd2l0aG91dCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgaXMgdGhlXG4gICAgICogW3N5bW1ldHJpYyBkaWZmZXJlbmNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW1tZXRyaWNfZGlmZmVyZW5jZSlcbiAgICAgKiBvZiB0aGUgZ2l2ZW4gYXJyYXlzLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlclxuICAgICAqIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLmRpZmZlcmVuY2UsIF8ud2l0aG91dFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnhvcihbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICovXG4gICAgdmFyIHhvciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy54b3JgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnlcbiAgICAgKiB3aGljaCBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XVxuICAgICAqICBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMiwgMy40XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy54b3JCeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgeG9yQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ueG9yYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ueG9yV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciB4b3JXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChjb21wYXJhdG9yKSkge1xuICAgICAgICBjb21wYXJhdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCksIHVuZGVmaW5lZCwgY29tcGFyYXRvcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMsIHRoZSBmaXJzdCBvZiB3aGljaCBjb250YWlucyB0aGVcbiAgICAgKiBmaXJzdCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCB0aGUgc2Vjb25kIG9mIHdoaWNoIGNvbnRhaW5zIHRoZVxuICAgICAqIHNlY29uZCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXAoWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMSwgdHJ1ZV0sIFsnYicsIDIsIGZhbHNlXV1cbiAgICAgKi9cbiAgICB2YXIgemlwID0gYmFzZVJlc3QodW56aXApO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mcm9tUGFpcnNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgdHdvIGFycmF5cyxcbiAgICAgKiBvbmUgb2YgcHJvcGVydHkgaWRlbnRpZmllcnMgYW5kIG9uZSBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wcz1bXV0gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3QoWydhJywgJ2InXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3QocHJvcHMsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGJhc2VaaXBPYmplY3QocHJvcHMgfHwgW10sIHZhbHVlcyB8fCBbXSwgYXNzaWduVmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwT2JqZWN0YCBleGNlcHQgdGhhdCBpdCBzdXBwb3J0cyBwcm9wZXJ0eSBwYXRocy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wcz1bXV0gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3REZWVwKFsnYS5iWzBdLmMnLCAnYS5iWzFdLmQnXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnYic6IFt7ICdjJzogMSB9LCB7ICdkJzogMiB9XSB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3REZWVwKHByb3BzLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMgfHwgW10sIGJhc2VTZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgdG8gc3BlY2lmeVxuICAgICAqIGhvdyBncm91cGVkIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhlXG4gICAgICogZWxlbWVudHMgb2YgZWFjaCBncm91cDogKC4uLmdyb3VwKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZ3JvdXBlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBXaXRoKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0sIGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBhICsgYiArIGM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzExMSwgMjIyXVxuICAgICAqL1xuICAgIHZhciB6aXBXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBpdGVyYXRlZSA9IGxlbmd0aCA+IDEgPyBhcnJheXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGl0ZXJhdGVlID0gdHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgPyAoYXJyYXlzLnBvcCgpLCBpdGVyYXRlZSkgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdW56aXBXaXRoKGFycmF5cywgaXRlcmF0ZWUpO1xuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UgdGhhdCB3cmFwcyBgdmFsdWVgIHdpdGggZXhwbGljaXQgbWV0aG9kXG4gICAgICogY2hhaW4gc2VxdWVuY2VzIGVuYWJsZWQuIFRoZSByZXN1bHQgb2Ygc3VjaCBzZXF1ZW5jZXMgbXVzdCBiZSB1bndyYXBwZWRcbiAgICAgKiB3aXRoIGBfI3ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgeW91bmdlc3QgPSBfXG4gICAgICogICAuY2hhaW4odXNlcnMpXG4gICAgICogICAuc29ydEJ5KCdhZ2UnKVxuICAgICAqICAgLm1hcChmdW5jdGlvbihvKSB7XG4gICAgICogICAgIHJldHVybiBvLnVzZXIgKyAnIGlzICcgKyBvLmFnZTtcbiAgICAgKiAgIH0pXG4gICAgICogICAuaGVhZCgpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcyBpcyAxJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYWluKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoKHZhbHVlKTtcbiAgICAgIHJlc3VsdC5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIGBpbnRlcmNlcHRvcmAgYW5kIHJldHVybnMgYHZhbHVlYC4gVGhlIGludGVyY2VwdG9yXG4gICAgICogaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS4gVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG9cbiAgICAgKiBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4gc2VxdWVuY2UgaW4gb3JkZXIgdG8gbW9kaWZ5IGludGVybWVkaWF0ZSByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKVxuICAgICAqICAudGFwKGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICogICAgLy8gTXV0YXRlIGlucHV0IGFycmF5LlxuICAgICAqICAgIGFycmF5LnBvcCgpO1xuICAgICAqICB9KVxuICAgICAqICAucmV2ZXJzZSgpXG4gICAgICogIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRhcCh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcbiAgICAgIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnRhcGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJwYXNzIHRocnVcIiB2YWx1ZXMgcmVwbGFjaW5nIGludGVybWVkaWF0ZVxuICAgICAqIHJlc3VsdHMgaW4gYSBtZXRob2QgY2hhaW4gc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKCcgIGFiYyAgJylcbiAgICAgKiAgLmNoYWluKClcbiAgICAgKiAgLnRyaW0oKVxuICAgICAqICAudGhydShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAqICB9KVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhydSh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcbiAgICAgIHJldHVybiBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdGhlIHdyYXBwZXIgdmVyc2lvbiBvZiBgXy5hdGAuXG4gICAgICpcbiAgICAgKiBAbmFtZSBhdFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIG9mIGVsZW1lbnRzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XG4gICAgICpcbiAgICAgKiBfKG9iamVjdCkuYXQoWydhWzBdLmIuYycsICdhWzFdJ10pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICovXG4gICAgdmFyIHdyYXBwZXJBdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGhzKSB7XG4gICAgICBwYXRocyA9IGJhc2VGbGF0dGVuKHBhdGhzLCAxKTtcbiAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgc3RhcnQgPSBsZW5ndGggPyBwYXRoc1swXSA6IDAsXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgIGludGVyY2VwdG9yID0gZnVuY3Rpb24ob2JqZWN0KSB7IHJldHVybiBiYXNlQXQob2JqZWN0LCBwYXRocyk7IH07XG5cbiAgICAgIGlmIChsZW5ndGggPiAxIHx8IHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoIHx8XG4gICAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB8fCAhaXNJbmRleChzdGFydCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKHN0YXJ0LCArc3RhcnQgKyAobGVuZ3RoID8gMSA6IDApKTtcbiAgICAgIHZhbHVlLl9fYWN0aW9uc19fLnB1c2goe1xuICAgICAgICAnZnVuYyc6IHRocnUsXG4gICAgICAgICdhcmdzJzogW2ludGVyY2VwdG9yXSxcbiAgICAgICAgJ3RoaXNBcmcnOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlLCB0aGlzLl9fY2hhaW5fXykudGhydShmdW5jdGlvbihhcnJheSkge1xuICAgICAgICBpZiAobGVuZ3RoICYmICFhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICBhcnJheS5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZSB3aXRoIGV4cGxpY2l0IG1ldGhvZCBjaGFpbiBzZXF1ZW5jZXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNoYWluXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIEEgc2VxdWVuY2Ugd2l0aG91dCBleHBsaWNpdCBjaGFpbmluZy5cbiAgICAgKiBfKHVzZXJzKS5oZWFkKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqXG4gICAgICogLy8gQSBzZXF1ZW5jZSB3aXRoIGV4cGxpY2l0IGNoYWluaW5nLlxuICAgICAqIF8odXNlcnMpXG4gICAgICogICAuY2hhaW4oKVxuICAgICAqICAgLmhlYWQoKVxuICAgICAqICAgLnBpY2soJ3VzZXInKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgICByZXR1cm4gY2hhaW4odGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluIHNlcXVlbmNlIGFuZCByZXR1cm5zIHRoZSB3cmFwcGVkIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNvbW1pdFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMl07XG4gICAgICogdmFyIHdyYXBwZWQgPSBfKGFycmF5KS5wdXNoKDMpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogd3JhcHBlZCA9IHdyYXBwZWQuY29tbWl0KCk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogd3JhcHBlZC5sYXN0KCk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDb21taXQoKSB7XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodGhpcy52YWx1ZSgpLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmV4dCB2YWx1ZSBvbiBhIHdyYXBwZWQgb2JqZWN0IGZvbGxvd2luZyB0aGVcbiAgICAgKiBbaXRlcmF0b3IgcHJvdG9jb2xdKGh0dHBzOi8vbWRuLmlvL2l0ZXJhdGlvbl9wcm90b2NvbHMjaXRlcmF0b3IpLlxuICAgICAqXG4gICAgICogQG5hbWUgbmV4dFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5leHQgaXRlcmF0b3IgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pO1xuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IGZhbHNlLCAndmFsdWUnOiAxIH1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiBmYWxzZSwgJ3ZhbHVlJzogMiB9XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogdHJ1ZSwgJ3ZhbHVlJzogdW5kZWZpbmVkIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyTmV4dCgpIHtcbiAgICAgIGlmICh0aGlzLl9fdmFsdWVzX18gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9fdmFsdWVzX18gPSB0b0FycmF5KHRoaXMudmFsdWUoKSk7XG4gICAgICB9XG4gICAgICB2YXIgZG9uZSA9IHRoaXMuX19pbmRleF9fID49IHRoaXMuX192YWx1ZXNfXy5sZW5ndGgsXG4gICAgICAgICAgdmFsdWUgPSBkb25lID8gdW5kZWZpbmVkIDogdGhpcy5fX3ZhbHVlc19fW3RoaXMuX19pbmRleF9fKytdO1xuXG4gICAgICByZXR1cm4geyAnZG9uZSc6IGRvbmUsICd2YWx1ZSc6IHZhbHVlIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGUgd3JhcHBlciB0byBiZSBpdGVyYWJsZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIFN5bWJvbC5pdGVyYXRvclxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKTtcbiAgICAgKlxuICAgICAqIHdyYXBwZWRbU3ltYm9sLml0ZXJhdG9yXSgpID09PSB3cmFwcGVkO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIEFycmF5LmZyb20od3JhcHBlZCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclRvSXRlcmF0b3IoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGNoYWluIHNlcXVlbmNlIHBsYW50aW5nIGB2YWx1ZWAgYXMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBwbGFudFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHBsYW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pLm1hcChzcXVhcmUpO1xuICAgICAqIHZhciBvdGhlciA9IHdyYXBwZWQucGxhbnQoWzMsIDRdKTtcbiAgICAgKlxuICAgICAqIG90aGVyLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzksIDE2XVxuICAgICAqXG4gICAgICogd3JhcHBlZC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJQbGFudCh2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzO1xuXG4gICAgICB3aGlsZSAocGFyZW50IGluc3RhbmNlb2YgYmFzZUxvZGFzaCkge1xuICAgICAgICB2YXIgY2xvbmUgPSB3cmFwcGVyQ2xvbmUocGFyZW50KTtcbiAgICAgICAgY2xvbmUuX19pbmRleF9fID0gMDtcbiAgICAgICAgY2xvbmUuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHByZXZpb3VzLl9fd3JhcHBlZF9fID0gY2xvbmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2xvbmU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZpb3VzID0gY2xvbmU7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5fX3dyYXBwZWRfXztcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSB3cmFwcGVyIHZlcnNpb24gb2YgYF8ucmV2ZXJzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyB0aGUgd3JhcHBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXyhhcnJheSkucmV2ZXJzZSgpLnZhbHVlKClcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUmV2ZXJzZSgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX187XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICB2YXIgd3JhcHBlZCA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgpIHtcbiAgICAgICAgICB3cmFwcGVkID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHdyYXBwZWQgPSB3cmFwcGVkLnJldmVyc2UoKTtcbiAgICAgICAgd3JhcHBlZC5fX2FjdGlvbnNfXy5wdXNoKHtcbiAgICAgICAgICAnZnVuYyc6IHRocnUsXG4gICAgICAgICAgJ2FyZ3MnOiBbcmV2ZXJzZV0sXG4gICAgICAgICAgJ3RoaXNBcmcnOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVkLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aHJ1KHJldmVyc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjaGFpbiBzZXF1ZW5jZSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIHRvSlNPTiwgdmFsdWVPZlxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWUoKSB7XG4gICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZSh0aGlzLl9fd3JhcHBlZF9fLCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb2ZcbiAgICAgKiBlYWNoIGtleSBpcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgd2FzIHJldHVybmVkIGJ5IGBpdGVyYXRlZWAuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5jb3VudEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IDIsICc1JzogMSB9XG4gICAgICovXG4gICAgdmFyIGNvdW50QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkgPyArK3Jlc3VsdFtrZXldIDogKHJlc3VsdFtrZXldID0gMSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYWxsKiogZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICogW2VtcHR5IGNvbGxlY3Rpb25zXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbXB0eV9zZXQpIGJlY2F1c2VcbiAgICAgKiBbZXZlcnl0aGluZyBpcyB0cnVlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYWN1b3VzX3RydXRoKSBvZlxuICAgICAqIGVsZW1lbnRzIG9mIGVtcHR5IGNvbGxlY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XVxuICAgICAqICBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFdmVyeSA6IGJhc2VFdmVyeTtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucmVtb3ZlYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV1cbiAgICAgKiAgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAc2VlIF8ucmVqZWN0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XVxuICAgICAqICBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAgICAgKi9cbiAgICB2YXIgZmluZCA9IGNyZWF0ZUZpbmQoZmluZEluZGV4KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XVxuICAgICAqICBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWNvbGxlY3Rpb24ubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIHZhciBmaW5kTGFzdCA9IGNyZWF0ZUZpbmQoZmluZExhc3RJbmRleCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmxhdHRlbmVkIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmBcbiAgICAgKiB0aHJ1IGBpdGVyYXRlZWAgYW5kIGZsYXR0ZW5pbmcgdGhlIG1hcHBlZCByZXN1bHRzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV1cbiAgICAgKiAgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW24sIG5dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcChbMSwgMl0sIGR1cGxpY2F0ZSk7XG4gICAgICogLy8gPT4gWzEsIDEsIDIsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxhdE1hcGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgZmxhdHRlbnMgdGhlXG4gICAgICogbWFwcGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV1cbiAgICAgKiAgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW1tbbiwgbl1dXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXBEZWVwKFsxLCAyXSwgZHVwbGljYXRlKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMiwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwRGVlcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIElORklOSVRZKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsYXRNYXBgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZVxuICAgICAqIG1hcHBlZCByZXN1bHRzIHVwIHRvIGBkZXB0aGAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV1cbiAgICAgKiAgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW1tbbiwgbl1dXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXBEZXB0aChbMSwgMl0sIGR1cGxpY2F0ZSwgMik7XG4gICAgICogLy8gPT4gW1sxLCAxXSwgWzIsIDJdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXBEZXB0aChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgZGVwdGgpIHtcbiAgICAgIGRlcHRoID0gZGVwdGggPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGgpO1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIGRlcHRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIlxuICAgICAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gICAgICogb3IgYF8uZm9yT3duYCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyBlYWNoXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQHNlZSBfLmZvckVhY2hSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyXSkuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgYDFgIHRoZW4gYDJgLlxuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JFYWNoYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBhbGlhcyBlYWNoUmlnaHRcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAc2VlIF8uZm9yRWFjaFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2hSaWdodChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyBgMmAgdGhlbiBgMWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2hSaWdodCA6IGJhc2VFYWNoUmlnaHQ7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgb3JkZXIgb2YgZ3JvdXBlZCB2YWx1ZXNcbiAgICAgKiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIGBjb2xsZWN0aW9uYC4gVGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiB2YWx1ZSBvZiBlYWNoIGtleSBpcyBhbiBhcnJheSBvZiBlbGVtZW50cyByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGVcbiAgICAgKiBrZXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldXG4gICAgICogIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzYuMSwgNC4yLCA2LjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi4zXSB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogWydvbmUnLCAndHdvJ10sICc1JzogWyd0aHJlZSddIH1cbiAgICAgKi9cbiAgICB2YXIgZ3JvdXBCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRba2V5XSA9IFt2YWx1ZV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBhIHN0cmluZywgaXQnc1xuICAgICAqIGNoZWNrZWQgZm9yIGEgc3Vic3RyaW5nIG9mIGB2YWx1ZWAsIG90aGVyd2lzZVxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogaXMgdXNlZCBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXNcbiAgICAgKiB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyh7ICdhJzogMSwgJ2InOiAyIH0sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoJ2FiY2QnLCAnYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5jbHVkZXMoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICAgIGNvbGxlY3Rpb24gPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4ICYmICFndWFyZCkgPyB0b0ludGVnZXIoZnJvbUluZGV4KSA6IDA7XG5cbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICAgIGZyb21JbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pXG4gICAgICAgID8gKGZyb21JbmRleCA8PSBsZW5ndGggJiYgY29sbGVjdGlvbi5pbmRleE9mKHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpXG4gICAgICAgIDogKCEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nXG4gICAgICogYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogYXJlIHByb3ZpZGVkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBwYXRoYCBpcyBhIGZ1bmN0aW9uLCBpdCdzIGludm9rZWRcbiAgICAgKiBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZSBvclxuICAgICAqICB0aGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGVhY2ggbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludm9rZU1hcChbWzUsIDEsIDddLCBbMywgMiwgMV1dLCAnc29ydCcpO1xuICAgICAqIC8vID0+IFtbMSwgNSwgN10sIFsxLCAyLCAzXV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlTWFwKFsxMjMsIDQ1Nl0sIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsICcnKTtcbiAgICAgKiAvLyA9PiBbWycxJywgJzInLCAnMyddLCBbJzQnLCAnNScsICc2J11dXG4gICAgICovXG4gICAgdmFyIGludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHBhdGgsIGFyZ3MpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzRnVuYyA9IHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicsXG4gICAgICAgICAgaXNQcm9wID0gaXNLZXkocGF0aCksXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBwYXRoIDogKChpc1Byb3AgJiYgdmFsdWUgIT0gbnVsbCkgPyB2YWx1ZVtwYXRoXSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGZ1bmMgPyBhcHBseShmdW5jLCB2YWx1ZSwgYXJncykgOiBiYXNlSW52b2tlKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZlxuICAgICAqIGVhY2gga2V5IGlzIHRoZSBsYXN0IGVsZW1lbnQgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XVxuICAgICAqICBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1xuICAgICAqICAgeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sXG4gICAgICogICB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ua2V5QnkoYXJyYXksIGZ1bmN0aW9uKG8pIHtcbiAgICAgKiAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG8uY29kZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5rZXlCeShhcnJheSwgJ2RpcicpO1xuICAgICAqIC8vID0+IHsgJ2xlZnQnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ3JpZ2h0JzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICovXG4gICAgdmFyIGtleUJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydVxuICAgICAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgICAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFyeWAsIGBjaHVua2AsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCxcbiAgICAgKiBgZmlsbGAsIGBpbnZlcnRgLCBgcGFyc2VJbnRgLCBgcmFuZG9tYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVwZWF0YCxcbiAgICAgKiBgc2FtcGxlU2l6ZWAsIGBzbGljZWAsIGBzb21lYCwgYHNvcnRCeWAsIGBzcGxpdGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gICAgICogYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBhbmQgYHdvcmRzYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWFwKFs0LCA4XSwgc3F1YXJlKTtcbiAgICAgKiAvLyA9PiBbMTYsIDY0XVxuICAgICAqXG4gICAgICogXy5tYXAoeyAnYSc6IDQsICdiJzogOCB9LCBzcXVhcmUpO1xuICAgICAqIC8vID0+IFsxNiwgNjRdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0QnlgIGV4Y2VwdCB0aGF0IGl0IGFsbG93cyBzcGVjaWZ5aW5nIHRoZSBzb3J0XG4gICAgICogb3JkZXJzIG9mIHRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS4gSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXNcbiAgICAgKiBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLCBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvclxuICAgICAqIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXIgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5W118RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3JkZXJzXSBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gU29ydCBieSBgdXNlcmAgaW4gYXNjZW5kaW5nIG9yZGVyIGFuZCBieSBgYWdlYCBpbiBkZXNjZW5kaW5nIG9yZGVyLlxuICAgICAqIF8ub3JkZXJCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddLCBbJ2FzYycsICdkZXNjJ10pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDBdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMsIGd1YXJkKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBcnJheShpdGVyYXRlZXMpKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGl0ZXJhdGVlcyA9PSBudWxsID8gW10gOiBbaXRlcmF0ZWVzXTtcbiAgICAgIH1cbiAgICAgIG9yZGVycyA9IGd1YXJkID8gdW5kZWZpbmVkIDogb3JkZXJzO1xuICAgICAgaWYgKCFpc0FycmF5KG9yZGVycykpIHtcbiAgICAgICAgb3JkZXJzID0gb3JkZXJzID09IG51bGwgPyBbXSA6IFtvcmRlcnNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gdHdvIGdyb3VwcywgdGhlIGZpcnN0IG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLCB0aGUgc2Vjb25kIG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkgZm9yLiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1sncGViYmxlcyddLCBbJ2Jhcm5leScsICdmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAncGViYmxlcyddLCBbJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gICAgICovXG4gICAgdmFyIHBhcnRpdGlvbiA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRba2V5ID8gMCA6IDFdLnB1c2godmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uKCkgeyByZXR1cm4gW1tdLCBbXV07IH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYCwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy4gSWYgYGFjY3VtdWxhdG9yYFxuICAgICAqIGlzIG5vdCBnaXZlbiwgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIGlzIHVzZWQgYXMgdGhlIGluaXRpYWxcbiAgICAgKiB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAgICAgKiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8ucmVkdWNlYCwgYF8ucmVkdWNlUmlnaHRgLCBhbmQgYF8udHJhbnNmb3JtYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhc3NpZ25gLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGluY2x1ZGVzYCwgYG1lcmdlYCwgYG9yZGVyQnlgLFxuICAgICAqIGFuZCBgc29ydEJ5YFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8ucmVkdWNlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZWR1Y2UoWzEsIDJdLCBmdW5jdGlvbihzdW0sIG4pIHtcbiAgICAgKiAgIHJldHVybiBzdW0gKyBuO1xuICAgICAqIH0sIDApO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gICAgICogICByZXR1cm4gcmVzdWx0O1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2UgOiBiYXNlUmVkdWNlLFxuICAgICAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJlZHVjZWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5yZWR1Y2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1swLCAxXSwgWzIsIDNdLCBbNCwgNV1dO1xuICAgICAqXG4gICAgICogXy5yZWR1Y2VSaWdodChhcnJheSwgZnVuY3Rpb24oZmxhdHRlbmVkLCBvdGhlcikge1xuICAgICAqICAgcmV0dXJuIGZsYXR0ZW5lZC5jb25jYXQob3RoZXIpO1xuICAgICAqIH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgNSwgMiwgMywgMCwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2VSaWdodChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlUmlnaHQgOiBiYXNlUmVkdWNlLFxuICAgICAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoUmlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgOyB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmBcbiAgICAgKiB0aGF0IGBwcmVkaWNhdGVgIGRvZXMgKipub3QqKiByZXR1cm4gdHJ1dGh5IGZvci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAc2VlIF8uZmlsdGVyXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHJhbmRvbSBlbGVtZW50IGZyb20gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGFycmF5ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdmFsdWVzKGNvbGxlY3Rpb24pLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgcmV0dXJuIGxlbmd0aCA+IDAgPyBhcnJheVtiYXNlUmFuZG9tKDAsIGxlbmd0aCAtIDEpXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGBuYCByYW5kb20gZWxlbWVudHMgYXQgdW5pcXVlIGtleXMgZnJvbSBgY29sbGVjdGlvbmAgdXAgdG8gdGhlXG4gICAgICogc2l6ZSBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGVTaXplKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzMsIDFdXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZVNpemUoWzEsIDIsIDNdLCA0KTtcbiAgICAgKiAvLyA9PiBbMiwgMywgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGVTaXplKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSB0b0FycmF5KGNvbGxlY3Rpb24pLFxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSA6IG4gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gYmFzZUNsYW1wKHRvSW50ZWdlcihuKSwgMCwgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgICB2YXIgcmFuZCA9IGJhc2VSYW5kb20oaW5kZXgsIGxhc3RJbmRleCksXG4gICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdFtyYW5kXTtcblxuICAgICAgICByZXN1bHRbcmFuZF0gPSByZXN1bHRbaW5kZXhdO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXN1bHQubGVuZ3RoID0gbjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGVcbiAgICAgKiBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gWzQsIDEsIDMsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gc2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBNQVhfQVJSQVlfTEVOR1RIKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgaXRzIGxlbmd0aCBmb3IgYXJyYXktbGlrZVxuICAgICAqIHZhbHVlcyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIHNpemUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2l6ZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2l6ZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+IDdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gc3RyaW5nU2l6ZShjb2xsZWN0aW9uKSA6IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyhjb2xsZWN0aW9uKTtcbiAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uc2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlS2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFueSoqIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb21lKFtudWxsLCAwLCAneWVzJywgZmFsc2VdLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U29tZSA6IGJhc2VTb21lO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhydSBlYWNoIGl0ZXJhdGVlLiBUaGlzIG1ldGhvZFxuICAgICAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZlxuICAgICAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgaXRlcmF0ZWVzIGFyZSBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDBdXVxuICAgICAqXG4gICAgICogXy5zb3J0QnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzRdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdLCBbJ2ZyZWQnLCA0OF1dXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeSh1c2VycywgJ3VzZXInLCBmdW5jdGlvbihvKSB7XG4gICAgICogICByZXR1cm4gTWF0aC5mbG9vcihvLmFnZSAvIDEwKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKi9cbiAgICB2YXIgc29ydEJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWVzKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtdO1xuICAgICAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBpdGVyYXRlZXNbMl0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKGl0ZXJhdGVlcywgMSksIFtdKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICAgICAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IERhdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gICAgICogfSwgXy5ub3coKSk7XG4gICAgICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgbm93ID0gY3R4Tm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmJlZm9yZWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcbiAgICAgKiBgZnVuY2Agb25jZSBpdCdzIGNhbGxlZCBgbmAgb3IgbW9yZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYmVmb3JlIGBmdW5jYCBpcyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xuICAgICAqXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnZG9uZSBzYXZpbmchJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdkb25lIHNhdmluZyEnIGFmdGVyIHRoZSB0d28gYXN5bmMgc2F2ZXMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWZ0ZXIobiwgZnVuYykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHVwIHRvIGBuYCBhcmd1bWVudHMsXG4gICAgICogaWdub3JpbmcgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgY2FwLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnOCcsICcxMCddLCBfLmFyeShwYXJzZUludCwgMSkpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnkoZnVuYywgbiwgZ3VhcmQpIHtcbiAgICAgIG4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IG47XG4gICAgICBuID0gKGZ1bmMgJiYgbiA9PSBudWxsKSA/IGZ1bmMubGVuZ3RoIDogbjtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIEFSWV9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzXG4gICAgICogb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoaWxlIGl0J3MgY2FsbGVkIGxlc3MgdGhhbiBgbmAgdGltZXMuIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYXQgd2hpY2ggYGZ1bmNgIGlzIG5vIGxvbmdlciBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmJlZm9yZSg1LCBhZGRDb250YWN0VG9MaXN0KSk7XG4gICAgICogLy8gPT4gQWxsb3dzIGFkZGluZyB1cCB0byA0IGNvbnRhY3RzIHRvIHRoZSBsaXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJlZm9yZShuLCBmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA+IDApIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPD0gMSkge1xuICAgICAgICAgIGZ1bmMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgXG4gICAgICogYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uYmluZC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIG5hdGl2ZSBgRnVuY3Rpb24jYmluZGAsIHRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiXG4gICAgICogcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsICdoaScpO1xuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgdGhpc0FyZywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gQklORF9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZCkpO1xuICAgICAgICBiaXRtYXNrIHw9IFBBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgb2JqZWN0W2tleV1gIHdpdGggYHBhcnRpYWxzYFxuICAgICAqIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBfLmJpbmRgIGJ5IGFsbG93aW5nIGJvdW5kIGZ1bmN0aW9ucyB0byByZWZlcmVuY2VcbiAgICAgKiBtZXRob2RzIHRoYXQgbWF5IGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuIFNlZVxuICAgICAqIFtQZXRlciBNaWNoYXV4J3MgYXJ0aWNsZV0oaHR0cDovL3BldGVyLm1pY2hhdXguY2EvYXJ0aWNsZXMvbGF6eS1mdW5jdGlvbi1kZWZpbml0aW9uLXBhdHRlcm4pXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kS2V5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52b2tlIHRoZSBtZXRob2Qgb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAndXNlcic6ICdmcmVkJyxcbiAgICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiBvYmplY3QuZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICd5YSAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kS2V5ID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBrZXksIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IEJJTkRfRkxBRyB8IEJJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihiaW5kS2V5KSk7XG4gICAgICAgIGJpdG1hc2sgfD0gUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoa2V5LCBiaXRtYXNrLCBvYmplY3QsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYXJndW1lbnRzIG9mIGBmdW5jYCBhbmQgZWl0aGVyIGludm9rZXNcbiAgICAgKiBgZnVuY2AgcmV0dXJuaW5nIGl0cyByZXN1bHQsIGlmIGF0IGxlYXN0IGBhcml0eWAgbnVtYmVyIG9mIGFyZ3VtZW50cyBoYXZlXG4gICAgICogYmVlbiBwcm92aWRlZCwgb3IgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgcmVtYWluaW5nIGBmdW5jYFxuICAgICAqIGFyZ3VtZW50cywgYW5kIHNvIG9uLiBUaGUgYXJpdHkgb2YgYGZ1bmNgIG1heSBiZSBzcGVjaWZpZWQgaWYgYGZ1bmMubGVuZ3RoYFxuICAgICAqIGlzIG5vdCBzdWZmaWNpZW50LlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEpKDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyBDdXJyaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIGN1cnJpZWQoMSkoXywgMykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnkoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICBhcml0eSA9IGd1YXJkID8gdW5kZWZpbmVkIDogYXJpdHk7XG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcChmdW5jLCBDVVJSWV9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkpO1xuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnkucGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY3VycnlgIGV4Y2VwdCB0aGF0IGFyZ3VtZW50cyBhcmUgYXBwbGllZCB0byBgZnVuY2BcbiAgICAgKiBpbiB0aGUgbWFubmVyIG9mIGBfLnBhcnRpYWxSaWdodGAgaW5zdGVhZCBvZiBgXy5wYXJ0aWFsYC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeVJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5UmlnaHQoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMykoMikoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDIsIDMpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIEN1cnJpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogY3VycmllZCgzKSgxLCBfKSgyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeVJpZ2h0KGZ1bmMsIGFyaXR5LCBndWFyZCkge1xuICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZCA6IGFyaXR5O1xuICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVdyYXAoZnVuYywgQ1VSUllfUklHSFRfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5KTtcbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IGN1cnJ5UmlnaHQucGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICAgICAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICAgICAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAgICAgKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAgICAgKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAgICAgKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gICAgICogaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICAgICAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAgICAgKlxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gICAgICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAgICAgKlxuICAgICAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSkpO1xuICAgICAqXG4gICAgICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAgICAgKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAgICAgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gICAgICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICAgICAqXG4gICAgICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGFzdEFyZ3MsXG4gICAgICAgICAgbGFzdFRoaXMsXG4gICAgICAgICAgbWF4V2FpdCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgdGltZXJJZCxcbiAgICAgICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICAgICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgICAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgICAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgICAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgICAgICByZXR1cm4gbWF4aW5nID8gbmF0aXZlTWluKHJlc3VsdCwgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpIDogcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgICAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgICAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgICAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgICAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgICAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgICAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgICAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICAgICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgICAgIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICAgICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZlcnMgaW52b2tpbmcgdGhlIGBmdW5jYCB1bnRpbCB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcyBjbGVhcmVkLiBBbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVmZXIuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24odGV4dCkge1xuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogfSwgJ2RlZmVycmVkJyk7XG4gICAgICogLy8gPT4gTG9ncyAnZGVmZXJyZWQnIGFmdGVyIG9uZSBvciBtb3JlIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICB2YXIgZGVmZXIgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIDEsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBgZnVuY2AgYWZ0ZXIgYHdhaXRgIG1pbGxpc2Vjb25kcy4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVsYXkoZnVuY3Rpb24odGV4dCkge1xuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogfSwgMTAwMCwgJ2xhdGVyJyk7XG4gICAgICogLy8gPT4gTG9ncyAnbGF0ZXInIGFmdGVyIG9uZSBzZWNvbmQuXG4gICAgICovXG4gICAgdmFyIGRlbGF5ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCB0b051bWJlcih3YWl0KSB8fCAwLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYXJndW1lbnRzIHJldmVyc2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZmxpcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsaXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmbGlwcGVkID0gXy5mbGlwKGZ1bmN0aW9uKCkge1xuICAgICAqICAgcmV0dXJuIF8udG9BcnJheShhcmd1bWVudHMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZmxpcHBlZCgnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+IFsnZCcsICdjJywgJ2InLCAnYSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxpcChmdW5jKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBGTElQX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAgICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICAgICAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gICAgICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAgICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAgICAgKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICAgICAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gICAgICpcbiAgICAgKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHZhbHVlcyhvdGhlcik7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICpcbiAgICAgKiBvYmplY3QuYSA9IDI7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAgICAgKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqXG4gICAgICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAgICAgKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9XG5cbiAgICAvLyBBc3NpZ24gY2FjaGUgdG8gYF8ubWVtb2l6ZWAuXG4gICAgbWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbmVnYXRlcyB0aGUgcmVzdWx0IG9mIHRoZSBwcmVkaWNhdGUgYGZ1bmNgLiBUaGVcbiAgICAgKiBgZnVuY2AgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gbmVnYXRlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG5lZ2F0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzRXZlbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIF8ubmVnYXRlKGlzRXZlbikpO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lZ2F0ZShwcmVkaWNhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMDogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSk7XG4gICAgICAgICAgY2FzZSAyOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcmVzdHJpY3RlZCB0byBpbnZva2luZyBgZnVuY2Agb25jZS4gUmVwZWF0IGNhbGxzXG4gICAgICogdG8gdGhlIGZ1bmN0aW9uIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGludm9jYXRpb24uIFRoZSBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgaW5pdGlhbGl6ZSA9IF8ub25jZShjcmVhdGVBcHBsaWNhdGlvbik7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiAvLyA9PiBgY3JlYXRlQXBwbGljYXRpb25gIGlzIGludm9rZWQgb25jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICAgICAgcmV0dXJuIGJlZm9yZSgyLCBmdW5jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudHMgdHJhbnNmb3JtZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbdHJhbnNmb3Jtcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm1zLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkb3VibGVkKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyQXJncyhmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4gW3gsIHldO1xuICAgICAqIH0sIFtzcXVhcmUsIGRvdWJsZWRdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoOSwgMyk7XG4gICAgICogLy8gPT4gWzgxLCA2XVxuICAgICAqXG4gICAgICogZnVuYygxMCwgNSk7XG4gICAgICogLy8gPT4gWzEwMCwgMTBdXG4gICAgICovXG4gICAgdmFyIG92ZXJBcmdzID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgdHJhbnNmb3Jtcykge1xuICAgICAgdHJhbnNmb3JtcyA9ICh0cmFuc2Zvcm1zLmxlbmd0aCA9PSAxICYmIGlzQXJyYXkodHJhbnNmb3Jtc1swXSkpXG4gICAgICAgID8gYXJyYXlNYXAodHJhbnNmb3Jtc1swXSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKVxuICAgICAgICA6IGFycmF5TWFwKGJhc2VGbGF0dGVuKHRyYW5zZm9ybXMsIDEpLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuXG4gICAgICB2YXIgZnVuY3NMZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGFyZ3MubGVuZ3RoLCBmdW5jc0xlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IHRyYW5zZm9ybXNbaW5kZXhdLmNhbGwodGhpcywgYXJnc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGVcbiAgICAgKiBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYmluZGAgZXhjZXB0IGl0IGRvZXMgKipub3QqKlxuICAgICAqIGFsdGVyIHRoZSBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGVsbG8nKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBQYXJ0aWFsbHkgYXBwbGllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsKGdyZWV0LCBfLCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIocGFydGlhbCkpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgUEFSVElBTF9GTEFHLCB1bmRlZmluZWQsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucGFydGlhbGAgZXhjZXB0IHRoYXQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzXG4gICAgICogYXJlIGFwcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbFJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBQYXJ0aWFsbHkgYXBwbGllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnaGVsbG8nLCBfKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWxSaWdodCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIocGFydGlhbFJpZ2h0KSk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBQQVJUSUFMX1JJR0hUX0ZMQUcsIHVuZGVmaW5lZCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgYXJyYW5nZWQgYWNjb3JkaW5nXG4gICAgICogdG8gdGhlIHNwZWNpZmllZCBgaW5kZXhlc2Agd2hlcmUgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBmaXJzdCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBzZWNvbmQgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZWFycmFuZ2UgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW10pfSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcmd1bWVudCBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcmVhcmdlZCA9IF8ucmVhcmcoZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9LCBbMiwgMCwgMV0pO1xuICAgICAqXG4gICAgICogcmVhcmdlZCgnYicsICdjJywgJ2EnKVxuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIHZhciByZWFyZyA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGluZGV4ZXMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFJFQVJHX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGJhc2VGbGF0dGVuKGluZGV4ZXMsIDEpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhc1xuICAgICAqIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZVxuICAgICAqIFtyZXN0IHBhcmFtZXRlcl0oaHR0cHM6Ly9tZG4uaW8vcmVzdF9wYXJhbWV0ZXJzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5yZXN0KGZ1bmN0aW9uKHdoYXQsIG5hbWVzKSB7XG4gICAgICogICByZXR1cm4gd2hhdCArICcgJyArIF8uaW5pdGlhbChuYW1lcykuam9pbignLCAnKSArXG4gICAgICogICAgIChfLnNpemUobmFtZXMpID4gMSA/ICcsICYgJyA6ICcnKSArIF8ubGFzdChuYW1lcyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoJ2hlbGxvJywgJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdChmdW5jLCBzdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGFydCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAgICAgKiBjcmVhdGUgZnVuY3Rpb24gYW5kIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBtdWNoIGxpa2VcbiAgICAgKiBbYEZ1bmN0aW9uI2FwcGx5YF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXG4gICAgICogW3NwcmVhZCBvcGVyYXRvcl0oaHR0cHM6Ly9tZG4uaW8vc3ByZWFkX29wZXJhdG9yKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHNwcmVhZCBhcmd1bWVudHMgb3Zlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgc3ByZWFkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5zcHJlYWQoZnVuY3Rpb24od2hvLCB3aGF0KSB7XG4gICAgICogICByZXR1cm4gd2hvICsgJyBzYXlzICcgKyB3aGF0O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2F5KFsnZnJlZCcsICdoZWxsbyddKTtcbiAgICAgKiAvLyA9PiAnZnJlZCBzYXlzIGhlbGxvJ1xuICAgICAqXG4gICAgICogdmFyIG51bWJlcnMgPSBQcm9taXNlLmFsbChbXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoNDApLFxuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDM2KVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogbnVtYmVycy50aGVuKF8uc3ByZWFkKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiB4ICsgeTtcbiAgICAgKiB9KSk7XG4gICAgICogLy8gPT4gYSBQcm9taXNlIG9mIDc2XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3ByZWFkKGZ1bmMsIHN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHN0YXJ0ID09PSB1bmRlZmluZWQgPyAwIDogbmF0aXZlTWF4KHRvSW50ZWdlcihzdGFydCksIDApO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJnc1tzdGFydF0sXG4gICAgICAgICAgICBvdGhlckFyZ3MgPSBjYXN0U2xpY2UoYXJncywgMCwgc3RhcnQpO1xuXG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIGFycmF5UHVzaChvdGhlckFyZ3MsIGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAgICAgKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICAgICAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAgICAgKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAgICAgKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gICAgICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICAgICAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAgICAgKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gICAgICpcbiAgICAgKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAgICAgKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gICAgICpcbiAgICAgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAgICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdXAgdG8gb25lIGFyZ3VtZW50LCBpZ25vcmluZyBhbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzgnLCAnMTAnXSwgXy51bmFyeShwYXJzZUludCkpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmFyeShmdW5jKSB7XG4gICAgICByZXR1cm4gYXJ5KGZ1bmMsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGB2YWx1ZWAgdG8gYHdyYXBwZXJgIGFzIGl0cyBmaXJzdFxuICAgICAqIGFyZ3VtZW50LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGZ1bmN0aW9uIGFyZSBhcHBlbmRlZFxuICAgICAqIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBgd3JhcHBlcmAuIFRoZSB3cmFwcGVyIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3dyYXBwZXI9aWRlbnRpdHldIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHAoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJzxwPmZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlczwvcD4nXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICAgICAgd3JhcHBlciA9IHdyYXBwZXIgPT0gbnVsbCA/IGlkZW50aXR5IDogd3JhcHBlcjtcbiAgICAgIHJldHVybiBwYXJ0aWFsKHdyYXBwZXIsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIGFzIGFuIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjQuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KDEpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoeyAnYSc6IDEgfSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH1dXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gWydhYmMnXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkobnVsbCk7XG4gICAgICogLy8gPT4gW251bGxdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSh1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IFt1bmRlZmluZWRdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICogY29uc29sZS5sb2coXy5jYXN0QXJyYXkoYXJyYXkpID09PSBhcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RBcnJheSgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICAgICAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gICAgICogYW5kIHN1cHBvcnRzIGNsb25pbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucywgZGF0ZSBvYmplY3RzLCBtYXBzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZFxuICAgICAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gICAgICogYXMgcGxhaW4gb2JqZWN0cy4gQW4gZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaFxuICAgICAqIGFzIGVycm9yIG9iamVjdHMsIGZ1bmN0aW9ucywgRE9NIG5vZGVzLCBhbmQgV2Vha01hcHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lRGVlcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAgICAgKlxuICAgICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCxcbiAgICAgKiBjbG9uaW5nIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHVwIHRvIGZvdXIgYXJndW1lbnRzOyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIHN0YWNrXSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVEZWVwV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBlbCA9IF8uY2xvbmVXaXRoKGRvY3VtZW50LmJvZHksIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZWwgPT09IGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogY29uc29sZS5sb2coZWwubm9kZU5hbWUpO1xuICAgICAqIC8vID0+ICdCT0RZJ1xuICAgICAqIGNvbnNvbGUubG9nKGVsLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVXaXRoKHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBmYWxzZSwgdHJ1ZSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKG9iamVjdHMpO1xuICAgICAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCB0cnVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lV2l0aGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZVdpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBlbCA9IF8uY2xvbmVEZWVwV2l0aChkb2N1bWVudC5ib2R5LCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGVsID09PSBkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGNvbnNvbGUubG9nKGVsLm5vZGVOYW1lKTtcbiAgICAgKiAvLyA9PiAnQk9EWSdcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXBXaXRoKHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCB0cnVlLCB0cnVlLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG9iamVjdGAgY29uZm9ybXMgdG8gYHNvdXJjZWAgYnkgaW52b2tpbmcgdGhlIHByZWRpY2F0ZVxuICAgICAqIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgXy5jb25mb3Jtc2Agd2hlbiBgc291cmNlYCBpc1xuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgY29uZm9ybXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKlxuICAgICAqIF8uY29uZm9ybXNUbyhvYmplY3QsIHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMTsgfSB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmNvbmZvcm1zVG8ob2JqZWN0LCB7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDI7IH0gfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25mb3Jtc1RvKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gc291cmNlID09IG51bGwgfHwgYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYVxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lcSgnYScsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lcShOYU4sIE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5sdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0KDMsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3QoMywgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZ3QoMSwgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgZ3QgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VHdCk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0b1xuICAgICAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmx0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBndGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID49IG90aGVyO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICAgICAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlCdWZmZXJgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUJ1ZmZlcihuZXcgQXJyYXlCdWZmZXIoMikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUJ1ZmZlcihuZXcgQXJyYXkoMikpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXlCdWZmZXIgPSBub2RlSXNBcnJheUJ1ZmZlciA/IGJhc2VVbmFyeShub2RlSXNBcnJheUJ1ZmZlcikgOiBiYXNlSXNBcnJheUJ1ZmZlcjtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAgICAgKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gICAgICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICAgICAqIGlzIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKGZhbHNlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBib29sVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRGF0ZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGRhdGUgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKG5ldyBEYXRlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZSgnTW9uIEFwcmlsIDIzIDIwMTInKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0RhdGUgPSBub2RlSXNEYXRlID8gYmFzZVVuYXJ5KG5vZGVJc0RhdGUpIDogYmFzZUlzRGF0ZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KCc8Ym9keT4nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuICEhdmFsdWUgJiYgdmFsdWUubm9kZVR5cGUgPT09IDEgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAgICAgKlxuICAgICAqIE9iamVjdHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIG5vIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZFxuICAgICAqIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBBcnJheS1saWtlIHZhbHVlcyBzdWNoIGFzIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgYnVmZmVycywgc3RyaW5ncywgb3JcbiAgICAgKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gICAgICogU2ltaWxhcmx5LCBtYXBzIGFuZCBzZXRzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBzaXplYCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkodHJ1ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8IGlzQnVmZmVyKHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSk7XG4gICAgICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub25FbnVtU2hhZG93cyB8fCBpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICFuYXRpdmVLZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAgICAgKiBlcXVpdmFsZW50LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICAgICAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAgICAgKiBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWQgYXJyYXlzLiBgT2JqZWN0YCBvYmplY3RzIGFyZSBjb21wYXJlZFxuICAgICAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICAgICAqIG5vZGVzIGFyZSAqKm5vdCoqIHN1cHBvcnRlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogb2JqZWN0ID09PSBvdGhlcjtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzRXF1YWxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIGNvbXBhcmlzb25zXG4gICAgICogYXJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCB1cCB0b1xuICAgICAqIHNpeCBhcmd1bWVudHM6IChvYmpWYWx1ZSwgb3RoVmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIG90aGVyLCBzdGFja10pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIC9eaCg/Oml8ZWxsbykkLy50ZXN0KHZhbHVlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSkge1xuICAgICAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcob3RoVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnaGVsbG8nLCAnZ29vZGJ5ZSddO1xuICAgICAqIHZhciBvdGhlciA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsV2l0aChhcnJheSwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsV2l0aCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgb3RoZXIpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBjdXN0b21pemVyKSA6ICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXG4gICAgICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBlcnJvciBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKG5ldyBFcnJvcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKEVycm9yKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXJyb3IodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IGVycm9yVGFnKSB8fFxuICAgICAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIHByaW1pdGl2ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc0Zpbml0ZWBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0Zpbml0ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmluaXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIG5hdGl2ZUlzRmluaXRlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgICAgIC8vIGluIFNhZmFyaSA4LTkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgICAgIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICAgICAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzSW50ZWdlcmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0ludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT0gdG9JbnRlZ2VyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgICAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gICAgICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICAgICAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3Qoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gICAgICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNNYXAobmV3IE1hcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc01hcChuZXcgV2Vha01hcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBgb2JqZWN0YCBhbmQgYHNvdXJjZWAgdG9cbiAgICAgKiBkZXRlcm1pbmUgaWYgYG9iamVjdGAgY29udGFpbnMgZXF1aXZhbGVudCBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgXy5tYXRjaGVzYCB3aGVuIGBzb3VyY2VgIGlzXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdCBgc291cmNlYFxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2InOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaChvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBnZXRNYXRjaERhdGEoc291cmNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc01hdGNoYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBjb21wYXJpc29uc1xuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggZml2ZVxuICAgICAqIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwgaW5kZXh8a2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIC9eaCg/Oml8ZWxsbykkLy50ZXN0KHZhbHVlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcoc3JjVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdncmVldGluZyc6ICdoZWxsbycgfTtcbiAgICAgKiB2YXIgc291cmNlID0geyAnZ3JlZXRpbmcnOiAnaGknIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaFdpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNOYU5gXShodHRwczovL21kbi5pby9OdW1iZXIvaXNOYU4pIGFuZCBpcyBub3QgdGhlIHNhbWUgYXNcbiAgICAgKiBnbG9iYWwgW2Bpc05hTmBdKGh0dHBzOi8vbWRuLmlvL2lzTmFOKSB3aGljaCByZXR1cm5zIGB0cnVlYCBmb3JcbiAgICAgKiBgdW5kZWZpbmVkYCBhbmQgb3RoZXIgbm9uLW51bWJlciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4oTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAgICAgLy8gQW4gYE5hTmAgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZi5cbiAgICAgIC8vIFBlcmZvcm0gdGhlIGB0b1N0cmluZ1RhZ2AgY2hlY2sgZmlyc3QgdG8gYXZvaWQgZXJyb3JzIHdpdGggc29tZVxuICAgICAgLy8gQWN0aXZlWCBvYmplY3RzIGluIElFLlxuICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAhPSArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcmlzdGluZSBuYXRpdmUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgY2FuJ3QgcmVsaWFibHkgZGV0ZWN0IG5hdGl2ZSBmdW5jdGlvbnMgaW4gdGhlIHByZXNlbmNlXG4gICAgICogb2YgdGhlIGNvcmUtanMgcGFja2FnZSBiZWNhdXNlIGNvcmUtanMgY2lyY3VtdmVudHMgdGhpcyBraW5kIG9mIGRldGVjdGlvbi5cbiAgICAgKiBEZXNwaXRlIG11bHRpcGxlIHJlcXVlc3RzLCB0aGUgY29yZS1qcyBtYWludGFpbmVyIGhhcyBtYWRlIGl0IGNsZWFyOiBhbnlcbiAgICAgKiBhdHRlbXB0IHRvIGZpeCB0aGUgZGV0ZWN0aW9uIHdpbGwgYmUgb2JzdHJ1Y3RlZC4gQXMgYSByZXN1bHQsIHdlJ3JlIGxlZnRcbiAgICAgKiB3aXRoIGxpdHRsZSBjaG9pY2UgYnV0IHRvIHRocm93IGFuIGVycm9yLiBVbmZvcnR1bmF0ZWx5LCB0aGlzIGFsc28gYWZmZWN0c1xuICAgICAqIHBhY2thZ2VzLCBsaWtlIFtiYWJlbC1wb2x5ZmlsbF0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYmFiZWwtcG9seWZpbGwpLFxuICAgICAqIHdoaWNoIHJlbHkgb24gY29yZS1qcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShfKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICBpZiAoaXNNYXNrYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIHdpdGggY29yZS1qcy4gVHJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYG51bGxgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKHZvaWQgMCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG51bGxpc2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05pbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05pbChOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTnVtYmVyYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRvIGV4Y2x1ZGUgYEluZmluaXR5YCwgYC1JbmZpbml0eWAsIGFuZCBgTmFOYCwgd2hpY2ggYXJlXG4gICAgICogY2xhc3NpZmllZCBhcyBudW1iZXJzLCB1c2UgdGhlIGBfLmlzRmluaXRlYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBudW1iZXJUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAgICAgKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHxcbiAgICAgICAgICBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSAhPSBvYmplY3RUYWcgfHwgaXNIb3N0T2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICAgICAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgICAgIHJldHVybiAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJiBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFJlZ0V4cGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKC9hYmMvKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKCcvYWJjLycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzUmVnRXhwID0gbm9kZUlzUmVnRXhwID8gYmFzZVVuYXJ5KG5vZGVJc1JlZ0V4cCkgOiBiYXNlSXNSZWdFeHA7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHNhZmUgaW50ZWdlci4gQW4gaW50ZWdlciBpcyBzYWZlIGlmIGl0J3MgYW4gSUVFRS03NTRcbiAgICAgKiBkb3VibGUgcHJlY2lzaW9uIG51bWJlciB3aGljaCBpc24ndCB0aGUgcmVzdWx0IG9mIGEgcm91bmRlZCB1bnNhZmUgaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzU2FmZUludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNTYWZlSW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2FmZSBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPj0gLU1BWF9TQUZFX0lOVEVHRVIgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFNldGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU2V0KG5ldyBTZXQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygnYWJjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha01hcGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrTWFwKG5ldyBXZWFrTWFwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha01hcChuZXcgTWFwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSB3ZWFrTWFwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha1NldGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrU2V0KG5ldyBXZWFrU2V0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha1NldChuZXcgU2V0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gd2Vha1NldFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmd0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHQoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBsdCA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUx0KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvXG4gICAgICogIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8uZ3RlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHRlKDEsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHRlKDMsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHRlKDMsIDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGx0ZSA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPD0gb3RoZXI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udG9BcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoMSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8udG9BcnJheShudWxsKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpID8gc3RyaW5nVG9BcnJheSh2YWx1ZSkgOiBjb3B5QXJyYXkodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdG9yU3ltYm9sICYmIHZhbHVlW2l0ZXJhdG9yU3ltYm9sXSkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JUb0FycmF5KHZhbHVlW2l0ZXJhdG9yU3ltYm9sXSgpKTtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICAgIGZ1bmMgPSB0YWcgPT0gbWFwVGFnID8gbWFwVG9BcnJheSA6ICh0YWcgPT0gc2V0VGFnID8gc2V0VG9BcnJheSA6IHZhbHVlcyk7XG5cbiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEyLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZSgzLjIpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiA1ZS0zMjRcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKCczLjInKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgICAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgICAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyIHN1aXRhYmxlIGZvciB1c2UgYXMgdGhlIGxlbmd0aCBvZiBhblxuICAgICAqIGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0xlbmd0aCgzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b0xlbmd0aChJbmZpbml0eSk7XG4gICAgICogLy8gPT4gNDI5NDk2NzI5NVxuICAgICAqXG4gICAgICogXy50b0xlbmd0aCgnMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTGVuZ3RoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPyBiYXNlQ2xhbXAodG9JbnRlZ2VyKHZhbHVlKSwgMCwgTUFYX0FSUkFZX0xFTkdUSCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKDMuMik7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDVlLTMyNFxuICAgICAqXG4gICAgICogXy50b051bWJlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gSW5maW5pdHlcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgIH1cbiAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgICAgIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gICAgICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICAgICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAgICAgKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHNhZmUgaW50ZWdlci4gQSBzYWZlIGludGVnZXIgY2FuIGJlIGNvbXBhcmVkIGFuZFxuICAgICAqIHJlcHJlc2VudGVkIGNvcnJlY3RseS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gOTAwNzE5OTI1NDc0MDk5MVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAgICAgKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcobnVsbCk7XG4gICAgICogLy8gPT4gJydcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcoLTApO1xuICAgICAqIC8vID0+ICctMCdcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAnMSwyLDMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICogU3Vic2VxdWVudCBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAgYW5kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYE9iamVjdC5hc3NpZ25gXShodHRwczovL21kbi5pby9PYmplY3QvYXNzaWduKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbkluXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQmFyKCkge1xuICAgICAqICAgdGhpcy5jID0gMztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICAgICAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIGlmIChub25FbnVtU2hhZG93cyB8fCBpc1Byb3RvdHlwZShzb3VyY2UpIHx8IGlzQXJyYXlMaWtlKHNvdXJjZSkpIHtcbiAgICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBvd24gYW5kXG4gICAgICogaW5oZXJpdGVkIHNvdXJjZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZXh0ZW5kXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBCYXIoKSB7XG4gICAgICogICB0aGlzLmMgPSAzO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gICAgICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAgICAgKlxuICAgICAqIF8uYXNzaWduSW4oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzLCAnZCc6IDQgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25JbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbkluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGV4dGVuZFdpdGhcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbkluV2l0aCwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduSW5XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25JbldpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25XaXRoLCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byBgcGF0aHNgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgb2YgZWxlbWVudHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHBpY2tlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XG4gICAgICpcbiAgICAgKiBfLmF0KG9iamVjdCwgWydhWzBdLmIuYycsICdhWzFdJ10pO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqL1xuICAgIHZhciBhdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHJldHVybiBiYXNlQXQob2JqZWN0LCBiYXNlRmxhdHRlbihwYXRocywgMSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBgcHJvdG90eXBlYCBvYmplY3QuIElmIGFcbiAgICAgKiBgcHJvcGVydGllc2Agb2JqZWN0IGlzIGdpdmVuLCBpdHMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXNcbiAgICAgKiBhcmUgYXNzaWduZWQgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwge1xuICAgICAqICAgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcyA/IGJhc2VBc3NpZ24ocmVzdWx0LCBwcm9wZXJ0aWVzKSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlXG4gICAgICogb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0XG4gICAgICogcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqIE9uY2UgYSBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmRlZmF1bHRzRGVlcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0cyA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIGFyZ3MucHVzaCh1bmRlZmluZWQsIGFzc2lnbkluRGVmYXVsdHMpO1xuICAgICAgcmV0dXJuIGFwcGx5KGFzc2lnbkluV2l0aCwgdW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGVmYXVsdHNgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGFzc2lnbnNcbiAgICAgKiBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmRlZmF1bHRzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdHNEZWVwKHsgJ2EnOiB7ICdiJzogMiB9IH0sIHsgJ2EnOiB7ICdiJzogMSwgJ2MnOiAzIH0gfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2InOiAyLCAnYyc6IDMgfSB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzRGVlcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIGFyZ3MucHVzaCh1bmRlZmluZWQsIG1lcmdlRGVmYXVsdHMpO1xuICAgICAgcmV0dXJuIGFwcGx5KG1lcmdlV2l0aCwgdW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUga2V5IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsXG4gICAgICogIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5JyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kS2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gYmFzZUZpbmRLZXkob2JqZWN0LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBiYXNlRm9yT3duKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRLZXlgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBhIGNvbGxlY3Rpb24gaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsXG4gICAgICogIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gcmV0dXJucyAncGViYmxlcycgYXNzdW1pbmcgYF8uZmluZEtleWAgcmV0dXJucyAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd25SaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGFuXG4gICAgICogb2JqZWN0IGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXRcbiAgICAgKiBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvckluUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW4obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJywgJ2InLCB0aGVuICdjJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGxcbiAgICAgICAgPyBvYmplY3RcbiAgICAgICAgOiBiYXNlRm9yKG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9ySW5gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvckluXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvckluUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdjJywgJ2InLCB0aGVuICdhJyBhc3N1bWluZyBgXy5mb3JJbmAgbG9ncyAnYScsICdiJywgdGhlbiAnYycuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW5SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGxcbiAgICAgICAgPyBvYmplY3RcbiAgICAgICAgOiBiYXNlRm9yUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBhbiBvYmplY3QgYW5kXG4gICAgICogaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvblxuICAgICAqIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JPd25SaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JPd24obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yT3duKG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvck93bmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9yT3duXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93blJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYicgdGhlbiAnYScgYXNzdW1pbmcgYF8uZm9yT3duYCBsb2dzICdhJyB0aGVuICdiJy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmcm9tIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAgICAgKiBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqIEBzZWUgXy5mdW5jdGlvbnNJblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSBfLmNvbnN0YW50KCdhJyk7XG4gICAgICogICB0aGlzLmIgPSBfLmNvbnN0YW50KCdiJyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gXy5jb25zdGFudCgnYycpO1xuICAgICAqXG4gICAgICogXy5mdW5jdGlvbnMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9ucyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZUZ1bmN0aW9ucyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmcm9tIG93biBhbmQgaW5oZXJpdGVkXG4gICAgICogZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICogQHNlZSBfLmZ1bmN0aW9uc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSBfLmNvbnN0YW50KCdhJyk7XG4gICAgICogICB0aGlzLmIgPSBfLmNvbnN0YW50KCdiJyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gXy5jb25zdGFudCgnYycpO1xuICAgICAqXG4gICAgICogXy5mdW5jdGlvbnNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZUZ1bmN0aW9ucyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICAgICAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiB7ICdiJzogMiB9IH07XG4gICAgICogdmFyIG90aGVyID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgJ2EuYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob3RoZXIsICdhJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgaW52ZXJ0ZWQga2V5cyBhbmQgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqIElmIGBvYmplY3RgIGNvbnRhaW5zIGR1cGxpY2F0ZSB2YWx1ZXMsIHN1YnNlcXVlbnQgdmFsdWVzIG92ZXJ3cml0ZVxuICAgICAqIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMSc6ICdjJywgJzInOiAnYicgfVxuICAgICAqL1xuICAgIHZhciBpbnZlcnQgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFt2YWx1ZV0gPSBrZXk7XG4gICAgfSwgY29uc3RhbnQoaWRlbnRpdHkpKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW52ZXJ0YCBleGNlcHQgdGhhdCB0aGUgaW52ZXJ0ZWQgb2JqZWN0IGlzIGdlbmVyYXRlZFxuICAgICAqIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGVsZW1lbnQgb2YgYG9iamVjdGAgdGhydSBgaXRlcmF0ZWVgLiBUaGVcbiAgICAgKiBjb3JyZXNwb25kaW5nIGludmVydGVkIHZhbHVlIG9mIGVhY2ggaW52ZXJ0ZWQga2V5IGlzIGFuIGFycmF5IG9mIGtleXNcbiAgICAgKiByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUgaW52ZXJ0ZWQgdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pbnZlcnRCeShvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0Qnkob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuICdncm91cCcgKyB2YWx1ZTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdncm91cDEnOiBbJ2EnLCAnYyddLCAnZ3JvdXAyJzogWydiJ10gfVxuICAgICAqL1xuICAgIHZhciBpbnZlcnRCeSA9IGNyZWF0ZUludmVydGVyKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0W3ZhbHVlXS5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbdmFsdWVdID0gW2tleV07XG4gICAgICB9XG4gICAgfSwgZ2V0SXRlcmF0ZWUpO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IFsxLCAyLCAzLCA0XSB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmludm9rZShvYmplY3QsICdhWzBdLmIuYy5zbGljZScsIDEsIDMpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIHZhciBpbnZva2UgPSBiYXNlUmVzdChiYXNlSW52b2tlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAgICAgKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5cyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLmtleXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1hcFZhbHVlc2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlXG4gICAgICogc2FtZSB2YWx1ZXMgYXMgYG9iamVjdGAgYW5kIGtleXMgZ2VuZXJhdGVkIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZVxuICAgICAqIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gICAgICogQHNlZSBfLm1hcFZhbHVlc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcEtleXMoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICByZXR1cm4ga2V5ICsgdmFsdWU7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYTEnOiAxLCAnYjInOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBLZXlzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIHJlc3VsdFtpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpXSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZFxuICAgICAqIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydVxuICAgICAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gICAgICogQHNlZSBfLm1hcEtleXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2ZyZWQnOiAgICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2U7IH0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcFZhbHVlcyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKTtcblxuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gICAgICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAgICAgKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICAgICAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICAgICAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlciA9IHtcbiAgICAgKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCkge1xuICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lcmdlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgbWVyZ2VkIHZhbHVlcyBvZiB0aGUgZGVzdGluYXRpb24gYW5kIHNvdXJjZVxuICAgICAqIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBtZXJnaW5nIGlzIGhhbmRsZWQgYnkgdGhlXG4gICAgICogbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIHNldmVuIGFyZ3VtZW50czpcbiAgICAgKiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiBvYmpWYWx1ZS5jb25jYXQoc3JjVmFsdWUpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogWzFdLCAnYic6IFsyXSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiBbM10sICdiJzogWzRdIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlV2l0aChvYmplY3QsIG90aGVyLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogWzEsIDNdLCAnYic6IFsyLCA0XSB9XG4gICAgICovXG4gICAgdmFyIG1lcmdlV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYG9iamVjdGAgdGhhdCBhcmVcbiAgICAgKiBub3Qgb21pdHRlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwcm9wc10gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIG9taXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLm9taXQob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAgICAgKiAvLyA9PiB7ICdiJzogJzInIH1cbiAgICAgKi9cbiAgICB2YXIgb21pdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBwcm9wcyA9IGFycmF5TWFwKGJhc2VGbGF0dGVuKHByb3BzLCAxKSwgdG9LZXkpO1xuICAgICAgcmV0dXJuIGJhc2VQaWNrKG9iamVjdCwgYmFzZURpZmZlcmVuY2UoZ2V0QWxsS2V5c0luKG9iamVjdCksIHByb3BzKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja0J5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2ZcbiAgICAgKiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0XG4gICAgICogYHByZWRpY2F0ZWAgZG9lc24ndCByZXR1cm4gdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdHdvXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ub21pdEJ5KG9iamVjdCwgXy5pc051bWJlcik7XG4gICAgICogLy8gPT4geyAnYic6ICcyJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb21pdEJ5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gcGlja0J5KG9iamVjdCwgbmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcHJvcHNdIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgdmFyIHBpY2sgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHByb3BzKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB7fSA6IGJhc2VQaWNrKG9iamVjdCwgYXJyYXlNYXAoYmFzZUZsYXR0ZW4ocHJvcHMsIDEpLCB0b0tleSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGBvYmplY3RgIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJuc1xuICAgICAqIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6ICh2YWx1ZSwga2V5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5waWNrQnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwaWNrQnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2tCeShvYmplY3QsIGdldEFsbEtleXNJbihvYmplY3QpLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmdldGAgZXhjZXB0IHRoYXQgaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGFcbiAgICAgKiBmdW5jdGlvbiBpdCdzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgaXRzIHBhcmVudCBvYmplY3QgYW5kXG4gICAgICogaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHJlc29sdmUuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjMSc6IDMsICdjMic6IF8uY29uc3RhbnQoNCkgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMxJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMyJyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMzJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMycsIF8uY29uc3RhbnQoJ2RlZmF1bHQnKSk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdWx0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICBwYXRoID0gaXNLZXkocGF0aCwgb2JqZWN0KSA/IFtwYXRoXSA6IGNhc3RQYXRoKHBhdGgpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgLy8gRW5zdXJlIHRoZSBsb29wIGlzIGVudGVyZWQgd2hlbiBwYXRoIGlzIGVtcHR5LlxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3RbdG9LZXkocGF0aFtpbmRleF0pXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGAgZG9lc24ndCBleGlzdCxcbiAgICAgKiBpdCdzIGNyZWF0ZWQuIEFycmF5cyBhcmUgY3JlYXRlZCBmb3IgbWlzc2luZyBpbmRleCBwcm9wZXJ0aWVzIHdoaWxlIG9iamVjdHNcbiAgICAgKiBhcmUgY3JlYXRlZCBmb3IgYWxsIG90aGVyIG1pc3NpbmcgcHJvcGVydGllcy4gVXNlIGBfLnNldFdpdGhgIHRvIGN1c3RvbWl6ZVxuICAgICAqIGBwYXRoYCBjcmVhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgJ2FbMF0uYi5jJywgNCk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsIFsneCcsICcwJywgJ3knLCAneiddLCA1KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNldGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG9iamVjdHMgb2YgYHBhdGhgLiAgSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKG5zVmFsdWUsIGtleSwgbnNPYmplY3QpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHt9O1xuICAgICAqXG4gICAgICogXy5zZXRXaXRoKG9iamVjdCwgJ1swXVsxXScsICdhJywgT2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcwJzogeyAnMSc6ICdhJyB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRXaXRoKG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgXG4gICAgICogd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwIG9yIHNldCwgaXRzXG4gICAgICogZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZW50cmllc1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnRvUGFpcnMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gW1snYScsIDFdLCBbJ2InLCAyXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgdG9QYWlycyA9IGNyZWF0ZVRvUGFpcnMoa2V5cyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkLXZhbHVlIHBhaXJzXG4gICAgICogZm9yIGBvYmplY3RgIHdoaWNoIGNhbiBiZSBjb25zdW1lZCBieSBgXy5mcm9tUGFpcnNgLiBJZiBgb2JqZWN0YCBpcyBhIG1hcFxuICAgICAqIG9yIHNldCwgaXRzIGVudHJpZXMgYXJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGVudHJpZXNJblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnRvUGFpcnNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMV0sIFsnYicsIDJdLCBbJ2MnLCAzXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgdG9QYWlyc0luID0gY3JlYXRlVG9QYWlycyhrZXlzSW4pO1xuXG4gICAgLyoqXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYDsgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICAgICAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd25cbiAgICAgKiBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIHRocnUgYGl0ZXJhdGVlYCwgd2l0aCBlYWNoIGludm9jYXRpb25cbiAgICAgKiBwb3RlbnRpYWxseSBtdXRhdGluZyB0aGUgYGFjY3VtdWxhdG9yYCBvYmplY3QuIElmIGBhY2N1bXVsYXRvcmAgaXMgbm90XG4gICAgICogcHJvdmlkZWQsIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGBbW1Byb3RvdHlwZV1dYCB3aWxsIGJlIHVzZWQuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oWzIsIDMsIDRdLCBmdW5jdGlvbihyZXN1bHQsIG4pIHtcbiAgICAgKiAgIHJlc3VsdC5wdXNoKG4gKj0gbik7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDldXG4gICAgICpcbiAgICAgKiBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCkgfHwgaXNUeXBlZEFycmF5KG9iamVjdCk7XG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KTtcblxuICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzQXJyIHx8IGlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNBcnJheShvYmplY3QpID8gbmV3IEN0b3IgOiBbXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0Z1bmN0aW9uKEN0b3IpID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSkgOiB7fTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgKGlzQXJyID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHByb3BlcnR5IGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHVuc2V0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDcgfSB9XSB9O1xuICAgICAqIF8udW5zZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IHt9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnVuc2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHRydWUgOiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNldGAgZXhjZXB0IHRoYXQgYWNjZXB0cyBgdXBkYXRlcmAgdG8gcHJvZHVjZSB0aGVcbiAgICAgKiB2YWx1ZSB0byBzZXQuIFVzZSBgXy51cGRhdGVXaXRoYCB0byBjdXN0b21pemUgYHBhdGhgIGNyZWF0aW9uLiBUaGUgYHVwZGF0ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZShvYmplY3QsICdhWzBdLmIuYycsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gKiBuOyB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKlxuICAgICAqIF8udXBkYXRlKG9iamVjdCwgJ3hbMF0ueS56JywgZnVuY3Rpb24obikgeyByZXR1cm4gbiA/IG4gKyAxIDogMDsgfSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlcikge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIGNhc3RGdW5jdGlvbih1cGRhdGVyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51cGRhdGVgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBvYmplY3RzIG9mIGBwYXRoYC4gIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogcGF0aCBjcmVhdGlvbiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6IChuc1ZhbHVlLCBrZXksIG5zT2JqZWN0KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZVdpdGgob2JqZWN0LCAnWzBdWzFdJywgXy5jb25zdGFudCgnYScpLCBPYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzAnOiB7ICcxJzogJ2EnIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVdpdGgob2JqZWN0LCBwYXRoLCB1cGRhdGVyLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgY2FzdEZ1bmN0aW9uKHVwZGF0ZXIpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLnZhbHVlcygnaGknKTtcbiAgICAgKiAvLyA9PiBbJ2gnLCAnaSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA/IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHlcbiAgICAgKiB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlc0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENsYW1wcyBgbnVtYmVyYCB3aXRoaW4gdGhlIGluY2x1c2l2ZSBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2xhbXAoLTEwLCAtNSwgNSk7XG4gICAgICogLy8gPT4gLTVcbiAgICAgKlxuICAgICAqIF8uY2xhbXAoMTAsIC01LCA1KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHtcbiAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwcGVyID0gbG93ZXI7XG4gICAgICAgIGxvd2VyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXBwZXIgPSB0b051bWJlcih1cHBlcik7XG4gICAgICAgIHVwcGVyID0gdXBwZXIgPT09IHVwcGVyID8gdXBwZXIgOiAwO1xuICAgICAgfVxuICAgICAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG93ZXIgPSB0b051bWJlcihsb3dlcik7XG4gICAgICAgIGxvd2VyID0gbG93ZXIgPT09IGxvd2VyID8gbG93ZXIgOiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VDbGFtcCh0b051bWJlcihudW1iZXIpLCBsb3dlciwgdXBwZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgbmAgaXMgYmV0d2VlbiBgc3RhcnRgIGFuZCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBJZlxuICAgICAqIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsIGl0J3Mgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKiBJZiBgc3RhcnRgIGlzIGdyZWF0ZXIgdGhhbiBgZW5kYCB0aGUgcGFyYW1zIGFyZSBzd2FwcGVkIHRvIHN1cHBvcnRcbiAgICAgKiBuZWdhdGl2ZSByYW5nZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbnVtYmVyYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ucmFuZ2UsIF8ucmFuZ2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMywgMiwgNCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDgpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg0LCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDIsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMS4yLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNS4yLCA0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKC0zLCAtMiwgLTYpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IHRvRmluaXRlKGVuZCk7XG4gICAgICB9XG4gICAgICBudW1iZXIgPSB0b051bWJlcihudW1iZXIpO1xuICAgICAgcmV0dXJuIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gdGhlIGluY2x1c2l2ZSBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcy5cbiAgICAgKiBJZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCBhIG51bWJlciBiZXR3ZWVuIGAwYCBhbmQgdGhlIGdpdmVuIG51bWJlclxuICAgICAqIGlzIHJldHVybmVkLiBJZiBgZmxvYXRpbmdgIGlzIGB0cnVlYCwgb3IgZWl0aGVyIGBsb3dlcmAgb3IgYHVwcGVyYCBhcmVcbiAgICAgKiBmbG9hdHMsIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGlzIHJldHVybmVkIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNy4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXI9MF0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdXBwZXI9MV0gVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zsb2F0aW5nXSBTcGVjaWZ5IHJldHVybmluZyBhIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgwLCA1KTtcbiAgICAgKiAvLyA9PiBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSk7XG4gICAgICogLy8gPT4gYWxzbyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgxLjIsIDUuMik7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAxLjIgYW5kIDUuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbShsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSB7XG4gICAgICBpZiAoZmxvYXRpbmcgJiYgdHlwZW9mIGZsb2F0aW5nICE9ICdib29sZWFuJyAmJiBpc0l0ZXJhdGVlQ2FsbChsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSkge1xuICAgICAgICB1cHBlciA9IGZsb2F0aW5nID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1cHBlciA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IHVwcGVyO1xuICAgICAgICAgIHVwcGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsb3dlciA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IGxvd2VyO1xuICAgICAgICAgIGxvd2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgPT09IHVuZGVmaW5lZCAmJiB1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvd2VyID0gMDtcbiAgICAgICAgdXBwZXIgPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxvd2VyID0gdG9GaW5pdGUobG93ZXIpO1xuICAgICAgICBpZiAodXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHVwcGVyID0gbG93ZXI7XG4gICAgICAgICAgbG93ZXIgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVwcGVyID0gdG9GaW5pdGUodXBwZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgPiB1cHBlcikge1xuICAgICAgICB2YXIgdGVtcCA9IGxvd2VyO1xuICAgICAgICBsb3dlciA9IHVwcGVyO1xuICAgICAgICB1cHBlciA9IHRlbXA7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgfHwgbG93ZXIgJSAxIHx8IHVwcGVyICUgMSkge1xuICAgICAgICB2YXIgcmFuZCA9IG5hdGl2ZVJhbmRvbSgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlTWluKGxvd2VyICsgKHJhbmQgKiAodXBwZXIgLSBsb3dlciArIGZyZWVQYXJzZUZsb2F0KCcxZS0nICsgKChyYW5kICsgJycpLmxlbmd0aCAtIDEpKSkpLCB1cHBlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtjYW1lbCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYW1lbENhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FtZWwgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKi9cbiAgICB2YXIgY2FtZWxDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICB3b3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/IGNhcGl0YWxpemUod29yZCkgOiB3b3JkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZSBhbmQgdGhlIHJlbWFpbmluZ1xuICAgICAqIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYXBpdGFsaXplZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FwaXRhbGl6ZSgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gdXBwZXJGaXJzdCh0b1N0cmluZyhzdHJpbmcpLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlYnVycnMgYHN0cmluZ2AgYnkgY29udmVydGluZ1xuICAgICAqIFtMYXRpbi0xIFN1cHBsZW1lbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICAgICAqIGFuZCBbTGF0aW4gRXh0ZW5kZWQtQV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fRXh0ZW5kZWQtQSlcbiAgICAgKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMgYW5kIHJlbW92aW5nXG4gICAgICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBkZWJ1cnIuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gICAgICogLy8gPT4gJ2RlamEgdnUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVidXJyKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbiwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj1zdHJpbmcubGVuZ3RoXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIHVwIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBlbmRzIHdpdGggYHRhcmdldGAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2MnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBsZW5ndGhcbiAgICAgICAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgbGVuZ3RoKTtcblxuICAgICAgdmFyIGVuZCA9IHBvc2l0aW9uO1xuICAgICAgcG9zaXRpb24gLT0gdGFyZ2V0Lmxlbmd0aDtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA+PSAwICYmIHN0cmluZy5zbGljZShwb3NpdGlvbiwgZW5kKSA9PSB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgXCInXCIsIGFuZCBcIlxcYFwiIGluIGBzdHJpbmdgIHRvXG4gICAgICogdGhlaXIgY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRvIGVzY2FwZSBhZGRpdGlvbmFsXG4gICAgICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBUaG91Z2ggdGhlIFwiPlwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXG4gICAgICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAgICAgKiB1bmxlc3MgdGhleSdyZSBwYXJ0IG9mIGEgdGFnIG9yIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS4gU2VlXG4gICAgICogW01hdGhpYXMgQnluZW5zJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzKVxuICAgICAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQmFja3RpY2tzIGFyZSBlc2NhcGVkIGJlY2F1c2UgaW4gSUUgPCA5LCB0aGV5IGNhbiBicmVhayBvdXQgb2ZcbiAgICAgKiBhdHRyaWJ1dGUgdmFsdWVzIG9yIEhUTUwgY29tbWVudHMuIFNlZSBbIzU5XShodHRwczovL2h0bWw1c2VjLm9yZy8jNTkpLFxuICAgICAqIFsjMTAyXShodHRwczovL2h0bWw1c2VjLm9yZy8jMTAyKSwgWyMxMDhdKGh0dHBzOi8vaHRtbDVzZWMub3JnLyMxMDgpLCBhbmRcbiAgICAgKiBbIzEzM10oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzEzMykgb2YgdGhlXG4gICAgICogW0hUTUw1IFNlY3VyaXR5IENoZWF0c2hlZXRdKGh0dHBzOi8vaHRtbDVzZWMub3JnLykgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcbiAgICAgKiBbcXVvdGUgYXR0cmlidXRlIHZhbHVlc10oaHR0cDovL3dvbmtvLmNvbS9wb3N0L2h0bWwtZXNjYXBpbmcpIHRvIHJlZHVjZVxuICAgICAqIFhTUyB2ZWN0b3JzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGVzIHRoZSBgUmVnRXhwYCBzcGVjaWFsIGNoYXJhY3RlcnMgXCJeXCIsIFwiJFwiLCBcIlxcXCIsIFwiLlwiLCBcIipcIiwgXCIrXCIsXG4gICAgICogXCI/XCIsIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiwgXCJ9XCIsIGFuZCBcInxcIiBpbiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlUmVnRXhwKCdbbG9kYXNoXShodHRwczovL2xvZGFzaC5jb20vKScpO1xuICAgICAqIC8vID0+ICdcXFtsb2Rhc2hcXF1cXChodHRwczovL2xvZGFzaFxcLmNvbS9cXCknXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzUmVnRXhwQ2hhci50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBba2ViYWIgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3BlY2lhbF9jYXNlX3N0eWxlcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBrZWJhYiBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKi9cbiAgICB2YXIga2ViYWJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJy0nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIHNwYWNlIHNlcGFyYXRlZCB3b3JkcywgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGxvd2VyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJy0tRm9vLUJhci0tJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKi9cbiAgICB2YXIgbG93ZXJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sb3dlckZpcnN0KCdGcmVkJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiBfLmxvd2VyRmlyc3QoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnZlJFRCdcbiAgICAgKi9cbiAgICB2YXIgbG93ZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9Mb3dlckNhc2UnKTtcblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGVzIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLlxuICAgICAqIFBhZGRpbmcgY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgY2FuJ3QgYmUgZXZlbmx5IGRpdmlkZWQgYnkgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgpO1xuICAgICAqIC8vID0+ICcgIGFiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1hYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgaWYgKCFsZW5ndGggfHwgc3RyTGVuZ3RoID49IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG1pZCA9IChsZW5ndGggLSBzdHJMZW5ndGgpIC8gMjtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGNyZWF0ZVBhZGRpbmcobmF0aXZlRmxvb3IobWlkKSwgY2hhcnMpICtcbiAgICAgICAgc3RyaW5nICtcbiAgICAgICAgY3JlYXRlUGFkZGluZyhuYXRpdmVDZWlsKG1pZCksIGNoYXJzKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSByaWdodCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnYWJjICAgJ1xuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWRFbmQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgcmV0dXJuIChsZW5ndGggJiYgc3RyTGVuZ3RoIDwgbGVuZ3RoKVxuICAgICAgICA/IChzdHJpbmcgKyBjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJyAgIGFiYydcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdfLV9hYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZFN0YXJ0KHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIHJldHVybiAobGVuZ3RoICYmIHN0ckxlbmd0aCA8IGxlbmd0aClcbiAgICAgICAgPyAoY3JlYXRlUGFkZGluZyhsZW5ndGggLSBzdHJMZW5ndGgsIGNoYXJzKSArIHN0cmluZylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gaW50ZWdlciBvZiB0aGUgc3BlY2lmaWVkIHJhZGl4LiBJZiBgcmFkaXhgIGlzXG4gICAgICogYHVuZGVmaW5lZGAgb3IgYDBgLCBhIGByYWRpeGAgb2YgYDEwYCBpcyB1c2VkIHVubGVzcyBgdmFsdWVgIGlzIGFcbiAgICAgKiBoZXhhZGVjaW1hbCwgaW4gd2hpY2ggY2FzZSBhIGByYWRpeGAgb2YgYDE2YCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGFsaWducyB3aXRoIHRoZVxuICAgICAqIFtFUzUgaW1wbGVtZW50YXRpb25dKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi4yKSBvZiBgcGFyc2VJbnRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXg9MTBdIFRoZSByYWRpeCB0byBpbnRlcnByZXQgYHZhbHVlYCBieS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICcwOCcsICcxMCddLCBfLnBhcnNlSW50KTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCwgZ3VhcmQpIHtcbiAgICAgIC8vIENocm9tZSBmYWlscyB0byB0cmltIGxlYWRpbmcgPEJPTT4gd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMxMDkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGlmIChndWFyZCB8fCByYWRpeCA9PSBudWxsKSB7XG4gICAgICAgIHJhZGl4ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocmFkaXgpIHtcbiAgICAgICAgcmFkaXggPSArcmFkaXg7XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gICAgICByZXR1cm4gbmF0aXZlUGFyc2VJbnQoc3RyaW5nLCByYWRpeCB8fCAocmVIYXNIZXhQcmVmaXgudGVzdChzdHJpbmcpID8gMTYgOiAxMCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGVhdHMgdGhlIGdpdmVuIHN0cmluZyBgbmAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnKicsIDMpO1xuICAgICAqIC8vID0+ICcqKionXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMik7XG4gICAgICogLy8gPT4gJ2FiY2FiYydcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAwKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmVwZWF0KHRvU3RyaW5nKHN0cmluZyksIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIG1hdGNoZXMgZm9yIGBwYXR0ZXJuYCBpbiBgc3RyaW5nYCB3aXRoIGByZXBsYWNlbWVudGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFN0cmluZyNyZXBsYWNlYF0oaHR0cHM6Ly9tZG4uaW8vU3RyaW5nL3JlcGxhY2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IHBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gcmVwbGFjZW1lbnQgVGhlIG1hdGNoIHJlcGxhY2VtZW50LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBsYWNlKCdIaSBGcmVkJywgJ0ZyZWQnLCAnQmFybmV5Jyk7XG4gICAgICogLy8gPT4gJ0hpIEJhcm5leSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoYXJnc1swXSk7XG5cbiAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA8IDMgPyBzdHJpbmcgOiBzdHJpbmcucmVwbGFjZShhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtzbmFrZSBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbmFrZV9jYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNuYWtlIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCctLUZPTy1CQVItLScpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqL1xuICAgIHZhciBzbmFrZUNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnXycgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgYnkgYHNlcGFyYXRvcmAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFN0cmluZyNzcGxpdGBdKGh0dHBzOi8vbWRuLmlvL1N0cmluZy9zcGxpdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gc3BsaXQuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBzZXBhcmF0b3IgVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHNwbGl0IGJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIFRoZSBsZW5ndGggdG8gdHJ1bmNhdGUgcmVzdWx0cyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHN0cmluZyBzZWdtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zcGxpdCgnYS1iLWMnLCAnLScsIDIpO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcGxpdChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIGlmIChsaW1pdCAmJiB0eXBlb2YgbGltaXQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KSkge1xuICAgICAgICBzZXBhcmF0b3IgPSBsaW1pdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9BUlJBWV9MRU5HVEggOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmICghbGltaXQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKFxuICAgICAgICAgICAgdHlwZW9mIHNlcGFyYXRvciA9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgKHNlcGFyYXRvciAhPSBudWxsICYmICFpc1JlZ0V4cChzZXBhcmF0b3IpKVxuICAgICAgICAgICkpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gYmFzZVRvU3RyaW5nKHNlcGFyYXRvcik7XG4gICAgICAgIGlmICghc2VwYXJhdG9yICYmIGhhc1VuaWNvZGUoc3RyaW5nKSkge1xuICAgICAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShzdHJpbmcpLCAwLCBsaW1pdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBbc3RhcnQgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3R5bGlzdGljX29yX3NwZWNpYWxpc2VkX3VzYWdlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0YXJ0IGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKi9cbiAgICB2YXIgc3RhcnRDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgdXBwZXJGaXJzdCh3b3JkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj0wXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIGB0YXJnZXRgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBwb3NpdGlvbiA9IGJhc2VDbGFtcCh0b0ludGVnZXIocG9zaXRpb24pLCAwLCBzdHJpbmcubGVuZ3RoKTtcbiAgICAgIHRhcmdldCA9IGJhc2VUb1N0cmluZyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHN0cmluZy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyB0YXJnZXQubGVuZ3RoKSA9PSB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICAgICAqIGluIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJzLCBIVE1MLWVzY2FwZSBpbnRlcnBvbGF0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluXG4gICAgICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXG4gICAgICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAgICAgKiBvYmplY3QgaXMgZ2l2ZW4sIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgXy50ZW1wbGF0ZVNldHRpbmdzYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuICAgICAqIFtzb3VyY2VVUkxzXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsKVxuICAgICAqIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWVcbiAgICAgKiBbbG9kYXNoJ3MgY3VzdG9tIGJ1aWxkcyBkb2N1bWVudGF0aW9uXShodHRwczovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkcykuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWVcbiAgICAgKiBbQ2hyb21lJ3MgZXh0ZW5zaW9ucyBkb2N1bWVudGF0aW9uXShodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgdGVtcGxhdGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmVzY2FwZV1cbiAgICAgKiAgVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlPV8udGVtcGxhdGVTZXR0aW5ncy5ldmFsdWF0ZV1cbiAgICAgKiAgVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHM9Xy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNdXG4gICAgICogIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlPV8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZV1cbiAgICAgKiAgVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVSTD0nbG9kYXNoLnRlbXBsYXRlU291cmNlc1tuXSddXG4gICAgICogIFRoZSBzb3VyY2VVUkwgb2YgdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZT0nb2JqJ11cbiAgICAgKiAgVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIGRhdGEgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XG4gICAgICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBleGVjdXRlIEphdmFTY3JpcHQgYW5kIGdlbmVyYXRlIEhUTUwuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgdXNlcik7ICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgRVMgZGVsaW1pdGVyIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBkZWZhdWx0IFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAncGViYmxlcycgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIGJhY2tzbGFzaGVzIHRvIHRyZWF0IGRlbGltaXRlcnMgYXMgcGxhaW4gdGV4dC5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JT0gXCJcXFxcPCUtIHZhbHVlICVcXFxcPlwiICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnaWdub3JlZCcgfSk7XG4gICAgICogLy8gPT4gJzwlLSB2YWx1ZSAlPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYC5cbiAgICAgKiB2YXIgdGV4dCA9ICc8JSBqcS5lYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUodGV4dCwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAgICAgKiBjb21waWxlZChkYXRhKTtcbiAgICAgKiAvLyA9PiBGaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yLlxuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICAgICAqIGNvbXBpbGVkLnNvdXJjZTtcbiAgICAgKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAgICAgKiAvLyAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICAgKiAvLyAgIHJldHVybiBfX3A7XG4gICAgICogLy8gfVxuICAgICAqXG4gICAgICogLy8gVXNlIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLlxuICAgICAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ211c3RhY2hlJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gICAgICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMuXG4gICAgICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2pzdC5qcycpLCAnXFxcbiAgICAgKiAgIHZhciBKU1QgPSB7XFxcbiAgICAgKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAgICAgKiAgIH07XFxcbiAgICAgKiAnKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0ZW1wbGF0ZShzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSB7XG4gICAgICAvLyBCYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uXG4gICAgICAvLyAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXG4gICAgICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzIChodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UKS5cbiAgICAgIHZhciBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO1xuXG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBvcHRpb25zID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLCBzZXR0aW5ncywgYXNzaWduSW5EZWZhdWx0cyk7XG5cbiAgICAgIHZhciBpbXBvcnRzID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMsIGFzc2lnbkluRGVmYXVsdHMpLFxuICAgICAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XG5cbiAgICAgIHZhciBpc0VzY2FwaW5nLFxuICAgICAgICAgIGlzRXZhbHVhdGluZyxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgICAgIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgICAgIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICAgICAsICdnJyk7XG5cbiAgICAgIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgIHZhciBzb3VyY2VVUkwgPSAnLy8jIHNvdXJjZVVSTD0nICtcbiAgICAgICAgKCdzb3VyY2VVUkwnIGluIG9wdGlvbnNcbiAgICAgICAgICA/IG9wdGlvbnMuc291cmNlVVJMXG4gICAgICAgICAgOiAoJ2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbJyArICgrK3RlbXBsYXRlQ291bnRlcikgKyAnXScpXG4gICAgICAgICkgKyAnXFxuJztcblxuICAgICAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgICAgIC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2FuJ3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzLlxuICAgICAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgICAvLyBUaGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIG5lZWRzIGBtYXRjaGAgcmV0dXJuZWQgaW5cbiAgICAgICAgLy8gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7XG5cbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAgIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpbi5cbiAgICAgIHZhciB2YXJpYWJsZSA9IG9wdGlvbnMudmFyaWFibGU7XG4gICAgICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgICAgIHNvdXJjZSA9ICd3aXRoIChvYmopIHtcXG4nICsgc291cmNlICsgJ1xcbn1cXG4nO1xuICAgICAgfVxuICAgICAgLy8gQ2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzLlxuICAgICAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gICAgICAvLyBGcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5LlxuICAgICAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAodmFyaWFibGUgfHwgJ29iaicpICsgJykge1xcbicgK1xuICAgICAgICAodmFyaWFibGVcbiAgICAgICAgICA/ICcnXG4gICAgICAgICAgOiAnb2JqIHx8IChvYmogPSB7fSk7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgXCJ2YXIgX190LCBfX3AgPSAnJ1wiICtcbiAgICAgICAgKGlzRXNjYXBpbmdcbiAgICAgICAgICAgPyAnLCBfX2UgPSBfLmVzY2FwZSdcbiAgICAgICAgICAgOiAnJ1xuICAgICAgICApICtcbiAgICAgICAgKGlzRXZhbHVhdGluZ1xuICAgICAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuJyArXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICAgICAgOiAnO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIHNvdXJjZSArXG4gICAgICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgICAgIHZhciByZXN1bHQgPSBhdHRlbXB0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24oaW1wb3J0c0tleXMsIHNvdXJjZVVSTCArICdyZXR1cm4gJyArIHNvdXJjZSlcbiAgICAgICAgICAuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2Qgb3JcbiAgICAgIC8vIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvciBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgaWYgKGlzRXJyb3IocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBhIHdob2xlLCB0byBsb3dlciBjYXNlIGp1c3QgbGlrZVxuICAgICAqIFtTdHJpbmcjdG9Mb3dlckNhc2VdKGh0dHBzOi8vbWRuLmlvL3RvTG93ZXJDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGxvd2VyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0xvd2VyKCctLUZvby1CYXItLScpO1xuICAgICAqIC8vID0+ICctLWZvby1iYXItLSdcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb2JhcidcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnX19mb29fYmFyX18nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Mb3dlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBhIHdob2xlLCB0byB1cHBlciBjYXNlIGp1c3QgbGlrZVxuICAgICAqIFtTdHJpbmcjdG9VcHBlckNhc2VdKGh0dHBzOi8vbWRuLmlvL3RvVXBwZXJDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVwcGVyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1VwcGVyKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICctLUZPTy1CQVItLSdcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPT0JBUidcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignX19mb29fYmFyX18nKTtcbiAgICAgKiAvLyA9PiAnX19GT09fQkFSX18nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9VcHBlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbSgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICpcbiAgICAgKiBfLm1hcChbJyAgZm9vICAnLCAnICBiYXIgICddLCBfLnRyaW0pO1xuICAgICAqIC8vID0+IFsnZm9vJywgJ2JhciddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbShzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgY2hyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoY2hhcnMpLFxuICAgICAgICAgIHN0YXJ0ID0gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpLFxuICAgICAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykgKyAxO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIHN0YXJ0LCBlbmQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbUVuZCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICcgIGFiYydcbiAgICAgKlxuICAgICAqIF8udHJpbUVuZCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJy1fLWFiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltRW5kKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbUVuZCwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBlbmQgPSBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKSArIDE7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMCwgZW5kKS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbVN0YXJ0KCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYyAgJ1xuICAgICAqXG4gICAgICogXy50cmltU3RhcnQoJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmMtXy0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbVN0YXJ0KHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIHN0YXJ0ID0gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGVzIGBzdHJpbmdgIGlmIGl0J3MgbG9uZ2VyIHRoYW4gdGhlIGdpdmVuIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBUaGUgbGFzdCBjaGFyYWN0ZXJzIG9mIHRoZSB0cnVuY2F0ZWQgc3RyaW5nIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBvbWlzc2lvblxuICAgICAqIHN0cmluZyB3aGljaCBkZWZhdWx0cyB0byBcIi4uLlwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRydW5jYXRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sZW5ndGg9MzBdIFRoZSBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9taXNzaW9uPScuLi4nXSBUaGUgc3RyaW5nIHRvIGluZGljYXRlIHRleHQgaXMgb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtvcHRpb25zLnNlcGFyYXRvcl0gVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHRydW5jYXRlIHRvLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRydW5jYXRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nKTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAnICdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLC4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogLyw/ICsvXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZS4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnb21pc3Npb24nOiAnIFsuLi5dJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWcgWy4uLl0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGUoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gREVGQVVMVF9UUlVOQ19MRU5HVEgsXG4gICAgICAgICAgb21pc3Npb24gPSBERUZBVUxUX1RSVU5DX09NSVNTSU9OO1xuXG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9ICdzZXBhcmF0b3InIGluIG9wdGlvbnMgPyBvcHRpb25zLnNlcGFyYXRvciA6IHNlcGFyYXRvcjtcbiAgICAgICAgbGVuZ3RoID0gJ2xlbmd0aCcgaW4gb3B0aW9ucyA/IHRvSW50ZWdlcihvcHRpb25zLmxlbmd0aCkgOiBsZW5ndGg7XG4gICAgICAgIG9taXNzaW9uID0gJ29taXNzaW9uJyBpbiBvcHRpb25zID8gYmFzZVRvU3RyaW5nKG9wdGlvbnMub21pc3Npb24pIDogb21pc3Npb247XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIGlmIChoYXNVbmljb2RlKHN0cmluZykpIHtcbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyk7XG4gICAgICAgIHN0ckxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA+PSBzdHJMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBlbmQgPSBsZW5ndGggLSBzdHJpbmdTaXplKG9taXNzaW9uKTtcbiAgICAgIGlmIChlbmQgPCAxKSB7XG4gICAgICAgIHJldHVybiBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzdHJTeW1ib2xzXG4gICAgICAgID8gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDAsIGVuZCkuam9pbignJylcbiAgICAgICAgOiBzdHJpbmcuc2xpY2UoMCwgZW5kKTtcblxuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJTeW1ib2xzKSB7XG4gICAgICAgIGVuZCArPSAocmVzdWx0Lmxlbmd0aCAtIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xuICAgICAgICBpZiAoc3RyaW5nLnNsaWNlKGVuZCkuc2VhcmNoKHNlcGFyYXRvcikpIHtcbiAgICAgICAgICB2YXIgbWF0Y2gsXG4gICAgICAgICAgICAgIHN1YnN0cmluZyA9IHJlc3VsdDtcblxuICAgICAgICAgIGlmICghc2VwYXJhdG9yLmdsb2JhbCkge1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIHRvU3RyaW5nKHJlRmxhZ3MuZXhlYyhzZXBhcmF0b3IpKSArICdnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdWJzdHJpbmcpKSkge1xuICAgICAgICAgICAgdmFyIG5ld0VuZCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgbmV3RW5kID09PSB1bmRlZmluZWQgPyBlbmQgOiBuZXdFbmQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0cmluZy5pbmRleE9mKGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpLCBlbmQpICE9IGVuZCkge1xuICAgICAgICB2YXIgaW5kZXggPSByZXN1bHQubGFzdEluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8uZXNjYXBlYDsgdGhpcyBtZXRob2QgY29udmVydHMgdGhlIEhUTUwgZW50aXRpZXNcbiAgICAgKiBgJmFtcDtgLCBgJmx0O2AsIGAmZ3Q7YCwgYCZxdW90O2AsIGAmIzM5O2AsIGFuZCBgJiM5NjtgIGluIGBzdHJpbmdgIHRvXG4gICAgICogdGhlaXIgY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIEhUTUwgZW50aXRpZXMgYXJlIHVuZXNjYXBlZC4gVG8gdW5lc2NhcGUgYWRkaXRpb25hbFxuICAgICAqIEhUTUwgZW50aXRpZXMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNi4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc0VzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZWRIdG1sLCB1bmVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgc3BhY2Ugc2VwYXJhdGVkIHdvcmRzLCB0byB1cHBlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdXBwZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnLS1mb28tYmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnX19mb29fYmFyX18nKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKi9cbiAgICB2YXIgdXBwZXJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgd29yZC50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51cHBlckZpcnN0KCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICpcbiAgICAgKiBfLnVwcGVyRmlyc3QoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnRlJFRCdcbiAgICAgKi9cbiAgICB2YXIgdXBwZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9VcHBlckNhc2UnKTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW3BhdHRlcm5dIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdvcmRzLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnLCAvW14sIF0rL2cpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAnJicsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3b3JkcyhzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcGF0dGVybiA9IGd1YXJkID8gdW5kZWZpbmVkIDogcGF0dGVybjtcblxuICAgICAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSA/IHVuaWNvZGVXb3JkcyhzdHJpbmcpIDogYXNjaWlXb3JkcyhzdHJpbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKSB8fCBbXTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICAgICAqIG9iamVjdC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGF0dGVtcHQuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzLlxuICAgICAqIHZhciBlbGVtZW50cyA9IF8uYXR0ZW1wdChmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAqIH0sICc+Xz4nKTtcbiAgICAgKlxuICAgICAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gICAgICogICBlbGVtZW50cyA9IFtdO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICB2YXIgYXR0ZW1wdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gaXNFcnJvcihlKSA/IGUgOiBuZXcgRXJyb3IoZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBtZXRob2RzIG9mIGFuIG9iamVjdCB0byB0aGUgb2JqZWN0IGl0c2VsZiwgb3ZlcndyaXRpbmcgdGhlIGV4aXN0aW5nXG4gICAgICogbWV0aG9kLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBtZXRob2ROYW1lcyBUaGUgb2JqZWN0IG1ldGhvZCBuYW1lcyB0byBiaW5kLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ2NsaWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdjbGlja2VkICcgKyB0aGlzLmxhYmVsKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5iaW5kQWxsKHZpZXcsIFsnY2xpY2snXSk7XG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHZpZXcuY2xpY2spO1xuICAgICAqIC8vID0+IExvZ3MgJ2NsaWNrZWQgZG9jcycgd2hlbiBjbGlja2VkLlxuICAgICAqL1xuICAgIHZhciBiaW5kQWxsID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBtZXRob2ROYW1lcykge1xuICAgICAgYXJyYXlFYWNoKGJhc2VGbGF0dGVuKG1ldGhvZE5hbWVzLCAxKSwgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGtleSA9IHRvS2V5KGtleSk7XG4gICAgICAgIG9iamVjdFtrZXldID0gYmluZChvYmplY3Rba2V5XSwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGl0ZXJhdGVzIG92ZXIgYHBhaXJzYCBhbmQgaW52b2tlcyB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqIGZ1bmN0aW9uIG9mIHRoZSBmaXJzdCBwcmVkaWNhdGUgdG8gcmV0dXJuIHRydXRoeS4gVGhlIHByZWRpY2F0ZS1mdW5jdGlvblxuICAgICAqIHBhaXJzIGFyZSBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgVGhlIHByZWRpY2F0ZS1mdW5jdGlvbiBwYWlycy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5jb25kKFtcbiAgICAgKiAgIFtfLm1hdGNoZXMoeyAnYSc6IDEgfSksICAgICAgICAgICBfLmNvbnN0YW50KCdtYXRjaGVzIEEnKV0sXG4gICAgICogICBbXy5jb25mb3Jtcyh7ICdiJzogXy5pc051bWJlciB9KSwgXy5jb25zdGFudCgnbWF0Y2hlcyBCJyldLFxuICAgICAqICAgW18uc3R1YlRydWUsICAgICAgICAgICAgICAgICAgICAgIF8uY29uc3RhbnQoJ25vIG1hdGNoJyldXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gJ21hdGNoZXMgQSdcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6IDAsICdiJzogMSB9KTtcbiAgICAgKiAvLyA9PiAnbWF0Y2hlcyBCJ1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogJzEnLCAnYic6ICcyJyB9KTtcbiAgICAgKiAvLyA9PiAnbm8gbWF0Y2gnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZChwYWlycykge1xuICAgICAgdmFyIGxlbmd0aCA9IHBhaXJzID8gcGFpcnMubGVuZ3RoIDogMCxcbiAgICAgICAgICB0b0l0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoKTtcblxuICAgICAgcGFpcnMgPSAhbGVuZ3RoID8gW10gOiBhcnJheU1hcChwYWlycywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICBpZiAodHlwZW9mIHBhaXJbMV0gIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RvSXRlcmF0ZWUocGFpclswXSksIHBhaXJbMV1dO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICAgIGlmIChhcHBseShwYWlyWzBdLCB0aGlzLCBhcmdzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHBhaXJbMV0sIHRoaXMsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgcHJlZGljYXRlIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgd2l0aFxuICAgICAqIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlcyBvZiBhIGdpdmVuIG9iamVjdCwgcmV0dXJuaW5nIGB0cnVlYCBpZlxuICAgICAqIGFsbCBwcmVkaWNhdGVzIHJldHVybiB0cnV0aHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmNvbmZvcm1zVG9gIHdpdGhcbiAgICAgKiBgc291cmNlYCBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAyLCAnYic6IDEgfSxcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLmNvbmZvcm1zKHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMTsgfSB9KSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25mb3Jtcyhzb3VyY2UpIHtcbiAgICAgIHJldHVybiBiYXNlQ29uZm9ybXMoYmFzZUNsb25lKHNvdXJjZSwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgYHZhbHVlYCB0byBkZXRlcm1pbmUgd2hldGhlciBhIGRlZmF1bHQgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkIGluXG4gICAgICogaXRzIHBsYWNlLiBUaGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaWYgYHZhbHVlYCBpcyBgTmFOYCwgYG51bGxgLFxuICAgICAqIG9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgVGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRUbygxLCAxMCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0VG8odW5kZWZpbmVkLCAxMCk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZhdWx0VG8odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSkgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIGdpdmVuIGZ1bmN0aW9uc1xuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2Z1bmNzXSBUaGUgZnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQHNlZSBfLmZsb3dSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3coW18uYWRkLCBzcXVhcmVdKTtcbiAgICAgKiBhZGRTcXVhcmUoMSwgMik7XG4gICAgICogLy8gPT4gOVxuICAgICAqL1xuICAgIHZhciBmbG93ID0gY3JlYXRlRmxvdygpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbG93YCBleGNlcHQgdGhhdCBpdCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdFxuICAgICAqIGludm9rZXMgdGhlIGdpdmVuIGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIF8uZmxvd1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3dSaWdodChbc3F1YXJlLCBfLmFkZF0pO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3dSaWdodCA9IGNyZWF0ZUZsb3codHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24uIElmIGBmdW5jYCBpcyBhIHByb3BlcnR5IG5hbWUsIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybnMgdGhlXG4gICAgICogcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gZWxlbWVudC4gSWYgYGZ1bmNgIGlzIGFuIGFycmF5IG9yIG9iamVjdCwgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbiByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBjb250YWluIHRoZSBlcXVpdmFsZW50XG4gICAgICogc291cmNlIHByb3BlcnRpZXMsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gW2Z1bmM9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLml0ZXJhdGVlKHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSkpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5pdGVyYXRlZShbJ3VzZXInLCAnZnJlZCddKSk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXAodXNlcnMsIF8uaXRlcmF0ZWUoJ3VzZXInKSk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgY3VzdG9tIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICogXy5pdGVyYXRlZSA9IF8ud3JhcChfLml0ZXJhdGVlLCBmdW5jdGlvbihpdGVyYXRlZSwgZnVuYykge1xuICAgICAqICAgcmV0dXJuICFfLmlzUmVnRXhwKGZ1bmMpID8gaXRlcmF0ZWUoZnVuYykgOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgKiAgICAgcmV0dXJuIGZ1bmMudGVzdChzdHJpbmcpO1xuICAgICAqICAgfTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFsnYWJjJywgJ2RlZiddLCAvZWYvKTtcbiAgICAgKiAvLyA9PiBbJ2RlZiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXRlcmF0ZWUoZnVuYykge1xuICAgICAgcmV0dXJuIGJhc2VJdGVyYXRlZSh0eXBlb2YgZnVuYyA9PSAnZnVuY3Rpb24nID8gZnVuYyA6IGJhc2VDbG9uZShmdW5jLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGEgZ2l2ZW5cbiAgICAgKiBvYmplY3QgYW5kIGBzb3VyY2VgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZSBnaXZlbiBvYmplY3QgaGFzIGVxdWl2YWxlbnRcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmlzTWF0Y2hgIHdpdGggYHNvdXJjZWBcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0IGBzb3VyY2VgXG4gICAgICogdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWUgYF8uaXNFcXVhbGBcbiAgICAgKiBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LFxuICAgICAqICAgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5tYXRjaGVzKHsgJ2EnOiA0LCAnYyc6IDYgfSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzKGJhc2VDbG9uZShzb3VyY2UsIHRydWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdGhlXG4gICAgICogdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0IHRvIGBzcmNWYWx1ZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlXG4gICAgICogb2JqZWN0IHZhbHVlIGlzIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdFxuICAgICAqIGBzcmNWYWx1ZWAgdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWVcbiAgICAgKiBgXy5pc0VxdWFsYCBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LFxuICAgICAqICAgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKG9iamVjdHMsIF8ubWF0Y2hlc1Byb3BlcnR5KCdhJywgNCkpO1xuICAgICAqIC8vID0+IHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBiYXNlQ2xvbmUoc3JjVmFsdWUsIHRydWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52b2tlciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogeyAnYic6IF8uY29uc3RhbnQoMikgfSB9LFxuICAgICAqICAgeyAnYSc6IHsgJ2InOiBfLmNvbnN0YW50KDEpIH0gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZCgnYS5iJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5tZXRob2QoWydhJywgJ2InXSkpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIHZhciBtZXRob2QgPSBiYXNlUmVzdChmdW5jdGlvbihwYXRoLCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1ldGhvZGA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcbiAgICAgKiB0aGUgbWV0aG9kIGF0IGEgZ2l2ZW4gcGF0aCBvZiBgb2JqZWN0YC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZva2VyIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBfLnRpbWVzKDMsIF8uY29uc3RhbnQpLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZE9mID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBmdW5jdGlvbiBwcm9wZXJ0aWVzIG9mIGEgc291cmNlXG4gICAgICogb2JqZWN0IHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIElmIGBvYmplY3RgIGlzIGEgZnVuY3Rpb24sIHRoZW4gbWV0aG9kc1xuICAgICAqIGFyZSBhZGRlZCB0byBpdHMgcHJvdG90eXBlIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVXNlIGBfLnJ1bkluQ29udGV4dGAgdG8gY3JlYXRlIGEgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdG9cbiAgICAgKiBhdm9pZCBjb25mbGljdHMgY2F1c2VkIGJ5IG1vZGlmeWluZyB0aGUgb3JpZ2luYWwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBbb2JqZWN0PWxvZGFzaF0gVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgZnVuY3Rpb25zIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoYWluPXRydWVdIFNwZWNpZnkgd2hldGhlciBtaXhpbnMgYXJlIGNoYWluYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiB2b3dlbHMoc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gXy5maWx0ZXIoc3RyaW5nLCBmdW5jdGlvbih2KSB7XG4gICAgICogICAgIHJldHVybiAvW2FlaW91XS9pLnRlc3Qodik7XG4gICAgICogICB9KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9KTtcbiAgICAgKiBfLnZvd2VscygnZnJlZCcpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpLFxuICAgICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIHByb3BzKTtcblxuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCAmJlxuICAgICAgICAgICEoaXNPYmplY3Qoc291cmNlKSAmJiAobWV0aG9kTmFtZXMubGVuZ3RoIHx8ICFwcm9wcy5sZW5ndGgpKSkge1xuICAgICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgICBzb3VyY2UgPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdCA9IHRoaXM7XG4gICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgICB9XG4gICAgICB2YXIgY2hhaW4gPSAhKGlzT2JqZWN0KG9wdGlvbnMpICYmICdjaGFpbicgaW4gb3B0aW9ucykgfHwgISFvcHRpb25zLmNoYWluLFxuICAgICAgICAgIGlzRnVuYyA9IGlzRnVuY3Rpb24ob2JqZWN0KTtcblxuICAgICAgYXJyYXlFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBmdW5jID0gc291cmNlW21ldGhvZE5hbWVdO1xuICAgICAgICBvYmplY3RbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgICAgb2JqZWN0LnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX187XG4gICAgICAgICAgICBpZiAoY2hhaW4gfHwgY2hhaW5BbGwpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCh0aGlzLl9fd3JhcHBlZF9fKSxcbiAgICAgICAgICAgICAgICAgIGFjdGlvbnMgPSByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XG5cbiAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHsgJ2Z1bmMnOiBmdW5jLCAnYXJncyc6IGFyZ3VtZW50cywgJ3RoaXNBcmcnOiBvYmplY3QgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSBjaGFpbkFsbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG9iamVjdCwgYXJyYXlQdXNoKFt0aGlzLnZhbHVlKCldLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnRzIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXG4gICAgICogdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbG9kYXNoID0gXy5ub0NvbmZsaWN0KCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgIGlmIChyb290Ll8gPT09IHRoaXMpIHtcbiAgICAgICAgcm9vdC5fID0gb2xkRGFzaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gICAgICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGdldHMgdGhlIGFyZ3VtZW50IGF0IGluZGV4IGBuYC4gSWYgYG5gIGlzIG5lZ2F0aXZlLFxuICAgICAqIHRoZSBudGggYXJndW1lbnQgZnJvbSB0aGUgZW5kIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MF0gVGhlIGluZGV4IG9mIHRoZSBhcmd1bWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFzcy10aHJ1IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ubnRoQXJnKDEpO1xuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiAnYidcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoLTIpO1xuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiAnYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudGhBcmcobikge1xuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBiYXNlTnRoKGFyZ3MsIG4pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgaXRlcmF0ZWVzYCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXNcbiAgICAgKiBhbmQgcmV0dXJucyB0aGVpciByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlcihbTWF0aC5tYXgsIE1hdGgubWluXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKDEsIDIsIDMsIDQpO1xuICAgICAqIC8vID0+IFs0LCAxXVxuICAgICAqL1xuICAgIHZhciBvdmVyID0gY3JlYXRlT3ZlcihhcnJheU1hcCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgKiphbGwqKiBvZiB0aGUgYHByZWRpY2F0ZXNgIHJldHVyblxuICAgICAqIHRydXRoeSB3aGVuIGludm9rZWQgd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgcHJlZGljYXRlcyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJFdmVyeShbQm9vbGVhbiwgaXNGaW5pdGVdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoJzEnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBmdW5jKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgb3ZlckV2ZXJ5ID0gY3JlYXRlT3ZlcihhcnJheUV2ZXJ5KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiAqKmFueSoqIG9mIHRoZSBgcHJlZGljYXRlc2AgcmV0dXJuXG4gICAgICogdHJ1dGh5IHdoZW4gaW52b2tlZCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbcHJlZGljYXRlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBwcmVkaWNhdGVzIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlclNvbWUoW0Jvb2xlYW4sIGlzRmluaXRlXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKCcxJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgb3ZlclNvbWUgPSBjcmVhdGVPdmVyKGFycmF5U29tZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gICAgICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucHJvcGVydHlgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zXG4gICAgICogdGhlIHZhbHVlIGF0IGEgZ2l2ZW4gcGF0aCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMCwgMSwgMl0sXG4gICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqXG4gICAgICogXy5tYXAoW1snYScsICcyJ10sIFsnYycsICcwJ11dLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHlPZihvYmplY3QpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cbiAgICAgKiBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIEEgc3RlcCBvZiBgLTFgIGlzIHVzZWQgaWYgYSBuZWdhdGl2ZVxuICAgICAqIGBzdGFydGAgaXMgc3BlY2lmaWVkIHdpdGhvdXQgYW4gYGVuZGAgb3IgYHN0ZXBgLiBJZiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLFxuICAgICAqIGl0J3Mgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZSg0KTtcbiAgICAgKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoLTQpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIHZhciByYW5nZSA9IGNyZWF0ZVJhbmdlKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJhbmdlYCBleGNlcHQgdGhhdCBpdCBwb3B1bGF0ZXMgdmFsdWVzIGluXG4gICAgICogZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoNCk7XG4gICAgICogLy8gPT4gWzMsIDIsIDEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoLTQpO1xuICAgICAqIC8vID0+IFstMywgLTIsIC0xLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDEsIDUpO1xuICAgICAqIC8vID0+IFs0LCAzLCAyLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMTUsIDEwLCA1LCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWy0zLCAtMiwgLTEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICB2YXIgcmFuZ2VSaWdodCA9IGNyZWF0ZVJhbmdlKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICAgICAqIC8vID0+IFtbXSwgW11dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gICAgICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5zdHViT2JqZWN0KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICAgICAqIC8vID0+IFt7fSwge31dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJPYmplY3QoKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViU3RyaW5nKTtcbiAgICAgKiAvLyA9PiBbJycsICcnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViVHJ1ZSk7XG4gICAgICogLy8gPT4gW3RydWUsIHRydWVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YlRydWUoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBpdGVyYXRlZSBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZlxuICAgICAqIGVhY2ggaW52b2NhdGlvbi4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7IChpbmRleCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIFN0cmluZyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnLCAnMiddXG4gICAgICpcbiAgICAgKiAgXy50aW1lcyg0LCBfLmNvbnN0YW50KDApKTtcbiAgICAgKiAvLyA9PiBbMCwgMCwgMCwgMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lcyhuLCBpdGVyYXRlZSkge1xuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIGlmIChuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBNQVhfQVJSQVlfTEVOR1RILFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKTtcblxuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSk7XG4gICAgICBuIC09IE1BWF9BUlJBWV9MRU5HVEg7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlVGltZXMobGVuZ3RoLCBpdGVyYXRlZSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgaXRlcmF0ZWUoaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvUGF0aCgnYS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKlxuICAgICAqIF8udG9QYXRoKCdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IFsnYScsICcwJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9QYXRoKHZhbHVlKSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCB0b0tleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTeW1ib2wodmFsdWUpID8gW3ZhbHVlXSA6IGNvcHlBcnJheShzdHJpbmdUb1BhdGgodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQuIElmIGBwcmVmaXhgIGlzIGdpdmVuLCB0aGUgSUQgaXMgYXBwZW5kZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4PScnXSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAgICAgKiAvLyA9PiAnY29udGFjdF8xMDQnXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCk7XG4gICAgICogLy8gPT4gJzEwNSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHByZWZpeCkgKyBpZDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXVnZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYW4gYWRkaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFkZGVuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhbiBhZGRpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0b3RhbC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hZGQoNiwgNCk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICB2YXIgYWRkID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihhdWdlbmQsIGFkZGVuZCkge1xuICAgICAgcmV0dXJuIGF1Z2VuZCArIGFkZGVuZDtcbiAgICB9LCAwKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgdXAgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQgdXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB1cCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIHVwIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jZWlsKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICpcbiAgICAgKiBfLmNlaWwoNi4wMDQsIDIpO1xuICAgICAqIC8vID0+IDYuMDFcbiAgICAgKlxuICAgICAqIF8uY2VpbCg2MDQwLCAtMik7XG4gICAgICogLy8gPT4gNjEwMFxuICAgICAqL1xuICAgIHZhciBjZWlsID0gY3JlYXRlUm91bmQoJ2NlaWwnKTtcblxuICAgIC8qKlxuICAgICAqIERpdmlkZSB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlkZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBkaXZpc2lvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGl2aXNvciBUaGUgc2Vjb25kIG51bWJlciBpbiBhIGRpdmlzaW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHF1b3RpZW50LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpdmlkZSg2LCA0KTtcbiAgICAgKiAvLyA9PiAxLjVcbiAgICAgKi9cbiAgICB2YXIgZGl2aWRlID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihkaXZpZGVuZCwgZGl2aXNvcikge1xuICAgICAgcmV0dXJuIGRpdmlkZW5kIC8gZGl2aXNvcjtcbiAgICB9LCAxKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgZG93biB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZCBkb3duLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgZG93biB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIGRvd24gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsb29yKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLmZsb29yKDAuMDQ2LCAyKTtcbiAgICAgKiAvLyA9PiAwLjA0XG4gICAgICpcbiAgICAgKiBfLmZsb29yKDQwNjAsIC0yKTtcbiAgICAgKiAvLyA9PiA0MDAwXG4gICAgICovXG4gICAgdmFyIGZsb29yID0gY3JlYXRlUm91bmQoJ2Zsb29yJyk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAgICAgKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXgoWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiBfLm1heChbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4KGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlR3QpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWF4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWF4Qnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduJzogMiB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1heEJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4geyAnbic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heEJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VHdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1lYW4gb2YgdGhlIHZhbHVlcyBpbiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWVhbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZWFuKGFycmF5KSB7XG4gICAgICByZXR1cm4gYmFzZU1lYW4oYXJyYXksIGlkZW50aXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lYW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSB2YWx1ZSB0byBiZSBhdmVyYWdlZC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDQgfSwgeyAnbic6IDIgfSwgeyAnbic6IDggfSwgeyAnbic6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLm1lYW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IDVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWVhbkJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lYW5CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlTWVhbihhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAgICAgKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5taW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLm1pbihbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlTHQpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWluQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduJzogMSB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1pbkJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4geyAnbic6IDEgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbkJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VMdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aXBsaWVyIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbXVsdGlwbGljYW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgbXVsdGlwbGljYXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcHJvZHVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tdWx0aXBseSg2LCA0KTtcbiAgICAgKiAvLyA9PiAyNFxuICAgICAqL1xuICAgIHZhciBtdWx0aXBseSA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obXVsdGlwbGllciwgbXVsdGlwbGljYW5kKSB7XG4gICAgICByZXR1cm4gbXVsdGlwbGllciAqIG11bHRpcGxpY2FuZDtcbiAgICB9LCAxKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNiwgMik7XG4gICAgICogLy8gPT4gNC4wMVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDEwMFxuICAgICAqL1xuICAgIHZhciByb3VuZCA9IGNyZWF0ZVJvdW5kKCdyb3VuZCcpO1xuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3QgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW51ZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBzdWJ0cmFjdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3VidHJhaGVuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhIHN1YnRyYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGRpZmZlcmVuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3VidHJhY3QoNiwgNCk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIHZhciBzdWJ0cmFjdCA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obWludWVuZCwgc3VidHJhaGVuZCkge1xuICAgICAgcmV0dXJuIG1pbnVlbmQgLSBzdWJ0cmFoZW5kO1xuICAgIH0sIDApO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHN1bSBvZiB0aGUgdmFsdWVzIGluIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN1bShbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU3VtKGFycmF5LCBpZGVudGl0eSlcbiAgICAgICAgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc3VtYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgdmFsdWUgdG8gYmUgc3VtbWVkLlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiA0IH0sIHsgJ24nOiAyIH0sIHsgJ24nOiA4IH0sIHsgJ24nOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5zdW1CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IDIwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnN1bUJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdW1CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiAwO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBtZXRob2RzIHRoYXQgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbiAgICBsb2Rhc2guYWZ0ZXIgPSBhZnRlcjtcbiAgICBsb2Rhc2guYXJ5ID0gYXJ5O1xuICAgIGxvZGFzaC5hc3NpZ24gPSBhc3NpZ247XG4gICAgbG9kYXNoLmFzc2lnbkluID0gYXNzaWduSW47XG4gICAgbG9kYXNoLmFzc2lnbkluV2l0aCA9IGFzc2lnbkluV2l0aDtcbiAgICBsb2Rhc2guYXNzaWduV2l0aCA9IGFzc2lnbldpdGg7XG4gICAgbG9kYXNoLmF0ID0gYXQ7XG4gICAgbG9kYXNoLmJlZm9yZSA9IGJlZm9yZTtcbiAgICBsb2Rhc2guYmluZCA9IGJpbmQ7XG4gICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcbiAgICBsb2Rhc2guY2FzdEFycmF5ID0gY2FzdEFycmF5O1xuICAgIGxvZGFzaC5jaGFpbiA9IGNoYWluO1xuICAgIGxvZGFzaC5jaHVuayA9IGNodW5rO1xuICAgIGxvZGFzaC5jb21wYWN0ID0gY29tcGFjdDtcbiAgICBsb2Rhc2guY29uY2F0ID0gY29uY2F0O1xuICAgIGxvZGFzaC5jb25kID0gY29uZDtcbiAgICBsb2Rhc2guY29uZm9ybXMgPSBjb25mb3JtcztcbiAgICBsb2Rhc2guY29uc3RhbnQgPSBjb25zdGFudDtcbiAgICBsb2Rhc2guY291bnRCeSA9IGNvdW50Qnk7XG4gICAgbG9kYXNoLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBsb2Rhc2guY3VycnkgPSBjdXJyeTtcbiAgICBsb2Rhc2guY3VycnlSaWdodCA9IGN1cnJ5UmlnaHQ7XG4gICAgbG9kYXNoLmRlYm91bmNlID0gZGVib3VuY2U7XG4gICAgbG9kYXNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgbG9kYXNoLmRlZmF1bHRzRGVlcCA9IGRlZmF1bHRzRGVlcDtcbiAgICBsb2Rhc2guZGVmZXIgPSBkZWZlcjtcbiAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2VCeSA9IGRpZmZlcmVuY2VCeTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZVdpdGggPSBkaWZmZXJlbmNlV2l0aDtcbiAgICBsb2Rhc2guZHJvcCA9IGRyb3A7XG4gICAgbG9kYXNoLmRyb3BSaWdodCA9IGRyb3BSaWdodDtcbiAgICBsb2Rhc2guZHJvcFJpZ2h0V2hpbGUgPSBkcm9wUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2guZHJvcFdoaWxlID0gZHJvcFdoaWxlO1xuICAgIGxvZGFzaC5maWxsID0gZmlsbDtcbiAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgIGxvZGFzaC5mbGF0TWFwID0gZmxhdE1hcDtcbiAgICBsb2Rhc2guZmxhdE1hcERlZXAgPSBmbGF0TWFwRGVlcDtcbiAgICBsb2Rhc2guZmxhdE1hcERlcHRoID0gZmxhdE1hcERlcHRoO1xuICAgIGxvZGFzaC5mbGF0dGVuID0gZmxhdHRlbjtcbiAgICBsb2Rhc2guZmxhdHRlbkRlZXAgPSBmbGF0dGVuRGVlcDtcbiAgICBsb2Rhc2guZmxhdHRlbkRlcHRoID0gZmxhdHRlbkRlcHRoO1xuICAgIGxvZGFzaC5mbGlwID0gZmxpcDtcbiAgICBsb2Rhc2guZmxvdyA9IGZsb3c7XG4gICAgbG9kYXNoLmZsb3dSaWdodCA9IGZsb3dSaWdodDtcbiAgICBsb2Rhc2guZnJvbVBhaXJzID0gZnJvbVBhaXJzO1xuICAgIGxvZGFzaC5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gICAgbG9kYXNoLmZ1bmN0aW9uc0luID0gZnVuY3Rpb25zSW47XG4gICAgbG9kYXNoLmdyb3VwQnkgPSBncm91cEJ5O1xuICAgIGxvZGFzaC5pbml0aWFsID0gaW5pdGlhbDtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb25CeSA9IGludGVyc2VjdGlvbkJ5O1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb25XaXRoID0gaW50ZXJzZWN0aW9uV2l0aDtcbiAgICBsb2Rhc2guaW52ZXJ0ID0gaW52ZXJ0O1xuICAgIGxvZGFzaC5pbnZlcnRCeSA9IGludmVydEJ5O1xuICAgIGxvZGFzaC5pbnZva2VNYXAgPSBpbnZva2VNYXA7XG4gICAgbG9kYXNoLml0ZXJhdGVlID0gaXRlcmF0ZWU7XG4gICAgbG9kYXNoLmtleUJ5ID0ga2V5Qnk7XG4gICAgbG9kYXNoLmtleXMgPSBrZXlzO1xuICAgIGxvZGFzaC5rZXlzSW4gPSBrZXlzSW47XG4gICAgbG9kYXNoLm1hcCA9IG1hcDtcbiAgICBsb2Rhc2gubWFwS2V5cyA9IG1hcEtleXM7XG4gICAgbG9kYXNoLm1hcFZhbHVlcyA9IG1hcFZhbHVlcztcbiAgICBsb2Rhc2gubWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgbG9kYXNoLm1hdGNoZXNQcm9wZXJ0eSA9IG1hdGNoZXNQcm9wZXJ0eTtcbiAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XG4gICAgbG9kYXNoLm1lcmdlID0gbWVyZ2U7XG4gICAgbG9kYXNoLm1lcmdlV2l0aCA9IG1lcmdlV2l0aDtcbiAgICBsb2Rhc2gubWV0aG9kID0gbWV0aG9kO1xuICAgIGxvZGFzaC5tZXRob2RPZiA9IG1ldGhvZE9mO1xuICAgIGxvZGFzaC5taXhpbiA9IG1peGluO1xuICAgIGxvZGFzaC5uZWdhdGUgPSBuZWdhdGU7XG4gICAgbG9kYXNoLm50aEFyZyA9IG50aEFyZztcbiAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgbG9kYXNoLm9taXRCeSA9IG9taXRCeTtcbiAgICBsb2Rhc2gub25jZSA9IG9uY2U7XG4gICAgbG9kYXNoLm9yZGVyQnkgPSBvcmRlckJ5O1xuICAgIGxvZGFzaC5vdmVyID0gb3ZlcjtcbiAgICBsb2Rhc2gub3ZlckFyZ3MgPSBvdmVyQXJncztcbiAgICBsb2Rhc2gub3ZlckV2ZXJ5ID0gb3ZlckV2ZXJ5O1xuICAgIGxvZGFzaC5vdmVyU29tZSA9IG92ZXJTb21lO1xuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgIGxvZGFzaC5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG4gICAgbG9kYXNoLnBpY2sgPSBwaWNrO1xuICAgIGxvZGFzaC5waWNrQnkgPSBwaWNrQnk7XG4gICAgbG9kYXNoLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgbG9kYXNoLnByb3BlcnR5T2YgPSBwcm9wZXJ0eU9mO1xuICAgIGxvZGFzaC5wdWxsID0gcHVsbDtcbiAgICBsb2Rhc2gucHVsbEFsbCA9IHB1bGxBbGw7XG4gICAgbG9kYXNoLnB1bGxBbGxCeSA9IHB1bGxBbGxCeTtcbiAgICBsb2Rhc2gucHVsbEFsbFdpdGggPSBwdWxsQWxsV2l0aDtcbiAgICBsb2Rhc2gucHVsbEF0ID0gcHVsbEF0O1xuICAgIGxvZGFzaC5yYW5nZSA9IHJhbmdlO1xuICAgIGxvZGFzaC5yYW5nZVJpZ2h0ID0gcmFuZ2VSaWdodDtcbiAgICBsb2Rhc2gucmVhcmcgPSByZWFyZztcbiAgICBsb2Rhc2gucmVqZWN0ID0gcmVqZWN0O1xuICAgIGxvZGFzaC5yZW1vdmUgPSByZW1vdmU7XG4gICAgbG9kYXNoLnJlc3QgPSByZXN0O1xuICAgIGxvZGFzaC5yZXZlcnNlID0gcmV2ZXJzZTtcbiAgICBsb2Rhc2guc2FtcGxlU2l6ZSA9IHNhbXBsZVNpemU7XG4gICAgbG9kYXNoLnNldCA9IHNldDtcbiAgICBsb2Rhc2guc2V0V2l0aCA9IHNldFdpdGg7XG4gICAgbG9kYXNoLnNodWZmbGUgPSBzaHVmZmxlO1xuICAgIGxvZGFzaC5zbGljZSA9IHNsaWNlO1xuICAgIGxvZGFzaC5zb3J0QnkgPSBzb3J0Qnk7XG4gICAgbG9kYXNoLnNvcnRlZFVuaXEgPSBzb3J0ZWRVbmlxO1xuICAgIGxvZGFzaC5zb3J0ZWRVbmlxQnkgPSBzb3J0ZWRVbmlxQnk7XG4gICAgbG9kYXNoLnNwbGl0ID0gc3BsaXQ7XG4gICAgbG9kYXNoLnNwcmVhZCA9IHNwcmVhZDtcbiAgICBsb2Rhc2gudGFpbCA9IHRhaWw7XG4gICAgbG9kYXNoLnRha2UgPSB0YWtlO1xuICAgIGxvZGFzaC50YWtlUmlnaHQgPSB0YWtlUmlnaHQ7XG4gICAgbG9kYXNoLnRha2VSaWdodFdoaWxlID0gdGFrZVJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLnRha2VXaGlsZSA9IHRha2VXaGlsZTtcbiAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICAgIGxvZGFzaC50aHJ1ID0gdGhydTtcbiAgICBsb2Rhc2gudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgbG9kYXNoLnRvUGFpcnMgPSB0b1BhaXJzO1xuICAgIGxvZGFzaC50b1BhaXJzSW4gPSB0b1BhaXJzSW47XG4gICAgbG9kYXNoLnRvUGF0aCA9IHRvUGF0aDtcbiAgICBsb2Rhc2gudG9QbGFpbk9iamVjdCA9IHRvUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBsb2Rhc2gudW5hcnkgPSB1bmFyeTtcbiAgICBsb2Rhc2gudW5pb24gPSB1bmlvbjtcbiAgICBsb2Rhc2gudW5pb25CeSA9IHVuaW9uQnk7XG4gICAgbG9kYXNoLnVuaW9uV2l0aCA9IHVuaW9uV2l0aDtcbiAgICBsb2Rhc2gudW5pcSA9IHVuaXE7XG4gICAgbG9kYXNoLnVuaXFCeSA9IHVuaXFCeTtcbiAgICBsb2Rhc2gudW5pcVdpdGggPSB1bmlxV2l0aDtcbiAgICBsb2Rhc2gudW5zZXQgPSB1bnNldDtcbiAgICBsb2Rhc2gudW56aXAgPSB1bnppcDtcbiAgICBsb2Rhc2gudW56aXBXaXRoID0gdW56aXBXaXRoO1xuICAgIGxvZGFzaC51cGRhdGUgPSB1cGRhdGU7XG4gICAgbG9kYXNoLnVwZGF0ZVdpdGggPSB1cGRhdGVXaXRoO1xuICAgIGxvZGFzaC52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgbG9kYXNoLnZhbHVlc0luID0gdmFsdWVzSW47XG4gICAgbG9kYXNoLndpdGhvdXQgPSB3aXRob3V0O1xuICAgIGxvZGFzaC53b3JkcyA9IHdvcmRzO1xuICAgIGxvZGFzaC53cmFwID0gd3JhcDtcbiAgICBsb2Rhc2gueG9yID0geG9yO1xuICAgIGxvZGFzaC54b3JCeSA9IHhvckJ5O1xuICAgIGxvZGFzaC54b3JXaXRoID0geG9yV2l0aDtcbiAgICBsb2Rhc2guemlwID0gemlwO1xuICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnppcE9iamVjdERlZXAgPSB6aXBPYmplY3REZWVwO1xuICAgIGxvZGFzaC56aXBXaXRoID0gemlwV2l0aDtcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5lbnRyaWVzID0gdG9QYWlycztcbiAgICBsb2Rhc2guZW50cmllc0luID0gdG9QYWlyc0luO1xuICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ25JbjtcbiAgICBsb2Rhc2guZXh0ZW5kV2l0aCA9IGFzc2lnbkluV2l0aDtcblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBtaXhpbihsb2Rhc2gsIGxvZGFzaCk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbiAgICBsb2Rhc2guYWRkID0gYWRkO1xuICAgIGxvZGFzaC5hdHRlbXB0ID0gYXR0ZW1wdDtcbiAgICBsb2Rhc2guY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xuICAgIGxvZGFzaC5jYXBpdGFsaXplID0gY2FwaXRhbGl6ZTtcbiAgICBsb2Rhc2guY2VpbCA9IGNlaWw7XG4gICAgbG9kYXNoLmNsYW1wID0gY2xhbXA7XG4gICAgbG9kYXNoLmNsb25lID0gY2xvbmU7XG4gICAgbG9kYXNoLmNsb25lRGVlcCA9IGNsb25lRGVlcDtcbiAgICBsb2Rhc2guY2xvbmVEZWVwV2l0aCA9IGNsb25lRGVlcFdpdGg7XG4gICAgbG9kYXNoLmNsb25lV2l0aCA9IGNsb25lV2l0aDtcbiAgICBsb2Rhc2guY29uZm9ybXNUbyA9IGNvbmZvcm1zVG87XG4gICAgbG9kYXNoLmRlYnVyciA9IGRlYnVycjtcbiAgICBsb2Rhc2guZGVmYXVsdFRvID0gZGVmYXVsdFRvO1xuICAgIGxvZGFzaC5kaXZpZGUgPSBkaXZpZGU7XG4gICAgbG9kYXNoLmVuZHNXaXRoID0gZW5kc1dpdGg7XG4gICAgbG9kYXNoLmVxID0gZXE7XG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcbiAgICBsb2Rhc2guZXNjYXBlUmVnRXhwID0gZXNjYXBlUmVnRXhwO1xuICAgIGxvZGFzaC5ldmVyeSA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5maW5kID0gZmluZDtcbiAgICBsb2Rhc2guZmluZEluZGV4ID0gZmluZEluZGV4O1xuICAgIGxvZGFzaC5maW5kS2V5ID0gZmluZEtleTtcbiAgICBsb2Rhc2guZmluZExhc3QgPSBmaW5kTGFzdDtcbiAgICBsb2Rhc2guZmluZExhc3RJbmRleCA9IGZpbmRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLmZpbmRMYXN0S2V5ID0gZmluZExhc3RLZXk7XG4gICAgbG9kYXNoLmZsb29yID0gZmxvb3I7XG4gICAgbG9kYXNoLmZvckVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5mb3JFYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZvckluID0gZm9ySW47XG4gICAgbG9kYXNoLmZvckluUmlnaHQgPSBmb3JJblJpZ2h0O1xuICAgIGxvZGFzaC5mb3JPd24gPSBmb3JPd247XG4gICAgbG9kYXNoLmZvck93blJpZ2h0ID0gZm9yT3duUmlnaHQ7XG4gICAgbG9kYXNoLmdldCA9IGdldDtcbiAgICBsb2Rhc2guZ3QgPSBndDtcbiAgICBsb2Rhc2guZ3RlID0gZ3RlO1xuICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgbG9kYXNoLmhhc0luID0gaGFzSW47XG4gICAgbG9kYXNoLmhlYWQgPSBoZWFkO1xuICAgIGxvZGFzaC5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIGxvZGFzaC5pbmNsdWRlcyA9IGluY2x1ZGVzO1xuICAgIGxvZGFzaC5pbmRleE9mID0gaW5kZXhPZjtcbiAgICBsb2Rhc2guaW5SYW5nZSA9IGluUmFuZ2U7XG4gICAgbG9kYXNoLmludm9rZSA9IGludm9rZTtcbiAgICBsb2Rhc2guaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbiAgICBsb2Rhc2guaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgbG9kYXNoLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuICAgIGxvZGFzaC5pc0FycmF5TGlrZSA9IGlzQXJyYXlMaWtlO1xuICAgIGxvZGFzaC5pc0FycmF5TGlrZU9iamVjdCA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuICAgIGxvZGFzaC5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG4gICAgbG9kYXNoLmlzQnVmZmVyID0gaXNCdWZmZXI7XG4gICAgbG9kYXNoLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICBsb2Rhc2guaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuICAgIGxvZGFzaC5pc0VtcHR5ID0gaXNFbXB0eTtcbiAgICBsb2Rhc2guaXNFcXVhbCA9IGlzRXF1YWw7XG4gICAgbG9kYXNoLmlzRXF1YWxXaXRoID0gaXNFcXVhbFdpdGg7XG4gICAgbG9kYXNoLmlzRXJyb3IgPSBpc0Vycm9yO1xuICAgIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlO1xuICAgIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICBsb2Rhc2guaXNJbnRlZ2VyID0gaXNJbnRlZ2VyO1xuICAgIGxvZGFzaC5pc0xlbmd0aCA9IGlzTGVuZ3RoO1xuICAgIGxvZGFzaC5pc01hcCA9IGlzTWFwO1xuICAgIGxvZGFzaC5pc01hdGNoID0gaXNNYXRjaDtcbiAgICBsb2Rhc2guaXNNYXRjaFdpdGggPSBpc01hdGNoV2l0aDtcbiAgICBsb2Rhc2guaXNOYU4gPSBpc05hTjtcbiAgICBsb2Rhc2guaXNOYXRpdmUgPSBpc05hdGl2ZTtcbiAgICBsb2Rhc2guaXNOaWwgPSBpc05pbDtcbiAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xuICAgIGxvZGFzaC5pc09iamVjdCA9IGlzT2JqZWN0O1xuICAgIGxvZGFzaC5pc09iamVjdExpa2UgPSBpc09iamVjdExpa2U7XG4gICAgbG9kYXNoLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuICAgIGxvZGFzaC5pc1NhZmVJbnRlZ2VyID0gaXNTYWZlSW50ZWdlcjtcbiAgICBsb2Rhc2guaXNTZXQgPSBpc1NldDtcbiAgICBsb2Rhc2guaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBsb2Rhc2guaXNTeW1ib2wgPSBpc1N5bWJvbDtcbiAgICBsb2Rhc2guaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuICAgIGxvZGFzaC5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuICAgIGxvZGFzaC5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG4gICAgbG9kYXNoLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcbiAgICBsb2Rhc2guam9pbiA9IGpvaW47XG4gICAgbG9kYXNoLmtlYmFiQ2FzZSA9IGtlYmFiQ2FzZTtcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gICAgbG9kYXNoLmxhc3RJbmRleE9mID0gbGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLmxvd2VyQ2FzZSA9IGxvd2VyQ2FzZTtcbiAgICBsb2Rhc2gubG93ZXJGaXJzdCA9IGxvd2VyRmlyc3Q7XG4gICAgbG9kYXNoLmx0ID0gbHQ7XG4gICAgbG9kYXNoLmx0ZSA9IGx0ZTtcbiAgICBsb2Rhc2gubWF4ID0gbWF4O1xuICAgIGxvZGFzaC5tYXhCeSA9IG1heEJ5O1xuICAgIGxvZGFzaC5tZWFuID0gbWVhbjtcbiAgICBsb2Rhc2gubWVhbkJ5ID0gbWVhbkJ5O1xuICAgIGxvZGFzaC5taW4gPSBtaW47XG4gICAgbG9kYXNoLm1pbkJ5ID0gbWluQnk7XG4gICAgbG9kYXNoLnN0dWJBcnJheSA9IHN0dWJBcnJheTtcbiAgICBsb2Rhc2guc3R1YkZhbHNlID0gc3R1YkZhbHNlO1xuICAgIGxvZGFzaC5zdHViT2JqZWN0ID0gc3R1Yk9iamVjdDtcbiAgICBsb2Rhc2guc3R1YlN0cmluZyA9IHN0dWJTdHJpbmc7XG4gICAgbG9kYXNoLnN0dWJUcnVlID0gc3R1YlRydWU7XG4gICAgbG9kYXNoLm11bHRpcGx5ID0gbXVsdGlwbHk7XG4gICAgbG9kYXNoLm50aCA9IG50aDtcbiAgICBsb2Rhc2gubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG4gICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgIGxvZGFzaC5ub3cgPSBub3c7XG4gICAgbG9kYXNoLnBhZCA9IHBhZDtcbiAgICBsb2Rhc2gucGFkRW5kID0gcGFkRW5kO1xuICAgIGxvZGFzaC5wYWRTdGFydCA9IHBhZFN0YXJ0O1xuICAgIGxvZGFzaC5wYXJzZUludCA9IHBhcnNlSW50O1xuICAgIGxvZGFzaC5yYW5kb20gPSByYW5kb207XG4gICAgbG9kYXNoLnJlZHVjZSA9IHJlZHVjZTtcbiAgICBsb2Rhc2gucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2gucmVwZWF0ID0gcmVwZWF0O1xuICAgIGxvZGFzaC5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICBsb2Rhc2gucmVzdWx0ID0gcmVzdWx0O1xuICAgIGxvZGFzaC5yb3VuZCA9IHJvdW5kO1xuICAgIGxvZGFzaC5ydW5JbkNvbnRleHQgPSBydW5JbkNvbnRleHQ7XG4gICAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gICAgbG9kYXNoLnNuYWtlQ2FzZSA9IHNuYWtlQ2FzZTtcbiAgICBsb2Rhc2guc29tZSA9IHNvbWU7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4ID0gc29ydGVkSW5kZXg7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4QnkgPSBzb3J0ZWRJbmRleEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleE9mID0gc29ydGVkSW5kZXhPZjtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4ID0gc29ydGVkTGFzdEluZGV4O1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhCeSA9IHNvcnRlZExhc3RJbmRleEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhPZiA9IHNvcnRlZExhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5zdGFydENhc2UgPSBzdGFydENhc2U7XG4gICAgbG9kYXNoLnN0YXJ0c1dpdGggPSBzdGFydHNXaXRoO1xuICAgIGxvZGFzaC5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuICAgIGxvZGFzaC5zdW0gPSBzdW07XG4gICAgbG9kYXNoLnN1bUJ5ID0gc3VtQnk7XG4gICAgbG9kYXNoLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgbG9kYXNoLnRpbWVzID0gdGltZXM7XG4gICAgbG9kYXNoLnRvRmluaXRlID0gdG9GaW5pdGU7XG4gICAgbG9kYXNoLnRvSW50ZWdlciA9IHRvSW50ZWdlcjtcbiAgICBsb2Rhc2gudG9MZW5ndGggPSB0b0xlbmd0aDtcbiAgICBsb2Rhc2gudG9Mb3dlciA9IHRvTG93ZXI7XG4gICAgbG9kYXNoLnRvTnVtYmVyID0gdG9OdW1iZXI7XG4gICAgbG9kYXNoLnRvU2FmZUludGVnZXIgPSB0b1NhZmVJbnRlZ2VyO1xuICAgIGxvZGFzaC50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIGxvZGFzaC50b1VwcGVyID0gdG9VcHBlcjtcbiAgICBsb2Rhc2gudHJpbSA9IHRyaW07XG4gICAgbG9kYXNoLnRyaW1FbmQgPSB0cmltRW5kO1xuICAgIGxvZGFzaC50cmltU3RhcnQgPSB0cmltU3RhcnQ7XG4gICAgbG9kYXNoLnRydW5jYXRlID0gdHJ1bmNhdGU7XG4gICAgbG9kYXNoLnVuZXNjYXBlID0gdW5lc2NhcGU7XG4gICAgbG9kYXNoLnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG4gICAgbG9kYXNoLnVwcGVyQ2FzZSA9IHVwcGVyQ2FzZTtcbiAgICBsb2Rhc2gudXBwZXJGaXJzdCA9IHVwcGVyRmlyc3Q7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZmlyc3QgPSBoZWFkO1xuXG4gICAgbWl4aW4obG9kYXNoLCAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0ge307XG4gICAgICBiYXNlRm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwobG9kYXNoLnByb3RvdHlwZSwgbWV0aG9kTmFtZSkpIHtcbiAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfSgpKSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgbG9kYXNoLlZFUlNJT04gPSBWRVJTSU9OO1xuXG4gICAgLy8gQXNzaWduIGRlZmF1bHQgcGxhY2Vob2xkZXJzLlxuICAgIGFycmF5RWFjaChbJ2JpbmQnLCAnYmluZEtleScsICdjdXJyeScsICdjdXJyeVJpZ2h0JywgJ3BhcnRpYWwnLCAncGFydGlhbFJpZ2h0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIGxvZGFzaFttZXRob2ROYW1lXS5wbGFjZWhvbGRlciA9IGxvZGFzaDtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmRyb3BgIGFuZCBgXy50YWtlYCB2YXJpYW50cy5cbiAgICBhcnJheUVhY2goWydkcm9wJywgJ3Rha2UnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdmFyIGZpbHRlcmVkID0gdGhpcy5fX2ZpbHRlcmVkX187XG4gICAgICAgIGlmIChmaWx0ZXJlZCAmJiAhaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuID09PSB1bmRlZmluZWQgPyAxIDogbmF0aXZlTWF4KHRvSW50ZWdlcihuKSwgMCk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgaWYgKGZpbHRlcmVkKSB7XG4gICAgICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSBuYXRpdmVNaW4obiwgcmVzdWx0Ll9fdGFrZUNvdW50X18pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5fX3ZpZXdzX18ucHVzaCh7XG4gICAgICAgICAgICAnc2l6ZSc6IG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKSxcbiAgICAgICAgICAgICd0eXBlJzogbWV0aG9kTmFtZSArIChyZXN1bHQuX19kaXJfXyA8IDAgPyAnUmlnaHQnIDogJycpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lICsgJ1JpZ2h0J10gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKVttZXRob2ROYW1lXShuKS5yZXZlcnNlKCk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0aGF0IGFjY2VwdCBhbiBgaXRlcmF0ZWVgIHZhbHVlLlxuICAgIGFycmF5RWFjaChbJ2ZpbHRlcicsICdtYXAnLCAndGFrZVdoaWxlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgdHlwZSA9IGluZGV4ICsgMSxcbiAgICAgICAgICBpc0ZpbHRlciA9IHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRyB8fCB0eXBlID09IExBWllfV0hJTEVfRkxBRztcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18ucHVzaCh7XG4gICAgICAgICAgJ2l0ZXJhdGVlJzogZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLFxuICAgICAgICAgICd0eXBlJzogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHJlc3VsdC5fX2ZpbHRlcmVkX18gfHwgaXNGaWx0ZXI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaGVhZGAgYW5kIGBfLmxhc3RgLlxuICAgIGFycmF5RWFjaChbJ2hlYWQnLCAnbGFzdCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHRha2VOYW1lID0gJ3Rha2UnICsgKGluZGV4ID8gJ1JpZ2h0JyA6ICcnKTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3Rha2VOYW1lXSgxKS52YWx1ZSgpWzBdO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmluaXRpYWxgIGFuZCBgXy50YWlsYC5cbiAgICBhcnJheUVhY2goWydpbml0aWFsJywgJ3RhaWwnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciBkcm9wTmFtZSA9ICdkcm9wJyArIChpbmRleCA/ICcnIDogJ1JpZ2h0Jyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2ZpbHRlcmVkX18gPyBuZXcgTGF6eVdyYXBwZXIodGhpcykgOiB0aGlzW2Ryb3BOYW1lXSgxKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29tcGFjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGlkZW50aXR5KTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihwcmVkaWNhdGUpLmhlYWQoKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmRMYXN0ID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmluZChwcmVkaWNhdGUpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24ocGF0aCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZSh2YWx1ZSwgcGF0aCwgYXJncyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlKSkpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICBzdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XG5cbiAgICAgIHZhciByZXN1bHQgPSB0aGlzO1xuICAgICAgaWYgKHJlc3VsdC5fX2ZpbHRlcmVkX18gJiYgKHN0YXJ0ID4gMCB8fCBlbmQgPCAwKSkge1xuICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC50YWtlUmlnaHQoLXN0YXJ0KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmRyb3Aoc3RhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IHRvSW50ZWdlcihlbmQpO1xuICAgICAgICByZXN1bHQgPSBlbmQgPCAwID8gcmVzdWx0LmRyb3BSaWdodCgtZW5kKSA6IHJlc3VsdC50YWtlKGVuZCAtIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS50YWtlUmlnaHRXaGlsZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLnRha2VXaGlsZShwcmVkaWNhdGUpLnJldmVyc2UoKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRha2UoTUFYX0FSUkFZX0xFTkdUSCk7XG4gICAgfTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgY2hlY2tJdGVyYXRlZSA9IC9eKD86ZmlsdGVyfGZpbmR8bWFwfHJlamVjdCl8V2hpbGUkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIGlzVGFrZXIgPSAvXig/OmhlYWR8bGFzdCkkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbaXNUYWtlciA/ICgndGFrZScgKyAobWV0aG9kTmFtZSA9PSAnbGFzdCcgPyAnUmlnaHQnIDogJycpKSA6IG1ldGhvZE5hbWVdLFxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IGlzVGFrZXIgfHwgL15maW5kLy50ZXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgICBpZiAoIWxvZGFzaEZ1bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgICAgYXJncyA9IGlzVGFrZXIgPyBbMV0gOiBhcmd1bWVudHMsXG4gICAgICAgICAgICBpc0xhenkgPSB2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyLFxuICAgICAgICAgICAgaXRlcmF0ZWUgPSBhcmdzWzBdLFxuICAgICAgICAgICAgdXNlTGF6eSA9IGlzTGF6eSB8fCBpc0FycmF5KHZhbHVlKTtcblxuICAgICAgICB2YXIgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2hGdW5jLmFwcGx5KGxvZGFzaCwgYXJyYXlQdXNoKFt2YWx1ZV0sIGFyZ3MpKTtcbiAgICAgICAgICByZXR1cm4gKGlzVGFrZXIgJiYgY2hhaW5BbGwpID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh1c2VMYXp5ICYmIGNoZWNrSXRlcmF0ZWUgJiYgdHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgJiYgaXRlcmF0ZWUubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgICAvLyBBdm9pZCBsYXp5IHVzZSBpZiB0aGUgaXRlcmF0ZWUgaGFzIGEgXCJsZW5ndGhcIiB2YWx1ZSBvdGhlciB0aGFuIGAxYC5cbiAgICAgICAgICBpc0xhenkgPSB1c2VMYXp5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICBpc0h5YnJpZCA9ICEhdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgsXG4gICAgICAgICAgICBpc1Vud3JhcHBlZCA9IHJldFVud3JhcHBlZCAmJiAhY2hhaW5BbGwsXG4gICAgICAgICAgICBvbmx5TGF6eSA9IGlzTGF6eSAmJiAhaXNIeWJyaWQ7XG5cbiAgICAgICAgaWYgKCFyZXRVbndyYXBwZWQgJiYgdXNlTGF6eSkge1xuICAgICAgICAgIHZhbHVlID0gb25seUxhenkgPyB2YWx1ZSA6IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fLnB1c2goeyAnZnVuYyc6IHRocnUsICdhcmdzJzogW2ludGVyY2VwdG9yXSwgJ3RoaXNBcmcnOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vud3JhcHBlZCAmJiBvbmx5TGF6eSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgICAgIHJldHVybiBpc1Vud3JhcHBlZCA/IChpc1Rha2VyID8gcmVzdWx0LnZhbHVlKClbMF0gOiByZXN1bHQudmFsdWUoKSkgOiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBBcnJheWAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYXJyYXlFYWNoKFsncG9wJywgJ3B1c2gnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UHJvdG9bbWV0aG9kTmFtZV0sXG4gICAgICAgICAgY2hhaW5OYW1lID0gL14oPzpwdXNofHNvcnR8dW5zaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpID8gJ3RhcCcgOiAndGhydScsXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gL14oPzpwb3B8c2hpZnQpJC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJldFVud3JhcHBlZCAmJiAhdGhpcy5fX2NoYWluX18pIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1tjaGFpbk5hbWVdKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gTWFwIG1pbmlmaWVkIG1ldGhvZCBuYW1lcyB0byB0aGVpciByZWFsIG5hbWVzLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgbG9kYXNoRnVuYyA9IGxvZGFzaFttZXRob2ROYW1lXTtcbiAgICAgIGlmIChsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHZhciBrZXkgPSAobG9kYXNoRnVuYy5uYW1lICsgJycpLFxuICAgICAgICAgICAgbmFtZXMgPSByZWFsTmFtZXNba2V5XSB8fCAocmVhbE5hbWVzW2tleV0gPSBbXSk7XG5cbiAgICAgICAgbmFtZXMucHVzaCh7ICduYW1lJzogbWV0aG9kTmFtZSwgJ2Z1bmMnOiBsb2Rhc2hGdW5jIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVhbE5hbWVzW2NyZWF0ZUh5YnJpZCh1bmRlZmluZWQsIEJJTkRfS0VZX0ZMQUcpLm5hbWVdID0gW3tcbiAgICAgICduYW1lJzogJ3dyYXBwZXInLFxuICAgICAgJ2Z1bmMnOiB1bmRlZmluZWRcbiAgICB9XTtcblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMYXp5V3JhcHBlcmAuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNsb25lID0gbGF6eUNsb25lO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZXZlcnNlID0gbGF6eVJldmVyc2U7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnZhbHVlID0gbGF6eVZhbHVlO1xuXG4gICAgLy8gQWRkIGNoYWluIHNlcXVlbmNlIG1ldGhvZHMgdG8gdGhlIGBsb2Rhc2hgIHdyYXBwZXIuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5hdCA9IHdyYXBwZXJBdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY29tbWl0ID0gd3JhcHBlckNvbW1pdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLm5leHQgPSB3cmFwcGVyTmV4dDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnBsYW50ID0gd3JhcHBlclBsYW50O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucmV2ZXJzZSA9IHdyYXBwZXJSZXZlcnNlO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudG9KU09OID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZU9mID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZTtcblxuICAgIC8vIEFkZCBsYXp5IGFsaWFzZXMuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5maXJzdCA9IGxvZGFzaC5wcm90b3R5cGUuaGVhZDtcblxuICAgIGlmIChpdGVyYXRvclN5bWJvbCkge1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSB3cmFwcGVyVG9JdGVyYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIGxvZGFzaDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIEV4cG9ydCBsb2Rhc2guXG4gIHZhciBfID0gcnVuSW5Db250ZXh0KCk7XG5cbiAgLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2U6XG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEV4cG9zZSBMb2Rhc2ggb24gdGhlIGdsb2JhbCBvYmplY3QgdG8gcHJldmVudCBlcnJvcnMgd2hlbiBMb2Rhc2ggaXNcbiAgICAvLyBsb2FkZWQgYnkgYSBzY3JpcHQgdGFnIGluIHRoZSBwcmVzZW5jZSBvZiBhbiBBTUQgbG9hZGVyLlxuICAgIC8vIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2Vycm9ycy5odG1sI21pc21hdGNoIGZvciBtb3JlIGRldGFpbHMuXG4gICAgLy8gVXNlIGBfLm5vQ29uZmxpY3RgIHRvIHJlbW92ZSBMb2Rhc2ggZnJvbSB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICByb290Ll8gPSBfO1xuXG4gICAgLy8gRGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28sIHRocm91Z2ggcGF0aCBtYXBwaW5nLCBpdCBjYW4gYmVcbiAgICAvLyByZWZlcmVuY2VkIGFzIHRoZSBcInVuZGVyc2NvcmVcIiBtb2R1bGUuXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgaXQuXG4gIGVsc2UgaWYgKGZyZWVNb2R1bGUpIHtcbiAgICAvLyBFeHBvcnQgZm9yIE5vZGUuanMuXG4gICAgKGZyZWVNb2R1bGUuZXhwb3J0cyA9IF8pLl8gPSBfO1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgc3VwcG9ydC5cbiAgICBmcmVlRXhwb3J0cy5fID0gXztcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBFeHBvcnQgdG8gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgcm9vdC5fID0gXztcbiAgfVxufS5jYWxsKHRoaXMpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2xvZGFzaC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlLmw7IH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGUuaTsgfVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==